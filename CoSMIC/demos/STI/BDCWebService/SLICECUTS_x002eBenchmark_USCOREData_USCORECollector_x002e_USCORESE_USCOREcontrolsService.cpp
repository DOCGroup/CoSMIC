/* SLICECUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService.cpp
   Generated by gSOAP 2.7.8c from SLICE.h
   Copyright (C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "SLICECUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService.h"

CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService::CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService (CUTS::Path_Measurement_ptr online_measurements, CUTS::BDC_Control_Handle_ptr controls)
  : online_measurements_ (CUTS::Path_Measurement::_duplicate (online_measurements)),
    controls_ (CUTS::BDC_Control_Handle::_duplicate (controls))
{
  CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService::CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService()
{
  CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService::CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService(soap_mode iomode)
{
  CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService_init(iomode, iomode);
}

CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService::CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService(soap_mode imode, soap_mode omode)
{
  CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService_init(imode, omode);
}

void CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService::CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService_init(soap_mode imode, soap_mode omode)
{	static const struct Namespace namespaces[] =
    {
      {"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL},
      {"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL},
      {"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL},
      {"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL},
      {"CORBA", "http://www.omg.org/IDL-WSDL/1.0/", NULL, NULL},
      {"SLICE", "urn:SLICE", NULL, NULL},
      {NULL, NULL, NULL, NULL}
    };
  soap_init2(this, imode, omode);
  if (!this->namespaces)
    this->namespaces = namespaces;
};

CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService::~CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService()
{
  soap_destroy(this);
  soap_end(this);
  soap_done(this);
};

int CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService::serve()
{
#ifndef WITH_FASTCGI
  unsigned int k = this->max_keep_alive;
#endif
  do
    {	soap_begin(this);
#ifdef WITH_FASTCGI
      if (FCGI_Accept() < 0)
        {
          this->error = SOAP_EOF;
          return soap_send_fault(this);
        }
#endif

      soap_begin(this);

#ifndef WITH_FASTCGI
      if (this->max_keep_alive > 0 && !--k)
        this->keep_alive = 0;
#endif

      if (soap_begin_recv(this))
        {	if (this->error < SOAP_STOP)
            {
#ifdef WITH_FASTCGI
              soap_send_fault(this);
#else
              return soap_send_fault(this);
#endif
            }
          soap_closesock(this);

          continue;
        }

      if (soap_envelope_begin_in(this)
          || soap_recv_header(this)
          || soap_body_begin_in(this)
          || dispatch() || (this->fserveloop && this->fserveloop(this)))
        {
#ifdef WITH_FASTCGI
          soap_send_fault(this);
#else
          return soap_send_fault(this);
#endif
        }

#ifdef WITH_FASTCGI
    } while (1);
#else
} while (this->keep_alive);
#endif
return SOAP_OK;
}

static int serve_SLICE__collect_USCOREperformance_USCOREdata(CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService*);
static int serve_SLICE__execution_USCOREtime(CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService*);
static int serve_SLICE__unbind_USCOREto_USCOREpath(CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService*);
static int serve_SLICE__bind_USCOREto_USCOREpath(CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService*);

int CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService::dispatch()
{
  if (soap_peek_element(this))
    return this->error;
  if (!soap_match_tag(this, this->tag, "SLICE:collect_performance_data"))
    return serve_SLICE__collect_USCOREperformance_USCOREdata(this);
  if (!soap_match_tag(this, this->tag, "SLICE:execution_time"))
    return serve_SLICE__execution_USCOREtime(this);
  if (!soap_match_tag(this, this->tag, "SLICE:unbind_to_path"))
    return serve_SLICE__unbind_USCOREto_USCOREpath(this);
  if (!soap_match_tag(this, this->tag, "SLICE:bind_to_path"))
    return serve_SLICE__bind_USCOREto_USCOREpath(this);
  return this->error = SOAP_NO_METHOD;
}

static int serve_SLICE__collect_USCOREperformance_USCOREdata(CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService *soap)
{
  struct SLICE__collect_USCOREperformance_USCOREdata soap_tmp_SLICE__collect_USCOREperformance_USCOREdata;
  struct SLICE__collect_USCOREperformance_USCOREdataResponse _param_1;
  soap_default_SLICE__collect_USCOREperformance_USCOREdataResponse(soap, &_param_1);
  soap_default_SLICE__collect_USCOREperformance_USCOREdata(soap, &soap_tmp_SLICE__collect_USCOREperformance_USCOREdata);
  soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
  if (!soap_get_SLICE__collect_USCOREperformance_USCOREdata(soap, &soap_tmp_SLICE__collect_USCOREperformance_USCOREdata, "SLICE:collect_performance_data", NULL))
    return soap->error;
  if (soap_body_end_in(soap)
      || soap_envelope_end_in(soap)
      || soap_end_recv(soap))
    return soap->error;
  soap->error = soap->collect_USCOREperformance_USCOREdata(_param_1);
  if (soap->error)
    return soap->error;
  soap_serializeheader(soap);
  soap_serialize_SLICE__collect_USCOREperformance_USCOREdataResponse(soap, &_param_1);
  if (soap_begin_count(soap))
    return soap->error;
  if (soap->mode & SOAP_IO_LENGTH)
    {	if (soap_envelope_begin_out(soap)
            || soap_putheader(soap)
            || soap_body_begin_out(soap)
            || soap_put_SLICE__collect_USCOREperformance_USCOREdataResponse(soap, &_param_1, "SLICE:collect_performance_dataResponse", "")
            || soap_body_end_out(soap)
            || soap_envelope_end_out(soap))
        return soap->error;
    };
  if (soap_end_count(soap)
      || soap_response(soap, SOAP_OK)
      || soap_envelope_begin_out(soap)
      || soap_putheader(soap)
      || soap_body_begin_out(soap)
      || soap_put_SLICE__collect_USCOREperformance_USCOREdataResponse(soap, &_param_1, "SLICE:collect_performance_dataResponse", "")
      || soap_body_end_out(soap)
      || soap_envelope_end_out(soap)
      || soap_end_send(soap))
    return soap->error;
  return soap_closesock(soap);
}

static int serve_SLICE__execution_USCOREtime(CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService *soap)
{	struct SLICE__execution_USCOREtime soap_tmp_SLICE__execution_USCOREtime;
  struct SLICE__execution_USCOREtimeResponse _param_1;
  soap_default_SLICE__execution_USCOREtimeResponse(soap, &_param_1);
  soap_default_SLICE__execution_USCOREtime(soap, &soap_tmp_SLICE__execution_USCOREtime);
  soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
  if (!soap_get_SLICE__execution_USCOREtime(soap, &soap_tmp_SLICE__execution_USCOREtime, "SLICE:execution_time", NULL))
    return soap->error;
  if (soap_body_end_in(soap)
      || soap_envelope_end_in(soap)
      || soap_end_recv(soap))
    return soap->error;
  soap->error = soap->execution_USCOREtime(soap_tmp_SLICE__execution_USCOREtime.path_USCOREid, _param_1);
  if (soap->error)
    return soap->error;
  soap_serializeheader(soap);
  soap_serialize_SLICE__execution_USCOREtimeResponse(soap, &_param_1);
  if (soap_begin_count(soap))
    return soap->error;
  if (soap->mode & SOAP_IO_LENGTH)
    {	if (soap_envelope_begin_out(soap)
            || soap_putheader(soap)
            || soap_body_begin_out(soap)
            || soap_put_SLICE__execution_USCOREtimeResponse(soap, &_param_1, "SLICE:execution_timeResponse", "")
            || soap_body_end_out(soap)
            || soap_envelope_end_out(soap))
        return soap->error;
    };
  if (soap_end_count(soap)
      || soap_response(soap, SOAP_OK)
      || soap_envelope_begin_out(soap)
      || soap_putheader(soap)
      || soap_body_begin_out(soap)
      || soap_put_SLICE__execution_USCOREtimeResponse(soap, &_param_1, "SLICE:execution_timeResponse", "")
      || soap_body_end_out(soap)
      || soap_envelope_end_out(soap)
      || soap_end_send(soap))
    return soap->error;
  return soap_closesock(soap);
}

static int serve_SLICE__unbind_USCOREto_USCOREpath(CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService *soap)
{	struct SLICE__unbind_USCOREto_USCOREpath soap_tmp_SLICE__unbind_USCOREto_USCOREpath;
  struct SLICE__unbind_USCOREto_USCOREpathResponse _param_1;
  soap_default_SLICE__unbind_USCOREto_USCOREpathResponse(soap, &_param_1);
  soap_default_SLICE__unbind_USCOREto_USCOREpath(soap, &soap_tmp_SLICE__unbind_USCOREto_USCOREpath);
  soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
  if (!soap_get_SLICE__unbind_USCOREto_USCOREpath(soap, &soap_tmp_SLICE__unbind_USCOREto_USCOREpath, "SLICE:unbind_to_path", NULL))
    return soap->error;
  if (soap_body_end_in(soap)
      || soap_envelope_end_in(soap)
      || soap_end_recv(soap))
    return soap->error;
  soap->error = soap->unbind_USCOREto_USCOREpath(soap_tmp_SLICE__unbind_USCOREto_USCOREpath.path_USCOREid, _param_1);
  if (soap->error)
    return soap->error;
  soap_serializeheader(soap);
  soap_serialize_SLICE__unbind_USCOREto_USCOREpathResponse(soap, &_param_1);
  if (soap_begin_count(soap))
    return soap->error;
  if (soap->mode & SOAP_IO_LENGTH)
    {	if (soap_envelope_begin_out(soap)
            || soap_putheader(soap)
            || soap_body_begin_out(soap)
            || soap_put_SLICE__unbind_USCOREto_USCOREpathResponse(soap, &_param_1, "SLICE:unbind_to_pathResponse", "")
            || soap_body_end_out(soap)
            || soap_envelope_end_out(soap))
        return soap->error;
    };
  if (soap_end_count(soap)
      || soap_response(soap, SOAP_OK)
      || soap_envelope_begin_out(soap)
      || soap_putheader(soap)
      || soap_body_begin_out(soap)
      || soap_put_SLICE__unbind_USCOREto_USCOREpathResponse(soap, &_param_1, "SLICE:unbind_to_pathResponse", "")
      || soap_body_end_out(soap)
      || soap_envelope_end_out(soap)
      || soap_end_send(soap))
    return soap->error;
  return soap_closesock(soap);
}

static int serve_SLICE__bind_USCOREto_USCOREpath(CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService *soap)
{
  struct SLICE__bind_USCOREto_USCOREpath soap_tmp_SLICE__bind_USCOREto_USCOREpath;
  struct SLICE__bind_USCOREto_USCOREpathResponse soap_tmp_SLICE__bind_USCOREto_USCOREpathResponse;
  soap_default_SLICE__bind_USCOREto_USCOREpathResponse(soap, &soap_tmp_SLICE__bind_USCOREto_USCOREpathResponse);
  soap_default_SLICE__bind_USCOREto_USCOREpath(soap, &soap_tmp_SLICE__bind_USCOREto_USCOREpath);
  soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
  if (!soap_get_SLICE__bind_USCOREto_USCOREpath(soap, &soap_tmp_SLICE__bind_USCOREto_USCOREpath, "SLICE:bind_to_path", NULL))
    return soap->error;
  if (soap_body_end_in(soap)
      || soap_envelope_end_in(soap)
      || soap_end_recv(soap))
    return soap->error;
  soap->error = soap->bind_USCOREto_USCOREpath(soap_tmp_SLICE__bind_USCOREto_USCOREpath.path, soap_tmp_SLICE__bind_USCOREto_USCOREpath.flags, soap_tmp_SLICE__bind_USCOREto_USCOREpathResponse._USCOREreturn);
  if (soap->error)
    return soap->error;
  soap_serializeheader(soap);
  soap_serialize_SLICE__bind_USCOREto_USCOREpathResponse(soap, &soap_tmp_SLICE__bind_USCOREto_USCOREpathResponse);
  if (soap_begin_count(soap))
    return soap->error;
  if (soap->mode & SOAP_IO_LENGTH)
    {	if (soap_envelope_begin_out(soap)
            || soap_putheader(soap)
            || soap_body_begin_out(soap)
            || soap_put_SLICE__bind_USCOREto_USCOREpathResponse(soap, &soap_tmp_SLICE__bind_USCOREto_USCOREpathResponse, "SLICE:bind_to_pathResponse", "")
            || soap_body_end_out(soap)
            || soap_envelope_end_out(soap))
        return soap->error;
    };
  if (soap_end_count(soap)
      || soap_response(soap, SOAP_OK)
      || soap_envelope_begin_out(soap)
      || soap_putheader(soap)
      || soap_body_begin_out(soap)
      || soap_put_SLICE__bind_USCOREto_USCOREpathResponse(soap, &soap_tmp_SLICE__bind_USCOREto_USCOREpathResponse, "SLICE:bind_to_pathResponse", "")
      || soap_body_end_out(soap)
      || soap_envelope_end_out(soap)
      || soap_end_send(soap))
    return soap->error;
  return soap_closesock(soap);
}

int
CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService::collect_USCOREperformance_USCOREdata(struct SLICE__collect_USCOREperformance_USCOREdataResponse &_param_1)
{
  try
    {
      this->controls_->collect_performance_data();
    }
  catch (CORBA::Exception& ex)
    {
      ACE_PRINT_EXCEPTION (ex, "collect_performance_data() failed");
      std::string msg (ex._info().c_str());
      msg += " collect_performance_data() ";
      msg += path;
      return soap_receiver_fault(this,
                                 "An exception occurred: ",
                                 msg.c_str());
    }
  return SOAP_OK;
}

int
CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService::execution_USCOREtime(int path_USCOREid, struct SLICE__execution_USCOREtimeResponse &_param_1)
{
  cout << "Received request for execution time of " << path_USCOREid << endl;
  try
    {
      CUTS::Event_Time_Info event_info;
      event_info = this->online_measurements_->execution_time (path_USCOREid);
      CUTS::Time_Info time = event_info.time;
      ACE_DEBUG ((LM_DEBUG, "ID %d: exec time (min/avg/max):"
                  "(%dms/%dms/%dms)\t"
                  "number of events (min/max): (%d/%d)\n", path_USCOREid,
                  time.min,
                  time.total,
                  time.max,
                  event_info.min_events,
                  event_info.max_events));

      _param_1._USCOREreturn = new SLICE__CUTS_x002eEvent_USCORETime_USCOREInfo();
      _param_1._USCOREreturn->time = new SLICE__CUTS_x002eTime_USCOREInfo();
      _param_1._USCOREreturn->max_USCOREevents = event_info.min_events;
      _param_1._USCOREreturn->min_USCOREevents = event_info.max_events;
      _param_1._USCOREreturn->time->total = time.total;
      _param_1._USCOREreturn->time->max_ = time.max;
      _param_1._USCOREreturn->time->min_ = time.min;
    }
  catch (CUTS::ID_Not_Found& ex)
    {
      ACE_PRINT_EXCEPTION (ex, "ID_Not_Found");
      std::string msg (ex._info().c_str());
      msg += " execution_time() ";
      msg += path;
      return soap_receiver_fault(this,
                                 "An exception occurred: ",
                                 msg.c_str());
    }
  catch (CUTS::Operation_Failed& ex)
    {
      ACE_PRINT_EXCEPTION (ex, "Operation_Failed");
      std::string msg (ex._info().c_str());
      msg += " execution_time() ";
      msg += path;
      return soap_receiver_fault(this,
                                 "An exception occurred: ",
                                 msg.c_str());
    }
  catch (CORBA::Exception& ex)
    {
      ACE_PRINT_EXCEPTION (ex, "execution_time() failed");
      std::string msg (ex._info().c_str());
      msg += " execution_time() ";
      msg += path;
      return soap_receiver_fault(this,
                                 "An exception occurred: ",
                                 msg.c_str());
    }
  return SOAP_OK;
}

int
CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService::unbind_USCOREto_USCOREpath(int path_USCOREid, struct SLICE__unbind_USCOREto_USCOREpathResponse &_param_1)
{
  cout << "Received Path id = " << path_USCOREid << endl;
  try
    {
      this->online_measurements_->unbind_to_path (path_USCOREid);
    }
  catch (CUTS::ID_Not_Found& ex)
    {
      ACE_PRINT_EXCEPTION (ex, "ID_Not_Found");
      std::string msg (ex._info().c_str());
      msg += " unbind_to_path() ";
      msg += path;
      return soap_receiver_fault(this,
                                 "An exception occurred: ",
                                 msg.c_str());
    }
  catch (CORBA::Exception& ex)
    {
      ACE_PRINT_EXCEPTION (ex, "unbind_to_path() failed");
      std::string msg (ex._info().c_str());
      msg += " unbind_to_path() ";
      msg += path;
      return soap_receiver_fault(this,
                                 "An exception occurred: ",
                                 msg.c_str());
    }
  return SOAP_OK;
}

int
CUTS_x002eBenchmark_USCOREData_USCORECollector_x002e_USCORESE_USCOREcontrolsService::bind_USCOREto_USCOREpath(CUTS_x002e_USCORESE_USCOREPath_USCORESequence *path, unsigned short flags, int &_USCOREreturn)
{

  switch (flags)
    {
      case 1:
        cout << "Flag = BPF_TRANSIT" << endl;
        break;
      case 2:
        cout << "Flag = BPF_PROCESS" << endl;
        break;
      case 3:
        cout << "Flag = BPF_BOTH" << endl;
        break;
      default:
        cerr << "Invalid value for flag" << endl;
    }
  std::string path_id;
  try
    {
      SLICE__CUTS_x002ePath_USCOREElement** array = path->__ptritem;
      int array_len = path->__size;
      CUTS::Path_Sequence path_seq;
      for (int i = 0; i < array_len; ++i) {
        SLICE__CUTS_x002ePath_USCOREElement element = *(*(array+i));
		path_id.append (element.node);
        path_id += element.src;
        path_id += element.dst;
        CUTS::Path_Element path_element;
        path_element.node = CORBA::string_dup (element.node);
        path_element.src = CORBA::string_dup (element.src);
        path_element.dst = CORBA::string_dup (element.dst);
        CORBA::ULong len = path_seq.length();
        path_seq.length (len + 1);
        path_seq[len] = path_element;
      }
      for (CORBA::ULong len = 0; len < path_seq.length(); ++len)
        {
          CUTS::Path_Element element = path_seq[len];
          cout << "Node = " << element.node << endl
             << "Source Port = " << element.src << endl
             << "Destination Port = " << element.dst << endl;

        }
      _USCOREreturn
        = this->online_measurements_->bind_to_path (path_seq, flags);
    }
  catch (CUTS::Binding_Failed& bf)
    {
      ACE_PRINT_EXCEPTION (bf, "Binding_Failed");
      std::string msg ("Binding Failed for path ");
      msg += path_id;
      return soap_receiver_fault(this,
                                 "An exception occurred: ",
                                 msg.c_str());
    }
  catch (CORBA::Exception& ex)
    {
      ACE_PRINT_EXCEPTION (ex, "bind_to_path() failed");
      std::string msg (ex._info().c_str());
      msg += " bind_to_path() ";
      msg += path_id;
      return soap_receiver_fault(this,
                                 "An exception occurred: ",
                                 msg.c_str());
    }
  return SOAP_OK;
}
