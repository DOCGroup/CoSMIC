/*
 * @file: options_view.h
 *
 * OptionsView QT construction file
 *
 * Most of the file is generated by the QT resource compiler
 * 
 * @author: Emre Turkay <emre.turkay@vanderbilt.edu>
 */

#ifndef _OPTIONS_VIEW_H_
#define _OPTIONS_VIEW_H_

#include <qscrollview.h>
#include <qlayout.h>
#include <qlabel.h>
#include <qhbox.h>
#include <qvbox.h>
#include <qvbuttongroup.h>
#include <qspinbox.h>
#include <qcheckbox.h>
#include <qlineedit.h>
#include <qradiobutton.h>
#include <qobject.h>
#include <qstring.h>

#include "help_view.h"

#include <qmessagebox.h>

#include "options.h"

class Option_Label: public QLabel {
	Q_OBJECT
public:
	Option_Label(const char* name, QWidget* parent)
		: QLabel(name, parent, 0, 0)
	{
		setFocusPolicy(QWidget::WheelFocus);
		setSizePolicy(QSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding));
		show();
	}

signals:
	void focus_gained(Option_Label*);

protected:
	virtual void focusInEvent(QFocusEvent* e) {
		QLabel::focusInEvent(e);
		emit focus_gained(this);
	}
};

class Option_Check_Box: public QCheckBox {
	Q_OBJECT
public:
	Option_Check_Box(const char* name, QWidget* parent)
		: QCheckBox(name, parent)
	{
		setFocusPolicy(QWidget::WheelFocus);
		setSizePolicy(QSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding));
		show();
	}

signals:
	void focus_gained(Option_Check_Box*);

protected:
	virtual void focusInEvent(QFocusEvent* e) {
		QCheckBox::focusInEvent(e);
		emit focus_gained(this);
	}
};

class Option_Radio_Button: public QRadioButton {
	Q_OBJECT
public:
	Option_Radio_Button(const char* name, QWidget* parent)
		: QRadioButton(name, parent)
	{
		setFocusPolicy(QWidget::WheelFocus);
		setSizePolicy(QSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding));
		show();
	}

signals:
	void focus_gained(Option_Radio_Button*);

protected:
	virtual void focusInEvent(QFocusEvent* e) {
		QRadioButton::focusInEvent(e);
		emit focus_gained(this);
	}
};

class Option_Line_Edit: public QLineEdit {
	Q_OBJECT
public:
	Option_Line_Edit(QWidget* parent)
		: QLineEdit(parent)
	{
		setFocusPolicy(QWidget::WheelFocus);
		setSizePolicy(QSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding));
		show();
	}

	Option_Line_Edit(const QString& contents, QWidget* parent)
		: QLineEdit(contents, parent)
	{
		setFocusPolicy(QWidget::WheelFocus);
		setSizePolicy(QSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding));
		show();
	}

signals:
	void focus_gained(Option_Line_Edit*);

protected:
	virtual void focusInEvent(QFocusEvent* e)
	{
		QLineEdit::focusInEvent(e);
		emit focus_gained(this);
	}
};

class Option_Spin_Box: public QSpinBox {
	Q_OBJECT
public:
	Option_Spin_Box(QWidget* parent)
		: QSpinBox(parent)
	{
		inline_editor_ = focusProxy();
		setFocusProxy(0);
		setFocusPolicy(QWidget::WheelFocus);
		setSizePolicy(QSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding));
		show();
	}

signals:
	void focus_gained(Option_Spin_Box*);

protected:
	virtual void focusInEvent(QFocusEvent* e)
	{
		QSpinBox::focusInEvent(e);
		emit focus_gained(this);
		if (inline_editor_)
			inline_editor_->setFocus();
	}

private:
	QWidget* inline_editor_;
};

/*
 *  Option Editors
 */

/*
 * The very base class of all option editors
 */

class Option_Editor {
public:
	Option_Editor(Option* option)
		: option_(option) { }

	Option* option() { return option_; }

	virtual void dump() { }

protected:
	Option* option_;
};

// option values derive from this
class Option_Editor_NoLabel: public QHBox, public Option_Editor {
	Q_OBJECT
public:
	Option_Editor_NoLabel(QWidget* parent, Option* option)
		: QHBox(parent), Option_Editor(option) {
		setFocusPolicy(QWidget::WheelFocus);
		show();
	}
};

// flag, integer, and string option editors derive from this
class Option_Editor_Label: public QHBox, public Option_Editor {
	Q_OBJECT
public:
	Option_Editor_Label(QWidget* parent, Option* option)
		: QHBox(parent), Option_Editor(option) {
		setFocusPolicy(QWidget::WheelFocus);
		label_ = new Option_Label(option->name().c_str(), this);
		connect(label_, SIGNAL(focus_gained(Option_Label*)), this, SLOT(child_focus_gained(QWidget*)));
		show();
	}

signals:
	void focus_gained(Option_Editor*);

protected slots:
	void child_focus_gained(QWidget*) {
		emit focus_gained(this);
	}

protected:
	virtual void focusInEvent(QFocusEvent* e) {
		QHBox::focusInEvent(e);
		emit focus_gained(this);
	}

private:
	Option_Label* label_;
};

/*
 *  Two base classes for the other option editors (both are derived from Option_Editor)
 */

// set and enum option editors derive from this
class Option_Editor_Box: public QVButtonGroup, public Option_Editor {
	Q_OBJECT
public:
	Option_Editor_Box(QWidget* parent, Option* option)
		: QVButtonGroup(option->name().c_str(), parent), Option_Editor(option) {
		setFocusPolicy(QWidget::WheelFocus);
		setRadioButtonExclusive(TRUE);
		show();
	}

signals:
	void focus_gained(Option_Editor*);

protected slots:
	void child_focus_gained(QWidget*) {
		emit focus_gained(this);
	}

protected:
	virtual void focusInEvent(QFocusEvent* e) {
		QVButtonGroup::focusInEvent(e);
		emit focus_gained(this);
	}
};

/*
 *  The real option editors
 */

template <typename T, typename V>
bool do_set(T *t, V v)
{
	const std::string* msg;
	if (msg = t->set(v)) {
		QMessageBox::critical(0, "Constraint viaolation", msg->c_str());
		delete msg;
		return false;
	}
	return true;
}

class Integer_Option_Editor: public Option_Editor_Label {
	Q_OBJECT
public:
	Integer_Option_Editor(QWidget *parent, Option* option)
		: Option_Editor_Label(parent, option) {
		spin_box_ = new Option_Spin_Box(this);
		spin_box_->setValue(as_integer()->get());
		connect(spin_box_, SIGNAL(focus_gained(Option_Spin_Box*)), this, SLOT(child_focus_gained(QWidget*)));
		connect(spin_box_, SIGNAL(valueChanged(int)), this, SLOT(set_value(int)));
	}

	Integer_Option* as_integer() {
		return dynamic_cast<Integer_Option*>(option_);
	}

protected slots:
	void set_value(int value) {
//		as_integer()->set(value);
		if (!do_set(as_integer(), value))
			spin_box_->setValue(as_integer()->get());
	}

private:
	Option_Spin_Box* spin_box_;
};

class String_Option_Editor: public Option_Editor_Label {
	Q_OBJECT
public:
	String_Option_Editor(QWidget *parent, Option* option)
		: Option_Editor_Label(parent, option) {
		line_edit_ = new Option_Line_Edit(as_string()->get().c_str(), this);
		connect(line_edit_, SIGNAL(focus_gained(Option_Line_Edit*)), this, SLOT(child_focus_gained(QWidget*)));
		connect(line_edit_, SIGNAL(textChanged(const QString&)), this, SLOT(set_value(const QString&)));
	}

	String_Option* as_string() {
		return dynamic_cast<String_Option*>(option_);
	}

protected slots:
	void set_value(const QString& value) {
		if (!do_set(as_string(), value.latin1()))
			line_edit_->setText(as_string()->get().c_str());
	}

private:
	Option_Line_Edit* line_edit_;
};

class Flag_Option_Editor: public Option_Editor_Label {
	Q_OBJECT
public:
	Flag_Option_Editor(QWidget *parent, Option* option)
		: Option_Editor_Label(parent, option) {
		check_box_ = new Option_Check_Box("", this);
		check_box_->setChecked(as_flag()->get());
		connect(check_box_, SIGNAL(focus_gained(Option_Check_Box*)), this, SLOT(child_focus_gained(QWidget*)));
		connect(check_box_, SIGNAL(stateChanged(int)), this, SLOT(set_value(int)));
	}

	Flag_Option* as_flag() {
		return dynamic_cast<Flag_Option*>(option_);
	}

protected slots:
	void set_value(int state) {
		bool result;
		if (state == 2)
			result = do_set(as_flag(), true);  //as_flag()->set(true);
		else if (state == 0)
			result = do_set(as_flag(), false); //as_flag()->set(false);

		if (!result)
			check_box_->setChecked(as_flag()->get());
	}

private:
	Option_Check_Box* check_box_;
};

class Set_Option_Value_Editor: public Option_Editor_Label {
	Q_OBJECT
public:
	Set_Option_Value_Editor(QWidget *parent, Option* option)
		: Option_Editor_Label(parent, option) {
		check_box_ = new Option_Check_Box("", this);
		check_box_->setChecked(as_flag()->get());
		connect(check_box_, SIGNAL(focus_gained(Option_Check_Box*)), this, SLOT(child_focus_gained(QWidget*)));
		connect(check_box_, SIGNAL(stateChanged(int)), this, SLOT(set_value(int)));
	}

	Set_Value* as_flag() {
		return dynamic_cast<Set_Value*>(option_);
	}

protected slots:
	void set_value(int state) {
		bool result;
		if (state == 2)
			result = do_set(as_flag(), true);  //as_flag()->set(true);
		else if (state == 0)
			result = do_set(as_flag(), false); //as_flag()->set(false);

		if (!result)
			check_box_->setChecked(as_flag()->get());
	}

private:
	Option_Check_Box* check_box_;
};

class Enum_Option_Value_Editor: public Option_Editor_NoLabel {
	Q_OBJECT
public:
	Enum_Option_Value_Editor(QWidget *parent, Option* option)
		: Option_Editor_NoLabel(parent, option) {
		radio_btn_ = new Option_Radio_Button("", parent);
		radio_btn_->setText(option->name().c_str());
		radio_btn_->setChecked(as_flag()->get());
		connect(radio_btn_, SIGNAL(focus_gained(Option_Radio_Button*)), this, SLOT(child_focus_gained(QWidget*)));
		connect(radio_btn_, SIGNAL(stateChanged(int)), this, SLOT(set_value(int)));
	}

	Enum_Value* as_flag() {
		return dynamic_cast<Enum_Value*>(option_);
	}

protected slots:
	void set_value(int state) {
		bool result;
		if (state == 2)
			result = do_set(as_flag(), true);  //as_flag()->set(true);
		else if (state == 0)
			result = do_set(as_flag(), false); //as_flag()->set(false);

		if (!result)
			radio_btn_->setChecked(as_flag()->get());
	}

private:
	Option_Radio_Button* radio_btn_;
};

class Enum_Option_Editor: public Option_Editor_Box {
	Q_OBJECT
public:
	Enum_Option_Editor(QWidget *parent, Option* option)
		: Option_Editor_Box(parent, option) {
		Enum_Option_Value_Editor *btn;
		for (Enum_Option::iterator iter = as_enum()->begin();
			 iter != as_enum()->end(); ++iter) {
			btn = new Enum_Option_Value_Editor(this, *iter);
			connect(btn, SIGNAL(focus_gained(OptionEditor*)), this, SLOT(child_focus_gained(Option_Editor*)));
		}
	}

	Enum_Option* as_enum() {
		return dynamic_cast<Enum_Option*>(option_);
	}
};

class Set_Option_Editor: public Option_Editor_Box {
	Q_OBJECT
public:
	Set_Option_Editor(QWidget *parent, Option* option)
		: Option_Editor_Box(parent, option) {
		Set_Option_Value_Editor* btn;
		for (Set_Option::iterator iter = as_set()->begin();
			 iter != as_set()->end(); ++iter) {
			btn = new Set_Option_Value_Editor(this, *iter);
			connect(btn, SIGNAL(focus_gained(Option_Editor*)), this, SLOT(child_focus_gained(Option_Editor*)));
		}
	}

	Set_Option* as_set() {
		return dynamic_cast<Set_Option*>(option_);
	}
};

/*
 *  class Option_View interface
 */
class Options_View: public QScrollView {
	Q_OBJECT
public:
	Options_View(QWidget* parent, Help_View* help_view);
	void update_options(Option_Category* category);
	Option_Editor* option_editor_factory(QWidget *parent, Option* option);

protected slots:
	void focus_changed(Option_Editor*);

private:
	QVBox* vbox_;
	QLabel* label_;
	Help_View* help_view_;
};

inline Option_Editor*
Options_View::option_editor_factory(QWidget *parent, Option* option)
{
	Option_Editor* result = NULL;
	if (dynamic_cast<Flag_Option*>(option))
		result = new Flag_Option_Editor(parent, option);
	if (dynamic_cast<Integer_Option*>(option))
		result = new Integer_Option_Editor(parent, option);
	if (dynamic_cast<String_Option*>(option))
		result = new String_Option_Editor(parent, option);

	if (result) {
		connect(dynamic_cast<Option_Editor_Label*> (result), SIGNAL(focus_gained(Option_Editor*)), 
				this, SLOT(focus_changed(Option_Editor*)));
	}
	else {
		if (dynamic_cast<Enum_Option*>(option))
			result = new Enum_Option_Editor(parent, option);
		if (dynamic_cast<Set_Option*>(option))
			result = new Set_Option_Editor(parent, option);
		if (result) {
			connect(dynamic_cast<Option_Editor_Box*> (result), SIGNAL(focus_gained(Option_Editor*)),
					this, SLOT(focus_changed(Option_Editor*)));
		}
	}

//	QMessageBox::information(NULL, "DEBUG", "Factory: EXIT");
	return result;
}

inline
Options_View::Options_View(QWidget* parent, Help_View* help_view)
	: QScrollView(parent, "Options_View"), help_view_(help_view)
{
	enableClipper(TRUE);
	vbox_ = new QVBox(viewport());
	addChild(vbox_);
	setSizePolicy(QSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding));
	setVScrollBarMode(QScrollView::AlwaysOn);
}

inline void
Options_View::update_options(Option_Category* category)
{
//	QMessageBox::information(NULL, "DEBUG", "Options_View::update_options: ENTER");
	delete vbox_;
	vbox_ = new QVBox(viewport());
	vbox_->show();
	addChild(vbox_);

	Option_Editor* option_editor;
	for (Option_Category::iterator iter = category->begin();
		 iter != category->end(); ++iter)
		if (!dynamic_cast<Option_Category*>(*iter))
			option_editor = option_editor_factory(vbox_, *iter);
//	QMessageBox::information(NULL, "DEBUG", "Options_View::update_options: EXIT");
}

inline void
Options_View::focus_changed(Option_Editor* option_editor)
{
	help_view_->update_description(option_editor->option());
}

#endif //  _OPTIONS_VIEW_H_
