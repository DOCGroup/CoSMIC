#ifndef MOBIES_PICML_H
#define MOBIES_PICML_H

// header file PICML.h generated from diagram PICML
// generated with Udm version 3.13 on Wed Dec 09 21:45:55 2009

#include <UdmBase.h>

#if !defined(UDM_VERSION_MAJOR) || !defined(UDM_VERSION_MINOR)
#    error "Udm headers too old, they do not define UDM_VERSION"
#elif UDM_VERSION_MAJOR < 3
#    error "Udm headers too old, minimum version required 3.13"
#elif UDM_VERSION_MAJOR == 3 && UDM_VERSION_MINOR < 13
#    error "Udm headers too old, minimum version required 3.13"
#endif

#include <Uml.h>

#define BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
#define BOOST_MPL_LIMIT_VECTOR_SIZE 40
#include <UdmMPL.h>

#ifdef min
#undef min
#endif

#ifdef max
#undef max
#endif

#include "PICML_export.h"

namespace PICML {

	extern ::Uml::Diagram meta;
	class PICML_Export InfoProperty;
	class PICML_Export ConfigProperty;
	class PICML_Export MonolithprimaryArtifact;
	class PICML_Export MonolithDeployRequirement;
	class PICML_Export MonolithExecParameter;
	class PICML_Export ComponentServantArtifact;
	class PICML_Export ComponentImplementationArtifact;
	class PICML_Export ImplementationContainer;
	class PICML_Export MonolithicImplementationBase;
	class PICML_Export Implemenation;
	class PICML_Export ComponentFactoryImplementations;
	class PICML_Export ComponentFactoryImplementationContainer;
	class PICML_Export ComponentFactoryInstance;
	class PICML_Export RTRequirements;
	class PICML_Export ServiceProvider;
	class PICML_Export MultipleServiceRequests;
	class PICML_Export ServiceLevels;
	class PICML_Export ServiceConsumer;
	class PICML_Export ECBehavior;
	class PICML_Export ECRequirements;
	class PICML_Export ECRole;
	class PICML_Export ExternalPortReferenceType;
	class PICML_Export ComponentAssemblyReference;
	class PICML_Export ComponentAssembly;
	class PICML_Export ExternalPortReference;
	class PICML_Export ConnectedComponent;
	class PICML_Export Path;
	class PICML_Export PathDiagrams;
	class PICML_Export DstEdge;
	class PICML_Export GraphVertex;
	class PICML_Export SrcEdge;
	class PICML_Export EdgeProperty;
	class PICML_Export Edge;
	class PICML_Export DisplayNode;
	class PICML_Export Paths;
	class PICML_Export PathProperty;
	class PICML_Export PathReference;
	class PICML_Export MetricConnection;
	class PICML_Export DataAnalysisBase;
	class PICML_Export Average;
	class PICML_Export Minimum;
	class PICML_Export Maximum;
	class PICML_Export Jitter;
	class PICML_Export TimeProbe;
	class PICML_Export TimerConnection;
	class PICML_Export Latency;
	class PICML_Export Throughput;
	class PICML_Export ComponentAnalyses;
	class PICML_Export BenchmarkAnalysis;
	class PICML_Export MetricsBase;
	class PICML_Export OperationRef;
	class PICML_Export EventRef;
	class PICML_Export TimerEventSinkConn;
	class PICML_Export TaskSet;
	class PICML_Export Task;
	class PICML_Export WorkloadCharacteristics;
	class PICML_Export ComponentOperation;
	class PICML_Export CompRef;
	class PICML_Export WorkLoadOperationConnection;
	class PICML_Export BenchmarkType;
	class PICML_Export TriggerBenchmarks;
	class PICML_Export FixedIterationBenchmarks;
	class PICML_Export PeriodicBenchmarks;
	class PICML_Export BenchmarkCharacteristics;
	class PICML_Export NodeReference;
	class PICML_Export Interconnect;
	class PICML_Export Node;
	class PICML_Export Resource;
	class PICML_Export Bridge;
	class PICML_Export SharedResource;
	class PICML_Export InstanceMapping;
	class PICML_Export DeploymentPlans;
	class PICML_Export CollocationGroup;
	class PICML_Export SharedComponentReference;
	class PICML_Export ComponentFactoryRef;
	class PICML_Export Deploys;
	class PICML_Export CollocationGroupMember;
	class PICML_Export DeploymentPlan;
	class PICML_Export invoke;
	class PICML_Export AssemblyselectRequirement;
	class PICML_Export AssemblyConfigProperty;
	class PICML_Export PublishConnector;
	class PICML_Export publish;
	class PICML_Export deliverTo;
	class PICML_Export AssemblyDeployRequirement;
	class PICML_Export emit;
	class PICML_Export ReceptacleDelegate;
	class PICML_Export FacetDelegate;
	class PICML_Export EventSourceDelegate;
	class PICML_Export EventSinkDelegate;
	class PICML_Export ExternalDelegate;
	class PICML_Export AttributeValue;
	class PICML_Export AttributeDelegate;
	class PICML_Export AttributeMapping;
	class PICML_Export AttributeMappingValue;
	class PICML_Export AttributeMappingDelegate;
	class PICML_Export SupportsDelegate;
	class PICML_Export InvokePortBase;
	class PICML_Export ImplementationCapability;
	class PICML_Export ImplementationDependsOn;
	class PICML_Export Implements;
	class PICML_Export ComponentImplementations;
	class PICML_Export ComponentImplementation;
	class PICML_Export ComponentImplementationContainer;
	class PICML_Export CriticalPath;
	class PICML_Export ComponentImplementationReference;
	class PICML_Export MonolithicImplementation;
	class PICML_Export PackageConfBasePackage;
	class PICML_Export PackageConfReference;
	class PICML_Export PackageConfigurations;
	class PICML_Export PackageConfigurationContainer;
	class PICML_Export PackageConfConfigProperty;
	class PICML_Export PackageConfSelectRequirement;
	class PICML_Export PackageConfSpecializedConfig;
	class PICML_Export PackageConfigurationReference;
	class PICML_Export PackageConfiguration;
	class PICML_Export ImplementationArtifacts;
	class PICML_Export ArtifactDependsOn;
	class PICML_Export ArtifactDeployRequirement;
	class PICML_Export ArtifactContainer;
	class PICML_Export ArtifactExecParameter;
	class PICML_Export ArtifactInfoProperty;
	class PICML_Export ArtifactDependency;
	class PICML_Export ImplementationArtifactReference;
	class PICML_Export ImplementationArtifact;
	class PICML_Export ComponentTypes;
	class PICML_Export ComponentPropertyDescription;
	class PICML_Export ComponentProperty;
	class PICML_Export ComponentContainer;
	class PICML_Export ComponentConfigProperty;
	class PICML_Export ComponentInfoProperty;
	class PICML_Export CommonPortAttrs;
	class PICML_Export TopLevelPackageContainer;
	class PICML_Export TopLevelPackages;
	class PICML_Export TopLevelPackage;
	class PICML_Export package;
	class PICML_Export ComponentPackages;
	class PICML_Export PackageInterface;
	class PICML_Export Implementation;
	class PICML_Export PackageContainer;
	class PICML_Export PackageConfigProperty;
	class PICML_Export PackageInfoProperty;
	class PICML_Export ComponentPackage;
	class PICML_Export ComponentPackageReference;
	class PICML_Export Requirement;
	class PICML_Export Capability;
	class PICML_Export DataType;
	class PICML_Export SatisfierProperty;
	class PICML_Export ImplementationDependency;
	class PICML_Export RequirementSatisfier;
	class PICML_Export RequirementBase;
	class PICML_Export ImplementationRequirement;
	class PICML_Export Property;
	class PICML_Export Targets;
	class PICML_Export Shares;
	class PICML_Export InterconnectConnection;
	class PICML_Export BridgeConnection;
	class PICML_Export Domain;
	class PICML_Export Prefixable;
	class PICML_Export Taggable;
	class PICML_Export Port;
	class PICML_Export Manageable;
	class PICML_Export Provideable;
	class PICML_Export ComponentFactory;
	class PICML_Export ComponentRef;
	class PICML_Export ManagesComponent;
	class PICML_Export ProvidedRequestPort;
	class PICML_Export InEventPort;
	class PICML_Export OutEventPort;
	class PICML_Export RequiredRequestPort;
	class PICML_Export Component;
	class PICML_Export OperationBase;
	class PICML_Export HasExceptions;
	class PICML_Export InParameter;
	class PICML_Export InoutParameter;
	class PICML_Export OutParameter;
	class PICML_Export ReturnType;
	class PICML_Export ParameterType;
	class PICML_Export OnewayOperation;
	class PICML_Export LookupOperation;
	class PICML_Export FactoryOperation;
	class PICML_Export TwowayOperation;
	class PICML_Export Object;
	class PICML_Export Inherits;
	class PICML_Export Event;
	class PICML_Export ValueObject;
	class PICML_Export HasOperations;
	class PICML_Export SupportsInterfaces;
	class PICML_Export Supports;
	class PICML_Export Attribute;
	class PICML_Export LookupKey;
	class PICML_Export SetException;
	class PICML_Export ObjectByValue;
	class PICML_Export GetException;
	class PICML_Export PrivateFlag;
	class PICML_Export MakeMemberPrivate;
	class PICML_Export AttributeMember;
	class PICML_Export Inheritable;
	class PICML_Export ReadonlyAttribute;
	class PICML_Export EnumValue;
	class PICML_Export Aggregate;
	class PICML_Export SwitchedAggregate;
	class PICML_Export Label;
	class PICML_Export LabelConnection;
	class PICML_Export MemberType;
	class PICML_Export Discriminator;
	class PICML_Export Alias;
	class PICML_Export Boxed;
	class PICML_Export NoInheritable;
	class PICML_Export Collection;
	class PICML_Export Enum;
	class PICML_Export Member;
	class PICML_Export NamedType;
	class PICML_Export PredefinedTypes;
	class PICML_Export Byte;
	class PICML_Export Boolean;
	class PICML_Export ShortInteger;
	class PICML_Export LongInteger;
	class PICML_Export RealNumber;
	class PICML_Export String;
	class PICML_Export GenericObject;
	class PICML_Export GenericValueObject;
	class PICML_Export GenericValue;
	class PICML_Export TypeEncoding;
	class PICML_Export TypeKind;
	class PICML_Export PredefinedType;
	class PICML_Export Package;
	class PICML_Export File;
	class PICML_Export Exception;
	class PICML_Export ExceptionRef;
	class PICML_Export InterfaceDefinitions;
	class PICML_Export ConstantType;
	class PICML_Export Constant;
	class PICML_Export FileRef;
	class PICML_Export ComponentBuild;
	class PICML_Export Project;
	class PICML_Export ExternalResources;
	class PICML_Export ExtResourceConn;
	class PICML_Export ComponentLib;
	class PICML_Export MPC;
	class PICML_Export StubProject;
	class PICML_Export ServantProject;
	class PICML_Export ExecutorProject;
	class PICML_Export Workspaces;
	class PICML_Export WorkerLibraries;
	class PICML_Export WorkerLibrary;
	class PICML_Export Worker;
	class PICML_Export WorkerFile;
	class PICML_Export WorkerPackage;
	class PICML_Export WorkerType;
	class PICML_Export WorkerPackageBase;
	class PICML_Export Variable;
	class PICML_Export BehaviorModel;
	class PICML_Export BehaviorInputAction;
	class PICML_Export Action;
	class PICML_Export OutputAction;
	class PICML_Export Finish;
	class PICML_Export QueryAction;
	class PICML_Export InputAction;
	class PICML_Export QueryInputAction;
	class PICML_Export MultiInputAction;
	class PICML_Export ActionBase;
	class PICML_Export Environment;
	class PICML_Export PeriodicEvent;
	class PICML_Export ApplicationTask;
	class PICML_Export Input;
	class PICML_Export SingleInputBase;
	class PICML_Export MultiInputBase;
	class PICML_Export MultiOutputBase;
	class PICML_Export SingleOutputBase;
	class PICML_Export MultiInput;
	class PICML_Export TopLevelBehavior;
	class PICML_Export QueryInput;
	class PICML_Export QueryInputBase;
	class PICML_Export Transition;
	class PICML_Export BranchState;
	class PICML_Export BranchTransition;
	class PICML_Export LoopState;
	class PICML_Export ForState;
	class PICML_Export DoWhileState;
	class PICML_Export WhileState;
	class PICML_Export LoopTransition;
	class PICML_Export State;
	class PICML_Export StateBase;
	class PICML_Export Terminal;
	class PICML_Export TerminalTransition;
	class PICML_Export Effect;
	class PICML_Export InputEffect;
	class PICML_Export TerminalEffect;
	class PICML_Export EffectBase;
	class PICML_Export RootFolder;
	class PICML_Export MgaObject;

	class PICML_Export Visitor : public Udm::BaseVisitor {
	public:
		virtual ~Visitor() {}

		virtual void Visit_InfoProperty(const InfoProperty &) {}
		virtual void Visit_ConfigProperty(const ConfigProperty &) {}
		virtual void Visit_MonolithprimaryArtifact(const MonolithprimaryArtifact &) {}
		virtual void Visit_MonolithDeployRequirement(const MonolithDeployRequirement &) {}
		virtual void Visit_MonolithExecParameter(const MonolithExecParameter &) {}
		virtual void Visit_ComponentServantArtifact(const ComponentServantArtifact &) {}
		virtual void Visit_ComponentImplementationArtifact(const ComponentImplementationArtifact &) {}
		virtual void Visit_ComponentFactoryImplementations(const ComponentFactoryImplementations &) {}
		virtual void Visit_ComponentFactoryImplementationContainer(const ComponentFactoryImplementationContainer &) {}
		virtual void Visit_ComponentFactoryInstance(const ComponentFactoryInstance &) {}
		virtual void Visit_RTRequirements(const RTRequirements &) {}
		virtual void Visit_ServiceProvider(const ServiceProvider &) {}
		virtual void Visit_MultipleServiceRequests(const MultipleServiceRequests &) {}
		virtual void Visit_ServiceLevels(const ServiceLevels &) {}
		virtual void Visit_ServiceConsumer(const ServiceConsumer &) {}
		virtual void Visit_ECBehavior(const ECBehavior &) {}
		virtual void Visit_ECRequirements(const ECRequirements &) {}
		virtual void Visit_ECRole(const ECRole &) {}
		virtual void Visit_ComponentAssemblyReference(const ComponentAssemblyReference &) {}
		virtual void Visit_ComponentAssembly(const ComponentAssembly &) {}
		virtual void Visit_ExternalPortReference(const ExternalPortReference &) {}
		virtual void Visit_ConnectedComponent(const ConnectedComponent &) {}
		virtual void Visit_Path(const Path &) {}
		virtual void Visit_PathDiagrams(const PathDiagrams &) {}
		virtual void Visit_DstEdge(const DstEdge &) {}
		virtual void Visit_SrcEdge(const SrcEdge &) {}
		virtual void Visit_EdgeProperty(const EdgeProperty &) {}
		virtual void Visit_Edge(const Edge &) {}
		virtual void Visit_DisplayNode(const DisplayNode &) {}
		virtual void Visit_Paths(const Paths &) {}
		virtual void Visit_PathProperty(const PathProperty &) {}
		virtual void Visit_PathReference(const PathReference &) {}
		virtual void Visit_MetricConnection(const MetricConnection &) {}
		virtual void Visit_Average(const Average &) {}
		virtual void Visit_Minimum(const Minimum &) {}
		virtual void Visit_Maximum(const Maximum &) {}
		virtual void Visit_Jitter(const Jitter &) {}
		virtual void Visit_TimeProbe(const TimeProbe &) {}
		virtual void Visit_TimerConnection(const TimerConnection &) {}
		virtual void Visit_Latency(const Latency &) {}
		virtual void Visit_Throughput(const Throughput &) {}
		virtual void Visit_ComponentAnalyses(const ComponentAnalyses &) {}
		virtual void Visit_BenchmarkAnalysis(const BenchmarkAnalysis &) {}
		virtual void Visit_OperationRef(const OperationRef &) {}
		virtual void Visit_EventRef(const EventRef &) {}
		virtual void Visit_TimerEventSinkConn(const TimerEventSinkConn &) {}
		virtual void Visit_TaskSet(const TaskSet &) {}
		virtual void Visit_Task(const Task &) {}
		virtual void Visit_WorkloadCharacteristics(const WorkloadCharacteristics &) {}
		virtual void Visit_ComponentOperation(const ComponentOperation &) {}
		virtual void Visit_CompRef(const CompRef &) {}
		virtual void Visit_WorkLoadOperationConnection(const WorkLoadOperationConnection &) {}
		virtual void Visit_TriggerBenchmarks(const TriggerBenchmarks &) {}
		virtual void Visit_FixedIterationBenchmarks(const FixedIterationBenchmarks &) {}
		virtual void Visit_PeriodicBenchmarks(const PeriodicBenchmarks &) {}
		virtual void Visit_BenchmarkCharacteristics(const BenchmarkCharacteristics &) {}
		virtual void Visit_NodeReference(const NodeReference &) {}
		virtual void Visit_Interconnect(const Interconnect &) {}
		virtual void Visit_Node(const Node &) {}
		virtual void Visit_Resource(const Resource &) {}
		virtual void Visit_Bridge(const Bridge &) {}
		virtual void Visit_SharedResource(const SharedResource &) {}
		virtual void Visit_InstanceMapping(const InstanceMapping &) {}
		virtual void Visit_DeploymentPlans(const DeploymentPlans &) {}
		virtual void Visit_CollocationGroup(const CollocationGroup &) {}
		virtual void Visit_SharedComponentReference(const SharedComponentReference &) {}
		virtual void Visit_ComponentFactoryRef(const ComponentFactoryRef &) {}
		virtual void Visit_Deploys(const Deploys &) {}
		virtual void Visit_DeploymentPlan(const DeploymentPlan &) {}
		virtual void Visit_invoke(const invoke &) {}
		virtual void Visit_AssemblyselectRequirement(const AssemblyselectRequirement &) {}
		virtual void Visit_AssemblyConfigProperty(const AssemblyConfigProperty &) {}
		virtual void Visit_PublishConnector(const PublishConnector &) {}
		virtual void Visit_publish(const publish &) {}
		virtual void Visit_deliverTo(const deliverTo &) {}
		virtual void Visit_AssemblyDeployRequirement(const AssemblyDeployRequirement &) {}
		virtual void Visit_emit(const emit &) {}
		virtual void Visit_ReceptacleDelegate(const ReceptacleDelegate &) {}
		virtual void Visit_FacetDelegate(const FacetDelegate &) {}
		virtual void Visit_EventSourceDelegate(const EventSourceDelegate &) {}
		virtual void Visit_EventSinkDelegate(const EventSinkDelegate &) {}
		virtual void Visit_ExternalDelegate(const ExternalDelegate &) {}
		virtual void Visit_AttributeValue(const AttributeValue &) {}
		virtual void Visit_AttributeDelegate(const AttributeDelegate &) {}
		virtual void Visit_AttributeMapping(const AttributeMapping &) {}
		virtual void Visit_AttributeMappingValue(const AttributeMappingValue &) {}
		virtual void Visit_AttributeMappingDelegate(const AttributeMappingDelegate &) {}
		virtual void Visit_SupportsDelegate(const SupportsDelegate &) {}
		virtual void Visit_ImplementationCapability(const ImplementationCapability &) {}
		virtual void Visit_ImplementationDependsOn(const ImplementationDependsOn &) {}
		virtual void Visit_Implements(const Implements &) {}
		virtual void Visit_ComponentImplementations(const ComponentImplementations &) {}
		virtual void Visit_ComponentImplementationContainer(const ComponentImplementationContainer &) {}
		virtual void Visit_CriticalPath(const CriticalPath &) {}
		virtual void Visit_ComponentImplementationReference(const ComponentImplementationReference &) {}
		virtual void Visit_MonolithicImplementation(const MonolithicImplementation &) {}
		virtual void Visit_PackageConfBasePackage(const PackageConfBasePackage &) {}
		virtual void Visit_PackageConfReference(const PackageConfReference &) {}
		virtual void Visit_PackageConfigurations(const PackageConfigurations &) {}
		virtual void Visit_PackageConfigurationContainer(const PackageConfigurationContainer &) {}
		virtual void Visit_PackageConfConfigProperty(const PackageConfConfigProperty &) {}
		virtual void Visit_PackageConfSelectRequirement(const PackageConfSelectRequirement &) {}
		virtual void Visit_PackageConfSpecializedConfig(const PackageConfSpecializedConfig &) {}
		virtual void Visit_PackageConfigurationReference(const PackageConfigurationReference &) {}
		virtual void Visit_PackageConfiguration(const PackageConfiguration &) {}
		virtual void Visit_ImplementationArtifacts(const ImplementationArtifacts &) {}
		virtual void Visit_ArtifactDependsOn(const ArtifactDependsOn &) {}
		virtual void Visit_ArtifactDeployRequirement(const ArtifactDeployRequirement &) {}
		virtual void Visit_ArtifactContainer(const ArtifactContainer &) {}
		virtual void Visit_ArtifactExecParameter(const ArtifactExecParameter &) {}
		virtual void Visit_ArtifactInfoProperty(const ArtifactInfoProperty &) {}
		virtual void Visit_ArtifactDependency(const ArtifactDependency &) {}
		virtual void Visit_ImplementationArtifactReference(const ImplementationArtifactReference &) {}
		virtual void Visit_ImplementationArtifact(const ImplementationArtifact &) {}
		virtual void Visit_ComponentTypes(const ComponentTypes &) {}
		virtual void Visit_ComponentPropertyDescription(const ComponentPropertyDescription &) {}
		virtual void Visit_ComponentProperty(const ComponentProperty &) {}
		virtual void Visit_ComponentContainer(const ComponentContainer &) {}
		virtual void Visit_ComponentConfigProperty(const ComponentConfigProperty &) {}
		virtual void Visit_ComponentInfoProperty(const ComponentInfoProperty &) {}
		virtual void Visit_TopLevelPackageContainer(const TopLevelPackageContainer &) {}
		virtual void Visit_TopLevelPackages(const TopLevelPackages &) {}
		virtual void Visit_TopLevelPackage(const TopLevelPackage &) {}
		virtual void Visit_package(const package &) {}
		virtual void Visit_ComponentPackages(const ComponentPackages &) {}
		virtual void Visit_PackageInterface(const PackageInterface &) {}
		virtual void Visit_Implementation(const Implementation &) {}
		virtual void Visit_PackageContainer(const PackageContainer &) {}
		virtual void Visit_PackageConfigProperty(const PackageConfigProperty &) {}
		virtual void Visit_PackageInfoProperty(const PackageInfoProperty &) {}
		virtual void Visit_ComponentPackage(const ComponentPackage &) {}
		virtual void Visit_ComponentPackageReference(const ComponentPackageReference &) {}
		virtual void Visit_Requirement(const Requirement &) {}
		virtual void Visit_Capability(const Capability &) {}
		virtual void Visit_DataType(const DataType &) {}
		virtual void Visit_SatisfierProperty(const SatisfierProperty &) {}
		virtual void Visit_ImplementationDependency(const ImplementationDependency &) {}
		virtual void Visit_ImplementationRequirement(const ImplementationRequirement &) {}
		virtual void Visit_Property(const Property &) {}
		virtual void Visit_Targets(const Targets &) {}
		virtual void Visit_Shares(const Shares &) {}
		virtual void Visit_InterconnectConnection(const InterconnectConnection &) {}
		virtual void Visit_BridgeConnection(const BridgeConnection &) {}
		virtual void Visit_Domain(const Domain &) {}
		virtual void Visit_ComponentFactory(const ComponentFactory &) {}
		virtual void Visit_ComponentRef(const ComponentRef &) {}
		virtual void Visit_ManagesComponent(const ManagesComponent &) {}
		virtual void Visit_ProvidedRequestPort(const ProvidedRequestPort &) {}
		virtual void Visit_InEventPort(const InEventPort &) {}
		virtual void Visit_OutEventPort(const OutEventPort &) {}
		virtual void Visit_RequiredRequestPort(const RequiredRequestPort &) {}
		virtual void Visit_Component(const Component &) {}
		virtual void Visit_InParameter(const InParameter &) {}
		virtual void Visit_InoutParameter(const InoutParameter &) {}
		virtual void Visit_OutParameter(const OutParameter &) {}
		virtual void Visit_ReturnType(const ReturnType &) {}
		virtual void Visit_OnewayOperation(const OnewayOperation &) {}
		virtual void Visit_LookupOperation(const LookupOperation &) {}
		virtual void Visit_FactoryOperation(const FactoryOperation &) {}
		virtual void Visit_TwowayOperation(const TwowayOperation &) {}
		virtual void Visit_Object(const Object &) {}
		virtual void Visit_Inherits(const Inherits &) {}
		virtual void Visit_Event(const Event &) {}
		virtual void Visit_ValueObject(const ValueObject &) {}
		virtual void Visit_Supports(const Supports &) {}
		virtual void Visit_Attribute(const Attribute &) {}
		virtual void Visit_LookupKey(const LookupKey &) {}
		virtual void Visit_SetException(const SetException &) {}
		virtual void Visit_GetException(const GetException &) {}
		virtual void Visit_PrivateFlag(const PrivateFlag &) {}
		virtual void Visit_MakeMemberPrivate(const MakeMemberPrivate &) {}
		virtual void Visit_AttributeMember(const AttributeMember &) {}
		virtual void Visit_ReadonlyAttribute(const ReadonlyAttribute &) {}
		virtual void Visit_EnumValue(const EnumValue &) {}
		virtual void Visit_Aggregate(const Aggregate &) {}
		virtual void Visit_SwitchedAggregate(const SwitchedAggregate &) {}
		virtual void Visit_Label(const Label &) {}
		virtual void Visit_LabelConnection(const LabelConnection &) {}
		virtual void Visit_Discriminator(const Discriminator &) {}
		virtual void Visit_Alias(const Alias &) {}
		virtual void Visit_Boxed(const Boxed &) {}
		virtual void Visit_Collection(const Collection &) {}
		virtual void Visit_Enum(const Enum &) {}
		virtual void Visit_Member(const Member &) {}
		virtual void Visit_PredefinedTypes(const PredefinedTypes &) {}
		virtual void Visit_Byte(const Byte &) {}
		virtual void Visit_Boolean(const Boolean &) {}
		virtual void Visit_ShortInteger(const ShortInteger &) {}
		virtual void Visit_LongInteger(const LongInteger &) {}
		virtual void Visit_RealNumber(const RealNumber &) {}
		virtual void Visit_String(const String &) {}
		virtual void Visit_GenericObject(const GenericObject &) {}
		virtual void Visit_GenericValueObject(const GenericValueObject &) {}
		virtual void Visit_GenericValue(const GenericValue &) {}
		virtual void Visit_TypeEncoding(const TypeEncoding &) {}
		virtual void Visit_TypeKind(const TypeKind &) {}
		virtual void Visit_Package(const Package &) {}
		virtual void Visit_File(const File &) {}
		virtual void Visit_Exception(const Exception &) {}
		virtual void Visit_ExceptionRef(const ExceptionRef &) {}
		virtual void Visit_InterfaceDefinitions(const InterfaceDefinitions &) {}
		virtual void Visit_Constant(const Constant &) {}
		virtual void Visit_FileRef(const FileRef &) {}
		virtual void Visit_ComponentBuild(const ComponentBuild &) {}
		virtual void Visit_Project(const Project &) {}
		virtual void Visit_ExternalResources(const ExternalResources &) {}
		virtual void Visit_ExtResourceConn(const ExtResourceConn &) {}
		virtual void Visit_MPC(const MPC &) {}
		virtual void Visit_StubProject(const StubProject &) {}
		virtual void Visit_ServantProject(const ServantProject &) {}
		virtual void Visit_ExecutorProject(const ExecutorProject &) {}
		virtual void Visit_Workspaces(const Workspaces &) {}
		virtual void Visit_WorkerLibraries(const WorkerLibraries &) {}
		virtual void Visit_WorkerLibrary(const WorkerLibrary &) {}
		virtual void Visit_Worker(const Worker &) {}
		virtual void Visit_WorkerFile(const WorkerFile &) {}
		virtual void Visit_WorkerPackage(const WorkerPackage &) {}
		virtual void Visit_WorkerType(const WorkerType &) {}
		virtual void Visit_Variable(const Variable &) {}
		virtual void Visit_Action(const Action &) {}
		virtual void Visit_OutputAction(const OutputAction &) {}
		virtual void Visit_Finish(const Finish &) {}
		virtual void Visit_QueryAction(const QueryAction &) {}
		virtual void Visit_InputAction(const InputAction &) {}
		virtual void Visit_QueryInputAction(const QueryInputAction &) {}
		virtual void Visit_MultiInputAction(const MultiInputAction &) {}
		virtual void Visit_Environment(const Environment &) {}
		virtual void Visit_PeriodicEvent(const PeriodicEvent &) {}
		virtual void Visit_ApplicationTask(const ApplicationTask &) {}
		virtual void Visit_Input(const Input &) {}
		virtual void Visit_MultiInput(const MultiInput &) {}
		virtual void Visit_QueryInput(const QueryInput &) {}
		virtual void Visit_Transition(const Transition &) {}
		virtual void Visit_BranchState(const BranchState &) {}
		virtual void Visit_BranchTransition(const BranchTransition &) {}
		virtual void Visit_ForState(const ForState &) {}
		virtual void Visit_DoWhileState(const DoWhileState &) {}
		virtual void Visit_WhileState(const WhileState &) {}
		virtual void Visit_LoopTransition(const LoopTransition &) {}
		virtual void Visit_State(const State &) {}
		virtual void Visit_Terminal(const Terminal &) {}
		virtual void Visit_TerminalTransition(const TerminalTransition &) {}
		virtual void Visit_Effect(const Effect &) {}
		virtual void Visit_InputEffect(const InputEffect &) {}
		virtual void Visit_TerminalEffect(const TerminalEffect &) {}
		virtual void Visit_RootFolder(const RootFolder &) {}
		virtual void Visit_Object(const Udm::Object &) {}

	};

	PICML_Export void Initialize();
	PICML_Export void Initialize(const ::Uml::Diagram &dgr);

	extern PICML_Export Udm::UdmDiagram diagram;

	class PICML_Export ComponentFactoryImplementations : public Udm::Object {
	public:
		typedef ::Udm::FolderMetaTag MetaKind;

		ComponentFactoryImplementations() {}
		ComponentFactoryImplementations(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		ComponentFactoryImplementations(const ComponentFactoryImplementations &master) : UDM_OBJECT(master) {}

		static ComponentFactoryImplementations Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentFactoryImplementations Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentFactoryImplementations CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentFactoryImplementations> Instances() { return Udm::InstantiatedAttr<ComponentFactoryImplementations>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentFactoryImplementations, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentFactoryImplementations, Pred>(impl); }
		ComponentFactoryImplementations CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentFactoryImplementations> Derived() { return Udm::DerivedAttr<ComponentFactoryImplementations>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentFactoryImplementations, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentFactoryImplementations, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentFactoryImplementations> Archetype() const { return Udm::ArchetypeAttr<ComponentFactoryImplementations>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementationContainer> ComponentFactoryImplementationContainer_children() const { return Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementationContainer>(impl, meta_ComponentFactoryImplementationContainer_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementationContainer, Pred> ComponentFactoryImplementationContainer_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementationContainer, Pred>(impl, meta_ComponentFactoryImplementationContainer_children); }
		Udm::ChildrenAttr< ::PICML::ImplementationContainer> ImplementationContainer_kind_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationContainer>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationContainer, Pred> ImplementationContainer_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationContainer, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementationContainer> ComponentFactoryImplementationContainer_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementationContainer>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementationContainer, Pred> ComponentFactoryImplementationContainer_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementationContainer, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, meta_RootFolder_parent); }
		Udm::ParentAttr< ::PICML::RootFolder> parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentFactoryImplementations(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_ComponentFactoryImplementationContainer_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RootFolder_parent {};
		typedef boost::mpl::pair< ::PICML::RootFolder, PR_RootFolder_parent > _PR_RootFolder_parent__RootFolder;
		typedef boost::mpl::vector< _PR_RootFolder_parent__RootFolder> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RootFolder> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ComponentFactoryImplementationContainer_children {};
		typedef boost::mpl::pair< ::PICML::ComponentFactoryImplementationContainer, CR_ComponentFactoryImplementationContainer_children > _CR_ComponentFactoryImplementationContainer_children__ComponentFactoryImplementationContainer;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_ComponentFactoryImplementationContainer_children__ComponentFactoryImplementationContainer> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentFactoryImplementationContainer> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PathDiagrams : public Udm::Object {
	public:
		typedef ::Udm::FolderMetaTag MetaKind;

		PathDiagrams() {}
		PathDiagrams(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		PathDiagrams(const PathDiagrams &master) : UDM_OBJECT(master) {}

		static PathDiagrams Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PathDiagrams Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PathDiagrams CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PathDiagrams> Instances() { return Udm::InstantiatedAttr<PathDiagrams>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PathDiagrams, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PathDiagrams, Pred>(impl); }
		PathDiagrams CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PathDiagrams> Derived() { return Udm::DerivedAttr<PathDiagrams>(impl); }
		template <class Pred> Udm::DerivedAttr<PathDiagrams, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PathDiagrams, Pred>(impl); }
		Udm::ArchetypeAttr<PathDiagrams> Archetype() const { return Udm::ArchetypeAttr<PathDiagrams>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ChildrenAttr< ::PICML::Paths> Paths_children() const { return Udm::ChildrenAttr< ::PICML::Paths>(impl, meta_Paths_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Paths, Pred> Paths_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Paths, Pred>(impl, meta_Paths_children); }
		Udm::ChildrenAttr< ::PICML::Paths> Paths_kind_children() const { return Udm::ChildrenAttr< ::PICML::Paths>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Paths, Pred> Paths_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Paths, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, meta_RootFolder_parent); }
		Udm::ParentAttr< ::PICML::RootFolder> parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_PathDiagrams(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_Paths_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RootFolder_parent {};
		typedef boost::mpl::pair< ::PICML::RootFolder, PR_RootFolder_parent > _PR_RootFolder_parent__RootFolder;
		typedef boost::mpl::vector< _PR_RootFolder_parent__RootFolder> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RootFolder> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Paths_children {};
		typedef boost::mpl::pair< ::PICML::Paths, CR_Paths_children > _CR_Paths_children__Paths;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Paths_children__Paths> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Paths> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentAnalyses : public Udm::Object {
	public:
		typedef ::Udm::FolderMetaTag MetaKind;

		ComponentAnalyses() {}
		ComponentAnalyses(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		ComponentAnalyses(const ComponentAnalyses &master) : UDM_OBJECT(master) {}

		static ComponentAnalyses Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentAnalyses Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentAnalyses CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentAnalyses> Instances() { return Udm::InstantiatedAttr<ComponentAnalyses>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentAnalyses, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentAnalyses, Pred>(impl); }
		ComponentAnalyses CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentAnalyses> Derived() { return Udm::DerivedAttr<ComponentAnalyses>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentAnalyses, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentAnalyses, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentAnalyses> Archetype() const { return Udm::ArchetypeAttr<ComponentAnalyses>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ChildrenAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_children() const { return Udm::ChildrenAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::BenchmarkAnalysis, Pred> BenchmarkAnalysis_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::BenchmarkAnalysis, Pred>(impl, meta_BenchmarkAnalysis_children); }
		Udm::ChildrenAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_kind_children() const { return Udm::ChildrenAttr< ::PICML::BenchmarkAnalysis>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::BenchmarkAnalysis, Pred> BenchmarkAnalysis_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::BenchmarkAnalysis, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, meta_RootFolder_parent); }
		Udm::ParentAttr< ::PICML::RootFolder> parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentAnalyses(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_BenchmarkAnalysis_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RootFolder_parent {};
		typedef boost::mpl::pair< ::PICML::RootFolder, PR_RootFolder_parent > _PR_RootFolder_parent__RootFolder;
		typedef boost::mpl::vector< _PR_RootFolder_parent__RootFolder> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RootFolder> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_BenchmarkAnalysis_children {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, CR_BenchmarkAnalysis_children > _CR_BenchmarkAnalysis_children__BenchmarkAnalysis;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_BenchmarkAnalysis_children__BenchmarkAnalysis> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export DeploymentPlans : public Udm::Object {
	public:
		typedef ::Udm::FolderMetaTag MetaKind;

		DeploymentPlans() {}
		DeploymentPlans(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		DeploymentPlans(const DeploymentPlans &master) : UDM_OBJECT(master) {}

		static DeploymentPlans Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static DeploymentPlans Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		DeploymentPlans CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<DeploymentPlans> Instances() { return Udm::InstantiatedAttr<DeploymentPlans>(impl); }
		template <class Pred> Udm::InstantiatedAttr<DeploymentPlans, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<DeploymentPlans, Pred>(impl); }
		DeploymentPlans CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<DeploymentPlans> Derived() { return Udm::DerivedAttr<DeploymentPlans>(impl); }
		template <class Pred> Udm::DerivedAttr<DeploymentPlans, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<DeploymentPlans, Pred>(impl); }
		Udm::ArchetypeAttr<DeploymentPlans> Archetype() const { return Udm::ArchetypeAttr<DeploymentPlans>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ChildrenAttr< ::PICML::DeploymentPlan> DeploymentPlan_children() const { return Udm::ChildrenAttr< ::PICML::DeploymentPlan>(impl, meta_DeploymentPlan_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DeploymentPlan, Pred> DeploymentPlan_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DeploymentPlan, Pred>(impl, meta_DeploymentPlan_children); }
		Udm::ChildrenAttr< ::PICML::DeploymentPlan> DeploymentPlan_kind_children() const { return Udm::ChildrenAttr< ::PICML::DeploymentPlan>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DeploymentPlan, Pred> DeploymentPlan_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DeploymentPlan, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, meta_RootFolder_parent); }
		Udm::ParentAttr< ::PICML::RootFolder> parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_DeploymentPlans(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_DeploymentPlan_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RootFolder_parent {};
		typedef boost::mpl::pair< ::PICML::RootFolder, PR_RootFolder_parent > _PR_RootFolder_parent__RootFolder;
		typedef boost::mpl::vector< _PR_RootFolder_parent__RootFolder> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RootFolder> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_DeploymentPlan_children {};
		typedef boost::mpl::pair< ::PICML::DeploymentPlan, CR_DeploymentPlan_children > _CR_DeploymentPlan_children__DeploymentPlan;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_DeploymentPlan_children__DeploymentPlan> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::DeploymentPlan> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentImplementations : public Udm::Object {
	public:
		typedef ::Udm::FolderMetaTag MetaKind;

		ComponentImplementations() {}
		ComponentImplementations(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		ComponentImplementations(const ComponentImplementations &master) : UDM_OBJECT(master) {}

		static ComponentImplementations Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentImplementations Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentImplementations CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentImplementations> Instances() { return Udm::InstantiatedAttr<ComponentImplementations>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentImplementations, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentImplementations, Pred>(impl); }
		ComponentImplementations CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentImplementations> Derived() { return Udm::DerivedAttr<ComponentImplementations>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentImplementations, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentImplementations, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentImplementations> Archetype() const { return Udm::ArchetypeAttr<ComponentImplementations>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ChildrenAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_children() const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationContainer>(impl, meta_ComponentImplementationContainer_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentImplementationContainer, Pred> ComponentImplementationContainer_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationContainer, Pred>(impl, meta_ComponentImplementationContainer_children); }
		Udm::ChildrenAttr< ::PICML::ImplementationContainer> ImplementationContainer_kind_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationContainer>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationContainer, Pred> ImplementationContainer_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationContainer, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationContainer>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentImplementationContainer, Pred> ComponentImplementationContainer_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationContainer, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, meta_RootFolder_parent); }
		Udm::ParentAttr< ::PICML::RootFolder> parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentImplementations(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_ComponentImplementationContainer_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RootFolder_parent {};
		typedef boost::mpl::pair< ::PICML::RootFolder, PR_RootFolder_parent > _PR_RootFolder_parent__RootFolder;
		typedef boost::mpl::vector< _PR_RootFolder_parent__RootFolder> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RootFolder> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ComponentImplementationContainer_children {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementationContainer, CR_ComponentImplementationContainer_children > _CR_ComponentImplementationContainer_children__ComponentImplementationContainer;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_ComponentImplementationContainer_children__ComponentImplementationContainer> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentImplementationContainer> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PackageConfigurations : public Udm::Object {
	public:
		typedef ::Udm::FolderMetaTag MetaKind;

		PackageConfigurations() {}
		PackageConfigurations(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		PackageConfigurations(const PackageConfigurations &master) : UDM_OBJECT(master) {}

		static PackageConfigurations Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PackageConfigurations Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PackageConfigurations CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PackageConfigurations> Instances() { return Udm::InstantiatedAttr<PackageConfigurations>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PackageConfigurations, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PackageConfigurations, Pred>(impl); }
		PackageConfigurations CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PackageConfigurations> Derived() { return Udm::DerivedAttr<PackageConfigurations>(impl); }
		template <class Pred> Udm::DerivedAttr<PackageConfigurations, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PackageConfigurations, Pred>(impl); }
		Udm::ArchetypeAttr<PackageConfigurations> Archetype() const { return Udm::ArchetypeAttr<PackageConfigurations>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ChildrenAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_children() const { return Udm::ChildrenAttr< ::PICML::PackageConfigurationContainer>(impl, meta_PackageConfigurationContainer_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageConfigurationContainer, Pred> PackageConfigurationContainer_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageConfigurationContainer, Pred>(impl, meta_PackageConfigurationContainer_children); }
		Udm::ChildrenAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_kind_children() const { return Udm::ChildrenAttr< ::PICML::PackageConfigurationContainer>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageConfigurationContainer, Pred> PackageConfigurationContainer_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageConfigurationContainer, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, meta_RootFolder_parent); }
		Udm::ParentAttr< ::PICML::RootFolder> parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_PackageConfigurations(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_PackageConfigurationContainer_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RootFolder_parent {};
		typedef boost::mpl::pair< ::PICML::RootFolder, PR_RootFolder_parent > _PR_RootFolder_parent__RootFolder;
		typedef boost::mpl::vector< _PR_RootFolder_parent__RootFolder> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RootFolder> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_PackageConfigurationContainer_children {};
		typedef boost::mpl::pair< ::PICML::PackageConfigurationContainer, CR_PackageConfigurationContainer_children > _CR_PackageConfigurationContainer_children__PackageConfigurationContainer;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_PackageConfigurationContainer_children__PackageConfigurationContainer> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::PackageConfigurationContainer> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ImplementationArtifacts : public Udm::Object {
	public:
		typedef ::Udm::FolderMetaTag MetaKind;

		ImplementationArtifacts() {}
		ImplementationArtifacts(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		ImplementationArtifacts(const ImplementationArtifacts &master) : UDM_OBJECT(master) {}

		static ImplementationArtifacts Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ImplementationArtifacts Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ImplementationArtifacts CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ImplementationArtifacts> Instances() { return Udm::InstantiatedAttr<ImplementationArtifacts>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ImplementationArtifacts, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ImplementationArtifacts, Pred>(impl); }
		ImplementationArtifacts CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ImplementationArtifacts> Derived() { return Udm::DerivedAttr<ImplementationArtifacts>(impl); }
		template <class Pred> Udm::DerivedAttr<ImplementationArtifacts, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ImplementationArtifacts, Pred>(impl); }
		Udm::ArchetypeAttr<ImplementationArtifacts> Archetype() const { return Udm::ArchetypeAttr<ImplementationArtifacts>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ChildrenAttr< ::PICML::ArtifactContainer> ArtifactContainer_children() const { return Udm::ChildrenAttr< ::PICML::ArtifactContainer>(impl, meta_ArtifactContainer_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ArtifactContainer, Pred> ArtifactContainer_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ArtifactContainer, Pred>(impl, meta_ArtifactContainer_children); }
		Udm::ChildrenAttr< ::PICML::ArtifactContainer> ArtifactContainer_kind_children() const { return Udm::ChildrenAttr< ::PICML::ArtifactContainer>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ArtifactContainer, Pred> ArtifactContainer_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ArtifactContainer, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, meta_RootFolder_parent); }
		Udm::ParentAttr< ::PICML::RootFolder> parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ImplementationArtifacts(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_ArtifactContainer_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RootFolder_parent {};
		typedef boost::mpl::pair< ::PICML::RootFolder, PR_RootFolder_parent > _PR_RootFolder_parent__RootFolder;
		typedef boost::mpl::vector< _PR_RootFolder_parent__RootFolder> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RootFolder> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ArtifactContainer_children {};
		typedef boost::mpl::pair< ::PICML::ArtifactContainer, CR_ArtifactContainer_children > _CR_ArtifactContainer_children__ArtifactContainer;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_ArtifactContainer_children__ArtifactContainer> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ArtifactContainer> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentTypes : public Udm::Object {
	public:
		typedef ::Udm::FolderMetaTag MetaKind;

		ComponentTypes() {}
		ComponentTypes(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		ComponentTypes(const ComponentTypes &master) : UDM_OBJECT(master) {}

		static ComponentTypes Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentTypes Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentTypes CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentTypes> Instances() { return Udm::InstantiatedAttr<ComponentTypes>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentTypes, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentTypes, Pred>(impl); }
		ComponentTypes CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentTypes> Derived() { return Udm::DerivedAttr<ComponentTypes>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentTypes, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentTypes, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentTypes> Archetype() const { return Udm::ArchetypeAttr<ComponentTypes>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ChildrenAttr< ::PICML::ComponentContainer> ComponentContainer_children() const { return Udm::ChildrenAttr< ::PICML::ComponentContainer>(impl, meta_ComponentContainer_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentContainer, Pred> ComponentContainer_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentContainer, Pred>(impl, meta_ComponentContainer_children); }
		Udm::ChildrenAttr< ::PICML::ComponentContainer> ComponentContainer_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentContainer>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentContainer, Pred> ComponentContainer_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentContainer, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, meta_RootFolder_parent); }
		Udm::ParentAttr< ::PICML::RootFolder> parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentTypes(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_ComponentContainer_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RootFolder_parent {};
		typedef boost::mpl::pair< ::PICML::RootFolder, PR_RootFolder_parent > _PR_RootFolder_parent__RootFolder;
		typedef boost::mpl::vector< _PR_RootFolder_parent__RootFolder> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RootFolder> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ComponentContainer_children {};
		typedef boost::mpl::pair< ::PICML::ComponentContainer, CR_ComponentContainer_children > _CR_ComponentContainer_children__ComponentContainer;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_ComponentContainer_children__ComponentContainer> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentContainer> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export TopLevelPackages : public Udm::Object {
	public:
		typedef ::Udm::FolderMetaTag MetaKind;

		TopLevelPackages() {}
		TopLevelPackages(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		TopLevelPackages(const TopLevelPackages &master) : UDM_OBJECT(master) {}

		static TopLevelPackages Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static TopLevelPackages Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		TopLevelPackages CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<TopLevelPackages> Instances() { return Udm::InstantiatedAttr<TopLevelPackages>(impl); }
		template <class Pred> Udm::InstantiatedAttr<TopLevelPackages, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<TopLevelPackages, Pred>(impl); }
		TopLevelPackages CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<TopLevelPackages> Derived() { return Udm::DerivedAttr<TopLevelPackages>(impl); }
		template <class Pred> Udm::DerivedAttr<TopLevelPackages, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<TopLevelPackages, Pred>(impl); }
		Udm::ArchetypeAttr<TopLevelPackages> Archetype() const { return Udm::ArchetypeAttr<TopLevelPackages>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ChildrenAttr< ::PICML::TopLevelPackageContainer> TopLevelPackageContainer_children() const { return Udm::ChildrenAttr< ::PICML::TopLevelPackageContainer>(impl, meta_TopLevelPackageContainer_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TopLevelPackageContainer, Pred> TopLevelPackageContainer_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TopLevelPackageContainer, Pred>(impl, meta_TopLevelPackageContainer_children); }
		Udm::ChildrenAttr< ::PICML::TopLevelPackageContainer> TopLevelPackageContainer_kind_children() const { return Udm::ChildrenAttr< ::PICML::TopLevelPackageContainer>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TopLevelPackageContainer, Pred> TopLevelPackageContainer_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TopLevelPackageContainer, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, meta_RootFolder_parent); }
		Udm::ParentAttr< ::PICML::RootFolder> parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_TopLevelPackages(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_TopLevelPackageContainer_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RootFolder_parent {};
		typedef boost::mpl::pair< ::PICML::RootFolder, PR_RootFolder_parent > _PR_RootFolder_parent__RootFolder;
		typedef boost::mpl::vector< _PR_RootFolder_parent__RootFolder> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RootFolder> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_TopLevelPackageContainer_children {};
		typedef boost::mpl::pair< ::PICML::TopLevelPackageContainer, CR_TopLevelPackageContainer_children > _CR_TopLevelPackageContainer_children__TopLevelPackageContainer;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_TopLevelPackageContainer_children__TopLevelPackageContainer> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::TopLevelPackageContainer> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentPackages : public Udm::Object {
	public:
		typedef ::Udm::FolderMetaTag MetaKind;

		ComponentPackages() {}
		ComponentPackages(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		ComponentPackages(const ComponentPackages &master) : UDM_OBJECT(master) {}

		static ComponentPackages Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentPackages Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentPackages CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentPackages> Instances() { return Udm::InstantiatedAttr<ComponentPackages>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentPackages, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentPackages, Pred>(impl); }
		ComponentPackages CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentPackages> Derived() { return Udm::DerivedAttr<ComponentPackages>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentPackages, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentPackages, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentPackages> Archetype() const { return Udm::ArchetypeAttr<ComponentPackages>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ChildrenAttr< ::PICML::PackageContainer> PackageContainer_children() const { return Udm::ChildrenAttr< ::PICML::PackageContainer>(impl, meta_PackageContainer_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageContainer, Pred> PackageContainer_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageContainer, Pred>(impl, meta_PackageContainer_children); }
		Udm::ChildrenAttr< ::PICML::PackageContainer> PackageContainer_kind_children() const { return Udm::ChildrenAttr< ::PICML::PackageContainer>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageContainer, Pred> PackageContainer_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageContainer, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, meta_RootFolder_parent); }
		Udm::ParentAttr< ::PICML::RootFolder> parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentPackages(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_PackageContainer_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RootFolder_parent {};
		typedef boost::mpl::pair< ::PICML::RootFolder, PR_RootFolder_parent > _PR_RootFolder_parent__RootFolder;
		typedef boost::mpl::vector< _PR_RootFolder_parent__RootFolder> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RootFolder> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_PackageContainer_children {};
		typedef boost::mpl::pair< ::PICML::PackageContainer, CR_PackageContainer_children > _CR_PackageContainer_children__PackageContainer;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_PackageContainer_children__PackageContainer> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::PackageContainer> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Targets : public Udm::Object {
	public:
		typedef ::Udm::FolderMetaTag MetaKind;

		Targets() {}
		Targets(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		Targets(const Targets &master) : UDM_OBJECT(master) {}

		static Targets Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Targets Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Targets CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Targets> Instances() { return Udm::InstantiatedAttr<Targets>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Targets, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Targets, Pred>(impl); }
		Targets CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Targets> Derived() { return Udm::DerivedAttr<Targets>(impl); }
		template <class Pred> Udm::DerivedAttr<Targets, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Targets, Pred>(impl); }
		Udm::ArchetypeAttr<Targets> Archetype() const { return Udm::ArchetypeAttr<Targets>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ChildrenAttr< ::PICML::Domain> Domain_children() const { return Udm::ChildrenAttr< ::PICML::Domain>(impl, meta_Domain_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Domain, Pred> Domain_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Domain, Pred>(impl, meta_Domain_children); }
		Udm::ChildrenAttr< ::PICML::Domain> Domain_kind_children() const { return Udm::ChildrenAttr< ::PICML::Domain>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Domain, Pred> Domain_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Domain, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, meta_RootFolder_parent); }
		Udm::ParentAttr< ::PICML::RootFolder> parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Targets(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_Domain_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RootFolder_parent {};
		typedef boost::mpl::pair< ::PICML::RootFolder, PR_RootFolder_parent > _PR_RootFolder_parent__RootFolder;
		typedef boost::mpl::vector< _PR_RootFolder_parent__RootFolder> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RootFolder> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Domain_children {};
		typedef boost::mpl::pair< ::PICML::Domain, CR_Domain_children > _CR_Domain_children__Domain;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Domain_children__Domain> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Domain> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PredefinedTypes : public Udm::Object {
	public:
		typedef ::Udm::FolderMetaTag MetaKind;

		PredefinedTypes() {}
		PredefinedTypes(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		PredefinedTypes(const PredefinedTypes &master) : UDM_OBJECT(master) {}

		static PredefinedTypes Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PredefinedTypes Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PredefinedTypes CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PredefinedTypes> Instances() { return Udm::InstantiatedAttr<PredefinedTypes>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PredefinedTypes, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PredefinedTypes, Pred>(impl); }
		PredefinedTypes CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PredefinedTypes> Derived() { return Udm::DerivedAttr<PredefinedTypes>(impl); }
		template <class Pred> Udm::DerivedAttr<PredefinedTypes, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PredefinedTypes, Pred>(impl); }
		Udm::ArchetypeAttr<PredefinedTypes> Archetype() const { return Udm::ArchetypeAttr<PredefinedTypes>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ChildrenAttr< ::PICML::Collection> Collection_children() const { return Udm::ChildrenAttr< ::PICML::Collection>(impl, meta_Collection_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Collection, Pred> Collection_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Collection, Pred>(impl, meta_Collection_children); }
		Udm::ChildrenAttr< ::PICML::PredefinedType> PredefinedType_children() const { return Udm::ChildrenAttr< ::PICML::PredefinedType>(impl, meta_PredefinedType_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PredefinedType, Pred> PredefinedType_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PredefinedType, Pred>(impl, meta_PredefinedType_children); }
		Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Taggable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MemberType> MemberType_kind_children() const { return Udm::ChildrenAttr< ::PICML::MemberType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MemberType, Pred> MemberType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MemberType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::NoInheritable> NoInheritable_kind_children() const { return Udm::ChildrenAttr< ::PICML::NoInheritable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::NoInheritable, Pred> NoInheritable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::NoInheritable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Collection> Collection_kind_children() const { return Udm::ChildrenAttr< ::PICML::Collection>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Collection, Pred> Collection_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Collection, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::NamedType> NamedType_kind_children() const { return Udm::ChildrenAttr< ::PICML::NamedType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::NamedType, Pred> NamedType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::NamedType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Byte> Byte_kind_children() const { return Udm::ChildrenAttr< ::PICML::Byte>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Byte, Pred> Byte_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Byte, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Boolean> Boolean_kind_children() const { return Udm::ChildrenAttr< ::PICML::Boolean>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Boolean, Pred> Boolean_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Boolean, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ShortInteger> ShortInteger_kind_children() const { return Udm::ChildrenAttr< ::PICML::ShortInteger>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ShortInteger, Pred> ShortInteger_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ShortInteger, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::LongInteger> LongInteger_kind_children() const { return Udm::ChildrenAttr< ::PICML::LongInteger>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::LongInteger, Pred> LongInteger_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::LongInteger, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RealNumber> RealNumber_kind_children() const { return Udm::ChildrenAttr< ::PICML::RealNumber>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RealNumber, Pred> RealNumber_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RealNumber, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::String> String_kind_children() const { return Udm::ChildrenAttr< ::PICML::String>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::String, Pred> String_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::String, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::GenericObject> GenericObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::GenericObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::GenericObject, Pred> GenericObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::GenericObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::GenericValueObject> GenericValueObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::GenericValueObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::GenericValueObject, Pred> GenericValueObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::GenericValueObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::GenericValue> GenericValue_kind_children() const { return Udm::ChildrenAttr< ::PICML::GenericValue>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::GenericValue, Pred> GenericValue_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::GenericValue, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::TypeEncoding> TypeEncoding_kind_children() const { return Udm::ChildrenAttr< ::PICML::TypeEncoding>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TypeEncoding, Pred> TypeEncoding_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TypeEncoding, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::TypeKind> TypeKind_kind_children() const { return Udm::ChildrenAttr< ::PICML::TypeKind>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TypeKind, Pred> TypeKind_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TypeKind, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PredefinedType> PredefinedType_kind_children() const { return Udm::ChildrenAttr< ::PICML::PredefinedType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PredefinedType, Pred> PredefinedType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PredefinedType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ConstantType> ConstantType_kind_children() const { return Udm::ChildrenAttr< ::PICML::ConstantType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ConstantType, Pred> ConstantType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ConstantType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, meta_RootFolder_parent); }
		Udm::ParentAttr< ::PICML::RootFolder> parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_PredefinedTypes(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_Collection_children;
		static ::Uml::CompositionChildRole meta_PredefinedType_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RootFolder_parent {};
		typedef boost::mpl::pair< ::PICML::RootFolder, PR_RootFolder_parent > _PR_RootFolder_parent__RootFolder;
		typedef boost::mpl::vector< _PR_RootFolder_parent__RootFolder> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RootFolder> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Collection_children {};
		class CR_PredefinedType_children {};
		typedef boost::mpl::pair< ::PICML::Collection, CR_Collection_children > _CR_Collection_children__Collection;
		typedef boost::mpl::pair< ::PICML::PredefinedType, CR_PredefinedType_children > _CR_PredefinedType_children__PredefinedType;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Collection_children__Collection, _CR_PredefinedType_children__PredefinedType> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Collection, ::PICML::Byte, ::PICML::Boolean, ::PICML::ShortInteger, ::PICML::LongInteger, ::PICML::RealNumber, ::PICML::String, ::PICML::GenericObject, ::PICML::GenericValueObject, ::PICML::GenericValue, ::PICML::TypeEncoding, ::PICML::TypeKind, ::PICML::PredefinedType> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export InterfaceDefinitions : public Udm::Object {
	public:
		typedef ::Udm::FolderMetaTag MetaKind;

		InterfaceDefinitions() {}
		InterfaceDefinitions(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		InterfaceDefinitions(const InterfaceDefinitions &master) : UDM_OBJECT(master) {}

		static InterfaceDefinitions Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static InterfaceDefinitions Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		InterfaceDefinitions CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<InterfaceDefinitions> Instances() { return Udm::InstantiatedAttr<InterfaceDefinitions>(impl); }
		template <class Pred> Udm::InstantiatedAttr<InterfaceDefinitions, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<InterfaceDefinitions, Pred>(impl); }
		InterfaceDefinitions CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<InterfaceDefinitions> Derived() { return Udm::DerivedAttr<InterfaceDefinitions>(impl); }
		template <class Pred> Udm::DerivedAttr<InterfaceDefinitions, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<InterfaceDefinitions, Pred>(impl); }
		Udm::ArchetypeAttr<InterfaceDefinitions> Archetype() const { return Udm::ArchetypeAttr<InterfaceDefinitions>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ChildrenAttr< ::PICML::File> File_children() const { return Udm::ChildrenAttr< ::PICML::File>(impl, meta_File_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::File, Pred> File_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::File, Pred>(impl, meta_File_children); }
		Udm::ChildrenAttr< ::PICML::Prefixable> Prefixable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Prefixable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Prefixable, Pred> Prefixable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Prefixable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::File> File_kind_children() const { return Udm::ChildrenAttr< ::PICML::File>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::File, Pred> File_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::File, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, meta_RootFolder_parent); }
		Udm::ParentAttr< ::PICML::RootFolder> parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_InterfaceDefinitions(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_File_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RootFolder_parent {};
		typedef boost::mpl::pair< ::PICML::RootFolder, PR_RootFolder_parent > _PR_RootFolder_parent__RootFolder;
		typedef boost::mpl::vector< _PR_RootFolder_parent__RootFolder> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RootFolder> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_File_children {};
		typedef boost::mpl::pair< ::PICML::File, CR_File_children > _CR_File_children__File;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_File_children__File> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::File> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentBuild : public Udm::Object {
	public:
		typedef ::Udm::FolderMetaTag MetaKind;

		ComponentBuild() {}
		ComponentBuild(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		ComponentBuild(const ComponentBuild &master) : UDM_OBJECT(master) {}

		static ComponentBuild Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentBuild Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentBuild CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentBuild> Instances() { return Udm::InstantiatedAttr<ComponentBuild>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentBuild, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentBuild, Pred>(impl); }
		ComponentBuild CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentBuild> Derived() { return Udm::DerivedAttr<ComponentBuild>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentBuild, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentBuild, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentBuild> Archetype() const { return Udm::ArchetypeAttr<ComponentBuild>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ChildrenAttr< ::PICML::MPC> MPC_children() const { return Udm::ChildrenAttr< ::PICML::MPC>(impl, meta_MPC_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MPC, Pred> MPC_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MPC, Pred>(impl, meta_MPC_children); }
		Udm::ChildrenAttr< ::PICML::MPC> MPC_kind_children() const { return Udm::ChildrenAttr< ::PICML::MPC>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MPC, Pred> MPC_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MPC, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, meta_RootFolder_parent); }
		Udm::ParentAttr< ::PICML::RootFolder> parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentBuild(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_MPC_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RootFolder_parent {};
		typedef boost::mpl::pair< ::PICML::RootFolder, PR_RootFolder_parent > _PR_RootFolder_parent__RootFolder;
		typedef boost::mpl::vector< _PR_RootFolder_parent__RootFolder> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RootFolder> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_MPC_children {};
		typedef boost::mpl::pair< ::PICML::MPC, CR_MPC_children > _CR_MPC_children__MPC;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_MPC_children__MPC> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::MPC> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export WorkerLibraries : public Udm::Object {
	public:
		typedef ::Udm::FolderMetaTag MetaKind;

		WorkerLibraries() {}
		WorkerLibraries(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		WorkerLibraries(const WorkerLibraries &master) : UDM_OBJECT(master) {}

		static WorkerLibraries Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static WorkerLibraries Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		WorkerLibraries CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<WorkerLibraries> Instances() { return Udm::InstantiatedAttr<WorkerLibraries>(impl); }
		template <class Pred> Udm::InstantiatedAttr<WorkerLibraries, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<WorkerLibraries, Pred>(impl); }
		WorkerLibraries CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<WorkerLibraries> Derived() { return Udm::DerivedAttr<WorkerLibraries>(impl); }
		template <class Pred> Udm::DerivedAttr<WorkerLibraries, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<WorkerLibraries, Pred>(impl); }
		Udm::ArchetypeAttr<WorkerLibraries> Archetype() const { return Udm::ArchetypeAttr<WorkerLibraries>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ChildrenAttr< ::PICML::WorkerLibrary> WorkerLibrary_children() const { return Udm::ChildrenAttr< ::PICML::WorkerLibrary>(impl, meta_WorkerLibrary_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkerLibrary, Pred> WorkerLibrary_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkerLibrary, Pred>(impl, meta_WorkerLibrary_children); }
		Udm::ChildrenAttr< ::PICML::WorkerLibrary> WorkerLibrary_kind_children() const { return Udm::ChildrenAttr< ::PICML::WorkerLibrary>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkerLibrary, Pred> WorkerLibrary_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkerLibrary, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, meta_RootFolder_parent); }
		Udm::ParentAttr< ::PICML::RootFolder> parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_WorkerLibraries(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_WorkerLibrary_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RootFolder_parent {};
		typedef boost::mpl::pair< ::PICML::RootFolder, PR_RootFolder_parent > _PR_RootFolder_parent__RootFolder;
		typedef boost::mpl::vector< _PR_RootFolder_parent__RootFolder> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RootFolder> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_WorkerLibrary_children {};
		typedef boost::mpl::pair< ::PICML::WorkerLibrary, CR_WorkerLibrary_children > _CR_WorkerLibrary_children__WorkerLibrary;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_WorkerLibrary_children__WorkerLibrary> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::WorkerLibrary> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export RootFolder : public Udm::Object {
	public:
		typedef ::Udm::FolderMetaTag MetaKind;

		RootFolder() {}
		RootFolder(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		RootFolder(const RootFolder &master) : UDM_OBJECT(master) {}

		static RootFolder Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static RootFolder Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		RootFolder CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<RootFolder> Instances() { return Udm::InstantiatedAttr<RootFolder>(impl); }
		template <class Pred> Udm::InstantiatedAttr<RootFolder, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<RootFolder, Pred>(impl); }
		RootFolder CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<RootFolder> Derived() { return Udm::DerivedAttr<RootFolder>(impl); }
		template <class Pred> Udm::DerivedAttr<RootFolder, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<RootFolder, Pred>(impl); }
		Udm::ArchetypeAttr<RootFolder> Archetype() const { return Udm::ArchetypeAttr<RootFolder>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ChildrenAttr< ::PICML::PathDiagrams> PathDiagrams_children() const { return Udm::ChildrenAttr< ::PICML::PathDiagrams>(impl, meta_PathDiagrams_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PathDiagrams, Pred> PathDiagrams_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PathDiagrams, Pred>(impl, meta_PathDiagrams_children); }
		Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementations> ComponentFactoryImplementations_children() const { return Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementations>(impl, meta_ComponentFactoryImplementations_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementations, Pred> ComponentFactoryImplementations_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementations, Pred>(impl, meta_ComponentFactoryImplementations_children); }
		Udm::ChildrenAttr< ::PICML::ComponentAnalyses> ComponentAnalyses_children() const { return Udm::ChildrenAttr< ::PICML::ComponentAnalyses>(impl, meta_ComponentAnalyses_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentAnalyses, Pred> ComponentAnalyses_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentAnalyses, Pred>(impl, meta_ComponentAnalyses_children); }
		Udm::ChildrenAttr< ::PICML::DeploymentPlans> DeploymentPlans_children() const { return Udm::ChildrenAttr< ::PICML::DeploymentPlans>(impl, meta_DeploymentPlans_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DeploymentPlans, Pred> DeploymentPlans_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DeploymentPlans, Pred>(impl, meta_DeploymentPlans_children); }
		Udm::ChildrenAttr< ::PICML::ComponentImplementations> ComponentImplementations_children() const { return Udm::ChildrenAttr< ::PICML::ComponentImplementations>(impl, meta_ComponentImplementations_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentImplementations, Pred> ComponentImplementations_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentImplementations, Pred>(impl, meta_ComponentImplementations_children); }
		Udm::ChildrenAttr< ::PICML::PackageConfigurations> PackageConfigurations_children() const { return Udm::ChildrenAttr< ::PICML::PackageConfigurations>(impl, meta_PackageConfigurations_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageConfigurations, Pred> PackageConfigurations_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageConfigurations, Pred>(impl, meta_PackageConfigurations_children); }
		Udm::ChildrenAttr< ::PICML::ImplementationArtifacts> ImplementationArtifacts_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifacts>(impl, meta_ImplementationArtifacts_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationArtifacts, Pred> ImplementationArtifacts_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifacts, Pred>(impl, meta_ImplementationArtifacts_children); }
		Udm::ChildrenAttr< ::PICML::ComponentTypes> ComponentTypes_children() const { return Udm::ChildrenAttr< ::PICML::ComponentTypes>(impl, meta_ComponentTypes_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentTypes, Pred> ComponentTypes_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentTypes, Pred>(impl, meta_ComponentTypes_children); }
		Udm::ChildrenAttr< ::PICML::TopLevelPackages> TopLevelPackages_children() const { return Udm::ChildrenAttr< ::PICML::TopLevelPackages>(impl, meta_TopLevelPackages_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TopLevelPackages, Pred> TopLevelPackages_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TopLevelPackages, Pred>(impl, meta_TopLevelPackages_children); }
		Udm::ChildrenAttr< ::PICML::ComponentPackages> ComponentPackages_children() const { return Udm::ChildrenAttr< ::PICML::ComponentPackages>(impl, meta_ComponentPackages_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentPackages, Pred> ComponentPackages_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentPackages, Pred>(impl, meta_ComponentPackages_children); }
		Udm::ChildrenAttr< ::PICML::Targets> Targets_children() const { return Udm::ChildrenAttr< ::PICML::Targets>(impl, meta_Targets_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Targets, Pred> Targets_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Targets, Pred>(impl, meta_Targets_children); }
		Udm::ChildrenAttr< ::PICML::PredefinedTypes> PredefinedTypes_children() const { return Udm::ChildrenAttr< ::PICML::PredefinedTypes>(impl, meta_PredefinedTypes_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PredefinedTypes, Pred> PredefinedTypes_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PredefinedTypes, Pred>(impl, meta_PredefinedTypes_children); }
		Udm::ChildrenAttr< ::PICML::InterfaceDefinitions> InterfaceDefinitions_children() const { return Udm::ChildrenAttr< ::PICML::InterfaceDefinitions>(impl, meta_InterfaceDefinitions_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InterfaceDefinitions, Pred> InterfaceDefinitions_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InterfaceDefinitions, Pred>(impl, meta_InterfaceDefinitions_children); }
		Udm::ChildrenAttr< ::PICML::ComponentBuild> ComponentBuild_children() const { return Udm::ChildrenAttr< ::PICML::ComponentBuild>(impl, meta_ComponentBuild_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentBuild, Pred> ComponentBuild_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentBuild, Pred>(impl, meta_ComponentBuild_children); }
		Udm::ChildrenAttr< ::PICML::WorkerLibraries> WorkerLibraries_children() const { return Udm::ChildrenAttr< ::PICML::WorkerLibraries>(impl, meta_WorkerLibraries_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkerLibraries, Pred> WorkerLibraries_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkerLibraries, Pred>(impl, meta_WorkerLibraries_children); }
		Udm::ChildrenAttr< ::PICML::RootFolder> RootFolder_children() const { return Udm::ChildrenAttr< ::PICML::RootFolder>(impl, meta_RootFolder_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RootFolder, Pred> RootFolder_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RootFolder, Pred>(impl, meta_RootFolder_children); }
		Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementations> ComponentFactoryImplementations_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementations>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementations, Pred> ComponentFactoryImplementations_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementations, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PathDiagrams> PathDiagrams_kind_children() const { return Udm::ChildrenAttr< ::PICML::PathDiagrams>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PathDiagrams, Pred> PathDiagrams_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PathDiagrams, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentAnalyses> ComponentAnalyses_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentAnalyses>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentAnalyses, Pred> ComponentAnalyses_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentAnalyses, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::DeploymentPlans> DeploymentPlans_kind_children() const { return Udm::ChildrenAttr< ::PICML::DeploymentPlans>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DeploymentPlans, Pred> DeploymentPlans_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DeploymentPlans, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentImplementations> ComponentImplementations_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentImplementations>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentImplementations, Pred> ComponentImplementations_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentImplementations, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PackageConfigurations> PackageConfigurations_kind_children() const { return Udm::ChildrenAttr< ::PICML::PackageConfigurations>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageConfigurations, Pred> PackageConfigurations_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageConfigurations, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ImplementationArtifacts> ImplementationArtifacts_kind_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifacts>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationArtifacts, Pred> ImplementationArtifacts_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifacts, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentTypes> ComponentTypes_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentTypes>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentTypes, Pred> ComponentTypes_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentTypes, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::TopLevelPackages> TopLevelPackages_kind_children() const { return Udm::ChildrenAttr< ::PICML::TopLevelPackages>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TopLevelPackages, Pred> TopLevelPackages_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TopLevelPackages, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentPackages> ComponentPackages_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentPackages>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentPackages, Pred> ComponentPackages_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentPackages, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Targets> Targets_kind_children() const { return Udm::ChildrenAttr< ::PICML::Targets>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Targets, Pred> Targets_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Targets, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PredefinedTypes> PredefinedTypes_kind_children() const { return Udm::ChildrenAttr< ::PICML::PredefinedTypes>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PredefinedTypes, Pred> PredefinedTypes_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PredefinedTypes, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::InterfaceDefinitions> InterfaceDefinitions_kind_children() const { return Udm::ChildrenAttr< ::PICML::InterfaceDefinitions>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InterfaceDefinitions, Pred> InterfaceDefinitions_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InterfaceDefinitions, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentBuild> ComponentBuild_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentBuild>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentBuild, Pred> ComponentBuild_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentBuild, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::WorkerLibraries> WorkerLibraries_kind_children() const { return Udm::ChildrenAttr< ::PICML::WorkerLibraries>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkerLibraries, Pred> WorkerLibraries_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkerLibraries, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RootFolder> RootFolder_kind_children() const { return Udm::ChildrenAttr< ::PICML::RootFolder>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RootFolder, Pred> RootFolder_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RootFolder, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, meta_RootFolder_parent); }
		Udm::ParentAttr< ::PICML::RootFolder> parent() const { return Udm::ParentAttr< ::PICML::RootFolder>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_RootFolder(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_PathDiagrams_children;
		static ::Uml::CompositionChildRole meta_ComponentFactoryImplementations_children;
		static ::Uml::CompositionChildRole meta_ComponentAnalyses_children;
		static ::Uml::CompositionChildRole meta_DeploymentPlans_children;
		static ::Uml::CompositionChildRole meta_ComponentImplementations_children;
		static ::Uml::CompositionChildRole meta_PackageConfigurations_children;
		static ::Uml::CompositionChildRole meta_ImplementationArtifacts_children;
		static ::Uml::CompositionChildRole meta_ComponentTypes_children;
		static ::Uml::CompositionChildRole meta_TopLevelPackages_children;
		static ::Uml::CompositionChildRole meta_ComponentPackages_children;
		static ::Uml::CompositionChildRole meta_Targets_children;
		static ::Uml::CompositionChildRole meta_PredefinedTypes_children;
		static ::Uml::CompositionChildRole meta_InterfaceDefinitions_children;
		static ::Uml::CompositionChildRole meta_ComponentBuild_children;
		static ::Uml::CompositionChildRole meta_WorkerLibraries_children;
		static ::Uml::CompositionChildRole meta_RootFolder_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RootFolder_parent {};
		typedef boost::mpl::pair< ::PICML::RootFolder, PR_RootFolder_parent > _PR_RootFolder_parent__RootFolder;
		typedef boost::mpl::vector< _PR_RootFolder_parent__RootFolder> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RootFolder> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_PathDiagrams_children {};
		class CR_ComponentFactoryImplementations_children {};
		class CR_ComponentAnalyses_children {};
		class CR_DeploymentPlans_children {};
		class CR_ComponentImplementations_children {};
		class CR_PackageConfigurations_children {};
		class CR_ImplementationArtifacts_children {};
		class CR_ComponentTypes_children {};
		class CR_TopLevelPackages_children {};
		class CR_ComponentPackages_children {};
		class CR_Targets_children {};
		class CR_PredefinedTypes_children {};
		class CR_InterfaceDefinitions_children {};
		class CR_ComponentBuild_children {};
		class CR_WorkerLibraries_children {};
		class CR_RootFolder_children {};
		typedef boost::mpl::pair< ::PICML::PathDiagrams, CR_PathDiagrams_children > _CR_PathDiagrams_children__PathDiagrams;
		typedef boost::mpl::pair< ::PICML::ComponentFactoryImplementations, CR_ComponentFactoryImplementations_children > _CR_ComponentFactoryImplementations_children__ComponentFactoryImplementations;
		typedef boost::mpl::pair< ::PICML::ComponentAnalyses, CR_ComponentAnalyses_children > _CR_ComponentAnalyses_children__ComponentAnalyses;
		typedef boost::mpl::pair< ::PICML::DeploymentPlans, CR_DeploymentPlans_children > _CR_DeploymentPlans_children__DeploymentPlans;
		typedef boost::mpl::pair< ::PICML::ComponentImplementations, CR_ComponentImplementations_children > _CR_ComponentImplementations_children__ComponentImplementations;
		typedef boost::mpl::pair< ::PICML::PackageConfigurations, CR_PackageConfigurations_children > _CR_PackageConfigurations_children__PackageConfigurations;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifacts, CR_ImplementationArtifacts_children > _CR_ImplementationArtifacts_children__ImplementationArtifacts;
		typedef boost::mpl::pair< ::PICML::ComponentTypes, CR_ComponentTypes_children > _CR_ComponentTypes_children__ComponentTypes;
		typedef boost::mpl::pair< ::PICML::TopLevelPackages, CR_TopLevelPackages_children > _CR_TopLevelPackages_children__TopLevelPackages;
		typedef boost::mpl::pair< ::PICML::ComponentPackages, CR_ComponentPackages_children > _CR_ComponentPackages_children__ComponentPackages;
		typedef boost::mpl::pair< ::PICML::Targets, CR_Targets_children > _CR_Targets_children__Targets;
		typedef boost::mpl::pair< ::PICML::PredefinedTypes, CR_PredefinedTypes_children > _CR_PredefinedTypes_children__PredefinedTypes;
		typedef boost::mpl::pair< ::PICML::InterfaceDefinitions, CR_InterfaceDefinitions_children > _CR_InterfaceDefinitions_children__InterfaceDefinitions;
		typedef boost::mpl::pair< ::PICML::ComponentBuild, CR_ComponentBuild_children > _CR_ComponentBuild_children__ComponentBuild;
		typedef boost::mpl::pair< ::PICML::WorkerLibraries, CR_WorkerLibraries_children > _CR_WorkerLibraries_children__WorkerLibraries;
		typedef boost::mpl::pair< ::PICML::RootFolder, CR_RootFolder_children > _CR_RootFolder_children__RootFolder;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_PathDiagrams_children__PathDiagrams, _CR_ComponentFactoryImplementations_children__ComponentFactoryImplementations, _CR_ComponentAnalyses_children__ComponentAnalyses, _CR_DeploymentPlans_children__DeploymentPlans, _CR_ComponentImplementations_children__ComponentImplementations, _CR_PackageConfigurations_children__PackageConfigurations, _CR_ImplementationArtifacts_children__ImplementationArtifacts, _CR_ComponentTypes_children__ComponentTypes, _CR_TopLevelPackages_children__TopLevelPackages, _CR_ComponentPackages_children__ComponentPackages, _CR_Targets_children__Targets, _CR_PredefinedTypes_children__PredefinedTypes, _CR_InterfaceDefinitions_children__InterfaceDefinitions, _CR_ComponentBuild_children__ComponentBuild, _CR_WorkerLibraries_children__WorkerLibraries, _CR_RootFolder_children__RootFolder> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentFactoryImplementations, ::PICML::PathDiagrams, ::PICML::ComponentAnalyses, ::PICML::DeploymentPlans, ::PICML::ComponentImplementations, ::PICML::PackageConfigurations, ::PICML::ImplementationArtifacts, ::PICML::ComponentTypes, ::PICML::TopLevelPackages, ::PICML::ComponentPackages, ::PICML::Targets, ::PICML::PredefinedTypes, ::PICML::InterfaceDefinitions, ::PICML::ComponentBuild, ::PICML::WorkerLibraries, ::PICML::RootFolder> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export MgaObject : public Udm::Object {
	public:
		typedef ::Udm::UnknownMetaTag MetaKind;

		MgaObject() {}
		MgaObject(Udm::ObjectImpl *impl) : UDM_OBJECT(impl) {}
		MgaObject(const MgaObject &master) : UDM_OBJECT(master) {}

		static MgaObject Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static MgaObject Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		MgaObject CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<MgaObject> Instances() { return Udm::InstantiatedAttr<MgaObject>(impl); }
		template <class Pred> Udm::InstantiatedAttr<MgaObject, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<MgaObject, Pred>(impl); }
		MgaObject CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<MgaObject> Derived() { return Udm::DerivedAttr<MgaObject>(impl); }
		template <class Pred> Udm::DerivedAttr<MgaObject, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<MgaObject, Pred>(impl); }
		Udm::ArchetypeAttr<MgaObject> Archetype() const { return Udm::ArchetypeAttr<MgaObject>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr position() const { return Udm::StringAttr(impl, meta_position); }
		Udm::StringAttr name() const { return Udm::StringAttr(impl, meta_name); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_position;
		static ::Uml::Attribute meta_name;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export InfoProperty :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		InfoProperty() {}
		InfoProperty(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		InfoProperty(const InfoProperty &master) : MgaObject(master) {}

		static InfoProperty Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static InfoProperty Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		InfoProperty CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<InfoProperty> Instances() { return Udm::InstantiatedAttr<InfoProperty>(impl); }
		template <class Pred> Udm::InstantiatedAttr<InfoProperty, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<InfoProperty, Pred>(impl); }
		InfoProperty CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<InfoProperty> Derived() { return Udm::DerivedAttr<InfoProperty>(impl); }
		template <class Pred> Udm::DerivedAttr<InfoProperty, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<InfoProperty, Pred>(impl); }
		Udm::ArchetypeAttr<InfoProperty> Archetype() const { return Udm::ArchetypeAttr<InfoProperty>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ImplementationContainer> ImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ImplementationContainer>(impl, meta_ImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::Implemenation> srcInfoProperty_end() const { return Udm::AssocEndAttr< ::PICML::Implemenation>(impl, meta_srcInfoProperty_end_); }
		Udm::AssocEndAttr< ::PICML::Property> dstInfoProperty_end() const { return Udm::AssocEndAttr< ::PICML::Property>(impl, meta_dstInfoProperty_end_); }
		void Accept(Visitor &v) { v.Visit_InfoProperty(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcInfoProperty_end_;
		static ::Uml::AssociationRole meta_dstInfoProperty_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ImplementationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ImplementationContainer, PR_ImplementationContainer_parent > _PR_ImplementationContainer_parent__ImplementationContainer;
		typedef boost::mpl::vector< _PR_ImplementationContainer_parent__ImplementationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcInfoProperty {};
		class ACE_dstInfoProperty {};
		typedef boost::mpl::pair< ::PICML::Implemenation, ACE_srcInfoProperty > _ACE_srcInfoProperty__Implemenation;
		typedef boost::mpl::pair< ::PICML::Property, ACE_dstInfoProperty > _ACE_dstInfoProperty__Property;
		typedef boost::mpl::vector< _ACE_srcInfoProperty__Implemenation, _ACE_dstInfoProperty__Property> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ConfigProperty :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		ConfigProperty() {}
		ConfigProperty(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ConfigProperty(const ConfigProperty &master) : MgaObject(master) {}

		static ConfigProperty Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ConfigProperty Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ConfigProperty CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ConfigProperty> Instances() { return Udm::InstantiatedAttr<ConfigProperty>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ConfigProperty, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ConfigProperty, Pred>(impl); }
		ConfigProperty CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ConfigProperty> Derived() { return Udm::DerivedAttr<ConfigProperty>(impl); }
		template <class Pred> Udm::DerivedAttr<ConfigProperty, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ConfigProperty, Pred>(impl); }
		Udm::ArchetypeAttr<ConfigProperty> Archetype() const { return Udm::ArchetypeAttr<ConfigProperty>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ImplementationContainer> ImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ImplementationContainer>(impl, meta_ImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::Implemenation> srcConfigProperty_end() const { return Udm::AssocEndAttr< ::PICML::Implemenation>(impl, meta_srcConfigProperty_end_); }
		Udm::AssocEndAttr< ::PICML::Property> dstConfigProperty_end() const { return Udm::AssocEndAttr< ::PICML::Property>(impl, meta_dstConfigProperty_end_); }
		void Accept(Visitor &v) { v.Visit_ConfigProperty(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcConfigProperty_end_;
		static ::Uml::AssociationRole meta_dstConfigProperty_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ImplementationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ImplementationContainer, PR_ImplementationContainer_parent > _PR_ImplementationContainer_parent__ImplementationContainer;
		typedef boost::mpl::vector< _PR_ImplementationContainer_parent__ImplementationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcConfigProperty {};
		class ACE_dstConfigProperty {};
		typedef boost::mpl::pair< ::PICML::Implemenation, ACE_srcConfigProperty > _ACE_srcConfigProperty__Implemenation;
		typedef boost::mpl::pair< ::PICML::Property, ACE_dstConfigProperty > _ACE_dstConfigProperty__Property;
		typedef boost::mpl::vector< _ACE_srcConfigProperty__Implemenation, _ACE_dstConfigProperty__Property> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export MonolithprimaryArtifact :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		MonolithprimaryArtifact() {}
		MonolithprimaryArtifact(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		MonolithprimaryArtifact(const MonolithprimaryArtifact &master) : MgaObject(master) {}

		static MonolithprimaryArtifact Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static MonolithprimaryArtifact Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		MonolithprimaryArtifact CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<MonolithprimaryArtifact> Instances() { return Udm::InstantiatedAttr<MonolithprimaryArtifact>(impl); }
		template <class Pred> Udm::InstantiatedAttr<MonolithprimaryArtifact, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<MonolithprimaryArtifact, Pred>(impl); }
		MonolithprimaryArtifact CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<MonolithprimaryArtifact> Derived() { return Udm::DerivedAttr<MonolithprimaryArtifact>(impl); }
		template <class Pred> Udm::DerivedAttr<MonolithprimaryArtifact, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<MonolithprimaryArtifact, Pred>(impl); }
		Udm::ArchetypeAttr<MonolithprimaryArtifact> Archetype() const { return Udm::ArchetypeAttr<MonolithprimaryArtifact>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ImplementationContainer> ImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ImplementationContainer>(impl, meta_ImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::MonolithicImplementationBase> srcMonolithprimaryArtifact_end() const { return Udm::AssocEndAttr< ::PICML::MonolithicImplementationBase>(impl, meta_srcMonolithprimaryArtifact_end_); }
		Udm::AssocEndAttr< ::PICML::ImplementationArtifactReference> dstMonolithprimaryArtifact_end() const { return Udm::AssocEndAttr< ::PICML::ImplementationArtifactReference>(impl, meta_dstMonolithprimaryArtifact_end_); }
		void Accept(Visitor &v) { v.Visit_MonolithprimaryArtifact(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcMonolithprimaryArtifact_end_;
		static ::Uml::AssociationRole meta_dstMonolithprimaryArtifact_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ImplementationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ImplementationContainer, PR_ImplementationContainer_parent > _PR_ImplementationContainer_parent__ImplementationContainer;
		typedef boost::mpl::vector< _PR_ImplementationContainer_parent__ImplementationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcMonolithprimaryArtifact {};
		class ACE_dstMonolithprimaryArtifact {};
		typedef boost::mpl::pair< ::PICML::MonolithicImplementationBase, ACE_srcMonolithprimaryArtifact > _ACE_srcMonolithprimaryArtifact__MonolithicImplementationBase;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifactReference, ACE_dstMonolithprimaryArtifact > _ACE_dstMonolithprimaryArtifact__ImplementationArtifactReference;
		typedef boost::mpl::vector< _ACE_srcMonolithprimaryArtifact__MonolithicImplementationBase, _ACE_dstMonolithprimaryArtifact__ImplementationArtifactReference> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export MonolithDeployRequirement :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		MonolithDeployRequirement() {}
		MonolithDeployRequirement(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		MonolithDeployRequirement(const MonolithDeployRequirement &master) : MgaObject(master) {}

		static MonolithDeployRequirement Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static MonolithDeployRequirement Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		MonolithDeployRequirement CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<MonolithDeployRequirement> Instances() { return Udm::InstantiatedAttr<MonolithDeployRequirement>(impl); }
		template <class Pred> Udm::InstantiatedAttr<MonolithDeployRequirement, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<MonolithDeployRequirement, Pred>(impl); }
		MonolithDeployRequirement CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<MonolithDeployRequirement> Derived() { return Udm::DerivedAttr<MonolithDeployRequirement>(impl); }
		template <class Pred> Udm::DerivedAttr<MonolithDeployRequirement, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<MonolithDeployRequirement, Pred>(impl); }
		Udm::ArchetypeAttr<MonolithDeployRequirement> Archetype() const { return Udm::ArchetypeAttr<MonolithDeployRequirement>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ImplementationContainer> ImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ImplementationContainer>(impl, meta_ImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::MonolithicImplementationBase> srcMonolithDeployRequirement_end() const { return Udm::AssocEndAttr< ::PICML::MonolithicImplementationBase>(impl, meta_srcMonolithDeployRequirement_end_); }
		Udm::AssocEndAttr< ::PICML::ImplementationRequirement> dstMonolithDeployRequirement_end() const { return Udm::AssocEndAttr< ::PICML::ImplementationRequirement>(impl, meta_dstMonolithDeployRequirement_end_); }
		void Accept(Visitor &v) { v.Visit_MonolithDeployRequirement(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcMonolithDeployRequirement_end_;
		static ::Uml::AssociationRole meta_dstMonolithDeployRequirement_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ImplementationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ImplementationContainer, PR_ImplementationContainer_parent > _PR_ImplementationContainer_parent__ImplementationContainer;
		typedef boost::mpl::vector< _PR_ImplementationContainer_parent__ImplementationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcMonolithDeployRequirement {};
		class ACE_dstMonolithDeployRequirement {};
		typedef boost::mpl::pair< ::PICML::MonolithicImplementationBase, ACE_srcMonolithDeployRequirement > _ACE_srcMonolithDeployRequirement__MonolithicImplementationBase;
		typedef boost::mpl::pair< ::PICML::ImplementationRequirement, ACE_dstMonolithDeployRequirement > _ACE_dstMonolithDeployRequirement__ImplementationRequirement;
		typedef boost::mpl::vector< _ACE_srcMonolithDeployRequirement__MonolithicImplementationBase, _ACE_dstMonolithDeployRequirement__ImplementationRequirement> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export MonolithExecParameter :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		MonolithExecParameter() {}
		MonolithExecParameter(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		MonolithExecParameter(const MonolithExecParameter &master) : MgaObject(master) {}

		static MonolithExecParameter Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static MonolithExecParameter Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		MonolithExecParameter CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<MonolithExecParameter> Instances() { return Udm::InstantiatedAttr<MonolithExecParameter>(impl); }
		template <class Pred> Udm::InstantiatedAttr<MonolithExecParameter, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<MonolithExecParameter, Pred>(impl); }
		MonolithExecParameter CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<MonolithExecParameter> Derived() { return Udm::DerivedAttr<MonolithExecParameter>(impl); }
		template <class Pred> Udm::DerivedAttr<MonolithExecParameter, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<MonolithExecParameter, Pred>(impl); }
		Udm::ArchetypeAttr<MonolithExecParameter> Archetype() const { return Udm::ArchetypeAttr<MonolithExecParameter>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ImplementationContainer> ImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ImplementationContainer>(impl, meta_ImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::MonolithicImplementationBase> srcMonolithExecParameter_end() const { return Udm::AssocEndAttr< ::PICML::MonolithicImplementationBase>(impl, meta_srcMonolithExecParameter_end_); }
		Udm::AssocEndAttr< ::PICML::Property> dstMonolithExecParameter_end() const { return Udm::AssocEndAttr< ::PICML::Property>(impl, meta_dstMonolithExecParameter_end_); }
		void Accept(Visitor &v) { v.Visit_MonolithExecParameter(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcMonolithExecParameter_end_;
		static ::Uml::AssociationRole meta_dstMonolithExecParameter_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ImplementationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ImplementationContainer, PR_ImplementationContainer_parent > _PR_ImplementationContainer_parent__ImplementationContainer;
		typedef boost::mpl::vector< _PR_ImplementationContainer_parent__ImplementationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcMonolithExecParameter {};
		class ACE_dstMonolithExecParameter {};
		typedef boost::mpl::pair< ::PICML::MonolithicImplementationBase, ACE_srcMonolithExecParameter > _ACE_srcMonolithExecParameter__MonolithicImplementationBase;
		typedef boost::mpl::pair< ::PICML::Property, ACE_dstMonolithExecParameter > _ACE_dstMonolithExecParameter__Property;
		typedef boost::mpl::vector< _ACE_srcMonolithExecParameter__MonolithicImplementationBase, _ACE_dstMonolithExecParameter__Property> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ImplementationContainer :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ImplementationContainer() {}
		ImplementationContainer(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ImplementationContainer(const ImplementationContainer &master) : MgaObject(master) {}

		static ImplementationContainer Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ImplementationContainer Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ImplementationContainer CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ImplementationContainer> Instances() { return Udm::InstantiatedAttr<ImplementationContainer>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ImplementationContainer, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ImplementationContainer, Pred>(impl); }
		ImplementationContainer CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ImplementationContainer> Derived() { return Udm::DerivedAttr<ImplementationContainer>(impl); }
		template <class Pred> Udm::DerivedAttr<ImplementationContainer, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ImplementationContainer, Pred>(impl); }
		Udm::ArchetypeAttr<ImplementationContainer> Archetype() const { return Udm::ArchetypeAttr<ImplementationContainer>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::ConfigProperty> ConfigProperty_children() const { return Udm::ChildrenAttr< ::PICML::ConfigProperty>(impl, meta_ConfigProperty_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ConfigProperty, Pred> ConfigProperty_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ConfigProperty, Pred>(impl, meta_ConfigProperty_children); }
		Udm::ChildrenAttr< ::PICML::InfoProperty> InfoProperty_children() const { return Udm::ChildrenAttr< ::PICML::InfoProperty>(impl, meta_InfoProperty_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InfoProperty, Pred> InfoProperty_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InfoProperty, Pred>(impl, meta_InfoProperty_children); }
		Udm::ChildrenAttr< ::PICML::Property> Property_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, meta_Property_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); }
		Udm::ChildrenAttr< ::PICML::MonolithprimaryArtifact> MonolithprimaryArtifact_children() const { return Udm::ChildrenAttr< ::PICML::MonolithprimaryArtifact>(impl, meta_MonolithprimaryArtifact_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MonolithprimaryArtifact, Pred> MonolithprimaryArtifact_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MonolithprimaryArtifact, Pred>(impl, meta_MonolithprimaryArtifact_children); }
		Udm::ChildrenAttr< ::PICML::MonolithDeployRequirement> MonolithDeployRequirement_children() const { return Udm::ChildrenAttr< ::PICML::MonolithDeployRequirement>(impl, meta_MonolithDeployRequirement_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MonolithDeployRequirement, Pred> MonolithDeployRequirement_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MonolithDeployRequirement, Pred>(impl, meta_MonolithDeployRequirement_children); }
		Udm::ChildrenAttr< ::PICML::MonolithExecParameter> MonolithExecParameter_children() const { return Udm::ChildrenAttr< ::PICML::MonolithExecParameter>(impl, meta_MonolithExecParameter_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MonolithExecParameter, Pred> MonolithExecParameter_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MonolithExecParameter, Pred>(impl, meta_MonolithExecParameter_children); }
		Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference>(impl, meta_ImplementationArtifactReference_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred> ImplementationArtifactReference_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred>(impl, meta_ImplementationArtifactReference_children); }
		Udm::ChildrenAttr< ::PICML::ImplementationRequirement> ImplementationRequirement_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationRequirement>(impl, meta_ImplementationRequirement_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationRequirement, Pred> ImplementationRequirement_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationRequirement, Pred>(impl, meta_ImplementationRequirement_children); }
		Udm::ChildrenAttr< ::PICML::InfoProperty> InfoProperty_kind_children() const { return Udm::ChildrenAttr< ::PICML::InfoProperty>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InfoProperty, Pred> InfoProperty_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InfoProperty, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ConfigProperty> ConfigProperty_kind_children() const { return Udm::ChildrenAttr< ::PICML::ConfigProperty>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ConfigProperty, Pred> ConfigProperty_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ConfigProperty, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MonolithprimaryArtifact> MonolithprimaryArtifact_kind_children() const { return Udm::ChildrenAttr< ::PICML::MonolithprimaryArtifact>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MonolithprimaryArtifact, Pred> MonolithprimaryArtifact_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MonolithprimaryArtifact, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MonolithDeployRequirement> MonolithDeployRequirement_kind_children() const { return Udm::ChildrenAttr< ::PICML::MonolithDeployRequirement>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MonolithDeployRequirement, Pred> MonolithDeployRequirement_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MonolithDeployRequirement, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MonolithExecParameter> MonolithExecParameter_kind_children() const { return Udm::ChildrenAttr< ::PICML::MonolithExecParameter>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MonolithExecParameter, Pred> MonolithExecParameter_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MonolithExecParameter, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentServantArtifact> ComponentServantArtifact_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentServantArtifact>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred> ComponentServantArtifact_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact> ComponentImplementationArtifact_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred> ComponentImplementationArtifact_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_kind_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred> ImplementationArtifactReference_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RequirementBase> RequirementBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::RequirementBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RequirementBase, Pred> RequirementBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RequirementBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ImplementationRequirement> ImplementationRequirement_kind_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationRequirement>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationRequirement, Pred> ImplementationRequirement_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationRequirement, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_ConfigProperty_children;
		static ::Uml::CompositionChildRole meta_InfoProperty_children;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_MonolithprimaryArtifact_children;
		static ::Uml::CompositionChildRole meta_MonolithDeployRequirement_children;
		static ::Uml::CompositionChildRole meta_MonolithExecParameter_children;
		static ::Uml::CompositionChildRole meta_ImplementationArtifactReference_children;
		static ::Uml::CompositionChildRole meta_ImplementationRequirement_children;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ConfigProperty_children {};
		class CR_InfoProperty_children {};
		class CR_Property_children {};
		class CR_MonolithprimaryArtifact_children {};
		class CR_MonolithDeployRequirement_children {};
		class CR_MonolithExecParameter_children {};
		class CR_ImplementationArtifactReference_children {};
		class CR_ImplementationRequirement_children {};
		typedef boost::mpl::pair< ::PICML::ConfigProperty, CR_ConfigProperty_children > _CR_ConfigProperty_children__ConfigProperty;
		typedef boost::mpl::pair< ::PICML::InfoProperty, CR_InfoProperty_children > _CR_InfoProperty_children__InfoProperty;
		typedef boost::mpl::pair< ::PICML::Property, CR_Property_children > _CR_Property_children__Property;
		typedef boost::mpl::pair< ::PICML::MonolithprimaryArtifact, CR_MonolithprimaryArtifact_children > _CR_MonolithprimaryArtifact_children__MonolithprimaryArtifact;
		typedef boost::mpl::pair< ::PICML::MonolithDeployRequirement, CR_MonolithDeployRequirement_children > _CR_MonolithDeployRequirement_children__MonolithDeployRequirement;
		typedef boost::mpl::pair< ::PICML::MonolithExecParameter, CR_MonolithExecParameter_children > _CR_MonolithExecParameter_children__MonolithExecParameter;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifactReference, CR_ImplementationArtifactReference_children > _CR_ImplementationArtifactReference_children__ImplementationArtifactReference;
		typedef boost::mpl::pair< ::PICML::ImplementationRequirement, CR_ImplementationRequirement_children > _CR_ImplementationRequirement_children__ImplementationRequirement;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_ConfigProperty_children__ConfigProperty, _CR_InfoProperty_children__InfoProperty, _CR_Property_children__Property, _CR_MonolithprimaryArtifact_children__MonolithprimaryArtifact, _CR_MonolithDeployRequirement_children__MonolithDeployRequirement, _CR_MonolithExecParameter_children__MonolithExecParameter, _CR_ImplementationArtifactReference_children__ImplementationArtifactReference, _CR_ImplementationRequirement_children__ImplementationRequirement> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::InfoProperty, ::PICML::ConfigProperty, ::PICML::MonolithprimaryArtifact, ::PICML::MonolithDeployRequirement, ::PICML::MonolithExecParameter, ::PICML::ComponentServantArtifact, ::PICML::ComponentImplementationArtifact, ::PICML::ImplementationArtifactReference, ::PICML::ImplementationRequirement, ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Implemenation :  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		Implemenation() {}
		Implemenation(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Implemenation(const Implemenation &master) : MgaObject(master) {}

		static Implemenation Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Implemenation Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Implemenation CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Implemenation> Instances() { return Udm::InstantiatedAttr<Implemenation>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Implemenation, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Implemenation, Pred>(impl); }
		Implemenation CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Implemenation> Derived() { return Udm::DerivedAttr<Implemenation>(impl); }
		template <class Pred> Udm::DerivedAttr<Implemenation, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Implemenation, Pred>(impl); }
		Udm::ArchetypeAttr<Implemenation> Archetype() const { return Udm::ArchetypeAttr<Implemenation>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr UUID() const { return Udm::StringAttr(impl, meta_UUID); }
		Udm::StringAttr label() const { return Udm::StringAttr(impl, meta_label); }
		Udm::AClassAssocAttr< ::PICML::InfoProperty, ::PICML::Property> dstInfoProperty() const { return Udm::AClassAssocAttr< ::PICML::InfoProperty, ::PICML::Property>(impl, meta_dstInfoProperty, meta_dstInfoProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::InfoProperty, ::PICML::Property, Pred> dstInfoProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::InfoProperty, ::PICML::Property, Pred>(impl, meta_dstInfoProperty, meta_dstInfoProperty_rev); }
		Udm::AClassAssocAttr< ::PICML::ConfigProperty, ::PICML::Property> dstConfigProperty() const { return Udm::AClassAssocAttr< ::PICML::ConfigProperty, ::PICML::Property>(impl, meta_dstConfigProperty, meta_dstConfigProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ConfigProperty, ::PICML::Property, Pred> dstConfigProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ConfigProperty, ::PICML::Property, Pred>(impl, meta_dstConfigProperty, meta_dstConfigProperty_rev); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::Attribute meta_label;
		static ::Uml::AssociationRole meta_dstInfoProperty;
		static ::Uml::AssociationRole meta_dstInfoProperty_rev;
		static ::Uml::AssociationRole meta_dstConfigProperty;
		static ::Uml::AssociationRole meta_dstConfigProperty_rev;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstInfoProperty {};
		class AR_dstConfigProperty {};
		typedef boost::mpl::pair< ::PICML::Property, boost::mpl::pair< ::PICML::InfoProperty, AR_dstInfoProperty > > _AR_dstInfoProperty__InfoProperty__Property;
		typedef boost::mpl::pair< ::PICML::Property, boost::mpl::pair< ::PICML::ConfigProperty, AR_dstConfigProperty > > _AR_dstConfigProperty__ConfigProperty__Property;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstInfoProperty__InfoProperty__Property, _AR_dstConfigProperty__ConfigProperty__Property> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export MonolithicImplementationBase :  virtual  public Implemenation {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		MonolithicImplementationBase() {}
		MonolithicImplementationBase(Udm::ObjectImpl *impl) : Implemenation(impl) {}
		MonolithicImplementationBase(const MonolithicImplementationBase &master) : Implemenation(master) {}

		static MonolithicImplementationBase Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static MonolithicImplementationBase Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		MonolithicImplementationBase CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<MonolithicImplementationBase> Instances() { return Udm::InstantiatedAttr<MonolithicImplementationBase>(impl); }
		template <class Pred> Udm::InstantiatedAttr<MonolithicImplementationBase, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<MonolithicImplementationBase, Pred>(impl); }
		MonolithicImplementationBase CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<MonolithicImplementationBase> Derived() { return Udm::DerivedAttr<MonolithicImplementationBase>(impl); }
		template <class Pred> Udm::DerivedAttr<MonolithicImplementationBase, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<MonolithicImplementationBase, Pred>(impl); }
		Udm::ArchetypeAttr<MonolithicImplementationBase> Archetype() const { return Udm::ArchetypeAttr<MonolithicImplementationBase>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::MonolithExecParameter, ::PICML::Property> dstMonolithExecParameter() const { return Udm::AClassAssocAttr< ::PICML::MonolithExecParameter, ::PICML::Property>(impl, meta_dstMonolithExecParameter, meta_dstMonolithExecParameter_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::MonolithExecParameter, ::PICML::Property, Pred> dstMonolithExecParameter_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::MonolithExecParameter, ::PICML::Property, Pred>(impl, meta_dstMonolithExecParameter, meta_dstMonolithExecParameter_rev); }
		Udm::AClassAssocAttr< ::PICML::MonolithDeployRequirement, ::PICML::ImplementationRequirement> dstMonolithDeployRequirement() const { return Udm::AClassAssocAttr< ::PICML::MonolithDeployRequirement, ::PICML::ImplementationRequirement>(impl, meta_dstMonolithDeployRequirement, meta_dstMonolithDeployRequirement_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::MonolithDeployRequirement, ::PICML::ImplementationRequirement, Pred> dstMonolithDeployRequirement_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::MonolithDeployRequirement, ::PICML::ImplementationRequirement, Pred>(impl, meta_dstMonolithDeployRequirement, meta_dstMonolithDeployRequirement_rev); }
		Udm::AClassAssocAttr< ::PICML::MonolithprimaryArtifact, ::PICML::ImplementationArtifactReference> dstMonolithprimaryArtifact() const { return Udm::AClassAssocAttr< ::PICML::MonolithprimaryArtifact, ::PICML::ImplementationArtifactReference>(impl, meta_dstMonolithprimaryArtifact, meta_dstMonolithprimaryArtifact_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::MonolithprimaryArtifact, ::PICML::ImplementationArtifactReference, Pred> dstMonolithprimaryArtifact_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::MonolithprimaryArtifact, ::PICML::ImplementationArtifactReference, Pred>(impl, meta_dstMonolithprimaryArtifact, meta_dstMonolithprimaryArtifact_rev); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstMonolithExecParameter;
		static ::Uml::AssociationRole meta_dstMonolithExecParameter_rev;
		static ::Uml::AssociationRole meta_dstMonolithDeployRequirement;
		static ::Uml::AssociationRole meta_dstMonolithDeployRequirement_rev;
		static ::Uml::AssociationRole meta_dstMonolithprimaryArtifact;
		static ::Uml::AssociationRole meta_dstMonolithprimaryArtifact_rev;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstMonolithExecParameter {};
		class AR_dstMonolithDeployRequirement {};
		class AR_dstMonolithprimaryArtifact {};
		typedef boost::mpl::pair< ::PICML::Property, boost::mpl::pair< ::PICML::MonolithExecParameter, AR_dstMonolithExecParameter > > _AR_dstMonolithExecParameter__MonolithExecParameter__Property;
		typedef boost::mpl::pair< ::PICML::ImplementationRequirement, boost::mpl::pair< ::PICML::MonolithDeployRequirement, AR_dstMonolithDeployRequirement > > _AR_dstMonolithDeployRequirement__MonolithDeployRequirement__ImplementationRequirement;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifactReference, boost::mpl::pair< ::PICML::MonolithprimaryArtifact, AR_dstMonolithprimaryArtifact > > _AR_dstMonolithprimaryArtifact__MonolithprimaryArtifact__ImplementationArtifactReference;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstMonolithExecParameter__MonolithExecParameter__Property, _AR_dstMonolithDeployRequirement__MonolithDeployRequirement__ImplementationRequirement, _AR_dstMonolithprimaryArtifact__MonolithprimaryArtifact__ImplementationArtifactReference> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentFactoryImplementationContainer :  public ImplementationContainer {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ComponentFactoryImplementationContainer() {}
		ComponentFactoryImplementationContainer(Udm::ObjectImpl *impl) : ImplementationContainer(impl) {}
		ComponentFactoryImplementationContainer(const ComponentFactoryImplementationContainer &master) : ImplementationContainer(master) {}

		static ComponentFactoryImplementationContainer Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentFactoryImplementationContainer Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentFactoryImplementationContainer CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentFactoryImplementationContainer> Instances() { return Udm::InstantiatedAttr<ComponentFactoryImplementationContainer>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentFactoryImplementationContainer, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentFactoryImplementationContainer, Pred>(impl); }
		ComponentFactoryImplementationContainer CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentFactoryImplementationContainer> Derived() { return Udm::DerivedAttr<ComponentFactoryImplementationContainer>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentFactoryImplementationContainer, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentFactoryImplementationContainer, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentFactoryImplementationContainer> Archetype() const { return Udm::ArchetypeAttr<ComponentFactoryImplementationContainer>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::ComponentFactoryInstance> ComponentFactoryInstance_children() const { return Udm::ChildrenAttr< ::PICML::ComponentFactoryInstance>(impl, meta_ComponentFactoryInstance_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentFactoryInstance, Pred> ComponentFactoryInstance_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentFactoryInstance, Pred>(impl, meta_ComponentFactoryInstance_children); }
		Udm::ChildrenAttr< ::PICML::MonolithicImplementationBase> MonolithicImplementationBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::MonolithicImplementationBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MonolithicImplementationBase, Pred> MonolithicImplementationBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MonolithicImplementationBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Implemenation> Implemenation_kind_children() const { return Udm::ChildrenAttr< ::PICML::Implemenation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Implemenation, Pred> Implemenation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Implemenation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentFactoryInstance> ComponentFactoryInstance_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentFactoryInstance>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentFactoryInstance, Pred> ComponentFactoryInstance_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentFactoryInstance, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::ComponentFactoryImplementations> ComponentFactoryImplementations_parent() const { return Udm::ParentAttr< ::PICML::ComponentFactoryImplementations>(impl, meta_ComponentFactoryImplementations_parent); }
		Udm::ParentAttr< ::PICML::ComponentFactoryImplementations> parent() const { return Udm::ParentAttr< ::PICML::ComponentFactoryImplementations>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentFactoryImplementationContainer(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_ComponentFactoryInstance_children;
		static ::Uml::CompositionParentRole meta_ComponentFactoryImplementations_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentFactoryImplementations_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentFactoryImplementations, PR_ComponentFactoryImplementations_parent > _PR_ComponentFactoryImplementations_parent__ComponentFactoryImplementations;
		typedef boost::mpl::vector< _PR_ComponentFactoryImplementations_parent__ComponentFactoryImplementations> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentFactoryImplementations> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ComponentFactoryInstance_children {};
		typedef boost::mpl::pair< ::PICML::ComponentFactoryInstance, CR_ComponentFactoryInstance_children > _CR_ComponentFactoryInstance_children__ComponentFactoryInstance;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_ComponentFactoryInstance_children__ComponentFactoryInstance> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::InfoProperty, ::PICML::ConfigProperty, ::PICML::MonolithprimaryArtifact, ::PICML::MonolithDeployRequirement, ::PICML::MonolithExecParameter, ::PICML::ComponentServantArtifact, ::PICML::ComponentImplementationArtifact, ::PICML::ComponentFactoryInstance, ::PICML::ImplementationArtifactReference, ::PICML::ImplementationRequirement, ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentFactoryInstance :  public MonolithicImplementationBase {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		ComponentFactoryInstance() {}
		ComponentFactoryInstance(Udm::ObjectImpl *impl) : MonolithicImplementationBase(impl), Implemenation(impl) {}
		ComponentFactoryInstance(const ComponentFactoryInstance &master) : MonolithicImplementationBase(master), Implemenation(master) {}

		static ComponentFactoryInstance Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentFactoryInstance Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentFactoryInstance CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentFactoryInstance> Instances() { return Udm::InstantiatedAttr<ComponentFactoryInstance>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentFactoryInstance, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentFactoryInstance, Pred>(impl); }
		ComponentFactoryInstance CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentFactoryInstance> Derived() { return Udm::DerivedAttr<ComponentFactoryInstance>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentFactoryInstance, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentFactoryInstance, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentFactoryInstance> Archetype() const { return Udm::ArchetypeAttr<ComponentFactoryInstance>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::ComponentFactoryRef> referedbyComponentFactoryRef() const { return Udm::AssocAttr< ::PICML::ComponentFactoryRef>(impl, meta_referedbyComponentFactoryRef); }
		template <class Pred> Udm::AssocAttr< ::PICML::ComponentFactoryRef, Pred> referedbyComponentFactoryRef_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::ComponentFactoryRef, Pred>(impl, meta_referedbyComponentFactoryRef); }
		Udm::PointerAttr< ::PICML::ComponentFactory> ref() const { return Udm::PointerAttr< ::PICML::ComponentFactory>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::ComponentFactoryImplementationContainer> ComponentFactoryImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ComponentFactoryImplementationContainer>(impl, meta_ComponentFactoryImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentFactoryInstance(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyComponentFactoryRef;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ComponentFactoryImplementationContainer_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentFactoryImplementationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentFactoryImplementationContainer, PR_ComponentFactoryImplementationContainer_parent > _PR_ComponentFactoryImplementationContainer_parent__ComponentFactoryImplementationContainer;
		typedef boost::mpl::vector< _PR_ComponentFactoryImplementationContainer_parent__ComponentFactoryImplementationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentFactoryImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyComponentFactoryRef {};
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::ComponentFactoryRef, AR_referedbyComponentFactoryRef > _AR_referedbyComponentFactoryRef__ComponentFactoryRef;
		typedef boost::mpl::pair< ::PICML::ComponentFactory, AR_ref > _AR_ref__ComponentFactory;
		typedef boost::mpl::vector< _AR_ref__ComponentFactory> AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyComponentFactoryRef__ComponentFactoryRef> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ServiceProvider :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ServiceProvider() {}
		ServiceProvider(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ServiceProvider(const ServiceProvider &master) : MgaObject(master) {}

		static ServiceProvider Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ServiceProvider Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ServiceProvider CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ServiceProvider> Instances() { return Udm::InstantiatedAttr<ServiceProvider>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ServiceProvider, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ServiceProvider, Pred>(impl); }
		ServiceProvider CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ServiceProvider> Derived() { return Udm::DerivedAttr<ServiceProvider>(impl); }
		template <class Pred> Udm::DerivedAttr<ServiceProvider, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ServiceProvider, Pred>(impl); }
		Udm::ArchetypeAttr<ServiceProvider> Archetype() const { return Udm::ArchetypeAttr<ServiceProvider>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::BooleanAttr fixed_prioirty_service_execution() const { return Udm::BooleanAttr(impl, meta_fixed_prioirty_service_execution); }
		Udm::ChildAttr< ::PICML::ServiceLevels> ServiceLevels_child() const { return Udm::ChildAttr< ::PICML::ServiceLevels>(impl, meta_ServiceLevels_child); }
		Udm::ChildAttr< ::PICML::MultipleServiceRequests> MultipleServiceRequests_child() const { return Udm::ChildAttr< ::PICML::MultipleServiceRequests>(impl, meta_MultipleServiceRequests_child); }
		Udm::ChildrenAttr< ::PICML::MultipleServiceRequests> MultipleServiceRequests_kind_children() const { return Udm::ChildrenAttr< ::PICML::MultipleServiceRequests>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MultipleServiceRequests, Pred> MultipleServiceRequests_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MultipleServiceRequests, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ServiceLevels> ServiceLevels_kind_children() const { return Udm::ChildrenAttr< ::PICML::ServiceLevels>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ServiceLevels, Pred> ServiceLevels_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ServiceLevels, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RTRequirements> RTRequirements_parent() const { return Udm::ParentAttr< ::PICML::RTRequirements>(impl, meta_RTRequirements_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ServiceProvider(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_fixed_prioirty_service_execution;
		static ::Uml::CompositionChildRole meta_ServiceLevels_child;
		static ::Uml::CompositionChildRole meta_MultipleServiceRequests_child;
		static ::Uml::CompositionParentRole meta_RTRequirements_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RTRequirements_parent {};
		typedef boost::mpl::pair< ::PICML::RTRequirements, PR_RTRequirements_parent > _PR_RTRequirements_parent__RTRequirements;
		typedef boost::mpl::vector< _PR_RTRequirements_parent__RTRequirements> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RTRequirements> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ServiceLevels_child {};
		class CR_MultipleServiceRequests_child {};
		typedef boost::mpl::pair< ::PICML::ServiceLevels, CR_ServiceLevels_child > _CR_ServiceLevels_child__ServiceLevels;
		typedef boost::mpl::pair< ::PICML::MultipleServiceRequests, CR_MultipleServiceRequests_child > _CR_MultipleServiceRequests_child__MultipleServiceRequests;
		typedef boost::mpl::vector< _CR_ServiceLevels_child__ServiceLevels, _CR_MultipleServiceRequests_child__MultipleServiceRequests> ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::MultipleServiceRequests, ::PICML::ServiceLevels> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export MultipleServiceRequests :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		MultipleServiceRequests() {}
		MultipleServiceRequests(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		MultipleServiceRequests(const MultipleServiceRequests &master) : MgaObject(master) {}

		static MultipleServiceRequests Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static MultipleServiceRequests Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		MultipleServiceRequests CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<MultipleServiceRequests> Instances() { return Udm::InstantiatedAttr<MultipleServiceRequests>(impl); }
		template <class Pred> Udm::InstantiatedAttr<MultipleServiceRequests, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<MultipleServiceRequests, Pred>(impl); }
		MultipleServiceRequests CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<MultipleServiceRequests> Derived() { return Udm::DerivedAttr<MultipleServiceRequests>(impl); }
		template <class Pred> Udm::DerivedAttr<MultipleServiceRequests, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<MultipleServiceRequests, Pred>(impl); }
		Udm::ArchetypeAttr<MultipleServiceRequests> Archetype() const { return Udm::ArchetypeAttr<MultipleServiceRequests>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::BooleanAttr simultaneous_service_execution() const { return Udm::BooleanAttr(impl, meta_simultaneous_service_execution); }
		Udm::IntegerAttr minimum_simultaneous_service_level() const { return Udm::IntegerAttr(impl, meta_minimum_simultaneous_service_level); }
		Udm::BooleanAttr buffer_service_requests() const { return Udm::BooleanAttr(impl, meta_buffer_service_requests); }
		Udm::IntegerAttr maximum_simultaneous_service_level() const { return Udm::IntegerAttr(impl, meta_maximum_simultaneous_service_level); }
		Udm::ParentAttr< ::PICML::ServiceProvider> ServiceProvider_parent() const { return Udm::ParentAttr< ::PICML::ServiceProvider>(impl, meta_ServiceProvider_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_MultipleServiceRequests(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_simultaneous_service_execution;
		static ::Uml::Attribute meta_minimum_simultaneous_service_level;
		static ::Uml::Attribute meta_buffer_service_requests;
		static ::Uml::Attribute meta_maximum_simultaneous_service_level;
		static ::Uml::CompositionParentRole meta_ServiceProvider_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ServiceProvider_parent {};
		typedef boost::mpl::pair< ::PICML::ServiceProvider, PR_ServiceProvider_parent > _PR_ServiceProvider_parent__ServiceProvider;
		typedef boost::mpl::vector< _PR_ServiceProvider_parent__ServiceProvider> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ServiceProvider> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ServiceLevels :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		ServiceLevels() {}
		ServiceLevels(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ServiceLevels(const ServiceLevels &master) : MgaObject(master) {}

		static ServiceLevels Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ServiceLevels Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ServiceLevels CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ServiceLevels> Instances() { return Udm::InstantiatedAttr<ServiceLevels>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ServiceLevels, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ServiceLevels, Pred>(impl); }
		ServiceLevels CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ServiceLevels> Derived() { return Udm::DerivedAttr<ServiceLevels>(impl); }
		template <class Pred> Udm::DerivedAttr<ServiceLevels, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ServiceLevels, Pred>(impl); }
		Udm::ArchetypeAttr<ServiceLevels> Archetype() const { return Udm::ArchetypeAttr<ServiceLevels>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::BooleanAttr varying_service_levels() const { return Udm::BooleanAttr(impl, meta_varying_service_levels); }
		Udm::ParentAttr< ::PICML::ServiceProvider> ServiceProvider_parent() const { return Udm::ParentAttr< ::PICML::ServiceProvider>(impl, meta_ServiceProvider_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ServiceLevels(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_varying_service_levels;
		static ::Uml::CompositionParentRole meta_ServiceProvider_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ServiceProvider_parent {};
		typedef boost::mpl::pair< ::PICML::ServiceProvider, PR_ServiceProvider_parent > _PR_ServiceProvider_parent__ServiceProvider;
		typedef boost::mpl::vector< _PR_ServiceProvider_parent__ServiceProvider> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ServiceProvider> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ServiceConsumer :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		ServiceConsumer() {}
		ServiceConsumer(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ServiceConsumer(const ServiceConsumer &master) : MgaObject(master) {}

		static ServiceConsumer Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ServiceConsumer Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ServiceConsumer CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ServiceConsumer> Instances() { return Udm::InstantiatedAttr<ServiceConsumer>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ServiceConsumer, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ServiceConsumer, Pred>(impl); }
		ServiceConsumer CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ServiceConsumer> Derived() { return Udm::DerivedAttr<ServiceConsumer>(impl); }
		template <class Pred> Udm::DerivedAttr<ServiceConsumer, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ServiceConsumer, Pred>(impl); }
		Udm::ArchetypeAttr<ServiceConsumer> Archetype() const { return Udm::ArchetypeAttr<ServiceConsumer>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::BooleanAttr prioritize_service_invocations() const { return Udm::BooleanAttr(impl, meta_prioritize_service_invocations); }
		Udm::ParentAttr< ::PICML::RTRequirements> RTRequirements_parent() const { return Udm::ParentAttr< ::PICML::RTRequirements>(impl, meta_RTRequirements_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ServiceConsumer(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_prioritize_service_invocations;
		static ::Uml::CompositionParentRole meta_RTRequirements_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RTRequirements_parent {};
		typedef boost::mpl::pair< ::PICML::RTRequirements, PR_RTRequirements_parent > _PR_RTRequirements_parent__RTRequirements;
		typedef boost::mpl::vector< _PR_RTRequirements_parent__RTRequirements> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RTRequirements> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ECBehavior :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		ECBehavior() {}
		ECBehavior(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ECBehavior(const ECBehavior &master) : MgaObject(master) {}

		static ECBehavior Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ECBehavior Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ECBehavior CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ECBehavior> Instances() { return Udm::InstantiatedAttr<ECBehavior>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ECBehavior, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ECBehavior, Pred>(impl); }
		ECBehavior CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ECBehavior> Derived() { return Udm::DerivedAttr<ECBehavior>(impl); }
		template <class Pred> Udm::DerivedAttr<ECBehavior, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ECBehavior, Pred>(impl); }
		Udm::ArchetypeAttr<ECBehavior> Archetype() const { return Udm::ArchetypeAttr<ECBehavior>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::BooleanAttr ConsumerBasedFiltering() const { return Udm::BooleanAttr(impl, meta_ConsumerBasedFiltering); }
		Udm::BooleanAttr SupplierBasedFiltering() const { return Udm::BooleanAttr(impl, meta_SupplierBasedFiltering); }
		Udm::BooleanAttr DisconnectDanglingConnections() const { return Udm::BooleanAttr(impl, meta_DisconnectDanglingConnections); }
		Udm::BooleanAttr MultithreadedConsumer() const { return Udm::BooleanAttr(impl, meta_MultithreadedConsumer); }
		Udm::IntegerAttr DispatchingMultithreadingLevel() const { return Udm::IntegerAttr(impl, meta_DispatchingMultithreadingLevel); }
		Udm::BooleanAttr MultithreadedSupplier() const { return Udm::BooleanAttr(impl, meta_MultithreadedSupplier); }
		Udm::ParentAttr< ::PICML::ECRequirements> ECRequirements_parent() const { return Udm::ParentAttr< ::PICML::ECRequirements>(impl, meta_ECRequirements_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ECBehavior(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_ConsumerBasedFiltering;
		static ::Uml::Attribute meta_SupplierBasedFiltering;
		static ::Uml::Attribute meta_DisconnectDanglingConnections;
		static ::Uml::Attribute meta_MultithreadedConsumer;
		static ::Uml::Attribute meta_DispatchingMultithreadingLevel;
		static ::Uml::Attribute meta_MultithreadedSupplier;
		static ::Uml::CompositionParentRole meta_ECRequirements_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ECRequirements_parent {};
		typedef boost::mpl::pair< ::PICML::ECRequirements, PR_ECRequirements_parent > _PR_ECRequirements_parent__ECRequirements;
		typedef boost::mpl::vector< _PR_ECRequirements_parent__ECRequirements> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ECRequirements> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ECRole :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		ECRole() {}
		ECRole(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ECRole(const ECRole &master) : MgaObject(master) {}

		static ECRole Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ECRole Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ECRole CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ECRole> Instances() { return Udm::InstantiatedAttr<ECRole>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ECRole, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ECRole, Pred>(impl); }
		ECRole CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ECRole> Derived() { return Udm::DerivedAttr<ECRole>(impl); }
		template <class Pred> Udm::DerivedAttr<ECRole, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ECRole, Pred>(impl); }
		Udm::ArchetypeAttr<ECRole> Archetype() const { return Udm::ArchetypeAttr<ECRole>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr rolekind() const { return Udm::StringAttr(impl, meta_rolekind); }
		Udm::StringAttr ECFilterType() const { return Udm::StringAttr(impl, meta_ECFilterType); }
		Udm::ParentAttr< ::PICML::ECRequirements> ECRequirements_parent() const { return Udm::ParentAttr< ::PICML::ECRequirements>(impl, meta_ECRequirements_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ECRole(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_rolekind;
		static ::Uml::Attribute meta_ECFilterType;
		static ::Uml::CompositionParentRole meta_ECRequirements_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ECRequirements_parent {};
		typedef boost::mpl::pair< ::PICML::ECRequirements, PR_ECRequirements_parent > _PR_ECRequirements_parent__ECRequirements;
		typedef boost::mpl::vector< _PR_ECRequirements_parent__ECRequirements> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ECRequirements> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ExternalPortReferenceType :  virtual  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		ExternalPortReferenceType() {}
		ExternalPortReferenceType(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ExternalPortReferenceType(const ExternalPortReferenceType &master) : MgaObject(master) {}

		static ExternalPortReferenceType Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ExternalPortReferenceType Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ExternalPortReferenceType CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ExternalPortReferenceType> Instances() { return Udm::InstantiatedAttr<ExternalPortReferenceType>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ExternalPortReferenceType, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ExternalPortReferenceType, Pred>(impl); }
		ExternalPortReferenceType CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ExternalPortReferenceType> Derived() { return Udm::DerivedAttr<ExternalPortReferenceType>(impl); }
		template <class Pred> Udm::DerivedAttr<ExternalPortReferenceType, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ExternalPortReferenceType, Pred>(impl); }
		Udm::ArchetypeAttr<ExternalPortReferenceType> Archetype() const { return Udm::ArchetypeAttr<ExternalPortReferenceType>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::ExternalPortReference> referedbyExternalPortReference() const { return Udm::AssocAttr< ::PICML::ExternalPortReference>(impl, meta_referedbyExternalPortReference); }
		template <class Pred> Udm::AssocAttr< ::PICML::ExternalPortReference, Pred> referedbyExternalPortReference_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::ExternalPortReference, Pred>(impl, meta_referedbyExternalPortReference); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyExternalPortReference;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyExternalPortReference {};
		typedef boost::mpl::pair< ::PICML::ExternalPortReference, AR_referedbyExternalPortReference > _AR_referedbyExternalPortReference__ExternalPortReference;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyExternalPortReference__ExternalPortReference> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ExternalPortReference :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		ExternalPortReference() {}
		ExternalPortReference(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ExternalPortReference(const ExternalPortReference &master) : MgaObject(master) {}

		static ExternalPortReference Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ExternalPortReference Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ExternalPortReference CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ExternalPortReference> Instances() { return Udm::InstantiatedAttr<ExternalPortReference>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ExternalPortReference, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ExternalPortReference, Pred>(impl); }
		ExternalPortReference CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ExternalPortReference> Derived() { return Udm::DerivedAttr<ExternalPortReference>(impl); }
		template <class Pred> Udm::DerivedAttr<ExternalPortReference, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ExternalPortReference, Pred>(impl); }
		Udm::ArchetypeAttr<ExternalPortReference> Archetype() const { return Udm::ArchetypeAttr<ExternalPortReference>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr label() const { return Udm::StringAttr(impl, meta_label); }
		Udm::StringAttr location() const { return Udm::StringAttr(impl, meta_location); }
		Udm::PointerAttr< ::PICML::ExternalPortReferenceType> ref() const { return Udm::PointerAttr< ::PICML::ExternalPortReferenceType>(impl, meta_ref); }
		Udm::AClassAssocAttr< ::PICML::ExternalDelegate, ::PICML::Port> dstExternalDelegate() const { return Udm::AClassAssocAttr< ::PICML::ExternalDelegate, ::PICML::Port>(impl, meta_dstExternalDelegate, meta_dstExternalDelegate_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ExternalDelegate, ::PICML::Port, Pred> dstExternalDelegate_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ExternalDelegate, ::PICML::Port, Pred>(impl, meta_dstExternalDelegate, meta_dstExternalDelegate_rev); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ExternalPortReference(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_label;
		static ::Uml::Attribute meta_location;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_dstExternalDelegate;
		static ::Uml::AssociationRole meta_dstExternalDelegate_rev;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::ExternalPortReferenceType, AR_ref > _AR_ref__ExternalPortReferenceType;
		typedef boost::mpl::vector< _AR_ref__ExternalPortReferenceType> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstExternalDelegate {};
		typedef boost::mpl::pair< ::PICML::Port, boost::mpl::pair< ::PICML::ExternalDelegate, AR_dstExternalDelegate > > _AR_dstExternalDelegate__ExternalDelegate__Port;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstExternalDelegate__ExternalDelegate__Port> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Path :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Path() {}
		Path(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Path(const Path &master) : MgaObject(master) {}

		static Path Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Path Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Path CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Path> Instances() { return Udm::InstantiatedAttr<Path>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Path, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Path, Pred>(impl); }
		Path CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Path> Derived() { return Udm::DerivedAttr<Path>(impl); }
		template <class Pred> Udm::DerivedAttr<Path, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Path, Pred>(impl); }
		Udm::ArchetypeAttr<Path> Archetype() const { return Udm::ArchetypeAttr<Path>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::PathReference> referedbyPathReference() const { return Udm::AssocAttr< ::PICML::PathReference>(impl, meta_referedbyPathReference); }
		template <class Pred> Udm::AssocAttr< ::PICML::PathReference, Pred> referedbyPathReference_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::PathReference, Pred>(impl, meta_referedbyPathReference); }
		Udm::AClassAssocAttr< ::PICML::PathProperty, ::PICML::Property> dstPathProperty() const { return Udm::AClassAssocAttr< ::PICML::PathProperty, ::PICML::Property>(impl, meta_dstPathProperty, meta_dstPathProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::PathProperty, ::PICML::Property, Pred> dstPathProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::PathProperty, ::PICML::Property, Pred>(impl, meta_dstPathProperty, meta_dstPathProperty_rev); }
		Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_children() const { return Udm::ChildrenAttr< ::PICML::ComponentRef>(impl, meta_ComponentRef_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, meta_ComponentRef_children); }
		Udm::ChildrenAttr< ::PICML::DstEdge> DstEdge_children() const { return Udm::ChildrenAttr< ::PICML::DstEdge>(impl, meta_DstEdge_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DstEdge, Pred> DstEdge_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DstEdge, Pred>(impl, meta_DstEdge_children); }
		Udm::ChildrenAttr< ::PICML::SrcEdge> SrcEdge_children() const { return Udm::ChildrenAttr< ::PICML::SrcEdge>(impl, meta_SrcEdge_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SrcEdge, Pred> SrcEdge_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SrcEdge, Pred>(impl, meta_SrcEdge_children); }
		Udm::ChildrenAttr< ::PICML::EdgeProperty> EdgeProperty_children() const { return Udm::ChildrenAttr< ::PICML::EdgeProperty>(impl, meta_EdgeProperty_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::EdgeProperty, Pred> EdgeProperty_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::EdgeProperty, Pred>(impl, meta_EdgeProperty_children); }
		Udm::ChildrenAttr< ::PICML::Edge> Edge_children() const { return Udm::ChildrenAttr< ::PICML::Edge>(impl, meta_Edge_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Edge, Pred> Edge_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Edge, Pred>(impl, meta_Edge_children); }
		Udm::ChildrenAttr< ::PICML::Property> Property_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, meta_Property_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); }
		Udm::ChildrenAttr< ::PICML::GraphVertex> GraphVertex_children() const { return Udm::ChildrenAttr< ::PICML::GraphVertex>(impl, meta_GraphVertex_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::GraphVertex, Pred> GraphVertex_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::GraphVertex, Pred>(impl, meta_GraphVertex_children); }
		Udm::ChildrenAttr< ::PICML::ConnectedComponent> ConnectedComponent_kind_children() const { return Udm::ChildrenAttr< ::PICML::ConnectedComponent>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ConnectedComponent, Pred> ConnectedComponent_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ConnectedComponent, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::DstEdge> DstEdge_kind_children() const { return Udm::ChildrenAttr< ::PICML::DstEdge>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DstEdge, Pred> DstEdge_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DstEdge, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::GraphVertex> GraphVertex_kind_children() const { return Udm::ChildrenAttr< ::PICML::GraphVertex>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::GraphVertex, Pred> GraphVertex_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::GraphVertex, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::SrcEdge> SrcEdge_kind_children() const { return Udm::ChildrenAttr< ::PICML::SrcEdge>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SrcEdge, Pred> SrcEdge_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SrcEdge, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::EdgeProperty> EdgeProperty_kind_children() const { return Udm::ChildrenAttr< ::PICML::EdgeProperty>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::EdgeProperty, Pred> EdgeProperty_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::EdgeProperty, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Edge> Edge_kind_children() const { return Udm::ChildrenAttr< ::PICML::Edge>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Edge, Pred> Edge_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Edge, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::DisplayNode> DisplayNode_kind_children() const { return Udm::ChildrenAttr< ::PICML::DisplayNode>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DisplayNode, Pred> DisplayNode_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DisplayNode, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::CollocationGroupMember> CollocationGroupMember_kind_children() const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred> CollocationGroupMember_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Port> Port_kind_children() const { return Udm::ChildrenAttr< ::PICML::Port>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Port, Pred> Port_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Port, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Manageable> Manageable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Manageable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Manageable, Pred> Manageable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Manageable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentRef>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ProvidedRequestPort> ProvidedRequestPort_kind_children() const { return Udm::ChildrenAttr< ::PICML::ProvidedRequestPort>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred> ProvidedRequestPort_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::InEventPort> InEventPort_kind_children() const { return Udm::ChildrenAttr< ::PICML::InEventPort>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InEventPort, Pred> InEventPort_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InEventPort, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::OutEventPort> OutEventPort_kind_children() const { return Udm::ChildrenAttr< ::PICML::OutEventPort>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OutEventPort, Pred> OutEventPort_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OutEventPort, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RequiredRequestPort> RequiredRequestPort_kind_children() const { return Udm::ChildrenAttr< ::PICML::RequiredRequestPort>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred> RequiredRequestPort_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::Paths> Paths_parent() const { return Udm::ParentAttr< ::PICML::Paths>(impl, meta_Paths_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Path(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyPathReference;
		static ::Uml::AssociationRole meta_dstPathProperty;
		static ::Uml::AssociationRole meta_dstPathProperty_rev;
		static ::Uml::CompositionChildRole meta_ComponentRef_children;
		static ::Uml::CompositionChildRole meta_DstEdge_children;
		static ::Uml::CompositionChildRole meta_SrcEdge_children;
		static ::Uml::CompositionChildRole meta_EdgeProperty_children;
		static ::Uml::CompositionChildRole meta_Edge_children;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_GraphVertex_children;
		static ::Uml::CompositionParentRole meta_Paths_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Paths_parent {};
		typedef boost::mpl::pair< ::PICML::Paths, PR_Paths_parent > _PR_Paths_parent__Paths;
		typedef boost::mpl::vector< _PR_Paths_parent__Paths> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Paths> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ComponentRef_children {};
		class CR_DstEdge_children {};
		class CR_SrcEdge_children {};
		class CR_EdgeProperty_children {};
		class CR_Edge_children {};
		class CR_Property_children {};
		class CR_GraphVertex_children {};
		typedef boost::mpl::pair< ::PICML::ComponentRef, CR_ComponentRef_children > _CR_ComponentRef_children__ComponentRef;
		typedef boost::mpl::pair< ::PICML::DstEdge, CR_DstEdge_children > _CR_DstEdge_children__DstEdge;
		typedef boost::mpl::pair< ::PICML::SrcEdge, CR_SrcEdge_children > _CR_SrcEdge_children__SrcEdge;
		typedef boost::mpl::pair< ::PICML::EdgeProperty, CR_EdgeProperty_children > _CR_EdgeProperty_children__EdgeProperty;
		typedef boost::mpl::pair< ::PICML::Edge, CR_Edge_children > _CR_Edge_children__Edge;
		typedef boost::mpl::pair< ::PICML::Property, CR_Property_children > _CR_Property_children__Property;
		typedef boost::mpl::pair< ::PICML::GraphVertex, CR_GraphVertex_children > _CR_GraphVertex_children__GraphVertex;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_ComponentRef_children__ComponentRef, _CR_DstEdge_children__DstEdge, _CR_SrcEdge_children__SrcEdge, _CR_EdgeProperty_children__EdgeProperty, _CR_Edge_children__Edge, _CR_Property_children__Property, _CR_GraphVertex_children__GraphVertex> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ConnectedComponent, ::PICML::DstEdge, ::PICML::GraphVertex, ::PICML::SrcEdge, ::PICML::EdgeProperty, ::PICML::Edge, ::PICML::DisplayNode, ::PICML::Property, ::PICML::Port, ::PICML::ComponentRef, ::PICML::ProvidedRequestPort, ::PICML::InEventPort, ::PICML::OutEventPort, ::PICML::RequiredRequestPort> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyPathReference {};
		typedef boost::mpl::pair< ::PICML::PathReference, AR_referedbyPathReference > _AR_referedbyPathReference__PathReference;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyPathReference__PathReference> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstPathProperty {};
		typedef boost::mpl::pair< ::PICML::Property, boost::mpl::pair< ::PICML::PathProperty, AR_dstPathProperty > > _AR_dstPathProperty__PathProperty__Property;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstPathProperty__PathProperty__Property> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export DstEdge :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		DstEdge() {}
		DstEdge(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		DstEdge(const DstEdge &master) : MgaObject(master) {}

		static DstEdge Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static DstEdge Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		DstEdge CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<DstEdge> Instances() { return Udm::InstantiatedAttr<DstEdge>(impl); }
		template <class Pred> Udm::InstantiatedAttr<DstEdge, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<DstEdge, Pred>(impl); }
		DstEdge CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<DstEdge> Derived() { return Udm::DerivedAttr<DstEdge>(impl); }
		template <class Pred> Udm::DerivedAttr<DstEdge, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<DstEdge, Pred>(impl); }
		Udm::ArchetypeAttr<DstEdge> Archetype() const { return Udm::ArchetypeAttr<DstEdge>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ConnectedComponent> ConnectedComponent_parent() const { return Udm::ParentAttr< ::PICML::ConnectedComponent>(impl, meta_ConnectedComponent_parent); }
		Udm::ParentAttr< ::PICML::Path> Path_parent() const { return Udm::ParentAttr< ::PICML::Path>(impl, meta_Path_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::GraphVertex> srcDstEdge_end() const { return Udm::AssocEndAttr< ::PICML::GraphVertex>(impl, meta_srcDstEdge_end_); }
		Udm::AssocEndAttr< ::PICML::Edge> dstDstEdge_end() const { return Udm::AssocEndAttr< ::PICML::Edge>(impl, meta_dstDstEdge_end_); }
		void Accept(Visitor &v) { v.Visit_DstEdge(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ConnectedComponent_parent;
		static ::Uml::CompositionParentRole meta_Path_parent;
		static ::Uml::AssociationRole meta_srcDstEdge_end_;
		static ::Uml::AssociationRole meta_dstDstEdge_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ConnectedComponent_parent {};
		class PR_Path_parent {};
		typedef boost::mpl::pair< ::PICML::ConnectedComponent, PR_ConnectedComponent_parent > _PR_ConnectedComponent_parent__ConnectedComponent;
		typedef boost::mpl::pair< ::PICML::Path, PR_Path_parent > _PR_Path_parent__Path;
		typedef boost::mpl::vector< _PR_ConnectedComponent_parent__ConnectedComponent, _PR_Path_parent__Path> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ConnectedComponent, ::PICML::Path> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcDstEdge {};
		class ACE_dstDstEdge {};
		typedef boost::mpl::pair< ::PICML::GraphVertex, ACE_srcDstEdge > _ACE_srcDstEdge__GraphVertex;
		typedef boost::mpl::pair< ::PICML::Edge, ACE_dstDstEdge > _ACE_dstDstEdge__Edge;
		typedef boost::mpl::vector< _ACE_srcDstEdge__GraphVertex, _ACE_dstDstEdge__Edge> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export GraphVertex :  virtual  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		GraphVertex() {}
		GraphVertex(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		GraphVertex(const GraphVertex &master) : MgaObject(master) {}

		static GraphVertex Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static GraphVertex Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		GraphVertex CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<GraphVertex> Instances() { return Udm::InstantiatedAttr<GraphVertex>(impl); }
		template <class Pred> Udm::InstantiatedAttr<GraphVertex, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<GraphVertex, Pred>(impl); }
		GraphVertex CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<GraphVertex> Derived() { return Udm::DerivedAttr<GraphVertex>(impl); }
		template <class Pred> Udm::DerivedAttr<GraphVertex, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<GraphVertex, Pred>(impl); }
		Udm::ArchetypeAttr<GraphVertex> Archetype() const { return Udm::ArchetypeAttr<GraphVertex>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::SrcEdge, ::PICML::Edge> srcSrcEdge() const { return Udm::AClassPointerAttr< ::PICML::SrcEdge, ::PICML::Edge>(impl, meta_srcSrcEdge, meta_srcSrcEdge_rev); }
		Udm::AClassPointerAttr< ::PICML::DstEdge, ::PICML::Edge> dstDstEdge() const { return Udm::AClassPointerAttr< ::PICML::DstEdge, ::PICML::Edge>(impl, meta_dstDstEdge, meta_dstDstEdge_rev); }
		Udm::ParentAttr< ::PICML::Path> Path_parent() const { return Udm::ParentAttr< ::PICML::Path>(impl, meta_Path_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcSrcEdge;
		static ::Uml::AssociationRole meta_srcSrcEdge_rev;
		static ::Uml::AssociationRole meta_dstDstEdge;
		static ::Uml::AssociationRole meta_dstDstEdge_rev;
		static ::Uml::CompositionParentRole meta_Path_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Path_parent {};
		typedef boost::mpl::pair< ::PICML::Path, PR_Path_parent > _PR_Path_parent__Path;
		typedef boost::mpl::vector< _PR_Path_parent__Path> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Path> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcSrcEdge {};
		class AR_dstDstEdge {};
		typedef boost::mpl::pair< ::PICML::Edge, boost::mpl::pair< ::PICML::SrcEdge, AR_srcSrcEdge > > _AR_srcSrcEdge__SrcEdge__Edge;
		typedef boost::mpl::pair< ::PICML::Edge, boost::mpl::pair< ::PICML::DstEdge, AR_dstDstEdge > > _AR_dstDstEdge__DstEdge__Edge;
		typedef boost::mpl::vector< _AR_srcSrcEdge__SrcEdge__Edge, _AR_dstDstEdge__DstEdge__Edge> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ConnectedComponent :  public GraphVertex {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ConnectedComponent() {}
		ConnectedComponent(Udm::ObjectImpl *impl) : GraphVertex(impl), MgaObject(impl) {}
		ConnectedComponent(const ConnectedComponent &master) : GraphVertex(master), MgaObject(master) {}

		static ConnectedComponent Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ConnectedComponent Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ConnectedComponent CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ConnectedComponent> Instances() { return Udm::InstantiatedAttr<ConnectedComponent>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ConnectedComponent, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ConnectedComponent, Pred>(impl); }
		ConnectedComponent CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ConnectedComponent> Derived() { return Udm::DerivedAttr<ConnectedComponent>(impl); }
		template <class Pred> Udm::DerivedAttr<ConnectedComponent, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ConnectedComponent, Pred>(impl); }
		Udm::ArchetypeAttr<ConnectedComponent> Archetype() const { return Udm::ArchetypeAttr<ConnectedComponent>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::Port> Port_children() const { return Udm::ChildrenAttr< ::PICML::Port>(impl, meta_Port_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Port, Pred> Port_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Port, Pred>(impl, meta_Port_children); }
		Udm::ChildrenAttr< ::PICML::DstEdge> DstEdge_children() const { return Udm::ChildrenAttr< ::PICML::DstEdge>(impl, meta_DstEdge_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DstEdge, Pred> DstEdge_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DstEdge, Pred>(impl, meta_DstEdge_children); }
		Udm::ChildrenAttr< ::PICML::DstEdge> DstEdge_kind_children() const { return Udm::ChildrenAttr< ::PICML::DstEdge>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DstEdge, Pred> DstEdge_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DstEdge, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::GraphVertex> GraphVertex_kind_children() const { return Udm::ChildrenAttr< ::PICML::GraphVertex>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::GraphVertex, Pred> GraphVertex_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::GraphVertex, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::CommonPortAttrs> CommonPortAttrs_kind_children() const { return Udm::ChildrenAttr< ::PICML::CommonPortAttrs>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CommonPortAttrs, Pred> CommonPortAttrs_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CommonPortAttrs, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Taggable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Port> Port_kind_children() const { return Udm::ChildrenAttr< ::PICML::Port>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Port, Pred> Port_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Port, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ProvidedRequestPort> ProvidedRequestPort_kind_children() const { return Udm::ChildrenAttr< ::PICML::ProvidedRequestPort>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred> ProvidedRequestPort_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::InEventPort> InEventPort_kind_children() const { return Udm::ChildrenAttr< ::PICML::InEventPort>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InEventPort, Pred> InEventPort_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InEventPort, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::OutEventPort> OutEventPort_kind_children() const { return Udm::ChildrenAttr< ::PICML::OutEventPort>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OutEventPort, Pred> OutEventPort_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OutEventPort, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RequiredRequestPort> RequiredRequestPort_kind_children() const { return Udm::ChildrenAttr< ::PICML::RequiredRequestPort>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred> RequiredRequestPort_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ConnectedComponent(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Port_children;
		static ::Uml::CompositionChildRole meta_DstEdge_children;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Path> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Port_children {};
		class CR_DstEdge_children {};
		typedef boost::mpl::pair< ::PICML::Port, CR_Port_children > _CR_Port_children__Port;
		typedef boost::mpl::pair< ::PICML::DstEdge, CR_DstEdge_children > _CR_DstEdge_children__DstEdge;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Port_children__Port, _CR_DstEdge_children__DstEdge> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::DstEdge, ::PICML::ProvidedRequestPort, ::PICML::InEventPort, ::PICML::OutEventPort, ::PICML::RequiredRequestPort, ::PICML::Port> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export SrcEdge :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		SrcEdge() {}
		SrcEdge(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		SrcEdge(const SrcEdge &master) : MgaObject(master) {}

		static SrcEdge Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static SrcEdge Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		SrcEdge CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<SrcEdge> Instances() { return Udm::InstantiatedAttr<SrcEdge>(impl); }
		template <class Pred> Udm::InstantiatedAttr<SrcEdge, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<SrcEdge, Pred>(impl); }
		SrcEdge CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<SrcEdge> Derived() { return Udm::DerivedAttr<SrcEdge>(impl); }
		template <class Pred> Udm::DerivedAttr<SrcEdge, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<SrcEdge, Pred>(impl); }
		Udm::ArchetypeAttr<SrcEdge> Archetype() const { return Udm::ArchetypeAttr<SrcEdge>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::Path> Path_parent() const { return Udm::ParentAttr< ::PICML::Path>(impl, meta_Path_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::GraphVertex> dstSrcEdge_end() const { return Udm::AssocEndAttr< ::PICML::GraphVertex>(impl, meta_dstSrcEdge_end_); }
		Udm::AssocEndAttr< ::PICML::Edge> srcSrcEdge_end() const { return Udm::AssocEndAttr< ::PICML::Edge>(impl, meta_srcSrcEdge_end_); }
		void Accept(Visitor &v) { v.Visit_SrcEdge(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Path_parent;
		static ::Uml::AssociationRole meta_dstSrcEdge_end_;
		static ::Uml::AssociationRole meta_srcSrcEdge_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_Path_parent {};
		typedef boost::mpl::pair< ::PICML::Path, PR_Path_parent > _PR_Path_parent__Path;
		typedef boost::mpl::vector< _PR_Path_parent__Path> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Path> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstSrcEdge {};
		class ACE_srcSrcEdge {};
		typedef boost::mpl::pair< ::PICML::GraphVertex, ACE_dstSrcEdge > _ACE_dstSrcEdge__GraphVertex;
		typedef boost::mpl::pair< ::PICML::Edge, ACE_srcSrcEdge > _ACE_srcSrcEdge__Edge;
		typedef boost::mpl::vector< _ACE_dstSrcEdge__GraphVertex, _ACE_srcSrcEdge__Edge> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export EdgeProperty :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		EdgeProperty() {}
		EdgeProperty(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		EdgeProperty(const EdgeProperty &master) : MgaObject(master) {}

		static EdgeProperty Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static EdgeProperty Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		EdgeProperty CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<EdgeProperty> Instances() { return Udm::InstantiatedAttr<EdgeProperty>(impl); }
		template <class Pred> Udm::InstantiatedAttr<EdgeProperty, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<EdgeProperty, Pred>(impl); }
		EdgeProperty CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<EdgeProperty> Derived() { return Udm::DerivedAttr<EdgeProperty>(impl); }
		template <class Pred> Udm::DerivedAttr<EdgeProperty, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<EdgeProperty, Pred>(impl); }
		Udm::ArchetypeAttr<EdgeProperty> Archetype() const { return Udm::ArchetypeAttr<EdgeProperty>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::Path> Path_parent() const { return Udm::ParentAttr< ::PICML::Path>(impl, meta_Path_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::Edge> dstPropertyConnector_end() const { return Udm::AssocEndAttr< ::PICML::Edge>(impl, meta_dstPropertyConnector_end_); }
		Udm::AssocEndAttr< ::PICML::Property> srcPropertyConnector_end() const { return Udm::AssocEndAttr< ::PICML::Property>(impl, meta_srcPropertyConnector_end_); }
		void Accept(Visitor &v) { v.Visit_EdgeProperty(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Path_parent;
		static ::Uml::AssociationRole meta_dstPropertyConnector_end_;
		static ::Uml::AssociationRole meta_srcPropertyConnector_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_Path_parent {};
		typedef boost::mpl::pair< ::PICML::Path, PR_Path_parent > _PR_Path_parent__Path;
		typedef boost::mpl::vector< _PR_Path_parent__Path> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Path> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstPropertyConnector {};
		class ACE_srcPropertyConnector {};
		typedef boost::mpl::pair< ::PICML::Edge, ACE_dstPropertyConnector > _ACE_dstPropertyConnector__Edge;
		typedef boost::mpl::pair< ::PICML::Property, ACE_srcPropertyConnector > _ACE_srcPropertyConnector__Property;
		typedef boost::mpl::vector< _ACE_dstPropertyConnector__Edge, _ACE_srcPropertyConnector__Property> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Edge :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		Edge() {}
		Edge(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Edge(const Edge &master) : MgaObject(master) {}

		static Edge Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Edge Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Edge CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Edge> Instances() { return Udm::InstantiatedAttr<Edge>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Edge, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Edge, Pred>(impl); }
		Edge CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Edge> Derived() { return Udm::DerivedAttr<Edge>(impl); }
		template <class Pred> Udm::DerivedAttr<Edge, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Edge, Pred>(impl); }
		Udm::ArchetypeAttr<Edge> Archetype() const { return Udm::ArchetypeAttr<Edge>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::SrcEdge, ::PICML::GraphVertex> dstSrcEdge() const { return Udm::AClassPointerAttr< ::PICML::SrcEdge, ::PICML::GraphVertex>(impl, meta_dstSrcEdge, meta_dstSrcEdge_rev); }
		Udm::AClassPointerAttr< ::PICML::DstEdge, ::PICML::GraphVertex> srcDstEdge() const { return Udm::AClassPointerAttr< ::PICML::DstEdge, ::PICML::GraphVertex>(impl, meta_srcDstEdge, meta_srcDstEdge_rev); }
		Udm::AClassAssocAttr< ::PICML::EdgeProperty, ::PICML::Property> srcPropertyConnector() const { return Udm::AClassAssocAttr< ::PICML::EdgeProperty, ::PICML::Property>(impl, meta_srcPropertyConnector, meta_srcPropertyConnector_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::EdgeProperty, ::PICML::Property, Pred> srcPropertyConnector_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::EdgeProperty, ::PICML::Property, Pred>(impl, meta_srcPropertyConnector, meta_srcPropertyConnector_rev); }
		Udm::ParentAttr< ::PICML::Path> Path_parent() const { return Udm::ParentAttr< ::PICML::Path>(impl, meta_Path_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Edge(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstSrcEdge;
		static ::Uml::AssociationRole meta_dstSrcEdge_rev;
		static ::Uml::AssociationRole meta_srcDstEdge;
		static ::Uml::AssociationRole meta_srcDstEdge_rev;
		static ::Uml::AssociationRole meta_srcPropertyConnector;
		static ::Uml::AssociationRole meta_srcPropertyConnector_rev;
		static ::Uml::CompositionParentRole meta_Path_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Path_parent {};
		typedef boost::mpl::pair< ::PICML::Path, PR_Path_parent > _PR_Path_parent__Path;
		typedef boost::mpl::vector< _PR_Path_parent__Path> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Path> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstSrcEdge {};
		class AR_srcDstEdge {};
		class AR_srcPropertyConnector {};
		typedef boost::mpl::pair< ::PICML::GraphVertex, boost::mpl::pair< ::PICML::SrcEdge, AR_dstSrcEdge > > _AR_dstSrcEdge__SrcEdge__GraphVertex;
		typedef boost::mpl::pair< ::PICML::GraphVertex, boost::mpl::pair< ::PICML::DstEdge, AR_srcDstEdge > > _AR_srcDstEdge__DstEdge__GraphVertex;
		typedef boost::mpl::pair< ::PICML::Property, boost::mpl::pair< ::PICML::EdgeProperty, AR_srcPropertyConnector > > _AR_srcPropertyConnector__EdgeProperty__Property;
		typedef boost::mpl::vector< _AR_dstSrcEdge__SrcEdge__GraphVertex, _AR_srcDstEdge__DstEdge__GraphVertex> AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcPropertyConnector__EdgeProperty__Property> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export DisplayNode :  public GraphVertex {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		DisplayNode() {}
		DisplayNode(Udm::ObjectImpl *impl) : GraphVertex(impl), MgaObject(impl) {}
		DisplayNode(const DisplayNode &master) : GraphVertex(master), MgaObject(master) {}

		static DisplayNode Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static DisplayNode Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		DisplayNode CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<DisplayNode> Instances() { return Udm::InstantiatedAttr<DisplayNode>(impl); }
		template <class Pred> Udm::InstantiatedAttr<DisplayNode, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<DisplayNode, Pred>(impl); }
		DisplayNode CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<DisplayNode> Derived() { return Udm::DerivedAttr<DisplayNode>(impl); }
		template <class Pred> Udm::DerivedAttr<DisplayNode, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<DisplayNode, Pred>(impl); }
		Udm::ArchetypeAttr<DisplayNode> Archetype() const { return Udm::ArchetypeAttr<DisplayNode>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_DisplayNode(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Path> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Paths :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Paths() {}
		Paths(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Paths(const Paths &master) : MgaObject(master) {}

		static Paths Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Paths Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Paths CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Paths> Instances() { return Udm::InstantiatedAttr<Paths>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Paths, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Paths, Pred>(impl); }
		Paths CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Paths> Derived() { return Udm::DerivedAttr<Paths>(impl); }
		template <class Pred> Udm::DerivedAttr<Paths, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Paths, Pred>(impl); }
		Udm::ArchetypeAttr<Paths> Archetype() const { return Udm::ArchetypeAttr<Paths>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::PathProperty> PathProperty_children() const { return Udm::ChildrenAttr< ::PICML::PathProperty>(impl, meta_PathProperty_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PathProperty, Pred> PathProperty_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PathProperty, Pred>(impl, meta_PathProperty_children); }
		Udm::ChildrenAttr< ::PICML::Path> Path_children() const { return Udm::ChildrenAttr< ::PICML::Path>(impl, meta_Path_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Path, Pred> Path_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Path, Pred>(impl, meta_Path_children); }
		Udm::ChildrenAttr< ::PICML::Property> Property_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, meta_Property_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); }
		Udm::ChildrenAttr< ::PICML::Path> Path_kind_children() const { return Udm::ChildrenAttr< ::PICML::Path>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Path, Pred> Path_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Path, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PathProperty> PathProperty_kind_children() const { return Udm::ChildrenAttr< ::PICML::PathProperty>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PathProperty, Pred> PathProperty_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PathProperty, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::PathDiagrams> PathDiagrams_parent() const { return Udm::ParentAttr< ::PICML::PathDiagrams>(impl, meta_PathDiagrams_parent); }
		Udm::ParentAttr< ::PICML::PathDiagrams> parent() const { return Udm::ParentAttr< ::PICML::PathDiagrams>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Paths(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_PathProperty_children;
		static ::Uml::CompositionChildRole meta_Path_children;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionParentRole meta_PathDiagrams_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_PathDiagrams_parent {};
		typedef boost::mpl::pair< ::PICML::PathDiagrams, PR_PathDiagrams_parent > _PR_PathDiagrams_parent__PathDiagrams;
		typedef boost::mpl::vector< _PR_PathDiagrams_parent__PathDiagrams> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PathDiagrams> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_PathProperty_children {};
		class CR_Path_children {};
		class CR_Property_children {};
		typedef boost::mpl::pair< ::PICML::PathProperty, CR_PathProperty_children > _CR_PathProperty_children__PathProperty;
		typedef boost::mpl::pair< ::PICML::Path, CR_Path_children > _CR_Path_children__Path;
		typedef boost::mpl::pair< ::PICML::Property, CR_Property_children > _CR_Property_children__Property;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_PathProperty_children__PathProperty, _CR_Path_children__Path, _CR_Property_children__Property> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Path, ::PICML::PathProperty, ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PathProperty :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		PathProperty() {}
		PathProperty(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		PathProperty(const PathProperty &master) : MgaObject(master) {}

		static PathProperty Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PathProperty Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PathProperty CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PathProperty> Instances() { return Udm::InstantiatedAttr<PathProperty>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PathProperty, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PathProperty, Pred>(impl); }
		PathProperty CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PathProperty> Derived() { return Udm::DerivedAttr<PathProperty>(impl); }
		template <class Pred> Udm::DerivedAttr<PathProperty, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PathProperty, Pred>(impl); }
		Udm::ArchetypeAttr<PathProperty> Archetype() const { return Udm::ArchetypeAttr<PathProperty>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::Paths> Paths_parent() const { return Udm::ParentAttr< ::PICML::Paths>(impl, meta_Paths_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::Path> srcPathProperty_end() const { return Udm::AssocEndAttr< ::PICML::Path>(impl, meta_srcPathProperty_end_); }
		Udm::AssocEndAttr< ::PICML::Property> dstPathProperty_end() const { return Udm::AssocEndAttr< ::PICML::Property>(impl, meta_dstPathProperty_end_); }
		void Accept(Visitor &v) { v.Visit_PathProperty(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Paths_parent;
		static ::Uml::AssociationRole meta_srcPathProperty_end_;
		static ::Uml::AssociationRole meta_dstPathProperty_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_Paths_parent {};
		typedef boost::mpl::pair< ::PICML::Paths, PR_Paths_parent > _PR_Paths_parent__Paths;
		typedef boost::mpl::vector< _PR_Paths_parent__Paths> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Paths> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcPathProperty {};
		class ACE_dstPathProperty {};
		typedef boost::mpl::pair< ::PICML::Path, ACE_srcPathProperty > _ACE_srcPathProperty__Path;
		typedef boost::mpl::pair< ::PICML::Property, ACE_dstPathProperty > _ACE_dstPathProperty__Property;
		typedef boost::mpl::vector< _ACE_srcPathProperty__Path, _ACE_dstPathProperty__Property> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PathReference :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		PathReference() {}
		PathReference(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		PathReference(const PathReference &master) : MgaObject(master) {}

		static PathReference Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PathReference Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PathReference CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PathReference> Instances() { return Udm::InstantiatedAttr<PathReference>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PathReference, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PathReference, Pred>(impl); }
		PathReference CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PathReference> Derived() { return Udm::DerivedAttr<PathReference>(impl); }
		template <class Pred> Udm::DerivedAttr<PathReference, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PathReference, Pred>(impl); }
		Udm::ArchetypeAttr<PathReference> Archetype() const { return Udm::ArchetypeAttr<PathReference>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::CriticalPath, ::PICML::ComponentAssembly> srcCriticalPath() const { return Udm::AClassPointerAttr< ::PICML::CriticalPath, ::PICML::ComponentAssembly>(impl, meta_srcCriticalPath, meta_srcCriticalPath_rev); }
		Udm::PointerAttr< ::PICML::Path> ref() const { return Udm::PointerAttr< ::PICML::Path>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ComponentImplementationContainer>(impl, meta_ComponentImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_PathReference(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcCriticalPath;
		static ::Uml::AssociationRole meta_srcCriticalPath_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentImplementationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementationContainer, PR_ComponentImplementationContainer_parent > _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer;
		typedef boost::mpl::vector< _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::Path, AR_ref > _AR_ref__Path;
		typedef boost::mpl::vector< _AR_ref__Path> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcCriticalPath {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, boost::mpl::pair< ::PICML::CriticalPath, AR_srcCriticalPath > > _AR_srcCriticalPath__CriticalPath__ComponentAssembly;
		typedef boost::mpl::vector< _AR_srcCriticalPath__CriticalPath__ComponentAssembly> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export MetricConnection :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		MetricConnection() {}
		MetricConnection(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		MetricConnection(const MetricConnection &master) : MgaObject(master) {}

		static MetricConnection Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static MetricConnection Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		MetricConnection CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<MetricConnection> Instances() { return Udm::InstantiatedAttr<MetricConnection>(impl); }
		template <class Pred> Udm::InstantiatedAttr<MetricConnection, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<MetricConnection, Pred>(impl); }
		MetricConnection CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<MetricConnection> Derived() { return Udm::DerivedAttr<MetricConnection>(impl); }
		template <class Pred> Udm::DerivedAttr<MetricConnection, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<MetricConnection, Pred>(impl); }
		Udm::ArchetypeAttr<MetricConnection> Archetype() const { return Udm::ArchetypeAttr<MetricConnection>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::MetricsBase> dstMetricConnection_end() const { return Udm::AssocEndAttr< ::PICML::MetricsBase>(impl, meta_dstMetricConnection_end_); }
		Udm::AssocEndAttr< ::PICML::OperationRef> srcMetricConnection_end() const { return Udm::AssocEndAttr< ::PICML::OperationRef>(impl, meta_srcMetricConnection_end_); }
		void Accept(Visitor &v) { v.Visit_MetricConnection(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;
		static ::Uml::AssociationRole meta_dstMetricConnection_end_;
		static ::Uml::AssociationRole meta_srcMetricConnection_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstMetricConnection {};
		class ACE_srcMetricConnection {};
		typedef boost::mpl::pair< ::PICML::MetricsBase, ACE_dstMetricConnection > _ACE_dstMetricConnection__MetricsBase;
		typedef boost::mpl::pair< ::PICML::OperationRef, ACE_srcMetricConnection > _ACE_srcMetricConnection__OperationRef;
		typedef boost::mpl::vector< _ACE_dstMetricConnection__MetricsBase, _ACE_srcMetricConnection__OperationRef> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export DataAnalysisBase :  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		DataAnalysisBase() {}
		DataAnalysisBase(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		DataAnalysisBase(const DataAnalysisBase &master) : MgaObject(master) {}

		static DataAnalysisBase Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static DataAnalysisBase Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		DataAnalysisBase CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<DataAnalysisBase> Instances() { return Udm::InstantiatedAttr<DataAnalysisBase>(impl); }
		template <class Pred> Udm::InstantiatedAttr<DataAnalysisBase, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<DataAnalysisBase, Pred>(impl); }
		DataAnalysisBase CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<DataAnalysisBase> Derived() { return Udm::DerivedAttr<DataAnalysisBase>(impl); }
		template <class Pred> Udm::DerivedAttr<DataAnalysisBase, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<DataAnalysisBase, Pred>(impl); }
		Udm::ArchetypeAttr<DataAnalysisBase> Archetype() const { return Udm::ArchetypeAttr<DataAnalysisBase>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::MetricsBase> MetricsBase_parent() const { return Udm::ParentAttr< ::PICML::MetricsBase>(impl, meta_MetricsBase_parent); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_MetricsBase_parent;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_MetricsBase_parent {};
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::MetricsBase, PR_MetricsBase_parent > _PR_MetricsBase_parent__MetricsBase;
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_MetricsBase_parent__MetricsBase, _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis, ::PICML::MetricsBase> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Average :  public DataAnalysisBase {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		Average() {}
		Average(Udm::ObjectImpl *impl) : DataAnalysisBase(impl) {}
		Average(const Average &master) : DataAnalysisBase(master) {}

		static Average Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Average Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Average CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Average> Instances() { return Udm::InstantiatedAttr<Average>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Average, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Average, Pred>(impl); }
		Average CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Average> Derived() { return Udm::DerivedAttr<Average>(impl); }
		template <class Pred> Udm::DerivedAttr<Average, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Average, Pred>(impl); }
		Udm::ArchetypeAttr<Average> Archetype() const { return Udm::ArchetypeAttr<Average>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Average(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis, ::PICML::MetricsBase> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Minimum :  public DataAnalysisBase {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		Minimum() {}
		Minimum(Udm::ObjectImpl *impl) : DataAnalysisBase(impl) {}
		Minimum(const Minimum &master) : DataAnalysisBase(master) {}

		static Minimum Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Minimum Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Minimum CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Minimum> Instances() { return Udm::InstantiatedAttr<Minimum>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Minimum, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Minimum, Pred>(impl); }
		Minimum CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Minimum> Derived() { return Udm::DerivedAttr<Minimum>(impl); }
		template <class Pred> Udm::DerivedAttr<Minimum, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Minimum, Pred>(impl); }
		Udm::ArchetypeAttr<Minimum> Archetype() const { return Udm::ArchetypeAttr<Minimum>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Minimum(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis, ::PICML::MetricsBase> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Maximum :  public DataAnalysisBase {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		Maximum() {}
		Maximum(Udm::ObjectImpl *impl) : DataAnalysisBase(impl) {}
		Maximum(const Maximum &master) : DataAnalysisBase(master) {}

		static Maximum Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Maximum Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Maximum CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Maximum> Instances() { return Udm::InstantiatedAttr<Maximum>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Maximum, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Maximum, Pred>(impl); }
		Maximum CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Maximum> Derived() { return Udm::DerivedAttr<Maximum>(impl); }
		template <class Pred> Udm::DerivedAttr<Maximum, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Maximum, Pred>(impl); }
		Udm::ArchetypeAttr<Maximum> Archetype() const { return Udm::ArchetypeAttr<Maximum>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Maximum(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis, ::PICML::MetricsBase> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Jitter :  public DataAnalysisBase {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		Jitter() {}
		Jitter(Udm::ObjectImpl *impl) : DataAnalysisBase(impl) {}
		Jitter(const Jitter &master) : DataAnalysisBase(master) {}

		static Jitter Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Jitter Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Jitter CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Jitter> Instances() { return Udm::InstantiatedAttr<Jitter>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Jitter, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Jitter, Pred>(impl); }
		Jitter CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Jitter> Derived() { return Udm::DerivedAttr<Jitter>(impl); }
		template <class Pred> Udm::DerivedAttr<Jitter, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Jitter, Pred>(impl); }
		Udm::ArchetypeAttr<Jitter> Archetype() const { return Udm::ArchetypeAttr<Jitter>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Jitter(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis, ::PICML::MetricsBase> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export TimeProbe :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		TimeProbe() {}
		TimeProbe(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		TimeProbe(const TimeProbe &master) : MgaObject(master) {}

		static TimeProbe Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static TimeProbe Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		TimeProbe CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<TimeProbe> Instances() { return Udm::InstantiatedAttr<TimeProbe>(impl); }
		template <class Pred> Udm::InstantiatedAttr<TimeProbe, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<TimeProbe, Pred>(impl); }
		TimeProbe CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<TimeProbe> Derived() { return Udm::DerivedAttr<TimeProbe>(impl); }
		template <class Pred> Udm::DerivedAttr<TimeProbe, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<TimeProbe, Pred>(impl); }
		Udm::ArchetypeAttr<TimeProbe> Archetype() const { return Udm::ArchetypeAttr<TimeProbe>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::TimerEventSinkConn, ::PICML::EventRef> srcTimerEventSinkConn() const { return Udm::AClassPointerAttr< ::PICML::TimerEventSinkConn, ::PICML::EventRef>(impl, meta_srcTimerEventSinkConn, meta_srcTimerEventSinkConn_rev); }
		Udm::AClassPointerAttr< ::PICML::TimerConnection, ::PICML::OperationRef> srcTimerConnection() const { return Udm::AClassPointerAttr< ::PICML::TimerConnection, ::PICML::OperationRef>(impl, meta_srcTimerConnection, meta_srcTimerConnection_rev); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_TimeProbe(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcTimerEventSinkConn;
		static ::Uml::AssociationRole meta_srcTimerEventSinkConn_rev;
		static ::Uml::AssociationRole meta_srcTimerConnection;
		static ::Uml::AssociationRole meta_srcTimerConnection_rev;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcTimerEventSinkConn {};
		class AR_srcTimerConnection {};
		typedef boost::mpl::pair< ::PICML::EventRef, boost::mpl::pair< ::PICML::TimerEventSinkConn, AR_srcTimerEventSinkConn > > _AR_srcTimerEventSinkConn__TimerEventSinkConn__EventRef;
		typedef boost::mpl::pair< ::PICML::OperationRef, boost::mpl::pair< ::PICML::TimerConnection, AR_srcTimerConnection > > _AR_srcTimerConnection__TimerConnection__OperationRef;
		typedef boost::mpl::vector< _AR_srcTimerEventSinkConn__TimerEventSinkConn__EventRef, _AR_srcTimerConnection__TimerConnection__OperationRef> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export TimerConnection :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		TimerConnection() {}
		TimerConnection(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		TimerConnection(const TimerConnection &master) : MgaObject(master) {}

		static TimerConnection Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static TimerConnection Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		TimerConnection CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<TimerConnection> Instances() { return Udm::InstantiatedAttr<TimerConnection>(impl); }
		template <class Pred> Udm::InstantiatedAttr<TimerConnection, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<TimerConnection, Pred>(impl); }
		TimerConnection CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<TimerConnection> Derived() { return Udm::DerivedAttr<TimerConnection>(impl); }
		template <class Pred> Udm::DerivedAttr<TimerConnection, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<TimerConnection, Pred>(impl); }
		Udm::ArchetypeAttr<TimerConnection> Archetype() const { return Udm::ArchetypeAttr<TimerConnection>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::TimeProbe> dstTimerConnection_end() const { return Udm::AssocEndAttr< ::PICML::TimeProbe>(impl, meta_dstTimerConnection_end_); }
		Udm::AssocEndAttr< ::PICML::OperationRef> srcTimerConnection_end() const { return Udm::AssocEndAttr< ::PICML::OperationRef>(impl, meta_srcTimerConnection_end_); }
		void Accept(Visitor &v) { v.Visit_TimerConnection(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;
		static ::Uml::AssociationRole meta_dstTimerConnection_end_;
		static ::Uml::AssociationRole meta_srcTimerConnection_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstTimerConnection {};
		class ACE_srcTimerConnection {};
		typedef boost::mpl::pair< ::PICML::TimeProbe, ACE_dstTimerConnection > _ACE_dstTimerConnection__TimeProbe;
		typedef boost::mpl::pair< ::PICML::OperationRef, ACE_srcTimerConnection > _ACE_srcTimerConnection__OperationRef;
		typedef boost::mpl::vector< _ACE_dstTimerConnection__TimeProbe, _ACE_srcTimerConnection__OperationRef> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export BenchmarkAnalysis :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		BenchmarkAnalysis() {}
		BenchmarkAnalysis(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		BenchmarkAnalysis(const BenchmarkAnalysis &master) : MgaObject(master) {}

		static BenchmarkAnalysis Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static BenchmarkAnalysis Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		BenchmarkAnalysis CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<BenchmarkAnalysis> Instances() { return Udm::InstantiatedAttr<BenchmarkAnalysis>(impl); }
		template <class Pred> Udm::InstantiatedAttr<BenchmarkAnalysis, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<BenchmarkAnalysis, Pred>(impl); }
		BenchmarkAnalysis CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<BenchmarkAnalysis> Derived() { return Udm::DerivedAttr<BenchmarkAnalysis>(impl); }
		template <class Pred> Udm::DerivedAttr<BenchmarkAnalysis, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<BenchmarkAnalysis, Pred>(impl); }
		Udm::ArchetypeAttr<BenchmarkAnalysis> Archetype() const { return Udm::ArchetypeAttr<BenchmarkAnalysis>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::TimerConnection> TimerConnection_children() const { return Udm::ChildrenAttr< ::PICML::TimerConnection>(impl, meta_TimerConnection_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TimerConnection, Pred> TimerConnection_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TimerConnection, Pred>(impl, meta_TimerConnection_children); }
		Udm::ChildrenAttr< ::PICML::OperationBase> OperationBase_children() const { return Udm::ChildrenAttr< ::PICML::OperationBase>(impl, meta_OperationBase_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OperationBase, Pred> OperationBase_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OperationBase, Pred>(impl, meta_OperationBase_children); }
		Udm::ChildrenAttr< ::PICML::MetricConnection> MetricConnection_children() const { return Udm::ChildrenAttr< ::PICML::MetricConnection>(impl, meta_MetricConnection_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MetricConnection, Pred> MetricConnection_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MetricConnection, Pred>(impl, meta_MetricConnection_children); }
		Udm::ChildrenAttr< ::PICML::DataAnalysisBase> DataAnalysisBase_children() const { return Udm::ChildrenAttr< ::PICML::DataAnalysisBase>(impl, meta_DataAnalysisBase_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DataAnalysisBase, Pred> DataAnalysisBase_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DataAnalysisBase, Pred>(impl, meta_DataAnalysisBase_children); }
		Udm::ChildrenAttr< ::PICML::MetricsBase> MetricsBase_children() const { return Udm::ChildrenAttr< ::PICML::MetricsBase>(impl, meta_MetricsBase_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MetricsBase, Pred> MetricsBase_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MetricsBase, Pred>(impl, meta_MetricsBase_children); }
		Udm::ChildrenAttr< ::PICML::TimeProbe> TimeProbe_children() const { return Udm::ChildrenAttr< ::PICML::TimeProbe>(impl, meta_TimeProbe_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TimeProbe, Pred> TimeProbe_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TimeProbe, Pred>(impl, meta_TimeProbe_children); }
		Udm::ChildrenAttr< ::PICML::OperationRef> OperationRef_children() const { return Udm::ChildrenAttr< ::PICML::OperationRef>(impl, meta_OperationRef_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OperationRef, Pred> OperationRef_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OperationRef, Pred>(impl, meta_OperationRef_children); }
		Udm::ChildrenAttr< ::PICML::EventRef> EventRef_children() const { return Udm::ChildrenAttr< ::PICML::EventRef>(impl, meta_EventRef_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::EventRef, Pred> EventRef_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::EventRef, Pred>(impl, meta_EventRef_children); }
		Udm::ChildrenAttr< ::PICML::Event> Event_children() const { return Udm::ChildrenAttr< ::PICML::Event>(impl, meta_Event_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Event, Pred> Event_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Event, Pred>(impl, meta_Event_children); }
		Udm::ChildrenAttr< ::PICML::TimerEventSinkConn> TimerEventSinkConn_children() const { return Udm::ChildrenAttr< ::PICML::TimerEventSinkConn>(impl, meta_TimerEventSinkConn_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TimerEventSinkConn, Pred> TimerEventSinkConn_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TimerEventSinkConn, Pred>(impl, meta_TimerEventSinkConn_children); }
		Udm::ChildrenAttr< ::PICML::TaskSet> TaskSet_children() const { return Udm::ChildrenAttr< ::PICML::TaskSet>(impl, meta_TaskSet_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TaskSet, Pred> TaskSet_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TaskSet, Pred>(impl, meta_TaskSet_children); }
		Udm::ChildrenAttr< ::PICML::Task> Task_children() const { return Udm::ChildrenAttr< ::PICML::Task>(impl, meta_Task_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Task, Pred> Task_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Task, Pred>(impl, meta_Task_children); }
		Udm::ChildrenAttr< ::PICML::WorkloadCharacteristics> WorkloadCharacteristics_children() const { return Udm::ChildrenAttr< ::PICML::WorkloadCharacteristics>(impl, meta_WorkloadCharacteristics_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkloadCharacteristics, Pred> WorkloadCharacteristics_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkloadCharacteristics, Pred>(impl, meta_WorkloadCharacteristics_children); }
		Udm::ChildrenAttr< ::PICML::ComponentOperation> ComponentOperation_children() const { return Udm::ChildrenAttr< ::PICML::ComponentOperation>(impl, meta_ComponentOperation_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentOperation, Pred> ComponentOperation_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentOperation, Pred>(impl, meta_ComponentOperation_children); }
		Udm::ChildrenAttr< ::PICML::CompRef> CompRef_children() const { return Udm::ChildrenAttr< ::PICML::CompRef>(impl, meta_CompRef_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CompRef, Pred> CompRef_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CompRef, Pred>(impl, meta_CompRef_children); }
		Udm::ChildrenAttr< ::PICML::WorkLoadOperationConnection> WorkLoadOperationConnection_children() const { return Udm::ChildrenAttr< ::PICML::WorkLoadOperationConnection>(impl, meta_WorkLoadOperationConnection_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkLoadOperationConnection, Pred> WorkLoadOperationConnection_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkLoadOperationConnection, Pred>(impl, meta_WorkLoadOperationConnection_children); }
		Udm::ChildrenAttr< ::PICML::BenchmarkType> BenchmarkType_children() const { return Udm::ChildrenAttr< ::PICML::BenchmarkType>(impl, meta_BenchmarkType_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::BenchmarkType, Pred> BenchmarkType_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::BenchmarkType, Pred>(impl, meta_BenchmarkType_children); }
		Udm::ChildrenAttr< ::PICML::BenchmarkCharacteristics> BenchmarkCharacteristics_children() const { return Udm::ChildrenAttr< ::PICML::BenchmarkCharacteristics>(impl, meta_BenchmarkCharacteristics_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::BenchmarkCharacteristics, Pred> BenchmarkCharacteristics_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::BenchmarkCharacteristics, Pred>(impl, meta_BenchmarkCharacteristics_children); }
		Udm::ChildrenAttr< ::PICML::ExternalPortReferenceType> ExternalPortReferenceType_kind_children() const { return Udm::ChildrenAttr< ::PICML::ExternalPortReferenceType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ExternalPortReferenceType, Pred> ExternalPortReferenceType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ExternalPortReferenceType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MetricConnection> MetricConnection_kind_children() const { return Udm::ChildrenAttr< ::PICML::MetricConnection>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MetricConnection, Pred> MetricConnection_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MetricConnection, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::DataAnalysisBase> DataAnalysisBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::DataAnalysisBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DataAnalysisBase, Pred> DataAnalysisBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DataAnalysisBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Average> Average_kind_children() const { return Udm::ChildrenAttr< ::PICML::Average>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Average, Pred> Average_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Average, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Minimum> Minimum_kind_children() const { return Udm::ChildrenAttr< ::PICML::Minimum>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Minimum, Pred> Minimum_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Minimum, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Maximum> Maximum_kind_children() const { return Udm::ChildrenAttr< ::PICML::Maximum>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Maximum, Pred> Maximum_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Maximum, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Jitter> Jitter_kind_children() const { return Udm::ChildrenAttr< ::PICML::Jitter>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Jitter, Pred> Jitter_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Jitter, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::TimeProbe> TimeProbe_kind_children() const { return Udm::ChildrenAttr< ::PICML::TimeProbe>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TimeProbe, Pred> TimeProbe_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TimeProbe, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::TimerConnection> TimerConnection_kind_children() const { return Udm::ChildrenAttr< ::PICML::TimerConnection>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TimerConnection, Pred> TimerConnection_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TimerConnection, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Latency> Latency_kind_children() const { return Udm::ChildrenAttr< ::PICML::Latency>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Latency, Pred> Latency_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Latency, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Throughput> Throughput_kind_children() const { return Udm::ChildrenAttr< ::PICML::Throughput>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Throughput, Pred> Throughput_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Throughput, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MetricsBase> MetricsBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::MetricsBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MetricsBase, Pred> MetricsBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MetricsBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::OperationRef> OperationRef_kind_children() const { return Udm::ChildrenAttr< ::PICML::OperationRef>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OperationRef, Pred> OperationRef_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OperationRef, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::EventRef> EventRef_kind_children() const { return Udm::ChildrenAttr< ::PICML::EventRef>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::EventRef, Pred> EventRef_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::EventRef, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::TimerEventSinkConn> TimerEventSinkConn_kind_children() const { return Udm::ChildrenAttr< ::PICML::TimerEventSinkConn>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TimerEventSinkConn, Pred> TimerEventSinkConn_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TimerEventSinkConn, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::TaskSet> TaskSet_kind_children() const { return Udm::ChildrenAttr< ::PICML::TaskSet>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TaskSet, Pred> TaskSet_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TaskSet, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Task> Task_kind_children() const { return Udm::ChildrenAttr< ::PICML::Task>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Task, Pred> Task_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Task, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::WorkloadCharacteristics> WorkloadCharacteristics_kind_children() const { return Udm::ChildrenAttr< ::PICML::WorkloadCharacteristics>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkloadCharacteristics, Pred> WorkloadCharacteristics_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkloadCharacteristics, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentOperation> ComponentOperation_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentOperation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentOperation, Pred> ComponentOperation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentOperation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::CompRef> CompRef_kind_children() const { return Udm::ChildrenAttr< ::PICML::CompRef>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CompRef, Pred> CompRef_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CompRef, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::WorkLoadOperationConnection> WorkLoadOperationConnection_kind_children() const { return Udm::ChildrenAttr< ::PICML::WorkLoadOperationConnection>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkLoadOperationConnection, Pred> WorkLoadOperationConnection_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkLoadOperationConnection, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::BenchmarkType> BenchmarkType_kind_children() const { return Udm::ChildrenAttr< ::PICML::BenchmarkType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::BenchmarkType, Pred> BenchmarkType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::BenchmarkType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::TriggerBenchmarks> TriggerBenchmarks_kind_children() const { return Udm::ChildrenAttr< ::PICML::TriggerBenchmarks>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TriggerBenchmarks, Pred> TriggerBenchmarks_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TriggerBenchmarks, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::FixedIterationBenchmarks> FixedIterationBenchmarks_kind_children() const { return Udm::ChildrenAttr< ::PICML::FixedIterationBenchmarks>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::FixedIterationBenchmarks, Pred> FixedIterationBenchmarks_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::FixedIterationBenchmarks, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PeriodicBenchmarks> PeriodicBenchmarks_kind_children() const { return Udm::ChildrenAttr< ::PICML::PeriodicBenchmarks>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PeriodicBenchmarks, Pred> PeriodicBenchmarks_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PeriodicBenchmarks, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::BenchmarkCharacteristics> BenchmarkCharacteristics_kind_children() const { return Udm::ChildrenAttr< ::PICML::BenchmarkCharacteristics>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::BenchmarkCharacteristics, Pred> BenchmarkCharacteristics_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::BenchmarkCharacteristics, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Prefixable> Prefixable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Prefixable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Prefixable, Pred> Prefixable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Prefixable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Taggable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::OperationBase> OperationBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::OperationBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OperationBase, Pred> OperationBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OperationBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::HasExceptions> HasExceptions_kind_children() const { return Udm::ChildrenAttr< ::PICML::HasExceptions>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::HasExceptions, Pred> HasExceptions_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::HasExceptions, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::OnewayOperation> OnewayOperation_kind_children() const { return Udm::ChildrenAttr< ::PICML::OnewayOperation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OnewayOperation, Pred> OnewayOperation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OnewayOperation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::LookupOperation> LookupOperation_kind_children() const { return Udm::ChildrenAttr< ::PICML::LookupOperation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::LookupOperation, Pred> LookupOperation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::LookupOperation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::FactoryOperation> FactoryOperation_kind_children() const { return Udm::ChildrenAttr< ::PICML::FactoryOperation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred> FactoryOperation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::TwowayOperation> TwowayOperation_kind_children() const { return Udm::ChildrenAttr< ::PICML::TwowayOperation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TwowayOperation, Pred> TwowayOperation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TwowayOperation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Event> Event_kind_children() const { return Udm::ChildrenAttr< ::PICML::Event>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Event, Pred> Event_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Event, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::HasOperations> HasOperations_kind_children() const { return Udm::ChildrenAttr< ::PICML::HasOperations>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::HasOperations, Pred> HasOperations_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::HasOperations, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::SupportsInterfaces> SupportsInterfaces_kind_children() const { return Udm::ChildrenAttr< ::PICML::SupportsInterfaces>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SupportsInterfaces, Pred> SupportsInterfaces_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SupportsInterfaces, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ObjectByValue> ObjectByValue_kind_children() const { return Udm::ChildrenAttr< ::PICML::ObjectByValue>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ObjectByValue, Pred> ObjectByValue_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ObjectByValue, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Inheritable> Inheritable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Inheritable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Inheritable, Pred> Inheritable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Inheritable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MemberType> MemberType_kind_children() const { return Udm::ChildrenAttr< ::PICML::MemberType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MemberType, Pred> MemberType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MemberType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::NamedType> NamedType_kind_children() const { return Udm::ChildrenAttr< ::PICML::NamedType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::NamedType, Pred> NamedType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::NamedType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::ComponentAnalyses> ComponentAnalyses_parent() const { return Udm::ParentAttr< ::PICML::ComponentAnalyses>(impl, meta_ComponentAnalyses_parent); }
		Udm::ParentAttr< ::PICML::ComponentAnalyses> parent() const { return Udm::ParentAttr< ::PICML::ComponentAnalyses>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_BenchmarkAnalysis(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_TimerConnection_children;
		static ::Uml::CompositionChildRole meta_OperationBase_children;
		static ::Uml::CompositionChildRole meta_MetricConnection_children;
		static ::Uml::CompositionChildRole meta_DataAnalysisBase_children;
		static ::Uml::CompositionChildRole meta_MetricsBase_children;
		static ::Uml::CompositionChildRole meta_TimeProbe_children;
		static ::Uml::CompositionChildRole meta_OperationRef_children;
		static ::Uml::CompositionChildRole meta_EventRef_children;
		static ::Uml::CompositionChildRole meta_Event_children;
		static ::Uml::CompositionChildRole meta_TimerEventSinkConn_children;
		static ::Uml::CompositionChildRole meta_TaskSet_children;
		static ::Uml::CompositionChildRole meta_Task_children;
		static ::Uml::CompositionChildRole meta_WorkloadCharacteristics_children;
		static ::Uml::CompositionChildRole meta_ComponentOperation_children;
		static ::Uml::CompositionChildRole meta_CompRef_children;
		static ::Uml::CompositionChildRole meta_WorkLoadOperationConnection_children;
		static ::Uml::CompositionChildRole meta_BenchmarkType_children;
		static ::Uml::CompositionChildRole meta_BenchmarkCharacteristics_children;
		static ::Uml::CompositionParentRole meta_ComponentAnalyses_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAnalyses_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAnalyses, PR_ComponentAnalyses_parent > _PR_ComponentAnalyses_parent__ComponentAnalyses;
		typedef boost::mpl::vector< _PR_ComponentAnalyses_parent__ComponentAnalyses> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAnalyses> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_TimerConnection_children {};
		class CR_OperationBase_children {};
		class CR_MetricConnection_children {};
		class CR_DataAnalysisBase_children {};
		class CR_MetricsBase_children {};
		class CR_TimeProbe_children {};
		class CR_OperationRef_children {};
		class CR_EventRef_children {};
		class CR_Event_children {};
		class CR_TimerEventSinkConn_children {};
		class CR_TaskSet_children {};
		class CR_Task_children {};
		class CR_WorkloadCharacteristics_children {};
		class CR_ComponentOperation_children {};
		class CR_CompRef_children {};
		class CR_WorkLoadOperationConnection_children {};
		class CR_BenchmarkType_children {};
		class CR_BenchmarkCharacteristics_children {};
		typedef boost::mpl::pair< ::PICML::TimerConnection, CR_TimerConnection_children > _CR_TimerConnection_children__TimerConnection;
		typedef boost::mpl::pair< ::PICML::OperationBase, CR_OperationBase_children > _CR_OperationBase_children__OperationBase;
		typedef boost::mpl::pair< ::PICML::MetricConnection, CR_MetricConnection_children > _CR_MetricConnection_children__MetricConnection;
		typedef boost::mpl::pair< ::PICML::DataAnalysisBase, CR_DataAnalysisBase_children > _CR_DataAnalysisBase_children__DataAnalysisBase;
		typedef boost::mpl::pair< ::PICML::MetricsBase, CR_MetricsBase_children > _CR_MetricsBase_children__MetricsBase;
		typedef boost::mpl::pair< ::PICML::TimeProbe, CR_TimeProbe_children > _CR_TimeProbe_children__TimeProbe;
		typedef boost::mpl::pair< ::PICML::OperationRef, CR_OperationRef_children > _CR_OperationRef_children__OperationRef;
		typedef boost::mpl::pair< ::PICML::EventRef, CR_EventRef_children > _CR_EventRef_children__EventRef;
		typedef boost::mpl::pair< ::PICML::Event, CR_Event_children > _CR_Event_children__Event;
		typedef boost::mpl::pair< ::PICML::TimerEventSinkConn, CR_TimerEventSinkConn_children > _CR_TimerEventSinkConn_children__TimerEventSinkConn;
		typedef boost::mpl::pair< ::PICML::TaskSet, CR_TaskSet_children > _CR_TaskSet_children__TaskSet;
		typedef boost::mpl::pair< ::PICML::Task, CR_Task_children > _CR_Task_children__Task;
		typedef boost::mpl::pair< ::PICML::WorkloadCharacteristics, CR_WorkloadCharacteristics_children > _CR_WorkloadCharacteristics_children__WorkloadCharacteristics;
		typedef boost::mpl::pair< ::PICML::ComponentOperation, CR_ComponentOperation_children > _CR_ComponentOperation_children__ComponentOperation;
		typedef boost::mpl::pair< ::PICML::CompRef, CR_CompRef_children > _CR_CompRef_children__CompRef;
		typedef boost::mpl::pair< ::PICML::WorkLoadOperationConnection, CR_WorkLoadOperationConnection_children > _CR_WorkLoadOperationConnection_children__WorkLoadOperationConnection;
		typedef boost::mpl::pair< ::PICML::BenchmarkType, CR_BenchmarkType_children > _CR_BenchmarkType_children__BenchmarkType;
		typedef boost::mpl::pair< ::PICML::BenchmarkCharacteristics, CR_BenchmarkCharacteristics_children > _CR_BenchmarkCharacteristics_children__BenchmarkCharacteristics;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_TimerConnection_children__TimerConnection, _CR_OperationBase_children__OperationBase, _CR_MetricConnection_children__MetricConnection, _CR_DataAnalysisBase_children__DataAnalysisBase, _CR_MetricsBase_children__MetricsBase, _CR_TimeProbe_children__TimeProbe, _CR_OperationRef_children__OperationRef, _CR_EventRef_children__EventRef, _CR_Event_children__Event, _CR_TimerEventSinkConn_children__TimerEventSinkConn, _CR_TaskSet_children__TaskSet, _CR_Task_children__Task, _CR_WorkloadCharacteristics_children__WorkloadCharacteristics, _CR_ComponentOperation_children__ComponentOperation, _CR_CompRef_children__CompRef, _CR_WorkLoadOperationConnection_children__WorkLoadOperationConnection, _CR_BenchmarkType_children__BenchmarkType, _CR_BenchmarkCharacteristics_children__BenchmarkCharacteristics> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::MetricConnection, ::PICML::Average, ::PICML::Minimum, ::PICML::Maximum, ::PICML::Jitter, ::PICML::DataAnalysisBase, ::PICML::TimeProbe, ::PICML::TimerConnection, ::PICML::Latency, ::PICML::Throughput, ::PICML::MetricsBase, ::PICML::OperationRef, ::PICML::EventRef, ::PICML::TimerEventSinkConn, ::PICML::TaskSet, ::PICML::Task, ::PICML::WorkloadCharacteristics, ::PICML::ComponentOperation, ::PICML::CompRef, ::PICML::WorkLoadOperationConnection, ::PICML::TriggerBenchmarks, ::PICML::FixedIterationBenchmarks, ::PICML::PeriodicBenchmarks, ::PICML::BenchmarkType, ::PICML::BenchmarkCharacteristics, ::PICML::HasExceptions, ::PICML::OnewayOperation, ::PICML::LookupOperation, ::PICML::FactoryOperation, ::PICML::TwowayOperation, ::PICML::OperationBase, ::PICML::Event> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export MetricsBase :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		MetricsBase() {}
		MetricsBase(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		MetricsBase(const MetricsBase &master) : MgaObject(master) {}

		static MetricsBase Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static MetricsBase Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		MetricsBase CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<MetricsBase> Instances() { return Udm::InstantiatedAttr<MetricsBase>(impl); }
		template <class Pred> Udm::InstantiatedAttr<MetricsBase, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<MetricsBase, Pred>(impl); }
		MetricsBase CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<MetricsBase> Derived() { return Udm::DerivedAttr<MetricsBase>(impl); }
		template <class Pred> Udm::DerivedAttr<MetricsBase, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<MetricsBase, Pred>(impl); }
		Udm::ArchetypeAttr<MetricsBase> Archetype() const { return Udm::ArchetypeAttr<MetricsBase>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::IntegerAttr warmup() const { return Udm::IntegerAttr(impl, meta_warmup); }
		Udm::StringAttr fileName() const { return Udm::StringAttr(impl, meta_fileName); }
		Udm::IntegerAttr iterations() const { return Udm::IntegerAttr(impl, meta_iterations); }
		Udm::IntegerAttr priority() const { return Udm::IntegerAttr(impl, meta_priority); }
		Udm::IntegerAttr rate() const { return Udm::IntegerAttr(impl, meta_rate); }
		Udm::StringAttr resolution() const { return Udm::StringAttr(impl, meta_resolution); }
		Udm::AClassPointerAttr< ::PICML::MetricConnection, ::PICML::OperationRef> srcMetricConnection() const { return Udm::AClassPointerAttr< ::PICML::MetricConnection, ::PICML::OperationRef>(impl, meta_srcMetricConnection, meta_srcMetricConnection_rev); }
		Udm::AClassPointerAttr< ::PICML::WorkloadCharacteristics, ::PICML::TaskSet> dstWorkloadCharacteristics() const { return Udm::AClassPointerAttr< ::PICML::WorkloadCharacteristics, ::PICML::TaskSet>(impl, meta_dstWorkloadCharacteristics, meta_dstWorkloadCharacteristics_rev); }
		Udm::AClassPointerAttr< ::PICML::BenchmarkCharacteristics, ::PICML::BenchmarkType> srcBenchmarkCharacteristics() const { return Udm::AClassPointerAttr< ::PICML::BenchmarkCharacteristics, ::PICML::BenchmarkType>(impl, meta_srcBenchmarkCharacteristics, meta_srcBenchmarkCharacteristics_rev); }
		Udm::ChildrenAttr< ::PICML::DataAnalysisBase> DataAnalysisBase_children() const { return Udm::ChildrenAttr< ::PICML::DataAnalysisBase>(impl, meta_DataAnalysisBase_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DataAnalysisBase, Pred> DataAnalysisBase_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DataAnalysisBase, Pred>(impl, meta_DataAnalysisBase_children); }
		Udm::ChildrenAttr< ::PICML::DataAnalysisBase> DataAnalysisBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::DataAnalysisBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DataAnalysisBase, Pred> DataAnalysisBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DataAnalysisBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Average> Average_kind_children() const { return Udm::ChildrenAttr< ::PICML::Average>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Average, Pred> Average_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Average, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Minimum> Minimum_kind_children() const { return Udm::ChildrenAttr< ::PICML::Minimum>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Minimum, Pred> Minimum_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Minimum, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Maximum> Maximum_kind_children() const { return Udm::ChildrenAttr< ::PICML::Maximum>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Maximum, Pred> Maximum_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Maximum, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Jitter> Jitter_kind_children() const { return Udm::ChildrenAttr< ::PICML::Jitter>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Jitter, Pred> Jitter_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Jitter, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_warmup;
		static ::Uml::Attribute meta_fileName;
		static ::Uml::Attribute meta_iterations;
		static ::Uml::Attribute meta_priority;
		static ::Uml::Attribute meta_rate;
		static ::Uml::Attribute meta_resolution;
		static ::Uml::AssociationRole meta_srcMetricConnection;
		static ::Uml::AssociationRole meta_srcMetricConnection_rev;
		static ::Uml::AssociationRole meta_dstWorkloadCharacteristics;
		static ::Uml::AssociationRole meta_dstWorkloadCharacteristics_rev;
		static ::Uml::AssociationRole meta_srcBenchmarkCharacteristics;
		static ::Uml::AssociationRole meta_srcBenchmarkCharacteristics_rev;
		static ::Uml::CompositionChildRole meta_DataAnalysisBase_children;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_DataAnalysisBase_children {};
		typedef boost::mpl::pair< ::PICML::DataAnalysisBase, CR_DataAnalysisBase_children > _CR_DataAnalysisBase_children__DataAnalysisBase;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_DataAnalysisBase_children__DataAnalysisBase> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Average, ::PICML::Minimum, ::PICML::Maximum, ::PICML::Jitter, ::PICML::DataAnalysisBase> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcMetricConnection {};
		class AR_dstWorkloadCharacteristics {};
		class AR_srcBenchmarkCharacteristics {};
		typedef boost::mpl::pair< ::PICML::OperationRef, boost::mpl::pair< ::PICML::MetricConnection, AR_srcMetricConnection > > _AR_srcMetricConnection__MetricConnection__OperationRef;
		typedef boost::mpl::pair< ::PICML::TaskSet, boost::mpl::pair< ::PICML::WorkloadCharacteristics, AR_dstWorkloadCharacteristics > > _AR_dstWorkloadCharacteristics__WorkloadCharacteristics__TaskSet;
		typedef boost::mpl::pair< ::PICML::BenchmarkType, boost::mpl::pair< ::PICML::BenchmarkCharacteristics, AR_srcBenchmarkCharacteristics > > _AR_srcBenchmarkCharacteristics__BenchmarkCharacteristics__BenchmarkType;
		typedef boost::mpl::vector< _AR_srcMetricConnection__MetricConnection__OperationRef, _AR_dstWorkloadCharacteristics__WorkloadCharacteristics__TaskSet, _AR_srcBenchmarkCharacteristics__BenchmarkCharacteristics__BenchmarkType> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Latency :  public MetricsBase {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Latency() {}
		Latency(Udm::ObjectImpl *impl) : MetricsBase(impl) {}
		Latency(const Latency &master) : MetricsBase(master) {}

		static Latency Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Latency Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Latency CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Latency> Instances() { return Udm::InstantiatedAttr<Latency>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Latency, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Latency, Pred>(impl); }
		Latency CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Latency> Derived() { return Udm::DerivedAttr<Latency>(impl); }
		template <class Pred> Udm::DerivedAttr<Latency, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Latency, Pred>(impl); }
		Udm::ArchetypeAttr<Latency> Archetype() const { return Udm::ArchetypeAttr<Latency>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Latency(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Average, ::PICML::Minimum, ::PICML::Maximum, ::PICML::Jitter, ::PICML::DataAnalysisBase> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Throughput :  public MetricsBase {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Throughput() {}
		Throughput(Udm::ObjectImpl *impl) : MetricsBase(impl) {}
		Throughput(const Throughput &master) : MetricsBase(master) {}

		static Throughput Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Throughput Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Throughput CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Throughput> Instances() { return Udm::InstantiatedAttr<Throughput>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Throughput, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Throughput, Pred>(impl); }
		Throughput CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Throughput> Derived() { return Udm::DerivedAttr<Throughput>(impl); }
		template <class Pred> Udm::DerivedAttr<Throughput, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Throughput, Pred>(impl); }
		Udm::ArchetypeAttr<Throughput> Archetype() const { return Udm::ArchetypeAttr<Throughput>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Throughput(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Average, ::PICML::Minimum, ::PICML::Maximum, ::PICML::Jitter, ::PICML::DataAnalysisBase> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export OperationRef :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		OperationRef() {}
		OperationRef(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		OperationRef(const OperationRef &master) : MgaObject(master) {}

		static OperationRef Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static OperationRef Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		OperationRef CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<OperationRef> Instances() { return Udm::InstantiatedAttr<OperationRef>(impl); }
		template <class Pred> Udm::InstantiatedAttr<OperationRef, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<OperationRef, Pred>(impl); }
		OperationRef CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<OperationRef> Derived() { return Udm::DerivedAttr<OperationRef>(impl); }
		template <class Pred> Udm::DerivedAttr<OperationRef, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<OperationRef, Pred>(impl); }
		Udm::ArchetypeAttr<OperationRef> Archetype() const { return Udm::ArchetypeAttr<OperationRef>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::TimerConnection, ::PICML::TimeProbe> dstTimerConnection() const { return Udm::AClassPointerAttr< ::PICML::TimerConnection, ::PICML::TimeProbe>(impl, meta_dstTimerConnection, meta_dstTimerConnection_rev); }
		Udm::AClassPointerAttr< ::PICML::MetricConnection, ::PICML::MetricsBase> dstMetricConnection() const { return Udm::AClassPointerAttr< ::PICML::MetricConnection, ::PICML::MetricsBase>(impl, meta_dstMetricConnection, meta_dstMetricConnection_rev); }
		Udm::AClassPointerAttr< ::PICML::ComponentOperation, ::PICML::CompRef> dstComponentOperation() const { return Udm::AClassPointerAttr< ::PICML::ComponentOperation, ::PICML::CompRef>(impl, meta_dstComponentOperation, meta_dstComponentOperation_rev); }
		Udm::AClassPointerAttr< ::PICML::WorkLoadOperationConnection, ::PICML::Task> dstWorkLoadOperationConnection() const { return Udm::AClassPointerAttr< ::PICML::WorkLoadOperationConnection, ::PICML::Task>(impl, meta_dstWorkLoadOperationConnection, meta_dstWorkLoadOperationConnection_rev); }
		Udm::PointerAttr< ::PICML::OperationBase> ref() const { return Udm::PointerAttr< ::PICML::OperationBase>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_OperationRef(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstTimerConnection;
		static ::Uml::AssociationRole meta_dstTimerConnection_rev;
		static ::Uml::AssociationRole meta_dstMetricConnection;
		static ::Uml::AssociationRole meta_dstMetricConnection_rev;
		static ::Uml::AssociationRole meta_dstComponentOperation;
		static ::Uml::AssociationRole meta_dstComponentOperation_rev;
		static ::Uml::AssociationRole meta_dstWorkLoadOperationConnection;
		static ::Uml::AssociationRole meta_dstWorkLoadOperationConnection_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::OperationBase, AR_ref > _AR_ref__OperationBase;
		typedef boost::mpl::vector< _AR_ref__OperationBase> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstTimerConnection {};
		class AR_dstMetricConnection {};
		class AR_dstComponentOperation {};
		class AR_dstWorkLoadOperationConnection {};
		typedef boost::mpl::pair< ::PICML::TimeProbe, boost::mpl::pair< ::PICML::TimerConnection, AR_dstTimerConnection > > _AR_dstTimerConnection__TimerConnection__TimeProbe;
		typedef boost::mpl::pair< ::PICML::MetricsBase, boost::mpl::pair< ::PICML::MetricConnection, AR_dstMetricConnection > > _AR_dstMetricConnection__MetricConnection__MetricsBase;
		typedef boost::mpl::pair< ::PICML::CompRef, boost::mpl::pair< ::PICML::ComponentOperation, AR_dstComponentOperation > > _AR_dstComponentOperation__ComponentOperation__CompRef;
		typedef boost::mpl::pair< ::PICML::Task, boost::mpl::pair< ::PICML::WorkLoadOperationConnection, AR_dstWorkLoadOperationConnection > > _AR_dstWorkLoadOperationConnection__WorkLoadOperationConnection__Task;
		typedef boost::mpl::vector< _AR_dstTimerConnection__TimerConnection__TimeProbe, _AR_dstMetricConnection__MetricConnection__MetricsBase, _AR_dstComponentOperation__ComponentOperation__CompRef, _AR_dstWorkLoadOperationConnection__WorkLoadOperationConnection__Task> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export EventRef :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		EventRef() {}
		EventRef(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		EventRef(const EventRef &master) : MgaObject(master) {}

		static EventRef Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static EventRef Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		EventRef CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<EventRef> Instances() { return Udm::InstantiatedAttr<EventRef>(impl); }
		template <class Pred> Udm::InstantiatedAttr<EventRef, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<EventRef, Pred>(impl); }
		EventRef CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<EventRef> Derived() { return Udm::DerivedAttr<EventRef>(impl); }
		template <class Pred> Udm::DerivedAttr<EventRef, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<EventRef, Pred>(impl); }
		Udm::ArchetypeAttr<EventRef> Archetype() const { return Udm::ArchetypeAttr<EventRef>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::TimerEventSinkConn, ::PICML::TimeProbe> dstTimerEventSinkConn() const { return Udm::AClassAssocAttr< ::PICML::TimerEventSinkConn, ::PICML::TimeProbe>(impl, meta_dstTimerEventSinkConn, meta_dstTimerEventSinkConn_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::TimerEventSinkConn, ::PICML::TimeProbe, Pred> dstTimerEventSinkConn_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::TimerEventSinkConn, ::PICML::TimeProbe, Pred>(impl, meta_dstTimerEventSinkConn, meta_dstTimerEventSinkConn_rev); }
		Udm::PointerAttr< ::PICML::Event> ref() const { return Udm::PointerAttr< ::PICML::Event>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_EventRef(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstTimerEventSinkConn;
		static ::Uml::AssociationRole meta_dstTimerEventSinkConn_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::Event, AR_ref > _AR_ref__Event;
		typedef boost::mpl::vector< _AR_ref__Event> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstTimerEventSinkConn {};
		typedef boost::mpl::pair< ::PICML::TimeProbe, boost::mpl::pair< ::PICML::TimerEventSinkConn, AR_dstTimerEventSinkConn > > _AR_dstTimerEventSinkConn__TimerEventSinkConn__TimeProbe;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstTimerEventSinkConn__TimerEventSinkConn__TimeProbe> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export TimerEventSinkConn :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		TimerEventSinkConn() {}
		TimerEventSinkConn(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		TimerEventSinkConn(const TimerEventSinkConn &master) : MgaObject(master) {}

		static TimerEventSinkConn Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static TimerEventSinkConn Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		TimerEventSinkConn CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<TimerEventSinkConn> Instances() { return Udm::InstantiatedAttr<TimerEventSinkConn>(impl); }
		template <class Pred> Udm::InstantiatedAttr<TimerEventSinkConn, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<TimerEventSinkConn, Pred>(impl); }
		TimerEventSinkConn CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<TimerEventSinkConn> Derived() { return Udm::DerivedAttr<TimerEventSinkConn>(impl); }
		template <class Pred> Udm::DerivedAttr<TimerEventSinkConn, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<TimerEventSinkConn, Pred>(impl); }
		Udm::ArchetypeAttr<TimerEventSinkConn> Archetype() const { return Udm::ArchetypeAttr<TimerEventSinkConn>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::TimeProbe> dstTimerEventSinkConn_end() const { return Udm::AssocEndAttr< ::PICML::TimeProbe>(impl, meta_dstTimerEventSinkConn_end_); }
		Udm::AssocEndAttr< ::PICML::EventRef> srcTimerEventSinkConn_end() const { return Udm::AssocEndAttr< ::PICML::EventRef>(impl, meta_srcTimerEventSinkConn_end_); }
		void Accept(Visitor &v) { v.Visit_TimerEventSinkConn(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;
		static ::Uml::AssociationRole meta_dstTimerEventSinkConn_end_;
		static ::Uml::AssociationRole meta_srcTimerEventSinkConn_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstTimerEventSinkConn {};
		class ACE_srcTimerEventSinkConn {};
		typedef boost::mpl::pair< ::PICML::TimeProbe, ACE_dstTimerEventSinkConn > _ACE_dstTimerEventSinkConn__TimeProbe;
		typedef boost::mpl::pair< ::PICML::EventRef, ACE_srcTimerEventSinkConn > _ACE_srcTimerEventSinkConn__EventRef;
		typedef boost::mpl::vector< _ACE_dstTimerEventSinkConn__TimeProbe, _ACE_srcTimerEventSinkConn__EventRef> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export TaskSet :  public MgaObject {
	public:
		typedef ::Udm::SetMetaTag MetaKind;

		TaskSet() {}
		TaskSet(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		TaskSet(const TaskSet &master) : MgaObject(master) {}

		static TaskSet Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static TaskSet Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		TaskSet CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<TaskSet> Instances() { return Udm::InstantiatedAttr<TaskSet>(impl); }
		template <class Pred> Udm::InstantiatedAttr<TaskSet, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<TaskSet, Pred>(impl); }
		TaskSet CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<TaskSet> Derived() { return Udm::DerivedAttr<TaskSet>(impl); }
		template <class Pred> Udm::DerivedAttr<TaskSet, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<TaskSet, Pred>(impl); }
		Udm::ArchetypeAttr<TaskSet> Archetype() const { return Udm::ArchetypeAttr<TaskSet>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::IntegerAttr rate() const { return Udm::IntegerAttr(impl, meta_rate); }
		Udm::IntegerAttr priority() const { return Udm::IntegerAttr(impl, meta_priority); }
		Udm::AClassPointerAttr< ::PICML::WorkloadCharacteristics, ::PICML::MetricsBase> srcWorkloadCharacteristics() const { return Udm::AClassPointerAttr< ::PICML::WorkloadCharacteristics, ::PICML::MetricsBase>(impl, meta_srcWorkloadCharacteristics, meta_srcWorkloadCharacteristics_rev); }
		Udm::AssocAttr< ::PICML::Task> members() const { return Udm::AssocAttr< ::PICML::Task>(impl, meta_members); }
		template <class Pred> Udm::AssocAttr< ::PICML::Task, Pred> members_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::Task, Pred>(impl, meta_members); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_TaskSet(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_rate;
		static ::Uml::Attribute meta_priority;
		static ::Uml::AssociationRole meta_srcWorkloadCharacteristics;
		static ::Uml::AssociationRole meta_srcWorkloadCharacteristics_rev;
		static ::Uml::AssociationRole meta_members;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_members {};
		typedef boost::mpl::pair< ::PICML::Task, AR_members > _AR_members__Task;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_members__Task> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcWorkloadCharacteristics {};
		typedef boost::mpl::pair< ::PICML::MetricsBase, boost::mpl::pair< ::PICML::WorkloadCharacteristics, AR_srcWorkloadCharacteristics > > _AR_srcWorkloadCharacteristics__WorkloadCharacteristics__MetricsBase;
		typedef boost::mpl::vector< _AR_srcWorkloadCharacteristics__WorkloadCharacteristics__MetricsBase> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Task :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		Task() {}
		Task(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Task(const Task &master) : MgaObject(master) {}

		static Task Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Task Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Task CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Task> Instances() { return Udm::InstantiatedAttr<Task>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Task, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Task, Pred>(impl); }
		Task CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Task> Derived() { return Udm::DerivedAttr<Task>(impl); }
		template <class Pred> Udm::DerivedAttr<Task, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Task, Pred>(impl); }
		Udm::ArchetypeAttr<Task> Archetype() const { return Udm::ArchetypeAttr<Task>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::WorkLoadOperationConnection, ::PICML::OperationRef> srcWorkLoadOperationConnection() const { return Udm::AClassPointerAttr< ::PICML::WorkLoadOperationConnection, ::PICML::OperationRef>(impl, meta_srcWorkLoadOperationConnection, meta_srcWorkLoadOperationConnection_rev); }
		Udm::AssocAttr< ::PICML::TaskSet> setTaskSet() const { return Udm::AssocAttr< ::PICML::TaskSet>(impl, meta_setTaskSet); }
		template <class Pred> Udm::AssocAttr< ::PICML::TaskSet, Pred> setTaskSet_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::TaskSet, Pred>(impl, meta_setTaskSet); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Task(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcWorkLoadOperationConnection;
		static ::Uml::AssociationRole meta_srcWorkLoadOperationConnection_rev;
		static ::Uml::AssociationRole meta_setTaskSet;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_setTaskSet {};
		typedef boost::mpl::pair< ::PICML::TaskSet, AR_setTaskSet > _AR_setTaskSet__TaskSet;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_setTaskSet__TaskSet> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcWorkLoadOperationConnection {};
		typedef boost::mpl::pair< ::PICML::OperationRef, boost::mpl::pair< ::PICML::WorkLoadOperationConnection, AR_srcWorkLoadOperationConnection > > _AR_srcWorkLoadOperationConnection__WorkLoadOperationConnection__OperationRef;
		typedef boost::mpl::vector< _AR_srcWorkLoadOperationConnection__WorkLoadOperationConnection__OperationRef> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export WorkloadCharacteristics :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		WorkloadCharacteristics() {}
		WorkloadCharacteristics(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		WorkloadCharacteristics(const WorkloadCharacteristics &master) : MgaObject(master) {}

		static WorkloadCharacteristics Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static WorkloadCharacteristics Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		WorkloadCharacteristics CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<WorkloadCharacteristics> Instances() { return Udm::InstantiatedAttr<WorkloadCharacteristics>(impl); }
		template <class Pred> Udm::InstantiatedAttr<WorkloadCharacteristics, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<WorkloadCharacteristics, Pred>(impl); }
		WorkloadCharacteristics CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<WorkloadCharacteristics> Derived() { return Udm::DerivedAttr<WorkloadCharacteristics>(impl); }
		template <class Pred> Udm::DerivedAttr<WorkloadCharacteristics, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<WorkloadCharacteristics, Pred>(impl); }
		Udm::ArchetypeAttr<WorkloadCharacteristics> Archetype() const { return Udm::ArchetypeAttr<WorkloadCharacteristics>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::MetricsBase> srcWorkloadCharacteristics_end() const { return Udm::AssocEndAttr< ::PICML::MetricsBase>(impl, meta_srcWorkloadCharacteristics_end_); }
		Udm::AssocEndAttr< ::PICML::TaskSet> dstWorkloadCharacteristics_end() const { return Udm::AssocEndAttr< ::PICML::TaskSet>(impl, meta_dstWorkloadCharacteristics_end_); }
		void Accept(Visitor &v) { v.Visit_WorkloadCharacteristics(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;
		static ::Uml::AssociationRole meta_srcWorkloadCharacteristics_end_;
		static ::Uml::AssociationRole meta_dstWorkloadCharacteristics_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcWorkloadCharacteristics {};
		class ACE_dstWorkloadCharacteristics {};
		typedef boost::mpl::pair< ::PICML::MetricsBase, ACE_srcWorkloadCharacteristics > _ACE_srcWorkloadCharacteristics__MetricsBase;
		typedef boost::mpl::pair< ::PICML::TaskSet, ACE_dstWorkloadCharacteristics > _ACE_dstWorkloadCharacteristics__TaskSet;
		typedef boost::mpl::vector< _ACE_srcWorkloadCharacteristics__MetricsBase, _ACE_dstWorkloadCharacteristics__TaskSet> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentOperation :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		ComponentOperation() {}
		ComponentOperation(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ComponentOperation(const ComponentOperation &master) : MgaObject(master) {}

		static ComponentOperation Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentOperation Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentOperation CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentOperation> Instances() { return Udm::InstantiatedAttr<ComponentOperation>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentOperation, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentOperation, Pred>(impl); }
		ComponentOperation CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentOperation> Derived() { return Udm::DerivedAttr<ComponentOperation>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentOperation, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentOperation, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentOperation> Archetype() const { return Udm::ArchetypeAttr<ComponentOperation>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::OperationRef> srcComponentOperation_end() const { return Udm::AssocEndAttr< ::PICML::OperationRef>(impl, meta_srcComponentOperation_end_); }
		Udm::AssocEndAttr< ::PICML::CompRef> dstComponentOperation_end() const { return Udm::AssocEndAttr< ::PICML::CompRef>(impl, meta_dstComponentOperation_end_); }
		void Accept(Visitor &v) { v.Visit_ComponentOperation(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;
		static ::Uml::AssociationRole meta_srcComponentOperation_end_;
		static ::Uml::AssociationRole meta_dstComponentOperation_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcComponentOperation {};
		class ACE_dstComponentOperation {};
		typedef boost::mpl::pair< ::PICML::OperationRef, ACE_srcComponentOperation > _ACE_srcComponentOperation__OperationRef;
		typedef boost::mpl::pair< ::PICML::CompRef, ACE_dstComponentOperation > _ACE_dstComponentOperation__CompRef;
		typedef boost::mpl::vector< _ACE_srcComponentOperation__OperationRef, _ACE_dstComponentOperation__CompRef> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export CompRef :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		CompRef() {}
		CompRef(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		CompRef(const CompRef &master) : MgaObject(master) {}

		static CompRef Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static CompRef Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		CompRef CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<CompRef> Instances() { return Udm::InstantiatedAttr<CompRef>(impl); }
		template <class Pred> Udm::InstantiatedAttr<CompRef, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<CompRef, Pred>(impl); }
		CompRef CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<CompRef> Derived() { return Udm::DerivedAttr<CompRef>(impl); }
		template <class Pred> Udm::DerivedAttr<CompRef, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<CompRef, Pred>(impl); }
		Udm::ArchetypeAttr<CompRef> Archetype() const { return Udm::ArchetypeAttr<CompRef>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::ComponentOperation, ::PICML::OperationRef> srcComponentOperation() const { return Udm::AClassPointerAttr< ::PICML::ComponentOperation, ::PICML::OperationRef>(impl, meta_srcComponentOperation, meta_srcComponentOperation_rev); }
		Udm::PointerAttr< ::PICML::Component> ref() const { return Udm::PointerAttr< ::PICML::Component>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_CompRef(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcComponentOperation;
		static ::Uml::AssociationRole meta_srcComponentOperation_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::Component, AR_ref > _AR_ref__Component;
		typedef boost::mpl::vector< _AR_ref__Component> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcComponentOperation {};
		typedef boost::mpl::pair< ::PICML::OperationRef, boost::mpl::pair< ::PICML::ComponentOperation, AR_srcComponentOperation > > _AR_srcComponentOperation__ComponentOperation__OperationRef;
		typedef boost::mpl::vector< _AR_srcComponentOperation__ComponentOperation__OperationRef> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export WorkLoadOperationConnection :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		WorkLoadOperationConnection() {}
		WorkLoadOperationConnection(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		WorkLoadOperationConnection(const WorkLoadOperationConnection &master) : MgaObject(master) {}

		static WorkLoadOperationConnection Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static WorkLoadOperationConnection Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		WorkLoadOperationConnection CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<WorkLoadOperationConnection> Instances() { return Udm::InstantiatedAttr<WorkLoadOperationConnection>(impl); }
		template <class Pred> Udm::InstantiatedAttr<WorkLoadOperationConnection, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<WorkLoadOperationConnection, Pred>(impl); }
		WorkLoadOperationConnection CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<WorkLoadOperationConnection> Derived() { return Udm::DerivedAttr<WorkLoadOperationConnection>(impl); }
		template <class Pred> Udm::DerivedAttr<WorkLoadOperationConnection, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<WorkLoadOperationConnection, Pred>(impl); }
		Udm::ArchetypeAttr<WorkLoadOperationConnection> Archetype() const { return Udm::ArchetypeAttr<WorkLoadOperationConnection>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::OperationRef> srcWorkLoadOperationConnection_end() const { return Udm::AssocEndAttr< ::PICML::OperationRef>(impl, meta_srcWorkLoadOperationConnection_end_); }
		Udm::AssocEndAttr< ::PICML::Task> dstWorkLoadOperationConnection_end() const { return Udm::AssocEndAttr< ::PICML::Task>(impl, meta_dstWorkLoadOperationConnection_end_); }
		void Accept(Visitor &v) { v.Visit_WorkLoadOperationConnection(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;
		static ::Uml::AssociationRole meta_srcWorkLoadOperationConnection_end_;
		static ::Uml::AssociationRole meta_dstWorkLoadOperationConnection_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcWorkLoadOperationConnection {};
		class ACE_dstWorkLoadOperationConnection {};
		typedef boost::mpl::pair< ::PICML::OperationRef, ACE_srcWorkLoadOperationConnection > _ACE_srcWorkLoadOperationConnection__OperationRef;
		typedef boost::mpl::pair< ::PICML::Task, ACE_dstWorkLoadOperationConnection > _ACE_dstWorkLoadOperationConnection__Task;
		typedef boost::mpl::vector< _ACE_srcWorkLoadOperationConnection__OperationRef, _ACE_dstWorkLoadOperationConnection__Task> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export BenchmarkType :  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		BenchmarkType() {}
		BenchmarkType(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		BenchmarkType(const BenchmarkType &master) : MgaObject(master) {}

		static BenchmarkType Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static BenchmarkType Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		BenchmarkType CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<BenchmarkType> Instances() { return Udm::InstantiatedAttr<BenchmarkType>(impl); }
		template <class Pred> Udm::InstantiatedAttr<BenchmarkType, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<BenchmarkType, Pred>(impl); }
		BenchmarkType CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<BenchmarkType> Derived() { return Udm::DerivedAttr<BenchmarkType>(impl); }
		template <class Pred> Udm::DerivedAttr<BenchmarkType, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<BenchmarkType, Pred>(impl); }
		Udm::ArchetypeAttr<BenchmarkType> Archetype() const { return Udm::ArchetypeAttr<BenchmarkType>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::BenchmarkCharacteristics, ::PICML::MetricsBase> dstBenchmarkCharacteristics() const { return Udm::AClassPointerAttr< ::PICML::BenchmarkCharacteristics, ::PICML::MetricsBase>(impl, meta_dstBenchmarkCharacteristics, meta_dstBenchmarkCharacteristics_rev); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstBenchmarkCharacteristics;
		static ::Uml::AssociationRole meta_dstBenchmarkCharacteristics_rev;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstBenchmarkCharacteristics {};
		typedef boost::mpl::pair< ::PICML::MetricsBase, boost::mpl::pair< ::PICML::BenchmarkCharacteristics, AR_dstBenchmarkCharacteristics > > _AR_dstBenchmarkCharacteristics__BenchmarkCharacteristics__MetricsBase;
		typedef boost::mpl::vector< _AR_dstBenchmarkCharacteristics__BenchmarkCharacteristics__MetricsBase> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export TriggerBenchmarks :  public BenchmarkType {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		TriggerBenchmarks() {}
		TriggerBenchmarks(Udm::ObjectImpl *impl) : BenchmarkType(impl) {}
		TriggerBenchmarks(const TriggerBenchmarks &master) : BenchmarkType(master) {}

		static TriggerBenchmarks Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static TriggerBenchmarks Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		TriggerBenchmarks CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<TriggerBenchmarks> Instances() { return Udm::InstantiatedAttr<TriggerBenchmarks>(impl); }
		template <class Pred> Udm::InstantiatedAttr<TriggerBenchmarks, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<TriggerBenchmarks, Pred>(impl); }
		TriggerBenchmarks CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<TriggerBenchmarks> Derived() { return Udm::DerivedAttr<TriggerBenchmarks>(impl); }
		template <class Pred> Udm::DerivedAttr<TriggerBenchmarks, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<TriggerBenchmarks, Pred>(impl); }
		Udm::ArchetypeAttr<TriggerBenchmarks> Archetype() const { return Udm::ArchetypeAttr<TriggerBenchmarks>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_TriggerBenchmarks(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export FixedIterationBenchmarks :  public BenchmarkType {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		FixedIterationBenchmarks() {}
		FixedIterationBenchmarks(Udm::ObjectImpl *impl) : BenchmarkType(impl) {}
		FixedIterationBenchmarks(const FixedIterationBenchmarks &master) : BenchmarkType(master) {}

		static FixedIterationBenchmarks Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static FixedIterationBenchmarks Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		FixedIterationBenchmarks CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<FixedIterationBenchmarks> Instances() { return Udm::InstantiatedAttr<FixedIterationBenchmarks>(impl); }
		template <class Pred> Udm::InstantiatedAttr<FixedIterationBenchmarks, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<FixedIterationBenchmarks, Pred>(impl); }
		FixedIterationBenchmarks CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<FixedIterationBenchmarks> Derived() { return Udm::DerivedAttr<FixedIterationBenchmarks>(impl); }
		template <class Pred> Udm::DerivedAttr<FixedIterationBenchmarks, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<FixedIterationBenchmarks, Pred>(impl); }
		Udm::ArchetypeAttr<FixedIterationBenchmarks> Archetype() const { return Udm::ArchetypeAttr<FixedIterationBenchmarks>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::IntegerAttr benchmarkIterations() const { return Udm::IntegerAttr(impl, meta_benchmarkIterations); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_FixedIterationBenchmarks(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_benchmarkIterations;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PeriodicBenchmarks :  public BenchmarkType {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		PeriodicBenchmarks() {}
		PeriodicBenchmarks(Udm::ObjectImpl *impl) : BenchmarkType(impl) {}
		PeriodicBenchmarks(const PeriodicBenchmarks &master) : BenchmarkType(master) {}

		static PeriodicBenchmarks Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PeriodicBenchmarks Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PeriodicBenchmarks CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PeriodicBenchmarks> Instances() { return Udm::InstantiatedAttr<PeriodicBenchmarks>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PeriodicBenchmarks, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PeriodicBenchmarks, Pred>(impl); }
		PeriodicBenchmarks CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PeriodicBenchmarks> Derived() { return Udm::DerivedAttr<PeriodicBenchmarks>(impl); }
		template <class Pred> Udm::DerivedAttr<PeriodicBenchmarks, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PeriodicBenchmarks, Pred>(impl); }
		Udm::ArchetypeAttr<PeriodicBenchmarks> Archetype() const { return Udm::ArchetypeAttr<PeriodicBenchmarks>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::IntegerAttr timeperiod() const { return Udm::IntegerAttr(impl, meta_timeperiod); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_PeriodicBenchmarks(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_timeperiod;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export BenchmarkCharacteristics :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		BenchmarkCharacteristics() {}
		BenchmarkCharacteristics(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		BenchmarkCharacteristics(const BenchmarkCharacteristics &master) : MgaObject(master) {}

		static BenchmarkCharacteristics Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static BenchmarkCharacteristics Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		BenchmarkCharacteristics CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<BenchmarkCharacteristics> Instances() { return Udm::InstantiatedAttr<BenchmarkCharacteristics>(impl); }
		template <class Pred> Udm::InstantiatedAttr<BenchmarkCharacteristics, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<BenchmarkCharacteristics, Pred>(impl); }
		BenchmarkCharacteristics CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<BenchmarkCharacteristics> Derived() { return Udm::DerivedAttr<BenchmarkCharacteristics>(impl); }
		template <class Pred> Udm::DerivedAttr<BenchmarkCharacteristics, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<BenchmarkCharacteristics, Pred>(impl); }
		Udm::ArchetypeAttr<BenchmarkCharacteristics> Archetype() const { return Udm::ArchetypeAttr<BenchmarkCharacteristics>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::MetricsBase> dstBenchmarkCharacteristics_end() const { return Udm::AssocEndAttr< ::PICML::MetricsBase>(impl, meta_dstBenchmarkCharacteristics_end_); }
		Udm::AssocEndAttr< ::PICML::BenchmarkType> srcBenchmarkCharacteristics_end() const { return Udm::AssocEndAttr< ::PICML::BenchmarkType>(impl, meta_srcBenchmarkCharacteristics_end_); }
		void Accept(Visitor &v) { v.Visit_BenchmarkCharacteristics(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;
		static ::Uml::AssociationRole meta_dstBenchmarkCharacteristics_end_;
		static ::Uml::AssociationRole meta_srcBenchmarkCharacteristics_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstBenchmarkCharacteristics {};
		class ACE_srcBenchmarkCharacteristics {};
		typedef boost::mpl::pair< ::PICML::MetricsBase, ACE_dstBenchmarkCharacteristics > _ACE_dstBenchmarkCharacteristics__MetricsBase;
		typedef boost::mpl::pair< ::PICML::BenchmarkType, ACE_srcBenchmarkCharacteristics > _ACE_srcBenchmarkCharacteristics__BenchmarkType;
		typedef boost::mpl::vector< _ACE_dstBenchmarkCharacteristics__MetricsBase, _ACE_srcBenchmarkCharacteristics__BenchmarkType> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export NodeReference :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		NodeReference() {}
		NodeReference(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		NodeReference(const NodeReference &master) : MgaObject(master) {}

		static NodeReference Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static NodeReference Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		NodeReference CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<NodeReference> Instances() { return Udm::InstantiatedAttr<NodeReference>(impl); }
		template <class Pred> Udm::InstantiatedAttr<NodeReference, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<NodeReference, Pred>(impl); }
		NodeReference CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<NodeReference> Derived() { return Udm::DerivedAttr<NodeReference>(impl); }
		template <class Pred> Udm::DerivedAttr<NodeReference, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<NodeReference, Pred>(impl); }
		Udm::ArchetypeAttr<NodeReference> Archetype() const { return Udm::ArchetypeAttr<NodeReference>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::InstanceMapping, ::PICML::CollocationGroup> srcInstanceMapping() const { return Udm::AClassAssocAttr< ::PICML::InstanceMapping, ::PICML::CollocationGroup>(impl, meta_srcInstanceMapping, meta_srcInstanceMapping_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::InstanceMapping, ::PICML::CollocationGroup, Pred> srcInstanceMapping_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::InstanceMapping, ::PICML::CollocationGroup, Pred>(impl, meta_srcInstanceMapping, meta_srcInstanceMapping_rev); }
		Udm::PointerAttr< ::PICML::Node> ref() const { return Udm::PointerAttr< ::PICML::Node>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::DeploymentPlan> DeploymentPlan_parent() const { return Udm::ParentAttr< ::PICML::DeploymentPlan>(impl, meta_DeploymentPlan_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_NodeReference(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcInstanceMapping;
		static ::Uml::AssociationRole meta_srcInstanceMapping_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_DeploymentPlan_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_DeploymentPlan_parent {};
		typedef boost::mpl::pair< ::PICML::DeploymentPlan, PR_DeploymentPlan_parent > _PR_DeploymentPlan_parent__DeploymentPlan;
		typedef boost::mpl::vector< _PR_DeploymentPlan_parent__DeploymentPlan> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::DeploymentPlan> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::Node, AR_ref > _AR_ref__Node;
		typedef boost::mpl::vector< _AR_ref__Node> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcInstanceMapping {};
		typedef boost::mpl::pair< ::PICML::CollocationGroup, boost::mpl::pair< ::PICML::InstanceMapping, AR_srcInstanceMapping > > _AR_srcInstanceMapping__InstanceMapping__CollocationGroup;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcInstanceMapping__InstanceMapping__CollocationGroup> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Interconnect :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Interconnect() {}
		Interconnect(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Interconnect(const Interconnect &master) : MgaObject(master) {}

		static Interconnect Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Interconnect Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Interconnect CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Interconnect> Instances() { return Udm::InstantiatedAttr<Interconnect>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Interconnect, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Interconnect, Pred>(impl); }
		Interconnect CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Interconnect> Derived() { return Udm::DerivedAttr<Interconnect>(impl); }
		template <class Pred> Udm::DerivedAttr<Interconnect, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Interconnect, Pred>(impl); }
		Udm::ArchetypeAttr<Interconnect> Archetype() const { return Udm::ArchetypeAttr<Interconnect>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr label() const { return Udm::StringAttr(impl, meta_label); }
		Udm::AClassAssocAttr< ::PICML::InterconnectConnection, ::PICML::Node> srcInterconnectConnection() const { return Udm::AClassAssocAttr< ::PICML::InterconnectConnection, ::PICML::Node>(impl, meta_srcInterconnectConnection, meta_srcInterconnectConnection_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::InterconnectConnection, ::PICML::Node, Pred> srcInterconnectConnection_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::InterconnectConnection, ::PICML::Node, Pred>(impl, meta_srcInterconnectConnection, meta_srcInterconnectConnection_rev); }
		Udm::AClassAssocAttr< ::PICML::BridgeConnection, ::PICML::Bridge> dstBridgeConnection() const { return Udm::AClassAssocAttr< ::PICML::BridgeConnection, ::PICML::Bridge>(impl, meta_dstBridgeConnection, meta_dstBridgeConnection_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::BridgeConnection, ::PICML::Bridge, Pred> dstBridgeConnection_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::BridgeConnection, ::PICML::Bridge, Pred>(impl, meta_dstBridgeConnection, meta_dstBridgeConnection_rev); }
		Udm::ChildrenAttr< ::PICML::Resource> Resource_children() const { return Udm::ChildrenAttr< ::PICML::Resource>(impl, meta_Resource_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Resource, Pred> Resource_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Resource, Pred>(impl, meta_Resource_children); }
		Udm::ChildrenAttr< ::PICML::Resource> Resource_kind_children() const { return Udm::ChildrenAttr< ::PICML::Resource>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Resource, Pred> Resource_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Resource, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RequirementSatisfier> RequirementSatisfier_kind_children() const { return Udm::ChildrenAttr< ::PICML::RequirementSatisfier>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred> RequirementSatisfier_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::Domain> Domain_parent() const { return Udm::ParentAttr< ::PICML::Domain>(impl, meta_Domain_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Interconnect(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_label;
		static ::Uml::AssociationRole meta_srcInterconnectConnection;
		static ::Uml::AssociationRole meta_srcInterconnectConnection_rev;
		static ::Uml::AssociationRole meta_dstBridgeConnection;
		static ::Uml::AssociationRole meta_dstBridgeConnection_rev;
		static ::Uml::CompositionChildRole meta_Resource_children;
		static ::Uml::CompositionParentRole meta_Domain_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Domain_parent {};
		typedef boost::mpl::pair< ::PICML::Domain, PR_Domain_parent > _PR_Domain_parent__Domain;
		typedef boost::mpl::vector< _PR_Domain_parent__Domain> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Domain> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Resource_children {};
		typedef boost::mpl::pair< ::PICML::Resource, CR_Resource_children > _CR_Resource_children__Resource;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Resource_children__Resource> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Resource> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcInterconnectConnection {};
		class AR_dstBridgeConnection {};
		typedef boost::mpl::pair< ::PICML::Node, boost::mpl::pair< ::PICML::InterconnectConnection, AR_srcInterconnectConnection > > _AR_srcInterconnectConnection__InterconnectConnection__Node;
		typedef boost::mpl::pair< ::PICML::Bridge, boost::mpl::pair< ::PICML::BridgeConnection, AR_dstBridgeConnection > > _AR_dstBridgeConnection__BridgeConnection__Bridge;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcInterconnectConnection__InterconnectConnection__Node, _AR_dstBridgeConnection__BridgeConnection__Bridge> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Node :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Node() {}
		Node(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Node(const Node &master) : MgaObject(master) {}

		static Node Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Node Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Node CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Node> Instances() { return Udm::InstantiatedAttr<Node>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Node, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Node, Pred>(impl); }
		Node CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Node> Derived() { return Udm::DerivedAttr<Node>(impl); }
		template <class Pred> Udm::DerivedAttr<Node, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Node, Pred>(impl); }
		Udm::ArchetypeAttr<Node> Archetype() const { return Udm::ArchetypeAttr<Node>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr operatingSystem() const { return Udm::StringAttr(impl, meta_operatingSystem); }
		Udm::StringAttr label() const { return Udm::StringAttr(impl, meta_label); }
		Udm::StringAttr architecture() const { return Udm::StringAttr(impl, meta_architecture); }
		Udm::AssocAttr< ::PICML::NodeReference> referedbyNodeReference() const { return Udm::AssocAttr< ::PICML::NodeReference>(impl, meta_referedbyNodeReference); }
		template <class Pred> Udm::AssocAttr< ::PICML::NodeReference, Pred> referedbyNodeReference_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::NodeReference, Pred>(impl, meta_referedbyNodeReference); }
		Udm::AClassAssocAttr< ::PICML::InterconnectConnection, ::PICML::Interconnect> dstInterconnectConnection() const { return Udm::AClassAssocAttr< ::PICML::InterconnectConnection, ::PICML::Interconnect>(impl, meta_dstInterconnectConnection, meta_dstInterconnectConnection_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::InterconnectConnection, ::PICML::Interconnect, Pred> dstInterconnectConnection_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::InterconnectConnection, ::PICML::Interconnect, Pred>(impl, meta_dstInterconnectConnection, meta_dstInterconnectConnection_rev); }
		Udm::AClassAssocAttr< ::PICML::Shares, ::PICML::SharedResource> dstShares() const { return Udm::AClassAssocAttr< ::PICML::Shares, ::PICML::SharedResource>(impl, meta_dstShares, meta_dstShares_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::Shares, ::PICML::SharedResource, Pred> dstShares_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::Shares, ::PICML::SharedResource, Pred>(impl, meta_dstShares, meta_dstShares_rev); }
		Udm::ChildrenAttr< ::PICML::Resource> Resource_children() const { return Udm::ChildrenAttr< ::PICML::Resource>(impl, meta_Resource_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Resource, Pred> Resource_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Resource, Pred>(impl, meta_Resource_children); }
		Udm::ChildrenAttr< ::PICML::Resource> Resource_kind_children() const { return Udm::ChildrenAttr< ::PICML::Resource>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Resource, Pred> Resource_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Resource, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RequirementSatisfier> RequirementSatisfier_kind_children() const { return Udm::ChildrenAttr< ::PICML::RequirementSatisfier>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred> RequirementSatisfier_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::Domain> Domain_parent() const { return Udm::ParentAttr< ::PICML::Domain>(impl, meta_Domain_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Node(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_operatingSystem;
		static ::Uml::Attribute meta_label;
		static ::Uml::Attribute meta_architecture;
		static ::Uml::AssociationRole meta_referedbyNodeReference;
		static ::Uml::AssociationRole meta_dstInterconnectConnection;
		static ::Uml::AssociationRole meta_dstInterconnectConnection_rev;
		static ::Uml::AssociationRole meta_dstShares;
		static ::Uml::AssociationRole meta_dstShares_rev;
		static ::Uml::CompositionChildRole meta_Resource_children;
		static ::Uml::CompositionParentRole meta_Domain_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Domain_parent {};
		typedef boost::mpl::pair< ::PICML::Domain, PR_Domain_parent > _PR_Domain_parent__Domain;
		typedef boost::mpl::vector< _PR_Domain_parent__Domain> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Domain> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Resource_children {};
		typedef boost::mpl::pair< ::PICML::Resource, CR_Resource_children > _CR_Resource_children__Resource;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Resource_children__Resource> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Resource> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyNodeReference {};
		typedef boost::mpl::pair< ::PICML::NodeReference, AR_referedbyNodeReference > _AR_referedbyNodeReference__NodeReference;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyNodeReference__NodeReference> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstInterconnectConnection {};
		class AR_dstShares {};
		typedef boost::mpl::pair< ::PICML::Interconnect, boost::mpl::pair< ::PICML::InterconnectConnection, AR_dstInterconnectConnection > > _AR_dstInterconnectConnection__InterconnectConnection__Interconnect;
		typedef boost::mpl::pair< ::PICML::SharedResource, boost::mpl::pair< ::PICML::Shares, AR_dstShares > > _AR_dstShares__Shares__SharedResource;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstInterconnectConnection__InterconnectConnection__Interconnect, _AR_dstShares__Shares__SharedResource> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Bridge :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Bridge() {}
		Bridge(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Bridge(const Bridge &master) : MgaObject(master) {}

		static Bridge Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Bridge Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Bridge CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Bridge> Instances() { return Udm::InstantiatedAttr<Bridge>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Bridge, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Bridge, Pred>(impl); }
		Bridge CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Bridge> Derived() { return Udm::DerivedAttr<Bridge>(impl); }
		template <class Pred> Udm::DerivedAttr<Bridge, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Bridge, Pred>(impl); }
		Udm::ArchetypeAttr<Bridge> Archetype() const { return Udm::ArchetypeAttr<Bridge>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr label() const { return Udm::StringAttr(impl, meta_label); }
		Udm::AClassAssocAttr< ::PICML::BridgeConnection, ::PICML::Interconnect> srcBridgeConnection() const { return Udm::AClassAssocAttr< ::PICML::BridgeConnection, ::PICML::Interconnect>(impl, meta_srcBridgeConnection, meta_srcBridgeConnection_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::BridgeConnection, ::PICML::Interconnect, Pred> srcBridgeConnection_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::BridgeConnection, ::PICML::Interconnect, Pred>(impl, meta_srcBridgeConnection, meta_srcBridgeConnection_rev); }
		Udm::ChildrenAttr< ::PICML::Resource> Resource_children() const { return Udm::ChildrenAttr< ::PICML::Resource>(impl, meta_Resource_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Resource, Pred> Resource_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Resource, Pred>(impl, meta_Resource_children); }
		Udm::ChildrenAttr< ::PICML::Resource> Resource_kind_children() const { return Udm::ChildrenAttr< ::PICML::Resource>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Resource, Pred> Resource_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Resource, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RequirementSatisfier> RequirementSatisfier_kind_children() const { return Udm::ChildrenAttr< ::PICML::RequirementSatisfier>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred> RequirementSatisfier_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::Domain> Domain_parent() const { return Udm::ParentAttr< ::PICML::Domain>(impl, meta_Domain_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Bridge(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_label;
		static ::Uml::AssociationRole meta_srcBridgeConnection;
		static ::Uml::AssociationRole meta_srcBridgeConnection_rev;
		static ::Uml::CompositionChildRole meta_Resource_children;
		static ::Uml::CompositionParentRole meta_Domain_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Domain_parent {};
		typedef boost::mpl::pair< ::PICML::Domain, PR_Domain_parent > _PR_Domain_parent__Domain;
		typedef boost::mpl::vector< _PR_Domain_parent__Domain> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Domain> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Resource_children {};
		typedef boost::mpl::pair< ::PICML::Resource, CR_Resource_children > _CR_Resource_children__Resource;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Resource_children__Resource> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Resource> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcBridgeConnection {};
		typedef boost::mpl::pair< ::PICML::Interconnect, boost::mpl::pair< ::PICML::BridgeConnection, AR_srcBridgeConnection > > _AR_srcBridgeConnection__BridgeConnection__Interconnect;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcBridgeConnection__BridgeConnection__Interconnect> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export InstanceMapping :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		InstanceMapping() {}
		InstanceMapping(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		InstanceMapping(const InstanceMapping &master) : MgaObject(master) {}

		static InstanceMapping Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static InstanceMapping Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		InstanceMapping CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<InstanceMapping> Instances() { return Udm::InstantiatedAttr<InstanceMapping>(impl); }
		template <class Pred> Udm::InstantiatedAttr<InstanceMapping, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<InstanceMapping, Pred>(impl); }
		InstanceMapping CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<InstanceMapping> Derived() { return Udm::DerivedAttr<InstanceMapping>(impl); }
		template <class Pred> Udm::DerivedAttr<InstanceMapping, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<InstanceMapping, Pred>(impl); }
		Udm::ArchetypeAttr<InstanceMapping> Archetype() const { return Udm::ArchetypeAttr<InstanceMapping>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::DeploymentPlan> DeploymentPlan_parent() const { return Udm::ParentAttr< ::PICML::DeploymentPlan>(impl, meta_DeploymentPlan_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::NodeReference> dstInstanceMapping_end() const { return Udm::AssocEndAttr< ::PICML::NodeReference>(impl, meta_dstInstanceMapping_end_); }
		Udm::AssocEndAttr< ::PICML::CollocationGroup> srcInstanceMapping_end() const { return Udm::AssocEndAttr< ::PICML::CollocationGroup>(impl, meta_srcInstanceMapping_end_); }
		void Accept(Visitor &v) { v.Visit_InstanceMapping(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_DeploymentPlan_parent;
		static ::Uml::AssociationRole meta_dstInstanceMapping_end_;
		static ::Uml::AssociationRole meta_srcInstanceMapping_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_DeploymentPlan_parent {};
		typedef boost::mpl::pair< ::PICML::DeploymentPlan, PR_DeploymentPlan_parent > _PR_DeploymentPlan_parent__DeploymentPlan;
		typedef boost::mpl::vector< _PR_DeploymentPlan_parent__DeploymentPlan> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::DeploymentPlan> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstInstanceMapping {};
		class ACE_srcInstanceMapping {};
		typedef boost::mpl::pair< ::PICML::NodeReference, ACE_dstInstanceMapping > _ACE_dstInstanceMapping__NodeReference;
		typedef boost::mpl::pair< ::PICML::CollocationGroup, ACE_srcInstanceMapping > _ACE_srcInstanceMapping__CollocationGroup;
		typedef boost::mpl::vector< _ACE_dstInstanceMapping__NodeReference, _ACE_srcInstanceMapping__CollocationGroup> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export CollocationGroup :  public MgaObject {
	public:
		typedef ::Udm::SetMetaTag MetaKind;

		CollocationGroup() {}
		CollocationGroup(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		CollocationGroup(const CollocationGroup &master) : MgaObject(master) {}

		static CollocationGroup Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static CollocationGroup Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		CollocationGroup CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<CollocationGroup> Instances() { return Udm::InstantiatedAttr<CollocationGroup>(impl); }
		template <class Pred> Udm::InstantiatedAttr<CollocationGroup, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<CollocationGroup, Pred>(impl); }
		CollocationGroup CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<CollocationGroup> Derived() { return Udm::DerivedAttr<CollocationGroup>(impl); }
		template <class Pred> Udm::DerivedAttr<CollocationGroup, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<CollocationGroup, Pred>(impl); }
		Udm::ArchetypeAttr<CollocationGroup> Archetype() const { return Udm::ArchetypeAttr<CollocationGroup>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::InstanceMapping, ::PICML::NodeReference> dstInstanceMapping() const { return Udm::AClassAssocAttr< ::PICML::InstanceMapping, ::PICML::NodeReference>(impl, meta_dstInstanceMapping, meta_dstInstanceMapping_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::InstanceMapping, ::PICML::NodeReference, Pred> dstInstanceMapping_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::InstanceMapping, ::PICML::NodeReference, Pred>(impl, meta_dstInstanceMapping, meta_dstInstanceMapping_rev); }
		Udm::AssocAttr< ::PICML::CollocationGroupMember> members() const { return Udm::AssocAttr< ::PICML::CollocationGroupMember>(impl, meta_members); }
		template <class Pred> Udm::AssocAttr< ::PICML::CollocationGroupMember, Pred> members_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::CollocationGroupMember, Pred>(impl, meta_members); }
		Udm::ParentAttr< ::PICML::DeploymentPlan> DeploymentPlan_parent() const { return Udm::ParentAttr< ::PICML::DeploymentPlan>(impl, meta_DeploymentPlan_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_CollocationGroup(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstInstanceMapping;
		static ::Uml::AssociationRole meta_dstInstanceMapping_rev;
		static ::Uml::AssociationRole meta_members;
		static ::Uml::CompositionParentRole meta_DeploymentPlan_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_DeploymentPlan_parent {};
		typedef boost::mpl::pair< ::PICML::DeploymentPlan, PR_DeploymentPlan_parent > _PR_DeploymentPlan_parent__DeploymentPlan;
		typedef boost::mpl::vector< _PR_DeploymentPlan_parent__DeploymentPlan> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::DeploymentPlan> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_members {};
		typedef boost::mpl::pair< ::PICML::CollocationGroupMember, AR_members > _AR_members__CollocationGroupMember;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_members__CollocationGroupMember> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstInstanceMapping {};
		typedef boost::mpl::pair< ::PICML::NodeReference, boost::mpl::pair< ::PICML::InstanceMapping, AR_dstInstanceMapping > > _AR_dstInstanceMapping__InstanceMapping__NodeReference;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstInstanceMapping__InstanceMapping__NodeReference> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Deploys :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		Deploys() {}
		Deploys(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Deploys(const Deploys &master) : MgaObject(master) {}

		static Deploys Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Deploys Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Deploys CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Deploys> Instances() { return Udm::InstantiatedAttr<Deploys>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Deploys, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Deploys, Pred>(impl); }
		Deploys CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Deploys> Derived() { return Udm::DerivedAttr<Deploys>(impl); }
		template <class Pred> Udm::DerivedAttr<Deploys, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Deploys, Pred>(impl); }
		Udm::ArchetypeAttr<Deploys> Archetype() const { return Udm::ArchetypeAttr<Deploys>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::DeploymentPlan> DeploymentPlan_parent() const { return Udm::ParentAttr< ::PICML::DeploymentPlan>(impl, meta_DeploymentPlan_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ComponentFactoryRef> srcDeploys_end() const { return Udm::AssocEndAttr< ::PICML::ComponentFactoryRef>(impl, meta_srcDeploys_end_); }
		Udm::AssocEndAttr< ::PICML::ComponentRef> dstDeploys_end() const { return Udm::AssocEndAttr< ::PICML::ComponentRef>(impl, meta_dstDeploys_end_); }
		void Accept(Visitor &v) { v.Visit_Deploys(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_DeploymentPlan_parent;
		static ::Uml::AssociationRole meta_srcDeploys_end_;
		static ::Uml::AssociationRole meta_dstDeploys_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_DeploymentPlan_parent {};
		typedef boost::mpl::pair< ::PICML::DeploymentPlan, PR_DeploymentPlan_parent > _PR_DeploymentPlan_parent__DeploymentPlan;
		typedef boost::mpl::vector< _PR_DeploymentPlan_parent__DeploymentPlan> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::DeploymentPlan> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcDeploys {};
		class ACE_dstDeploys {};
		typedef boost::mpl::pair< ::PICML::ComponentFactoryRef, ACE_srcDeploys > _ACE_srcDeploys__ComponentFactoryRef;
		typedef boost::mpl::pair< ::PICML::ComponentRef, ACE_dstDeploys > _ACE_dstDeploys__ComponentRef;
		typedef boost::mpl::vector< _ACE_srcDeploys__ComponentFactoryRef, _ACE_dstDeploys__ComponentRef> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export CollocationGroupMember :  virtual  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		CollocationGroupMember() {}
		CollocationGroupMember(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		CollocationGroupMember(const CollocationGroupMember &master) : MgaObject(master) {}

		static CollocationGroupMember Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static CollocationGroupMember Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		CollocationGroupMember CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<CollocationGroupMember> Instances() { return Udm::InstantiatedAttr<CollocationGroupMember>(impl); }
		template <class Pred> Udm::InstantiatedAttr<CollocationGroupMember, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<CollocationGroupMember, Pred>(impl); }
		CollocationGroupMember CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<CollocationGroupMember> Derived() { return Udm::DerivedAttr<CollocationGroupMember>(impl); }
		template <class Pred> Udm::DerivedAttr<CollocationGroupMember, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<CollocationGroupMember, Pred>(impl); }
		Udm::ArchetypeAttr<CollocationGroupMember> Archetype() const { return Udm::ArchetypeAttr<CollocationGroupMember>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::CollocationGroup> setCollocationGroup() const { return Udm::AssocAttr< ::PICML::CollocationGroup>(impl, meta_setCollocationGroup); }
		template <class Pred> Udm::AssocAttr< ::PICML::CollocationGroup, Pred> setCollocationGroup_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::CollocationGroup, Pred>(impl, meta_setCollocationGroup); }
		Udm::ParentAttr< ::PICML::DeploymentPlan> DeploymentPlan_parent() const { return Udm::ParentAttr< ::PICML::DeploymentPlan>(impl, meta_DeploymentPlan_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_setCollocationGroup;
		static ::Uml::CompositionParentRole meta_DeploymentPlan_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_DeploymentPlan_parent {};
		typedef boost::mpl::pair< ::PICML::DeploymentPlan, PR_DeploymentPlan_parent > _PR_DeploymentPlan_parent__DeploymentPlan;
		typedef boost::mpl::vector< _PR_DeploymentPlan_parent__DeploymentPlan> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::DeploymentPlan> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_setCollocationGroup {};
		typedef boost::mpl::pair< ::PICML::CollocationGroup, AR_setCollocationGroup > _AR_setCollocationGroup__CollocationGroup;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_setCollocationGroup__CollocationGroup> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentAssemblyReference :  public CollocationGroupMember {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		ComponentAssemblyReference() {}
		ComponentAssemblyReference(Udm::ObjectImpl *impl) : CollocationGroupMember(impl), MgaObject(impl) {}
		ComponentAssemblyReference(const ComponentAssemblyReference &master) : CollocationGroupMember(master), MgaObject(master) {}

		static ComponentAssemblyReference Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentAssemblyReference Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentAssemblyReference CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentAssemblyReference> Instances() { return Udm::InstantiatedAttr<ComponentAssemblyReference>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentAssemblyReference, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentAssemblyReference, Pred>(impl); }
		ComponentAssemblyReference CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentAssemblyReference> Derived() { return Udm::DerivedAttr<ComponentAssemblyReference>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentAssemblyReference, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentAssemblyReference, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentAssemblyReference> Archetype() const { return Udm::ArchetypeAttr<ComponentAssemblyReference>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::ComponentAssembly> ref() const { return Udm::PointerAttr< ::PICML::ComponentAssembly>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentAssemblyReference(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly, ::PICML::DeploymentPlan> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, AR_ref > _AR_ref__ComponentAssembly;
		typedef boost::mpl::vector< _AR_ref__ComponentAssembly> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export SharedComponentReference :  public CollocationGroupMember {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		SharedComponentReference() {}
		SharedComponentReference(Udm::ObjectImpl *impl) : CollocationGroupMember(impl), MgaObject(impl) {}
		SharedComponentReference(const SharedComponentReference &master) : CollocationGroupMember(master), MgaObject(master) {}

		static SharedComponentReference Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static SharedComponentReference Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		SharedComponentReference CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<SharedComponentReference> Instances() { return Udm::InstantiatedAttr<SharedComponentReference>(impl); }
		template <class Pred> Udm::InstantiatedAttr<SharedComponentReference, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<SharedComponentReference, Pred>(impl); }
		SharedComponentReference CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<SharedComponentReference> Derived() { return Udm::DerivedAttr<SharedComponentReference>(impl); }
		template <class Pred> Udm::DerivedAttr<SharedComponentReference, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<SharedComponentReference, Pred>(impl); }
		Udm::ArchetypeAttr<SharedComponentReference> Archetype() const { return Udm::ArchetypeAttr<SharedComponentReference>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::ComponentRef> ref() const { return Udm::PointerAttr< ::PICML::ComponentRef>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_SharedComponentReference(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::DeploymentPlan> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::ComponentRef, AR_ref > _AR_ref__ComponentRef;
		typedef boost::mpl::vector< _AR_ref__ComponentRef> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentFactoryRef :  public CollocationGroupMember {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		ComponentFactoryRef() {}
		ComponentFactoryRef(Udm::ObjectImpl *impl) : CollocationGroupMember(impl), MgaObject(impl) {}
		ComponentFactoryRef(const ComponentFactoryRef &master) : CollocationGroupMember(master), MgaObject(master) {}

		static ComponentFactoryRef Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentFactoryRef Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentFactoryRef CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentFactoryRef> Instances() { return Udm::InstantiatedAttr<ComponentFactoryRef>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentFactoryRef, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentFactoryRef, Pred>(impl); }
		ComponentFactoryRef CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentFactoryRef> Derived() { return Udm::DerivedAttr<ComponentFactoryRef>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentFactoryRef, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentFactoryRef, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentFactoryRef> Archetype() const { return Udm::ArchetypeAttr<ComponentFactoryRef>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::ComponentFactoryInstance> ref() const { return Udm::PointerAttr< ::PICML::ComponentFactoryInstance>(impl, meta_ref); }
		Udm::AClassAssocAttr< ::PICML::Deploys, ::PICML::ComponentRef> dstDeploys() const { return Udm::AClassAssocAttr< ::PICML::Deploys, ::PICML::ComponentRef>(impl, meta_dstDeploys, meta_dstDeploys_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::Deploys, ::PICML::ComponentRef, Pred> dstDeploys_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::Deploys, ::PICML::ComponentRef, Pred>(impl, meta_dstDeploys, meta_dstDeploys_rev); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentFactoryRef(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_dstDeploys;
		static ::Uml::AssociationRole meta_dstDeploys_rev;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::DeploymentPlan> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::ComponentFactoryInstance, AR_ref > _AR_ref__ComponentFactoryInstance;
		typedef boost::mpl::vector< _AR_ref__ComponentFactoryInstance> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstDeploys {};
		typedef boost::mpl::pair< ::PICML::ComponentRef, boost::mpl::pair< ::PICML::Deploys, AR_dstDeploys > > _AR_dstDeploys__Deploys__ComponentRef;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstDeploys__Deploys__ComponentRef> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export DeploymentPlan :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		DeploymentPlan() {}
		DeploymentPlan(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		DeploymentPlan(const DeploymentPlan &master) : MgaObject(master) {}

		static DeploymentPlan Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static DeploymentPlan Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		DeploymentPlan CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<DeploymentPlan> Instances() { return Udm::InstantiatedAttr<DeploymentPlan>(impl); }
		template <class Pred> Udm::InstantiatedAttr<DeploymentPlan, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<DeploymentPlan, Pred>(impl); }
		DeploymentPlan CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<DeploymentPlan> Derived() { return Udm::DerivedAttr<DeploymentPlan>(impl); }
		template <class Pred> Udm::DerivedAttr<DeploymentPlan, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<DeploymentPlan, Pred>(impl); }
		Udm::ArchetypeAttr<DeploymentPlan> Archetype() const { return Udm::ArchetypeAttr<DeploymentPlan>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr UUID() const { return Udm::StringAttr(impl, meta_UUID); }
		Udm::StringAttr label() const { return Udm::StringAttr(impl, meta_label); }
		Udm::ChildrenAttr< ::PICML::InstanceMapping> InstanceMapping_children() const { return Udm::ChildrenAttr< ::PICML::InstanceMapping>(impl, meta_InstanceMapping_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InstanceMapping, Pred> InstanceMapping_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InstanceMapping, Pred>(impl, meta_InstanceMapping_children); }
		Udm::ChildrenAttr< ::PICML::NodeReference> NodeReference_children() const { return Udm::ChildrenAttr< ::PICML::NodeReference>(impl, meta_NodeReference_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::NodeReference, Pred> NodeReference_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::NodeReference, Pred>(impl, meta_NodeReference_children); }
		Udm::ChildrenAttr< ::PICML::CollocationGroup> CollocationGroup_children() const { return Udm::ChildrenAttr< ::PICML::CollocationGroup>(impl, meta_CollocationGroup_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CollocationGroup, Pred> CollocationGroup_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CollocationGroup, Pred>(impl, meta_CollocationGroup_children); }
		Udm::ChildrenAttr< ::PICML::Property> Property_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, meta_Property_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); }
		Udm::ChildrenAttr< ::PICML::Deploys> Deploys_children() const { return Udm::ChildrenAttr< ::PICML::Deploys>(impl, meta_Deploys_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Deploys, Pred> Deploys_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Deploys, Pred>(impl, meta_Deploys_children); }
		Udm::ChildrenAttr< ::PICML::CollocationGroupMember> CollocationGroupMember_children() const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember>(impl, meta_CollocationGroupMember_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred> CollocationGroupMember_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred>(impl, meta_CollocationGroupMember_children); }
		Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference> ComponentAssemblyReference_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference, Pred> ComponentAssemblyReference_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::NodeReference> NodeReference_kind_children() const { return Udm::ChildrenAttr< ::PICML::NodeReference>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::NodeReference, Pred> NodeReference_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::NodeReference, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::InstanceMapping> InstanceMapping_kind_children() const { return Udm::ChildrenAttr< ::PICML::InstanceMapping>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InstanceMapping, Pred> InstanceMapping_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InstanceMapping, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::CollocationGroup> CollocationGroup_kind_children() const { return Udm::ChildrenAttr< ::PICML::CollocationGroup>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CollocationGroup, Pred> CollocationGroup_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CollocationGroup, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::SharedComponentReference> SharedComponentReference_kind_children() const { return Udm::ChildrenAttr< ::PICML::SharedComponentReference>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SharedComponentReference, Pred> SharedComponentReference_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SharedComponentReference, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentFactoryRef> ComponentFactoryRef_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentFactoryRef>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentFactoryRef, Pred> ComponentFactoryRef_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentFactoryRef, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Deploys> Deploys_kind_children() const { return Udm::ChildrenAttr< ::PICML::Deploys>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Deploys, Pred> Deploys_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Deploys, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::CollocationGroupMember> CollocationGroupMember_kind_children() const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred> CollocationGroupMember_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentRef>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::DeploymentPlans> DeploymentPlans_parent() const { return Udm::ParentAttr< ::PICML::DeploymentPlans>(impl, meta_DeploymentPlans_parent); }
		Udm::ParentAttr< ::PICML::DeploymentPlans> parent() const { return Udm::ParentAttr< ::PICML::DeploymentPlans>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_DeploymentPlan(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::Attribute meta_label;
		static ::Uml::CompositionChildRole meta_InstanceMapping_children;
		static ::Uml::CompositionChildRole meta_NodeReference_children;
		static ::Uml::CompositionChildRole meta_CollocationGroup_children;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_Deploys_children;
		static ::Uml::CompositionChildRole meta_CollocationGroupMember_children;
		static ::Uml::CompositionParentRole meta_DeploymentPlans_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_DeploymentPlans_parent {};
		typedef boost::mpl::pair< ::PICML::DeploymentPlans, PR_DeploymentPlans_parent > _PR_DeploymentPlans_parent__DeploymentPlans;
		typedef boost::mpl::vector< _PR_DeploymentPlans_parent__DeploymentPlans> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::DeploymentPlans> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_InstanceMapping_children {};
		class CR_NodeReference_children {};
		class CR_CollocationGroup_children {};
		class CR_Property_children {};
		class CR_Deploys_children {};
		class CR_CollocationGroupMember_children {};
		typedef boost::mpl::pair< ::PICML::InstanceMapping, CR_InstanceMapping_children > _CR_InstanceMapping_children__InstanceMapping;
		typedef boost::mpl::pair< ::PICML::NodeReference, CR_NodeReference_children > _CR_NodeReference_children__NodeReference;
		typedef boost::mpl::pair< ::PICML::CollocationGroup, CR_CollocationGroup_children > _CR_CollocationGroup_children__CollocationGroup;
		typedef boost::mpl::pair< ::PICML::Property, CR_Property_children > _CR_Property_children__Property;
		typedef boost::mpl::pair< ::PICML::Deploys, CR_Deploys_children > _CR_Deploys_children__Deploys;
		typedef boost::mpl::pair< ::PICML::CollocationGroupMember, CR_CollocationGroupMember_children > _CR_CollocationGroupMember_children__CollocationGroupMember;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_InstanceMapping_children__InstanceMapping, _CR_NodeReference_children__NodeReference, _CR_CollocationGroup_children__CollocationGroup, _CR_Property_children__Property, _CR_Deploys_children__Deploys, _CR_CollocationGroupMember_children__CollocationGroupMember> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssemblyReference, ::PICML::NodeReference, ::PICML::InstanceMapping, ::PICML::CollocationGroup, ::PICML::SharedComponentReference, ::PICML::ComponentFactoryRef, ::PICML::Deploys, ::PICML::CollocationGroupMember, ::PICML::Property, ::PICML::ComponentRef> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export invoke :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		invoke() {}
		invoke(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		invoke(const invoke &master) : MgaObject(master) {}

		static invoke Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static invoke Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		invoke CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<invoke> Instances() { return Udm::InstantiatedAttr<invoke>(impl); }
		template <class Pred> Udm::InstantiatedAttr<invoke, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<invoke, Pred>(impl); }
		invoke CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<invoke> Derived() { return Udm::DerivedAttr<invoke>(impl); }
		template <class Pred> Udm::DerivedAttr<invoke, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<invoke, Pred>(impl); }
		Udm::ArchetypeAttr<invoke> Archetype() const { return Udm::ArchetypeAttr<invoke>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::InvokePortBase> dstinvoke_end() const { return Udm::AssocEndAttr< ::PICML::InvokePortBase>(impl, meta_dstinvoke_end_); }
		Udm::AssocEndAttr< ::PICML::RequiredRequestPort> srcinvoke_end() const { return Udm::AssocEndAttr< ::PICML::RequiredRequestPort>(impl, meta_srcinvoke_end_); }
		void Accept(Visitor &v) { v.Visit_invoke(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_dstinvoke_end_;
		static ::Uml::AssociationRole meta_srcinvoke_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstinvoke {};
		class ACE_srcinvoke {};
		typedef boost::mpl::pair< ::PICML::InvokePortBase, ACE_dstinvoke > _ACE_dstinvoke__InvokePortBase;
		typedef boost::mpl::pair< ::PICML::RequiredRequestPort, ACE_srcinvoke > _ACE_srcinvoke__RequiredRequestPort;
		typedef boost::mpl::vector< _ACE_dstinvoke__InvokePortBase, _ACE_srcinvoke__RequiredRequestPort> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export AssemblyselectRequirement :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		AssemblyselectRequirement() {}
		AssemblyselectRequirement(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		AssemblyselectRequirement(const AssemblyselectRequirement &master) : MgaObject(master) {}

		static AssemblyselectRequirement Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static AssemblyselectRequirement Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		AssemblyselectRequirement CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<AssemblyselectRequirement> Instances() { return Udm::InstantiatedAttr<AssemblyselectRequirement>(impl); }
		template <class Pred> Udm::InstantiatedAttr<AssemblyselectRequirement, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<AssemblyselectRequirement, Pred>(impl); }
		AssemblyselectRequirement CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<AssemblyselectRequirement> Derived() { return Udm::DerivedAttr<AssemblyselectRequirement>(impl); }
		template <class Pred> Udm::DerivedAttr<AssemblyselectRequirement, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<AssemblyselectRequirement, Pred>(impl); }
		Udm::ArchetypeAttr<AssemblyselectRequirement> Archetype() const { return Udm::ArchetypeAttr<AssemblyselectRequirement>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::Requirement> dstAssemblyselectRequirement_end() const { return Udm::AssocEndAttr< ::PICML::Requirement>(impl, meta_dstAssemblyselectRequirement_end_); }
		Udm::AssocEndAttr< ::PICML::Component> srcAssemblyselectRequirement_end() const { return Udm::AssocEndAttr< ::PICML::Component>(impl, meta_srcAssemblyselectRequirement_end_); }
		void Accept(Visitor &v) { v.Visit_AssemblyselectRequirement(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_dstAssemblyselectRequirement_end_;
		static ::Uml::AssociationRole meta_srcAssemblyselectRequirement_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstAssemblyselectRequirement {};
		class ACE_srcAssemblyselectRequirement {};
		typedef boost::mpl::pair< ::PICML::Requirement, ACE_dstAssemblyselectRequirement > _ACE_dstAssemblyselectRequirement__Requirement;
		typedef boost::mpl::pair< ::PICML::Component, ACE_srcAssemblyselectRequirement > _ACE_srcAssemblyselectRequirement__Component;
		typedef boost::mpl::vector< _ACE_dstAssemblyselectRequirement__Requirement, _ACE_srcAssemblyselectRequirement__Component> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export AssemblyConfigProperty :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		AssemblyConfigProperty() {}
		AssemblyConfigProperty(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		AssemblyConfigProperty(const AssemblyConfigProperty &master) : MgaObject(master) {}

		static AssemblyConfigProperty Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static AssemblyConfigProperty Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		AssemblyConfigProperty CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<AssemblyConfigProperty> Instances() { return Udm::InstantiatedAttr<AssemblyConfigProperty>(impl); }
		template <class Pred> Udm::InstantiatedAttr<AssemblyConfigProperty, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<AssemblyConfigProperty, Pred>(impl); }
		AssemblyConfigProperty CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<AssemblyConfigProperty> Derived() { return Udm::DerivedAttr<AssemblyConfigProperty>(impl); }
		template <class Pred> Udm::DerivedAttr<AssemblyConfigProperty, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<AssemblyConfigProperty, Pred>(impl); }
		Udm::ArchetypeAttr<AssemblyConfigProperty> Archetype() const { return Udm::ArchetypeAttr<AssemblyConfigProperty>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::Property> dstAssemblyConfigProperty_end() const { return Udm::AssocEndAttr< ::PICML::Property>(impl, meta_dstAssemblyConfigProperty_end_); }
		Udm::AssocEndAttr< ::PICML::Component> srcAssemblyConfigProperty_end() const { return Udm::AssocEndAttr< ::PICML::Component>(impl, meta_srcAssemblyConfigProperty_end_); }
		void Accept(Visitor &v) { v.Visit_AssemblyConfigProperty(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_dstAssemblyConfigProperty_end_;
		static ::Uml::AssociationRole meta_srcAssemblyConfigProperty_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstAssemblyConfigProperty {};
		class ACE_srcAssemblyConfigProperty {};
		typedef boost::mpl::pair< ::PICML::Property, ACE_dstAssemblyConfigProperty > _ACE_dstAssemblyConfigProperty__Property;
		typedef boost::mpl::pair< ::PICML::Component, ACE_srcAssemblyConfigProperty > _ACE_srcAssemblyConfigProperty__Component;
		typedef boost::mpl::vector< _ACE_dstAssemblyConfigProperty__Property, _ACE_srcAssemblyConfigProperty__Component> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PublishConnector :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		PublishConnector() {}
		PublishConnector(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		PublishConnector(const PublishConnector &master) : MgaObject(master) {}

		static PublishConnector Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PublishConnector Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PublishConnector CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PublishConnector> Instances() { return Udm::InstantiatedAttr<PublishConnector>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PublishConnector, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PublishConnector, Pred>(impl); }
		PublishConnector CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PublishConnector> Derived() { return Udm::DerivedAttr<PublishConnector>(impl); }
		template <class Pred> Udm::DerivedAttr<PublishConnector, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PublishConnector, Pred>(impl); }
		Udm::ArchetypeAttr<PublishConnector> Archetype() const { return Udm::ArchetypeAttr<PublishConnector>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::AssemblyDeployRequirement, ::PICML::Requirement> dstAssemblyDeployRequirement() const { return Udm::AClassAssocAttr< ::PICML::AssemblyDeployRequirement, ::PICML::Requirement>(impl, meta_dstAssemblyDeployRequirement, meta_dstAssemblyDeployRequirement_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::AssemblyDeployRequirement, ::PICML::Requirement, Pred> dstAssemblyDeployRequirement_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::AssemblyDeployRequirement, ::PICML::Requirement, Pred>(impl, meta_dstAssemblyDeployRequirement, meta_dstAssemblyDeployRequirement_rev); }
		Udm::AClassAssocAttr< ::PICML::deliverTo, ::PICML::InEventPort> dstdeliverTo() const { return Udm::AClassAssocAttr< ::PICML::deliverTo, ::PICML::InEventPort>(impl, meta_dstdeliverTo, meta_dstdeliverTo_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::deliverTo, ::PICML::InEventPort, Pred> dstdeliverTo_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::deliverTo, ::PICML::InEventPort, Pred>(impl, meta_dstdeliverTo, meta_dstdeliverTo_rev); }
		Udm::AClassPointerAttr< ::PICML::publish, ::PICML::OutEventPort> srcpublish() const { return Udm::AClassPointerAttr< ::PICML::publish, ::PICML::OutEventPort>(impl, meta_srcpublish, meta_srcpublish_rev); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_PublishConnector(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstAssemblyDeployRequirement;
		static ::Uml::AssociationRole meta_dstAssemblyDeployRequirement_rev;
		static ::Uml::AssociationRole meta_dstdeliverTo;
		static ::Uml::AssociationRole meta_dstdeliverTo_rev;
		static ::Uml::AssociationRole meta_srcpublish;
		static ::Uml::AssociationRole meta_srcpublish_rev;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstAssemblyDeployRequirement {};
		class AR_dstdeliverTo {};
		class AR_srcpublish {};
		typedef boost::mpl::pair< ::PICML::Requirement, boost::mpl::pair< ::PICML::AssemblyDeployRequirement, AR_dstAssemblyDeployRequirement > > _AR_dstAssemblyDeployRequirement__AssemblyDeployRequirement__Requirement;
		typedef boost::mpl::pair< ::PICML::InEventPort, boost::mpl::pair< ::PICML::deliverTo, AR_dstdeliverTo > > _AR_dstdeliverTo__deliverTo__InEventPort;
		typedef boost::mpl::pair< ::PICML::OutEventPort, boost::mpl::pair< ::PICML::publish, AR_srcpublish > > _AR_srcpublish__publish__OutEventPort;
		typedef boost::mpl::vector< _AR_srcpublish__publish__OutEventPort> AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstAssemblyDeployRequirement__AssemblyDeployRequirement__Requirement, _AR_dstdeliverTo__deliverTo__InEventPort> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export publish :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		publish() {}
		publish(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		publish(const publish &master) : MgaObject(master) {}

		static publish Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static publish Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		publish CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<publish> Instances() { return Udm::InstantiatedAttr<publish>(impl); }
		template <class Pred> Udm::InstantiatedAttr<publish, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<publish, Pred>(impl); }
		publish CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<publish> Derived() { return Udm::DerivedAttr<publish>(impl); }
		template <class Pred> Udm::DerivedAttr<publish, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<publish, Pred>(impl); }
		Udm::ArchetypeAttr<publish> Archetype() const { return Udm::ArchetypeAttr<publish>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::PublishConnector> dstpublish_end() const { return Udm::AssocEndAttr< ::PICML::PublishConnector>(impl, meta_dstpublish_end_); }
		Udm::AssocEndAttr< ::PICML::OutEventPort> srcpublish_end() const { return Udm::AssocEndAttr< ::PICML::OutEventPort>(impl, meta_srcpublish_end_); }
		void Accept(Visitor &v) { v.Visit_publish(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_dstpublish_end_;
		static ::Uml::AssociationRole meta_srcpublish_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstpublish {};
		class ACE_srcpublish {};
		typedef boost::mpl::pair< ::PICML::PublishConnector, ACE_dstpublish > _ACE_dstpublish__PublishConnector;
		typedef boost::mpl::pair< ::PICML::OutEventPort, ACE_srcpublish > _ACE_srcpublish__OutEventPort;
		typedef boost::mpl::vector< _ACE_dstpublish__PublishConnector, _ACE_srcpublish__OutEventPort> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export deliverTo :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		deliverTo() {}
		deliverTo(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		deliverTo(const deliverTo &master) : MgaObject(master) {}

		static deliverTo Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static deliverTo Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		deliverTo CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<deliverTo> Instances() { return Udm::InstantiatedAttr<deliverTo>(impl); }
		template <class Pred> Udm::InstantiatedAttr<deliverTo, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<deliverTo, Pred>(impl); }
		deliverTo CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<deliverTo> Derived() { return Udm::DerivedAttr<deliverTo>(impl); }
		template <class Pred> Udm::DerivedAttr<deliverTo, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<deliverTo, Pred>(impl); }
		Udm::ArchetypeAttr<deliverTo> Archetype() const { return Udm::ArchetypeAttr<deliverTo>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::PublishConnector> srcdeliverTo_end() const { return Udm::AssocEndAttr< ::PICML::PublishConnector>(impl, meta_srcdeliverTo_end_); }
		Udm::AssocEndAttr< ::PICML::InEventPort> dstdeliverTo_end() const { return Udm::AssocEndAttr< ::PICML::InEventPort>(impl, meta_dstdeliverTo_end_); }
		void Accept(Visitor &v) { v.Visit_deliverTo(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcdeliverTo_end_;
		static ::Uml::AssociationRole meta_dstdeliverTo_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcdeliverTo {};
		class ACE_dstdeliverTo {};
		typedef boost::mpl::pair< ::PICML::PublishConnector, ACE_srcdeliverTo > _ACE_srcdeliverTo__PublishConnector;
		typedef boost::mpl::pair< ::PICML::InEventPort, ACE_dstdeliverTo > _ACE_dstdeliverTo__InEventPort;
		typedef boost::mpl::vector< _ACE_srcdeliverTo__PublishConnector, _ACE_dstdeliverTo__InEventPort> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export AssemblyDeployRequirement :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		AssemblyDeployRequirement() {}
		AssemblyDeployRequirement(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		AssemblyDeployRequirement(const AssemblyDeployRequirement &master) : MgaObject(master) {}

		static AssemblyDeployRequirement Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static AssemblyDeployRequirement Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		AssemblyDeployRequirement CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<AssemblyDeployRequirement> Instances() { return Udm::InstantiatedAttr<AssemblyDeployRequirement>(impl); }
		template <class Pred> Udm::InstantiatedAttr<AssemblyDeployRequirement, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<AssemblyDeployRequirement, Pred>(impl); }
		AssemblyDeployRequirement CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<AssemblyDeployRequirement> Derived() { return Udm::DerivedAttr<AssemblyDeployRequirement>(impl); }
		template <class Pred> Udm::DerivedAttr<AssemblyDeployRequirement, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<AssemblyDeployRequirement, Pred>(impl); }
		Udm::ArchetypeAttr<AssemblyDeployRequirement> Archetype() const { return Udm::ArchetypeAttr<AssemblyDeployRequirement>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::PublishConnector> srcAssemblyDeployRequirement_end() const { return Udm::AssocEndAttr< ::PICML::PublishConnector>(impl, meta_srcAssemblyDeployRequirement_end_); }
		Udm::AssocEndAttr< ::PICML::Requirement> dstAssemblyDeployRequirement_end() const { return Udm::AssocEndAttr< ::PICML::Requirement>(impl, meta_dstAssemblyDeployRequirement_end_); }
		void Accept(Visitor &v) { v.Visit_AssemblyDeployRequirement(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcAssemblyDeployRequirement_end_;
		static ::Uml::AssociationRole meta_dstAssemblyDeployRequirement_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcAssemblyDeployRequirement {};
		class ACE_dstAssemblyDeployRequirement {};
		typedef boost::mpl::pair< ::PICML::PublishConnector, ACE_srcAssemblyDeployRequirement > _ACE_srcAssemblyDeployRequirement__PublishConnector;
		typedef boost::mpl::pair< ::PICML::Requirement, ACE_dstAssemblyDeployRequirement > _ACE_dstAssemblyDeployRequirement__Requirement;
		typedef boost::mpl::vector< _ACE_srcAssemblyDeployRequirement__PublishConnector, _ACE_dstAssemblyDeployRequirement__Requirement> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export emit :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		emit() {}
		emit(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		emit(const emit &master) : MgaObject(master) {}

		static emit Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static emit Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		emit CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<emit> Instances() { return Udm::InstantiatedAttr<emit>(impl); }
		template <class Pred> Udm::InstantiatedAttr<emit, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<emit, Pred>(impl); }
		emit CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<emit> Derived() { return Udm::DerivedAttr<emit>(impl); }
		template <class Pred> Udm::DerivedAttr<emit, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<emit, Pred>(impl); }
		Udm::ArchetypeAttr<emit> Archetype() const { return Udm::ArchetypeAttr<emit>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::InEventPort> dstemit_end() const { return Udm::AssocEndAttr< ::PICML::InEventPort>(impl, meta_dstemit_end_); }
		Udm::AssocEndAttr< ::PICML::OutEventPort> srcemit_end() const { return Udm::AssocEndAttr< ::PICML::OutEventPort>(impl, meta_srcemit_end_); }
		void Accept(Visitor &v) { v.Visit_emit(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_dstemit_end_;
		static ::Uml::AssociationRole meta_srcemit_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstemit {};
		class ACE_srcemit {};
		typedef boost::mpl::pair< ::PICML::InEventPort, ACE_dstemit > _ACE_dstemit__InEventPort;
		typedef boost::mpl::pair< ::PICML::OutEventPort, ACE_srcemit > _ACE_srcemit__OutEventPort;
		typedef boost::mpl::vector< _ACE_dstemit__InEventPort, _ACE_srcemit__OutEventPort> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ReceptacleDelegate :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		ReceptacleDelegate() {}
		ReceptacleDelegate(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ReceptacleDelegate(const ReceptacleDelegate &master) : MgaObject(master) {}

		static ReceptacleDelegate Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ReceptacleDelegate Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ReceptacleDelegate CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ReceptacleDelegate> Instances() { return Udm::InstantiatedAttr<ReceptacleDelegate>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ReceptacleDelegate, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ReceptacleDelegate, Pred>(impl); }
		ReceptacleDelegate CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ReceptacleDelegate> Derived() { return Udm::DerivedAttr<ReceptacleDelegate>(impl); }
		template <class Pred> Udm::DerivedAttr<ReceptacleDelegate, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ReceptacleDelegate, Pred>(impl); }
		Udm::ArchetypeAttr<ReceptacleDelegate> Archetype() const { return Udm::ArchetypeAttr<ReceptacleDelegate>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::RequiredRequestPort> srcReceptacleDelegate_end() const { return Udm::AssocEndAttr< ::PICML::RequiredRequestPort>(impl, meta_srcReceptacleDelegate_end_); }
		Udm::AssocEndAttr< ::PICML::RequiredRequestPort> dstReceptacleDelegate_end() const { return Udm::AssocEndAttr< ::PICML::RequiredRequestPort>(impl, meta_dstReceptacleDelegate_end_); }
		void Accept(Visitor &v) { v.Visit_ReceptacleDelegate(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcReceptacleDelegate_end_;
		static ::Uml::AssociationRole meta_dstReceptacleDelegate_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcReceptacleDelegate {};
		class ACE_dstReceptacleDelegate {};
		typedef boost::mpl::pair< ::PICML::RequiredRequestPort, ACE_srcReceptacleDelegate > _ACE_srcReceptacleDelegate__RequiredRequestPort;
		typedef boost::mpl::pair< ::PICML::RequiredRequestPort, ACE_dstReceptacleDelegate > _ACE_dstReceptacleDelegate__RequiredRequestPort;
		typedef boost::mpl::vector< _ACE_srcReceptacleDelegate__RequiredRequestPort, _ACE_dstReceptacleDelegate__RequiredRequestPort> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export FacetDelegate :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		FacetDelegate() {}
		FacetDelegate(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		FacetDelegate(const FacetDelegate &master) : MgaObject(master) {}

		static FacetDelegate Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static FacetDelegate Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		FacetDelegate CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<FacetDelegate> Instances() { return Udm::InstantiatedAttr<FacetDelegate>(impl); }
		template <class Pred> Udm::InstantiatedAttr<FacetDelegate, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<FacetDelegate, Pred>(impl); }
		FacetDelegate CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<FacetDelegate> Derived() { return Udm::DerivedAttr<FacetDelegate>(impl); }
		template <class Pred> Udm::DerivedAttr<FacetDelegate, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<FacetDelegate, Pred>(impl); }
		Udm::ArchetypeAttr<FacetDelegate> Archetype() const { return Udm::ArchetypeAttr<FacetDelegate>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ProvidedRequestPort> srcFacetDelegate_end() const { return Udm::AssocEndAttr< ::PICML::ProvidedRequestPort>(impl, meta_srcFacetDelegate_end_); }
		Udm::AssocEndAttr< ::PICML::ProvidedRequestPort> dstFacetDelegate_end() const { return Udm::AssocEndAttr< ::PICML::ProvidedRequestPort>(impl, meta_dstFacetDelegate_end_); }
		void Accept(Visitor &v) { v.Visit_FacetDelegate(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcFacetDelegate_end_;
		static ::Uml::AssociationRole meta_dstFacetDelegate_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcFacetDelegate {};
		class ACE_dstFacetDelegate {};
		typedef boost::mpl::pair< ::PICML::ProvidedRequestPort, ACE_srcFacetDelegate > _ACE_srcFacetDelegate__ProvidedRequestPort;
		typedef boost::mpl::pair< ::PICML::ProvidedRequestPort, ACE_dstFacetDelegate > _ACE_dstFacetDelegate__ProvidedRequestPort;
		typedef boost::mpl::vector< _ACE_srcFacetDelegate__ProvidedRequestPort, _ACE_dstFacetDelegate__ProvidedRequestPort> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export EventSourceDelegate :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		EventSourceDelegate() {}
		EventSourceDelegate(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		EventSourceDelegate(const EventSourceDelegate &master) : MgaObject(master) {}

		static EventSourceDelegate Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static EventSourceDelegate Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		EventSourceDelegate CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<EventSourceDelegate> Instances() { return Udm::InstantiatedAttr<EventSourceDelegate>(impl); }
		template <class Pred> Udm::InstantiatedAttr<EventSourceDelegate, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<EventSourceDelegate, Pred>(impl); }
		EventSourceDelegate CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<EventSourceDelegate> Derived() { return Udm::DerivedAttr<EventSourceDelegate>(impl); }
		template <class Pred> Udm::DerivedAttr<EventSourceDelegate, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<EventSourceDelegate, Pred>(impl); }
		Udm::ArchetypeAttr<EventSourceDelegate> Archetype() const { return Udm::ArchetypeAttr<EventSourceDelegate>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::OutEventPort> srcEventSourceDelegate_end() const { return Udm::AssocEndAttr< ::PICML::OutEventPort>(impl, meta_srcEventSourceDelegate_end_); }
		Udm::AssocEndAttr< ::PICML::OutEventPort> dstEventSourceDelegate_end() const { return Udm::AssocEndAttr< ::PICML::OutEventPort>(impl, meta_dstEventSourceDelegate_end_); }
		void Accept(Visitor &v) { v.Visit_EventSourceDelegate(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcEventSourceDelegate_end_;
		static ::Uml::AssociationRole meta_dstEventSourceDelegate_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcEventSourceDelegate {};
		class ACE_dstEventSourceDelegate {};
		typedef boost::mpl::pair< ::PICML::OutEventPort, ACE_srcEventSourceDelegate > _ACE_srcEventSourceDelegate__OutEventPort;
		typedef boost::mpl::pair< ::PICML::OutEventPort, ACE_dstEventSourceDelegate > _ACE_dstEventSourceDelegate__OutEventPort;
		typedef boost::mpl::vector< _ACE_srcEventSourceDelegate__OutEventPort, _ACE_dstEventSourceDelegate__OutEventPort> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export EventSinkDelegate :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		EventSinkDelegate() {}
		EventSinkDelegate(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		EventSinkDelegate(const EventSinkDelegate &master) : MgaObject(master) {}

		static EventSinkDelegate Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static EventSinkDelegate Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		EventSinkDelegate CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<EventSinkDelegate> Instances() { return Udm::InstantiatedAttr<EventSinkDelegate>(impl); }
		template <class Pred> Udm::InstantiatedAttr<EventSinkDelegate, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<EventSinkDelegate, Pred>(impl); }
		EventSinkDelegate CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<EventSinkDelegate> Derived() { return Udm::DerivedAttr<EventSinkDelegate>(impl); }
		template <class Pred> Udm::DerivedAttr<EventSinkDelegate, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<EventSinkDelegate, Pred>(impl); }
		Udm::ArchetypeAttr<EventSinkDelegate> Archetype() const { return Udm::ArchetypeAttr<EventSinkDelegate>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::InEventPort> srcEventSinkDelegate_end() const { return Udm::AssocEndAttr< ::PICML::InEventPort>(impl, meta_srcEventSinkDelegate_end_); }
		Udm::AssocEndAttr< ::PICML::InEventPort> dstEventSinkDelegate_end() const { return Udm::AssocEndAttr< ::PICML::InEventPort>(impl, meta_dstEventSinkDelegate_end_); }
		void Accept(Visitor &v) { v.Visit_EventSinkDelegate(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcEventSinkDelegate_end_;
		static ::Uml::AssociationRole meta_dstEventSinkDelegate_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcEventSinkDelegate {};
		class ACE_dstEventSinkDelegate {};
		typedef boost::mpl::pair< ::PICML::InEventPort, ACE_srcEventSinkDelegate > _ACE_srcEventSinkDelegate__InEventPort;
		typedef boost::mpl::pair< ::PICML::InEventPort, ACE_dstEventSinkDelegate > _ACE_dstEventSinkDelegate__InEventPort;
		typedef boost::mpl::vector< _ACE_srcEventSinkDelegate__InEventPort, _ACE_dstEventSinkDelegate__InEventPort> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ExternalDelegate :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		ExternalDelegate() {}
		ExternalDelegate(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ExternalDelegate(const ExternalDelegate &master) : MgaObject(master) {}

		static ExternalDelegate Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ExternalDelegate Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ExternalDelegate CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ExternalDelegate> Instances() { return Udm::InstantiatedAttr<ExternalDelegate>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ExternalDelegate, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ExternalDelegate, Pred>(impl); }
		ExternalDelegate CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ExternalDelegate> Derived() { return Udm::DerivedAttr<ExternalDelegate>(impl); }
		template <class Pred> Udm::DerivedAttr<ExternalDelegate, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ExternalDelegate, Pred>(impl); }
		Udm::ArchetypeAttr<ExternalDelegate> Archetype() const { return Udm::ArchetypeAttr<ExternalDelegate>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ExternalPortReference> srcExternalDelegate_end() const { return Udm::AssocEndAttr< ::PICML::ExternalPortReference>(impl, meta_srcExternalDelegate_end_); }
		Udm::AssocEndAttr< ::PICML::Port> dstExternalDelegate_end() const { return Udm::AssocEndAttr< ::PICML::Port>(impl, meta_dstExternalDelegate_end_); }
		void Accept(Visitor &v) { v.Visit_ExternalDelegate(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcExternalDelegate_end_;
		static ::Uml::AssociationRole meta_dstExternalDelegate_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcExternalDelegate {};
		class ACE_dstExternalDelegate {};
		typedef boost::mpl::pair< ::PICML::ExternalPortReference, ACE_srcExternalDelegate > _ACE_srcExternalDelegate__ExternalPortReference;
		typedef boost::mpl::pair< ::PICML::Port, ACE_dstExternalDelegate > _ACE_dstExternalDelegate__Port;
		typedef boost::mpl::vector< _ACE_srcExternalDelegate__ExternalPortReference, _ACE_dstExternalDelegate__Port> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export AttributeValue :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		AttributeValue() {}
		AttributeValue(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		AttributeValue(const AttributeValue &master) : MgaObject(master) {}

		static AttributeValue Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static AttributeValue Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		AttributeValue CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<AttributeValue> Instances() { return Udm::InstantiatedAttr<AttributeValue>(impl); }
		template <class Pred> Udm::InstantiatedAttr<AttributeValue, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<AttributeValue, Pred>(impl); }
		AttributeValue CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<AttributeValue> Derived() { return Udm::DerivedAttr<AttributeValue>(impl); }
		template <class Pred> Udm::DerivedAttr<AttributeValue, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<AttributeValue, Pred>(impl); }
		Udm::ArchetypeAttr<AttributeValue> Archetype() const { return Udm::ArchetypeAttr<AttributeValue>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::Property> dstAttributeValue_end() const { return Udm::AssocEndAttr< ::PICML::Property>(impl, meta_dstAttributeValue_end_); }
		Udm::AssocEndAttr< ::PICML::ReadonlyAttribute> srcAttributeValue_end() const { return Udm::AssocEndAttr< ::PICML::ReadonlyAttribute>(impl, meta_srcAttributeValue_end_); }
		void Accept(Visitor &v) { v.Visit_AttributeValue(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_dstAttributeValue_end_;
		static ::Uml::AssociationRole meta_srcAttributeValue_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstAttributeValue {};
		class ACE_srcAttributeValue {};
		typedef boost::mpl::pair< ::PICML::Property, ACE_dstAttributeValue > _ACE_dstAttributeValue__Property;
		typedef boost::mpl::pair< ::PICML::ReadonlyAttribute, ACE_srcAttributeValue > _ACE_srcAttributeValue__ReadonlyAttribute;
		typedef boost::mpl::vector< _ACE_dstAttributeValue__Property, _ACE_srcAttributeValue__ReadonlyAttribute> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export AttributeDelegate :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		AttributeDelegate() {}
		AttributeDelegate(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		AttributeDelegate(const AttributeDelegate &master) : MgaObject(master) {}

		static AttributeDelegate Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static AttributeDelegate Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		AttributeDelegate CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<AttributeDelegate> Instances() { return Udm::InstantiatedAttr<AttributeDelegate>(impl); }
		template <class Pred> Udm::InstantiatedAttr<AttributeDelegate, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<AttributeDelegate, Pred>(impl); }
		AttributeDelegate CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<AttributeDelegate> Derived() { return Udm::DerivedAttr<AttributeDelegate>(impl); }
		template <class Pred> Udm::DerivedAttr<AttributeDelegate, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<AttributeDelegate, Pred>(impl); }
		Udm::ArchetypeAttr<AttributeDelegate> Archetype() const { return Udm::ArchetypeAttr<AttributeDelegate>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::AttributeMapping> srcAttributeDelegate_end() const { return Udm::AssocEndAttr< ::PICML::AttributeMapping>(impl, meta_srcAttributeDelegate_end_); }
		Udm::AssocEndAttr< ::PICML::ReadonlyAttribute> dstAttributeDelegate_end() const { return Udm::AssocEndAttr< ::PICML::ReadonlyAttribute>(impl, meta_dstAttributeDelegate_end_); }
		void Accept(Visitor &v) { v.Visit_AttributeDelegate(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcAttributeDelegate_end_;
		static ::Uml::AssociationRole meta_dstAttributeDelegate_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcAttributeDelegate {};
		class ACE_dstAttributeDelegate {};
		typedef boost::mpl::pair< ::PICML::AttributeMapping, ACE_srcAttributeDelegate > _ACE_srcAttributeDelegate__AttributeMapping;
		typedef boost::mpl::pair< ::PICML::ReadonlyAttribute, ACE_dstAttributeDelegate > _ACE_dstAttributeDelegate__ReadonlyAttribute;
		typedef boost::mpl::vector< _ACE_srcAttributeDelegate__AttributeMapping, _ACE_dstAttributeDelegate__ReadonlyAttribute> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export AttributeMapping :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		AttributeMapping() {}
		AttributeMapping(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		AttributeMapping(const AttributeMapping &master) : MgaObject(master) {}

		static AttributeMapping Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static AttributeMapping Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		AttributeMapping CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<AttributeMapping> Instances() { return Udm::InstantiatedAttr<AttributeMapping>(impl); }
		template <class Pred> Udm::InstantiatedAttr<AttributeMapping, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<AttributeMapping, Pred>(impl); }
		AttributeMapping CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<AttributeMapping> Derived() { return Udm::DerivedAttr<AttributeMapping>(impl); }
		template <class Pred> Udm::DerivedAttr<AttributeMapping, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<AttributeMapping, Pred>(impl); }
		Udm::ArchetypeAttr<AttributeMapping> Archetype() const { return Udm::ArchetypeAttr<AttributeMapping>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::AttributeMappingValue, ::PICML::Property> dstAttributeMappingValue() const { return Udm::AClassPointerAttr< ::PICML::AttributeMappingValue, ::PICML::Property>(impl, meta_dstAttributeMappingValue, meta_dstAttributeMappingValue_rev); }
		Udm::AClassAssocAttr< ::PICML::AttributeDelegate, ::PICML::ReadonlyAttribute> dstAttributeDelegate() const { return Udm::AClassAssocAttr< ::PICML::AttributeDelegate, ::PICML::ReadonlyAttribute>(impl, meta_dstAttributeDelegate, meta_dstAttributeDelegate_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::AttributeDelegate, ::PICML::ReadonlyAttribute, Pred> dstAttributeDelegate_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::AttributeDelegate, ::PICML::ReadonlyAttribute, Pred>(impl, meta_dstAttributeDelegate, meta_dstAttributeDelegate_rev); }
		Udm::AClassAssocAttr< ::PICML::AttributeMappingDelegate, ::PICML::AttributeMapping> dstAttributeMappingDelegate() const { return Udm::AClassAssocAttr< ::PICML::AttributeMappingDelegate, ::PICML::AttributeMapping>(impl, meta_dstAttributeMappingDelegate, meta_dstAttributeMappingDelegate_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::AttributeMappingDelegate, ::PICML::AttributeMapping, Pred> dstAttributeMappingDelegate_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::AttributeMappingDelegate, ::PICML::AttributeMapping, Pred>(impl, meta_dstAttributeMappingDelegate, meta_dstAttributeMappingDelegate_rev); }
		Udm::AClassPointerAttr< ::PICML::AttributeMappingDelegate, ::PICML::AttributeMapping> srcAttributeMappingDelegate() const { return Udm::AClassPointerAttr< ::PICML::AttributeMappingDelegate, ::PICML::AttributeMapping>(impl, meta_srcAttributeMappingDelegate, meta_srcAttributeMappingDelegate_rev); }
		Udm::PointerAttr< ::PICML::ReadonlyAttribute> ref() const { return Udm::PointerAttr< ::PICML::ReadonlyAttribute>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_AttributeMapping(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstAttributeMappingValue;
		static ::Uml::AssociationRole meta_dstAttributeMappingValue_rev;
		static ::Uml::AssociationRole meta_dstAttributeDelegate;
		static ::Uml::AssociationRole meta_dstAttributeDelegate_rev;
		static ::Uml::AssociationRole meta_dstAttributeMappingDelegate;
		static ::Uml::AssociationRole meta_dstAttributeMappingDelegate_rev;
		static ::Uml::AssociationRole meta_srcAttributeMappingDelegate;
		static ::Uml::AssociationRole meta_srcAttributeMappingDelegate_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::ReadonlyAttribute, AR_ref > _AR_ref__ReadonlyAttribute;
		typedef boost::mpl::vector< _AR_ref__ReadonlyAttribute> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstAttributeMappingValue {};
		class AR_dstAttributeDelegate {};
		class AR_dstAttributeMappingDelegate {};
		class AR_srcAttributeMappingDelegate {};
		typedef boost::mpl::pair< ::PICML::Property, boost::mpl::pair< ::PICML::AttributeMappingValue, AR_dstAttributeMappingValue > > _AR_dstAttributeMappingValue__AttributeMappingValue__Property;
		typedef boost::mpl::pair< ::PICML::ReadonlyAttribute, boost::mpl::pair< ::PICML::AttributeDelegate, AR_dstAttributeDelegate > > _AR_dstAttributeDelegate__AttributeDelegate__ReadonlyAttribute;
		typedef boost::mpl::pair< ::PICML::AttributeMapping, boost::mpl::pair< ::PICML::AttributeMappingDelegate, AR_dstAttributeMappingDelegate > > _AR_dstAttributeMappingDelegate__AttributeMappingDelegate__AttributeMapping;
		typedef boost::mpl::pair< ::PICML::AttributeMapping, boost::mpl::pair< ::PICML::AttributeMappingDelegate, AR_srcAttributeMappingDelegate > > _AR_srcAttributeMappingDelegate__AttributeMappingDelegate__AttributeMapping;
		typedef boost::mpl::vector< _AR_dstAttributeMappingValue__AttributeMappingValue__Property, _AR_srcAttributeMappingDelegate__AttributeMappingDelegate__AttributeMapping> AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstAttributeDelegate__AttributeDelegate__ReadonlyAttribute, _AR_dstAttributeMappingDelegate__AttributeMappingDelegate__AttributeMapping> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export AttributeMappingValue :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		AttributeMappingValue() {}
		AttributeMappingValue(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		AttributeMappingValue(const AttributeMappingValue &master) : MgaObject(master) {}

		static AttributeMappingValue Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static AttributeMappingValue Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		AttributeMappingValue CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<AttributeMappingValue> Instances() { return Udm::InstantiatedAttr<AttributeMappingValue>(impl); }
		template <class Pred> Udm::InstantiatedAttr<AttributeMappingValue, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<AttributeMappingValue, Pred>(impl); }
		AttributeMappingValue CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<AttributeMappingValue> Derived() { return Udm::DerivedAttr<AttributeMappingValue>(impl); }
		template <class Pred> Udm::DerivedAttr<AttributeMappingValue, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<AttributeMappingValue, Pred>(impl); }
		Udm::ArchetypeAttr<AttributeMappingValue> Archetype() const { return Udm::ArchetypeAttr<AttributeMappingValue>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::AttributeMapping> srcAttributeMappingValue_end() const { return Udm::AssocEndAttr< ::PICML::AttributeMapping>(impl, meta_srcAttributeMappingValue_end_); }
		Udm::AssocEndAttr< ::PICML::Property> dstAttributeMappingValue_end() const { return Udm::AssocEndAttr< ::PICML::Property>(impl, meta_dstAttributeMappingValue_end_); }
		void Accept(Visitor &v) { v.Visit_AttributeMappingValue(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcAttributeMappingValue_end_;
		static ::Uml::AssociationRole meta_dstAttributeMappingValue_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcAttributeMappingValue {};
		class ACE_dstAttributeMappingValue {};
		typedef boost::mpl::pair< ::PICML::AttributeMapping, ACE_srcAttributeMappingValue > _ACE_srcAttributeMappingValue__AttributeMapping;
		typedef boost::mpl::pair< ::PICML::Property, ACE_dstAttributeMappingValue > _ACE_dstAttributeMappingValue__Property;
		typedef boost::mpl::vector< _ACE_srcAttributeMappingValue__AttributeMapping, _ACE_dstAttributeMappingValue__Property> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export AttributeMappingDelegate :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		AttributeMappingDelegate() {}
		AttributeMappingDelegate(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		AttributeMappingDelegate(const AttributeMappingDelegate &master) : MgaObject(master) {}

		static AttributeMappingDelegate Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static AttributeMappingDelegate Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		AttributeMappingDelegate CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<AttributeMappingDelegate> Instances() { return Udm::InstantiatedAttr<AttributeMappingDelegate>(impl); }
		template <class Pred> Udm::InstantiatedAttr<AttributeMappingDelegate, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<AttributeMappingDelegate, Pred>(impl); }
		AttributeMappingDelegate CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<AttributeMappingDelegate> Derived() { return Udm::DerivedAttr<AttributeMappingDelegate>(impl); }
		template <class Pred> Udm::DerivedAttr<AttributeMappingDelegate, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<AttributeMappingDelegate, Pred>(impl); }
		Udm::ArchetypeAttr<AttributeMappingDelegate> Archetype() const { return Udm::ArchetypeAttr<AttributeMappingDelegate>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::AttributeMapping> srcAttributeMappingDelegate_end() const { return Udm::AssocEndAttr< ::PICML::AttributeMapping>(impl, meta_srcAttributeMappingDelegate_end_); }
		Udm::AssocEndAttr< ::PICML::AttributeMapping> dstAttributeMappingDelegate_end() const { return Udm::AssocEndAttr< ::PICML::AttributeMapping>(impl, meta_dstAttributeMappingDelegate_end_); }
		void Accept(Visitor &v) { v.Visit_AttributeMappingDelegate(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcAttributeMappingDelegate_end_;
		static ::Uml::AssociationRole meta_dstAttributeMappingDelegate_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcAttributeMappingDelegate {};
		class ACE_dstAttributeMappingDelegate {};
		typedef boost::mpl::pair< ::PICML::AttributeMapping, ACE_srcAttributeMappingDelegate > _ACE_srcAttributeMappingDelegate__AttributeMapping;
		typedef boost::mpl::pair< ::PICML::AttributeMapping, ACE_dstAttributeMappingDelegate > _ACE_dstAttributeMappingDelegate__AttributeMapping;
		typedef boost::mpl::vector< _ACE_srcAttributeMappingDelegate__AttributeMapping, _ACE_dstAttributeMappingDelegate__AttributeMapping> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export SupportsDelegate :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		SupportsDelegate() {}
		SupportsDelegate(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		SupportsDelegate(const SupportsDelegate &master) : MgaObject(master) {}

		static SupportsDelegate Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static SupportsDelegate Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		SupportsDelegate CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<SupportsDelegate> Instances() { return Udm::InstantiatedAttr<SupportsDelegate>(impl); }
		template <class Pred> Udm::InstantiatedAttr<SupportsDelegate, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<SupportsDelegate, Pred>(impl); }
		SupportsDelegate CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<SupportsDelegate> Derived() { return Udm::DerivedAttr<SupportsDelegate>(impl); }
		template <class Pred> Udm::DerivedAttr<SupportsDelegate, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<SupportsDelegate, Pred>(impl); }
		Udm::ArchetypeAttr<SupportsDelegate> Archetype() const { return Udm::ArchetypeAttr<SupportsDelegate>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ProvidedRequestPort> dstSupportsDelegate_end() const { return Udm::AssocEndAttr< ::PICML::ProvidedRequestPort>(impl, meta_dstSupportsDelegate_end_); }
		Udm::AssocEndAttr< ::PICML::Supports> srcSupportsDelegate_end() const { return Udm::AssocEndAttr< ::PICML::Supports>(impl, meta_srcSupportsDelegate_end_); }
		void Accept(Visitor &v) { v.Visit_SupportsDelegate(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_dstSupportsDelegate_end_;
		static ::Uml::AssociationRole meta_srcSupportsDelegate_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstSupportsDelegate {};
		class ACE_srcSupportsDelegate {};
		typedef boost::mpl::pair< ::PICML::ProvidedRequestPort, ACE_dstSupportsDelegate > _ACE_dstSupportsDelegate__ProvidedRequestPort;
		typedef boost::mpl::pair< ::PICML::Supports, ACE_srcSupportsDelegate > _ACE_srcSupportsDelegate__Supports;
		typedef boost::mpl::vector< _ACE_dstSupportsDelegate__ProvidedRequestPort, _ACE_srcSupportsDelegate__Supports> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export InvokePortBase :  virtual  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		InvokePortBase() {}
		InvokePortBase(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		InvokePortBase(const InvokePortBase &master) : MgaObject(master) {}

		static InvokePortBase Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static InvokePortBase Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		InvokePortBase CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<InvokePortBase> Instances() { return Udm::InstantiatedAttr<InvokePortBase>(impl); }
		template <class Pred> Udm::InstantiatedAttr<InvokePortBase, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<InvokePortBase, Pred>(impl); }
		InvokePortBase CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<InvokePortBase> Derived() { return Udm::DerivedAttr<InvokePortBase>(impl); }
		template <class Pred> Udm::DerivedAttr<InvokePortBase, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<InvokePortBase, Pred>(impl); }
		Udm::ArchetypeAttr<InvokePortBase> Archetype() const { return Udm::ArchetypeAttr<InvokePortBase>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::invoke, ::PICML::RequiredRequestPort> srcinvoke() const { return Udm::AClassAssocAttr< ::PICML::invoke, ::PICML::RequiredRequestPort>(impl, meta_srcinvoke, meta_srcinvoke_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::invoke, ::PICML::RequiredRequestPort, Pred> srcinvoke_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::invoke, ::PICML::RequiredRequestPort, Pred>(impl, meta_srcinvoke, meta_srcinvoke_rev); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcinvoke;
		static ::Uml::AssociationRole meta_srcinvoke_rev;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcinvoke {};
		typedef boost::mpl::pair< ::PICML::RequiredRequestPort, boost::mpl::pair< ::PICML::invoke, AR_srcinvoke > > _AR_srcinvoke__invoke__RequiredRequestPort;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcinvoke__invoke__RequiredRequestPort> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ImplementationCapability :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		ImplementationCapability() {}
		ImplementationCapability(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ImplementationCapability(const ImplementationCapability &master) : MgaObject(master) {}

		static ImplementationCapability Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ImplementationCapability Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ImplementationCapability CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ImplementationCapability> Instances() { return Udm::InstantiatedAttr<ImplementationCapability>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ImplementationCapability, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ImplementationCapability, Pred>(impl); }
		ImplementationCapability CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ImplementationCapability> Derived() { return Udm::DerivedAttr<ImplementationCapability>(impl); }
		template <class Pred> Udm::DerivedAttr<ImplementationCapability, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ImplementationCapability, Pred>(impl); }
		Udm::ArchetypeAttr<ImplementationCapability> Archetype() const { return Udm::ArchetypeAttr<ImplementationCapability>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ComponentImplementationContainer>(impl, meta_ComponentImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ComponentImplementation> srcImplementationCapability_end() const { return Udm::AssocEndAttr< ::PICML::ComponentImplementation>(impl, meta_srcImplementationCapability_end_); }
		Udm::AssocEndAttr< ::PICML::Capability> dstImplementationCapability_end() const { return Udm::AssocEndAttr< ::PICML::Capability>(impl, meta_dstImplementationCapability_end_); }
		void Accept(Visitor &v) { v.Visit_ImplementationCapability(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcImplementationCapability_end_;
		static ::Uml::AssociationRole meta_dstImplementationCapability_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentImplementationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementationContainer, PR_ComponentImplementationContainer_parent > _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer;
		typedef boost::mpl::vector< _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcImplementationCapability {};
		class ACE_dstImplementationCapability {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementation, ACE_srcImplementationCapability > _ACE_srcImplementationCapability__ComponentImplementation;
		typedef boost::mpl::pair< ::PICML::Capability, ACE_dstImplementationCapability > _ACE_dstImplementationCapability__Capability;
		typedef boost::mpl::vector< _ACE_srcImplementationCapability__ComponentImplementation, _ACE_dstImplementationCapability__Capability> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ImplementationDependsOn :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		ImplementationDependsOn() {}
		ImplementationDependsOn(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ImplementationDependsOn(const ImplementationDependsOn &master) : MgaObject(master) {}

		static ImplementationDependsOn Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ImplementationDependsOn Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ImplementationDependsOn CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ImplementationDependsOn> Instances() { return Udm::InstantiatedAttr<ImplementationDependsOn>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ImplementationDependsOn, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ImplementationDependsOn, Pred>(impl); }
		ImplementationDependsOn CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ImplementationDependsOn> Derived() { return Udm::DerivedAttr<ImplementationDependsOn>(impl); }
		template <class Pred> Udm::DerivedAttr<ImplementationDependsOn, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ImplementationDependsOn, Pred>(impl); }
		Udm::ArchetypeAttr<ImplementationDependsOn> Archetype() const { return Udm::ArchetypeAttr<ImplementationDependsOn>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ComponentImplementationContainer>(impl, meta_ComponentImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ComponentImplementation> srcImplementationDependsOn_end() const { return Udm::AssocEndAttr< ::PICML::ComponentImplementation>(impl, meta_srcImplementationDependsOn_end_); }
		Udm::AssocEndAttr< ::PICML::ImplementationDependency> dstImplementationDependsOn_end() const { return Udm::AssocEndAttr< ::PICML::ImplementationDependency>(impl, meta_dstImplementationDependsOn_end_); }
		void Accept(Visitor &v) { v.Visit_ImplementationDependsOn(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcImplementationDependsOn_end_;
		static ::Uml::AssociationRole meta_dstImplementationDependsOn_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentImplementationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementationContainer, PR_ComponentImplementationContainer_parent > _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer;
		typedef boost::mpl::vector< _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcImplementationDependsOn {};
		class ACE_dstImplementationDependsOn {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementation, ACE_srcImplementationDependsOn > _ACE_srcImplementationDependsOn__ComponentImplementation;
		typedef boost::mpl::pair< ::PICML::ImplementationDependency, ACE_dstImplementationDependsOn > _ACE_dstImplementationDependsOn__ImplementationDependency;
		typedef boost::mpl::vector< _ACE_srcImplementationDependsOn__ComponentImplementation, _ACE_dstImplementationDependsOn__ImplementationDependency> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Implements :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		Implements() {}
		Implements(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Implements(const Implements &master) : MgaObject(master) {}

		static Implements Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Implements Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Implements CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Implements> Instances() { return Udm::InstantiatedAttr<Implements>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Implements, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Implements, Pred>(impl); }
		Implements CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Implements> Derived() { return Udm::DerivedAttr<Implements>(impl); }
		template <class Pred> Udm::DerivedAttr<Implements, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Implements, Pred>(impl); }
		Udm::ArchetypeAttr<Implements> Archetype() const { return Udm::ArchetypeAttr<Implements>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ComponentImplementationContainer>(impl, meta_ComponentImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ComponentImplementation> srcImplements_end() const { return Udm::AssocEndAttr< ::PICML::ComponentImplementation>(impl, meta_srcImplements_end_); }
		Udm::AssocEndAttr< ::PICML::ComponentRef> dstImplements_end() const { return Udm::AssocEndAttr< ::PICML::ComponentRef>(impl, meta_dstImplements_end_); }
		void Accept(Visitor &v) { v.Visit_Implements(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcImplements_end_;
		static ::Uml::AssociationRole meta_dstImplements_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentImplementationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementationContainer, PR_ComponentImplementationContainer_parent > _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer;
		typedef boost::mpl::vector< _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcImplements {};
		class ACE_dstImplements {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementation, ACE_srcImplements > _ACE_srcImplements__ComponentImplementation;
		typedef boost::mpl::pair< ::PICML::ComponentRef, ACE_dstImplements > _ACE_dstImplements__ComponentRef;
		typedef boost::mpl::vector< _ACE_srcImplements__ComponentImplementation, _ACE_dstImplements__ComponentRef> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentImplementation :  virtual  public Implemenation {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		ComponentImplementation() {}
		ComponentImplementation(Udm::ObjectImpl *impl) : Implemenation(impl) {}
		ComponentImplementation(const ComponentImplementation &master) : Implemenation(master) {}

		static ComponentImplementation Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentImplementation Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentImplementation CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentImplementation> Instances() { return Udm::InstantiatedAttr<ComponentImplementation>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentImplementation, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentImplementation, Pred>(impl); }
		ComponentImplementation CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentImplementation> Derived() { return Udm::DerivedAttr<ComponentImplementation>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentImplementation, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentImplementation, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentImplementation> Archetype() const { return Udm::ArchetypeAttr<ComponentImplementation>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::ImplementationDependsOn, ::PICML::ImplementationDependency> dstImplementationDependsOn() const { return Udm::AClassAssocAttr< ::PICML::ImplementationDependsOn, ::PICML::ImplementationDependency>(impl, meta_dstImplementationDependsOn, meta_dstImplementationDependsOn_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ImplementationDependsOn, ::PICML::ImplementationDependency, Pred> dstImplementationDependsOn_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ImplementationDependsOn, ::PICML::ImplementationDependency, Pred>(impl, meta_dstImplementationDependsOn, meta_dstImplementationDependsOn_rev); }
		Udm::AClassAssocAttr< ::PICML::ImplementationCapability, ::PICML::Capability> dstImplementationCapability() const { return Udm::AClassAssocAttr< ::PICML::ImplementationCapability, ::PICML::Capability>(impl, meta_dstImplementationCapability, meta_dstImplementationCapability_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ImplementationCapability, ::PICML::Capability, Pred> dstImplementationCapability_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ImplementationCapability, ::PICML::Capability, Pred>(impl, meta_dstImplementationCapability, meta_dstImplementationCapability_rev); }
		Udm::AClassPointerAttr< ::PICML::Implements, ::PICML::ComponentRef> dstImplements() const { return Udm::AClassPointerAttr< ::PICML::Implements, ::PICML::ComponentRef>(impl, meta_dstImplements, meta_dstImplements_rev); }
		Udm::AssocAttr< ::PICML::ComponentImplementationReference> referedbyComponentImplementationReference() const { return Udm::AssocAttr< ::PICML::ComponentImplementationReference>(impl, meta_referedbyComponentImplementationReference); }
		template <class Pred> Udm::AssocAttr< ::PICML::ComponentImplementationReference, Pred> referedbyComponentImplementationReference_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::ComponentImplementationReference, Pred>(impl, meta_referedbyComponentImplementationReference); }
		Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ComponentImplementationContainer>(impl, meta_ComponentImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstImplementationDependsOn;
		static ::Uml::AssociationRole meta_dstImplementationDependsOn_rev;
		static ::Uml::AssociationRole meta_dstImplementationCapability;
		static ::Uml::AssociationRole meta_dstImplementationCapability_rev;
		static ::Uml::AssociationRole meta_dstImplements;
		static ::Uml::AssociationRole meta_dstImplements_rev;
		static ::Uml::AssociationRole meta_referedbyComponentImplementationReference;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentImplementationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementationContainer, PR_ComponentImplementationContainer_parent > _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer;
		typedef boost::mpl::vector< _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyComponentImplementationReference {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementationReference, AR_referedbyComponentImplementationReference > _AR_referedbyComponentImplementationReference__ComponentImplementationReference;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyComponentImplementationReference__ComponentImplementationReference> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstImplementationDependsOn {};
		class AR_dstImplementationCapability {};
		class AR_dstImplements {};
		typedef boost::mpl::pair< ::PICML::ImplementationDependency, boost::mpl::pair< ::PICML::ImplementationDependsOn, AR_dstImplementationDependsOn > > _AR_dstImplementationDependsOn__ImplementationDependsOn__ImplementationDependency;
		typedef boost::mpl::pair< ::PICML::Capability, boost::mpl::pair< ::PICML::ImplementationCapability, AR_dstImplementationCapability > > _AR_dstImplementationCapability__ImplementationCapability__Capability;
		typedef boost::mpl::pair< ::PICML::ComponentRef, boost::mpl::pair< ::PICML::Implements, AR_dstImplements > > _AR_dstImplements__Implements__ComponentRef;
		typedef boost::mpl::vector< _AR_dstImplements__Implements__ComponentRef> AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstImplementationDependsOn__ImplementationDependsOn__ImplementationDependency, _AR_dstImplementationCapability__ImplementationCapability__Capability> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentAssembly :  public ComponentImplementation {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ComponentAssembly() {}
		ComponentAssembly(Udm::ObjectImpl *impl) : ComponentImplementation(impl), Implemenation(impl) {}
		ComponentAssembly(const ComponentAssembly &master) : ComponentImplementation(master), Implemenation(master) {}

		static ComponentAssembly Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentAssembly Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentAssembly CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentAssembly> Instances() { return Udm::InstantiatedAttr<ComponentAssembly>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentAssembly, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentAssembly, Pred>(impl); }
		ComponentAssembly CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentAssembly> Derived() { return Udm::DerivedAttr<ComponentAssembly>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentAssembly, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentAssembly, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentAssembly> Archetype() const { return Udm::ArchetypeAttr<ComponentAssembly>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::ComponentAssemblyReference> referedbyComponentAssemblyReference() const { return Udm::AssocAttr< ::PICML::ComponentAssemblyReference>(impl, meta_referedbyComponentAssemblyReference); }
		template <class Pred> Udm::AssocAttr< ::PICML::ComponentAssemblyReference, Pred> referedbyComponentAssemblyReference_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::ComponentAssemblyReference, Pred>(impl, meta_referedbyComponentAssemblyReference); }
		Udm::AClassPointerAttr< ::PICML::CriticalPath, ::PICML::PathReference> dstCriticalPath() const { return Udm::AClassPointerAttr< ::PICML::CriticalPath, ::PICML::PathReference>(impl, meta_dstCriticalPath, meta_dstCriticalPath_rev); }
		Udm::ChildrenAttr< ::PICML::Property> Property_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, meta_Property_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); }
		Udm::ChildrenAttr< ::PICML::ComponentPackage> ComponentPackage_children() const { return Udm::ChildrenAttr< ::PICML::ComponentPackage>(impl, meta_ComponentPackage_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentPackage, Pred> ComponentPackage_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentPackage, Pred>(impl, meta_ComponentPackage_children); }
		Udm::ChildrenAttr< ::PICML::ComponentPackageReference> ComponentPackageReference_children() const { return Udm::ChildrenAttr< ::PICML::ComponentPackageReference>(impl, meta_ComponentPackageReference_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentPackageReference, Pred> ComponentPackageReference_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentPackageReference, Pred>(impl, meta_ComponentPackageReference_children); }
		Udm::ChildrenAttr< ::PICML::Requirement> Requirement_children() const { return Udm::ChildrenAttr< ::PICML::Requirement>(impl, meta_Requirement_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Requirement, Pred> Requirement_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Requirement, Pred>(impl, meta_Requirement_children); }
		Udm::ChildrenAttr< ::PICML::Component> Component_children() const { return Udm::ChildrenAttr< ::PICML::Component>(impl, meta_Component_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Component, Pred> Component_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Component, Pred>(impl, meta_Component_children); }
		Udm::ChildrenAttr< ::PICML::ComponentAssembly> ComponentAssembly_children() const { return Udm::ChildrenAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentAssembly, Pred> ComponentAssembly_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentAssembly, Pred>(impl, meta_ComponentAssembly_children); }
		Udm::ChildrenAttr< ::PICML::ProvidedRequestPort> ProvidedRequestPort_children() const { return Udm::ChildrenAttr< ::PICML::ProvidedRequestPort>(impl, meta_ProvidedRequestPort_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred> ProvidedRequestPort_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred>(impl, meta_ProvidedRequestPort_children); }
		Udm::ChildrenAttr< ::PICML::RequiredRequestPort> RequiredRequestPort_children() const { return Udm::ChildrenAttr< ::PICML::RequiredRequestPort>(impl, meta_RequiredRequestPort_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred> RequiredRequestPort_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred>(impl, meta_RequiredRequestPort_children); }
		Udm::ChildrenAttr< ::PICML::InEventPort> InEventPort_children() const { return Udm::ChildrenAttr< ::PICML::InEventPort>(impl, meta_InEventPort_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InEventPort, Pred> InEventPort_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InEventPort, Pred>(impl, meta_InEventPort_children); }
		Udm::ChildrenAttr< ::PICML::OutEventPort> OutEventPort_children() const { return Udm::ChildrenAttr< ::PICML::OutEventPort>(impl, meta_OutEventPort_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OutEventPort, Pred> OutEventPort_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OutEventPort, Pred>(impl, meta_OutEventPort_children); }
		Udm::ChildrenAttr< ::PICML::emit> emit_children() const { return Udm::ChildrenAttr< ::PICML::emit>(impl, meta_emit_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::emit, Pred> emit_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::emit, Pred>(impl, meta_emit_children); }
		Udm::ChildrenAttr< ::PICML::EventSourceDelegate> EventSourceDelegate_children() const { return Udm::ChildrenAttr< ::PICML::EventSourceDelegate>(impl, meta_EventSourceDelegate_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::EventSourceDelegate, Pred> EventSourceDelegate_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::EventSourceDelegate, Pred>(impl, meta_EventSourceDelegate_children); }
		Udm::ChildrenAttr< ::PICML::EventSinkDelegate> EventSinkDelegate_children() const { return Udm::ChildrenAttr< ::PICML::EventSinkDelegate>(impl, meta_EventSinkDelegate_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::EventSinkDelegate, Pred> EventSinkDelegate_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::EventSinkDelegate, Pred>(impl, meta_EventSinkDelegate_children); }
		Udm::ChildrenAttr< ::PICML::deliverTo> deliverTo_children() const { return Udm::ChildrenAttr< ::PICML::deliverTo>(impl, meta_deliverTo_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::deliverTo, Pred> deliverTo_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::deliverTo, Pred>(impl, meta_deliverTo_children); }
		Udm::ChildrenAttr< ::PICML::publish> publish_children() const { return Udm::ChildrenAttr< ::PICML::publish>(impl, meta_publish_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::publish, Pred> publish_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::publish, Pred>(impl, meta_publish_children); }
		Udm::ChildrenAttr< ::PICML::AssemblyDeployRequirement> AssemblyDeployRequirement_children() const { return Udm::ChildrenAttr< ::PICML::AssemblyDeployRequirement>(impl, meta_AssemblyDeployRequirement_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AssemblyDeployRequirement, Pred> AssemblyDeployRequirement_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AssemblyDeployRequirement, Pred>(impl, meta_AssemblyDeployRequirement_children); }
		Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference> ComponentAssemblyReference_children() const { return Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference>(impl, meta_ComponentAssemblyReference_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference, Pred> ComponentAssemblyReference_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference, Pred>(impl, meta_ComponentAssemblyReference_children); }
		Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_children() const { return Udm::ChildrenAttr< ::PICML::ComponentRef>(impl, meta_ComponentRef_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, meta_ComponentRef_children); }
		Udm::ChildrenAttr< ::PICML::AssemblyselectRequirement> AssemblyselectRequirement_children() const { return Udm::ChildrenAttr< ::PICML::AssemblyselectRequirement>(impl, meta_AssemblyselectRequirement_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AssemblyselectRequirement, Pred> AssemblyselectRequirement_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AssemblyselectRequirement, Pred>(impl, meta_AssemblyselectRequirement_children); }
		Udm::ChildrenAttr< ::PICML::AttributeValue> AttributeValue_children() const { return Udm::ChildrenAttr< ::PICML::AttributeValue>(impl, meta_AttributeValue_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AttributeValue, Pred> AttributeValue_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AttributeValue, Pred>(impl, meta_AttributeValue_children); }
		Udm::ChildrenAttr< ::PICML::AttributeDelegate> AttributeDelegate_children() const { return Udm::ChildrenAttr< ::PICML::AttributeDelegate>(impl, meta_AttributeDelegate_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AttributeDelegate, Pred> AttributeDelegate_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AttributeDelegate, Pred>(impl, meta_AttributeDelegate_children); }
		Udm::ChildrenAttr< ::PICML::AttributeMappingValue> AttributeMappingValue_children() const { return Udm::ChildrenAttr< ::PICML::AttributeMappingValue>(impl, meta_AttributeMappingValue_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AttributeMappingValue, Pred> AttributeMappingValue_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AttributeMappingValue, Pred>(impl, meta_AttributeMappingValue_children); }
		Udm::ChildrenAttr< ::PICML::AssemblyConfigProperty> AssemblyConfigProperty_children() const { return Udm::ChildrenAttr< ::PICML::AssemblyConfigProperty>(impl, meta_AssemblyConfigProperty_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AssemblyConfigProperty, Pred> AssemblyConfigProperty_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AssemblyConfigProperty, Pred>(impl, meta_AssemblyConfigProperty_children); }
		Udm::ChildrenAttr< ::PICML::FacetDelegate> FacetDelegate_children() const { return Udm::ChildrenAttr< ::PICML::FacetDelegate>(impl, meta_FacetDelegate_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::FacetDelegate, Pred> FacetDelegate_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::FacetDelegate, Pred>(impl, meta_FacetDelegate_children); }
		Udm::ChildrenAttr< ::PICML::invoke> invoke_children() const { return Udm::ChildrenAttr< ::PICML::invoke>(impl, meta_invoke_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::invoke, Pred> invoke_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::invoke, Pred>(impl, meta_invoke_children); }
		Udm::ChildrenAttr< ::PICML::ReceptacleDelegate> ReceptacleDelegate_children() const { return Udm::ChildrenAttr< ::PICML::ReceptacleDelegate>(impl, meta_ReceptacleDelegate_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ReceptacleDelegate, Pred> ReceptacleDelegate_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ReceptacleDelegate, Pred>(impl, meta_ReceptacleDelegate_children); }
		Udm::ChildrenAttr< ::PICML::AttributeMappingDelegate> AttributeMappingDelegate_children() const { return Udm::ChildrenAttr< ::PICML::AttributeMappingDelegate>(impl, meta_AttributeMappingDelegate_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AttributeMappingDelegate, Pred> AttributeMappingDelegate_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AttributeMappingDelegate, Pred>(impl, meta_AttributeMappingDelegate_children); }
		Udm::ChildrenAttr< ::PICML::ExternalDelegate> ExternalDelegate_children() const { return Udm::ChildrenAttr< ::PICML::ExternalDelegate>(impl, meta_ExternalDelegate_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ExternalDelegate, Pred> ExternalDelegate_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ExternalDelegate, Pred>(impl, meta_ExternalDelegate_children); }
		Udm::ChildrenAttr< ::PICML::AttributeMapping> AttributeMapping_children() const { return Udm::ChildrenAttr< ::PICML::AttributeMapping>(impl, meta_AttributeMapping_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AttributeMapping, Pred> AttributeMapping_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AttributeMapping, Pred>(impl, meta_AttributeMapping_children); }
		Udm::ChildrenAttr< ::PICML::PublishConnector> PublishConnector_children() const { return Udm::ChildrenAttr< ::PICML::PublishConnector>(impl, meta_PublishConnector_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PublishConnector, Pred> PublishConnector_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PublishConnector, Pred>(impl, meta_PublishConnector_children); }
		Udm::ChildrenAttr< ::PICML::ExternalPortReference> ExternalPortReference_children() const { return Udm::ChildrenAttr< ::PICML::ExternalPortReference>(impl, meta_ExternalPortReference_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ExternalPortReference, Pred> ExternalPortReference_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ExternalPortReference, Pred>(impl, meta_ExternalPortReference_children); }
		Udm::ChildrenAttr< ::PICML::SupportsDelegate> SupportsDelegate_children() const { return Udm::ChildrenAttr< ::PICML::SupportsDelegate>(impl, meta_SupportsDelegate_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SupportsDelegate, Pred> SupportsDelegate_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SupportsDelegate, Pred>(impl, meta_SupportsDelegate_children); }
		Udm::ChildrenAttr< ::PICML::Implemenation> Implemenation_kind_children() const { return Udm::ChildrenAttr< ::PICML::Implemenation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Implemenation, Pred> Implemenation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Implemenation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RTRequirements> RTRequirements_kind_children() const { return Udm::ChildrenAttr< ::PICML::RTRequirements>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RTRequirements, Pred> RTRequirements_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RTRequirements, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ECRequirements> ECRequirements_kind_children() const { return Udm::ChildrenAttr< ::PICML::ECRequirements>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ECRequirements, Pred> ECRequirements_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ECRequirements, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference> ComponentAssemblyReference_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference, Pred> ComponentAssemblyReference_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentAssembly> ComponentAssembly_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentAssembly>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentAssembly, Pred> ComponentAssembly_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentAssembly, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ExternalPortReference> ExternalPortReference_kind_children() const { return Udm::ChildrenAttr< ::PICML::ExternalPortReference>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ExternalPortReference, Pred> ExternalPortReference_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ExternalPortReference, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::GraphVertex> GraphVertex_kind_children() const { return Udm::ChildrenAttr< ::PICML::GraphVertex>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::GraphVertex, Pred> GraphVertex_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::GraphVertex, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::CollocationGroupMember> CollocationGroupMember_kind_children() const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred> CollocationGroupMember_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::invoke> invoke_kind_children() const { return Udm::ChildrenAttr< ::PICML::invoke>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::invoke, Pred> invoke_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::invoke, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::AssemblyselectRequirement> AssemblyselectRequirement_kind_children() const { return Udm::ChildrenAttr< ::PICML::AssemblyselectRequirement>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AssemblyselectRequirement, Pred> AssemblyselectRequirement_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AssemblyselectRequirement, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::AssemblyConfigProperty> AssemblyConfigProperty_kind_children() const { return Udm::ChildrenAttr< ::PICML::AssemblyConfigProperty>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AssemblyConfigProperty, Pred> AssemblyConfigProperty_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AssemblyConfigProperty, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PublishConnector> PublishConnector_kind_children() const { return Udm::ChildrenAttr< ::PICML::PublishConnector>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PublishConnector, Pred> PublishConnector_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PublishConnector, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::publish> publish_kind_children() const { return Udm::ChildrenAttr< ::PICML::publish>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::publish, Pred> publish_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::publish, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::deliverTo> deliverTo_kind_children() const { return Udm::ChildrenAttr< ::PICML::deliverTo>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::deliverTo, Pred> deliverTo_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::deliverTo, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::AssemblyDeployRequirement> AssemblyDeployRequirement_kind_children() const { return Udm::ChildrenAttr< ::PICML::AssemblyDeployRequirement>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AssemblyDeployRequirement, Pred> AssemblyDeployRequirement_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AssemblyDeployRequirement, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::emit> emit_kind_children() const { return Udm::ChildrenAttr< ::PICML::emit>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::emit, Pred> emit_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::emit, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ReceptacleDelegate> ReceptacleDelegate_kind_children() const { return Udm::ChildrenAttr< ::PICML::ReceptacleDelegate>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ReceptacleDelegate, Pred> ReceptacleDelegate_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ReceptacleDelegate, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::FacetDelegate> FacetDelegate_kind_children() const { return Udm::ChildrenAttr< ::PICML::FacetDelegate>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::FacetDelegate, Pred> FacetDelegate_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::FacetDelegate, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::EventSourceDelegate> EventSourceDelegate_kind_children() const { return Udm::ChildrenAttr< ::PICML::EventSourceDelegate>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::EventSourceDelegate, Pred> EventSourceDelegate_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::EventSourceDelegate, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::EventSinkDelegate> EventSinkDelegate_kind_children() const { return Udm::ChildrenAttr< ::PICML::EventSinkDelegate>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::EventSinkDelegate, Pred> EventSinkDelegate_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::EventSinkDelegate, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ExternalDelegate> ExternalDelegate_kind_children() const { return Udm::ChildrenAttr< ::PICML::ExternalDelegate>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ExternalDelegate, Pred> ExternalDelegate_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ExternalDelegate, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::AttributeValue> AttributeValue_kind_children() const { return Udm::ChildrenAttr< ::PICML::AttributeValue>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AttributeValue, Pred> AttributeValue_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AttributeValue, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::AttributeDelegate> AttributeDelegate_kind_children() const { return Udm::ChildrenAttr< ::PICML::AttributeDelegate>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AttributeDelegate, Pred> AttributeDelegate_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AttributeDelegate, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::AttributeMapping> AttributeMapping_kind_children() const { return Udm::ChildrenAttr< ::PICML::AttributeMapping>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AttributeMapping, Pred> AttributeMapping_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AttributeMapping, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::AttributeMappingValue> AttributeMappingValue_kind_children() const { return Udm::ChildrenAttr< ::PICML::AttributeMappingValue>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AttributeMappingValue, Pred> AttributeMappingValue_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AttributeMappingValue, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::AttributeMappingDelegate> AttributeMappingDelegate_kind_children() const { return Udm::ChildrenAttr< ::PICML::AttributeMappingDelegate>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AttributeMappingDelegate, Pred> AttributeMappingDelegate_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AttributeMappingDelegate, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::SupportsDelegate> SupportsDelegate_kind_children() const { return Udm::ChildrenAttr< ::PICML::SupportsDelegate>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SupportsDelegate, Pred> SupportsDelegate_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SupportsDelegate, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::InvokePortBase> InvokePortBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::InvokePortBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InvokePortBase, Pred> InvokePortBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InvokePortBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentImplementation> ComponentImplementation_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentImplementation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentImplementation, Pred> ComponentImplementation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentImplementation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::CommonPortAttrs> CommonPortAttrs_kind_children() const { return Udm::ChildrenAttr< ::PICML::CommonPortAttrs>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CommonPortAttrs, Pred> CommonPortAttrs_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CommonPortAttrs, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentPackage> ComponentPackage_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentPackage>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentPackage, Pred> ComponentPackage_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentPackage, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentPackageReference> ComponentPackageReference_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentPackageReference>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentPackageReference, Pred> ComponentPackageReference_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentPackageReference, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Requirement> Requirement_kind_children() const { return Udm::ChildrenAttr< ::PICML::Requirement>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Requirement, Pred> Requirement_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Requirement, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RequirementBase> RequirementBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::RequirementBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RequirementBase, Pred> RequirementBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RequirementBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Taggable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Port> Port_kind_children() const { return Udm::ChildrenAttr< ::PICML::Port>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Port, Pred> Port_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Port, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Manageable> Manageable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Manageable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Manageable, Pred> Manageable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Manageable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentRef>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ProvidedRequestPort> ProvidedRequestPort_kind_children() const { return Udm::ChildrenAttr< ::PICML::ProvidedRequestPort>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred> ProvidedRequestPort_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::InEventPort> InEventPort_kind_children() const { return Udm::ChildrenAttr< ::PICML::InEventPort>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InEventPort, Pred> InEventPort_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InEventPort, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::OutEventPort> OutEventPort_kind_children() const { return Udm::ChildrenAttr< ::PICML::OutEventPort>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OutEventPort, Pred> OutEventPort_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OutEventPort, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RequiredRequestPort> RequiredRequestPort_kind_children() const { return Udm::ChildrenAttr< ::PICML::RequiredRequestPort>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred> RequiredRequestPort_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Component> Component_kind_children() const { return Udm::ChildrenAttr< ::PICML::Component>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Component, Pred> Component_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Component, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::SupportsInterfaces> SupportsInterfaces_kind_children() const { return Udm::ChildrenAttr< ::PICML::SupportsInterfaces>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SupportsInterfaces, Pred> SupportsInterfaces_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SupportsInterfaces, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MemberType> MemberType_kind_children() const { return Udm::ChildrenAttr< ::PICML::MemberType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MemberType, Pred> MemberType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MemberType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::NamedType> NamedType_kind_children() const { return Udm::ChildrenAttr< ::PICML::NamedType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::NamedType, Pred> NamedType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::NamedType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::BehaviorModel> BehaviorModel_kind_children() const { return Udm::ChildrenAttr< ::PICML::BehaviorModel>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::BehaviorModel, Pred> BehaviorModel_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::BehaviorModel, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::SingleInputBase> SingleInputBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::SingleInputBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SingleInputBase, Pred> SingleInputBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SingleInputBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MultiInputBase> MultiInputBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::MultiInputBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MultiInputBase, Pred> MultiInputBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MultiInputBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MultiOutputBase> MultiOutputBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::MultiOutputBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MultiOutputBase, Pred> MultiOutputBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MultiOutputBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::SingleOutputBase> SingleOutputBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::SingleOutputBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SingleOutputBase, Pred> SingleOutputBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SingleOutputBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::TopLevelBehavior> TopLevelBehavior_kind_children() const { return Udm::ChildrenAttr< ::PICML::TopLevelBehavior>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TopLevelBehavior, Pred> TopLevelBehavior_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TopLevelBehavior, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::QueryInputBase> QueryInputBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::QueryInputBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::QueryInputBase, Pred> QueryInputBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::QueryInputBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentAssembly(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyComponentAssemblyReference;
		static ::Uml::AssociationRole meta_dstCriticalPath;
		static ::Uml::AssociationRole meta_dstCriticalPath_rev;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_ComponentPackage_children;
		static ::Uml::CompositionChildRole meta_ComponentPackageReference_children;
		static ::Uml::CompositionChildRole meta_Requirement_children;
		static ::Uml::CompositionChildRole meta_Component_children;
		static ::Uml::CompositionChildRole meta_ComponentAssembly_children;
		static ::Uml::CompositionChildRole meta_ProvidedRequestPort_children;
		static ::Uml::CompositionChildRole meta_RequiredRequestPort_children;
		static ::Uml::CompositionChildRole meta_InEventPort_children;
		static ::Uml::CompositionChildRole meta_OutEventPort_children;
		static ::Uml::CompositionChildRole meta_emit_children;
		static ::Uml::CompositionChildRole meta_EventSourceDelegate_children;
		static ::Uml::CompositionChildRole meta_EventSinkDelegate_children;
		static ::Uml::CompositionChildRole meta_deliverTo_children;
		static ::Uml::CompositionChildRole meta_publish_children;
		static ::Uml::CompositionChildRole meta_AssemblyDeployRequirement_children;
		static ::Uml::CompositionChildRole meta_ComponentAssemblyReference_children;
		static ::Uml::CompositionChildRole meta_ComponentRef_children;
		static ::Uml::CompositionChildRole meta_AssemblyselectRequirement_children;
		static ::Uml::CompositionChildRole meta_AttributeValue_children;
		static ::Uml::CompositionChildRole meta_AttributeDelegate_children;
		static ::Uml::CompositionChildRole meta_AttributeMappingValue_children;
		static ::Uml::CompositionChildRole meta_AssemblyConfigProperty_children;
		static ::Uml::CompositionChildRole meta_FacetDelegate_children;
		static ::Uml::CompositionChildRole meta_invoke_children;
		static ::Uml::CompositionChildRole meta_ReceptacleDelegate_children;
		static ::Uml::CompositionChildRole meta_AttributeMappingDelegate_children;
		static ::Uml::CompositionChildRole meta_ExternalDelegate_children;
		static ::Uml::CompositionChildRole meta_AttributeMapping_children;
		static ::Uml::CompositionChildRole meta_PublishConnector_children;
		static ::Uml::CompositionChildRole meta_ExternalPortReference_children;
		static ::Uml::CompositionChildRole meta_SupportsDelegate_children;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly, ::PICML::ComponentImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Property_children {};
		class CR_ComponentPackage_children {};
		class CR_ComponentPackageReference_children {};
		class CR_Requirement_children {};
		class CR_Component_children {};
		class CR_ComponentAssembly_children {};
		class CR_ProvidedRequestPort_children {};
		class CR_RequiredRequestPort_children {};
		class CR_InEventPort_children {};
		class CR_OutEventPort_children {};
		class CR_emit_children {};
		class CR_EventSourceDelegate_children {};
		class CR_EventSinkDelegate_children {};
		class CR_deliverTo_children {};
		class CR_publish_children {};
		class CR_AssemblyDeployRequirement_children {};
		class CR_ComponentAssemblyReference_children {};
		class CR_ComponentRef_children {};
		class CR_AssemblyselectRequirement_children {};
		class CR_AttributeValue_children {};
		class CR_AttributeDelegate_children {};
		class CR_AttributeMappingValue_children {};
		class CR_AssemblyConfigProperty_children {};
		class CR_FacetDelegate_children {};
		class CR_invoke_children {};
		class CR_ReceptacleDelegate_children {};
		class CR_AttributeMappingDelegate_children {};
		class CR_ExternalDelegate_children {};
		class CR_AttributeMapping_children {};
		class CR_PublishConnector_children {};
		class CR_ExternalPortReference_children {};
		class CR_SupportsDelegate_children {};
		typedef boost::mpl::pair< ::PICML::Property, CR_Property_children > _CR_Property_children__Property;
		typedef boost::mpl::pair< ::PICML::ComponentPackage, CR_ComponentPackage_children > _CR_ComponentPackage_children__ComponentPackage;
		typedef boost::mpl::pair< ::PICML::ComponentPackageReference, CR_ComponentPackageReference_children > _CR_ComponentPackageReference_children__ComponentPackageReference;
		typedef boost::mpl::pair< ::PICML::Requirement, CR_Requirement_children > _CR_Requirement_children__Requirement;
		typedef boost::mpl::pair< ::PICML::Component, CR_Component_children > _CR_Component_children__Component;
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, CR_ComponentAssembly_children > _CR_ComponentAssembly_children__ComponentAssembly;
		typedef boost::mpl::pair< ::PICML::ProvidedRequestPort, CR_ProvidedRequestPort_children > _CR_ProvidedRequestPort_children__ProvidedRequestPort;
		typedef boost::mpl::pair< ::PICML::RequiredRequestPort, CR_RequiredRequestPort_children > _CR_RequiredRequestPort_children__RequiredRequestPort;
		typedef boost::mpl::pair< ::PICML::InEventPort, CR_InEventPort_children > _CR_InEventPort_children__InEventPort;
		typedef boost::mpl::pair< ::PICML::OutEventPort, CR_OutEventPort_children > _CR_OutEventPort_children__OutEventPort;
		typedef boost::mpl::pair< ::PICML::emit, CR_emit_children > _CR_emit_children__emit;
		typedef boost::mpl::pair< ::PICML::EventSourceDelegate, CR_EventSourceDelegate_children > _CR_EventSourceDelegate_children__EventSourceDelegate;
		typedef boost::mpl::pair< ::PICML::EventSinkDelegate, CR_EventSinkDelegate_children > _CR_EventSinkDelegate_children__EventSinkDelegate;
		typedef boost::mpl::pair< ::PICML::deliverTo, CR_deliverTo_children > _CR_deliverTo_children__deliverTo;
		typedef boost::mpl::pair< ::PICML::publish, CR_publish_children > _CR_publish_children__publish;
		typedef boost::mpl::pair< ::PICML::AssemblyDeployRequirement, CR_AssemblyDeployRequirement_children > _CR_AssemblyDeployRequirement_children__AssemblyDeployRequirement;
		typedef boost::mpl::pair< ::PICML::ComponentAssemblyReference, CR_ComponentAssemblyReference_children > _CR_ComponentAssemblyReference_children__ComponentAssemblyReference;
		typedef boost::mpl::pair< ::PICML::ComponentRef, CR_ComponentRef_children > _CR_ComponentRef_children__ComponentRef;
		typedef boost::mpl::pair< ::PICML::AssemblyselectRequirement, CR_AssemblyselectRequirement_children > _CR_AssemblyselectRequirement_children__AssemblyselectRequirement;
		typedef boost::mpl::pair< ::PICML::AttributeValue, CR_AttributeValue_children > _CR_AttributeValue_children__AttributeValue;
		typedef boost::mpl::pair< ::PICML::AttributeDelegate, CR_AttributeDelegate_children > _CR_AttributeDelegate_children__AttributeDelegate;
		typedef boost::mpl::pair< ::PICML::AttributeMappingValue, CR_AttributeMappingValue_children > _CR_AttributeMappingValue_children__AttributeMappingValue;
		typedef boost::mpl::pair< ::PICML::AssemblyConfigProperty, CR_AssemblyConfigProperty_children > _CR_AssemblyConfigProperty_children__AssemblyConfigProperty;
		typedef boost::mpl::pair< ::PICML::FacetDelegate, CR_FacetDelegate_children > _CR_FacetDelegate_children__FacetDelegate;
		typedef boost::mpl::pair< ::PICML::invoke, CR_invoke_children > _CR_invoke_children__invoke;
		typedef boost::mpl::pair< ::PICML::ReceptacleDelegate, CR_ReceptacleDelegate_children > _CR_ReceptacleDelegate_children__ReceptacleDelegate;
		typedef boost::mpl::pair< ::PICML::AttributeMappingDelegate, CR_AttributeMappingDelegate_children > _CR_AttributeMappingDelegate_children__AttributeMappingDelegate;
		typedef boost::mpl::pair< ::PICML::ExternalDelegate, CR_ExternalDelegate_children > _CR_ExternalDelegate_children__ExternalDelegate;
		typedef boost::mpl::pair< ::PICML::AttributeMapping, CR_AttributeMapping_children > _CR_AttributeMapping_children__AttributeMapping;
		typedef boost::mpl::pair< ::PICML::PublishConnector, CR_PublishConnector_children > _CR_PublishConnector_children__PublishConnector;
		typedef boost::mpl::pair< ::PICML::ExternalPortReference, CR_ExternalPortReference_children > _CR_ExternalPortReference_children__ExternalPortReference;
		typedef boost::mpl::pair< ::PICML::SupportsDelegate, CR_SupportsDelegate_children > _CR_SupportsDelegate_children__SupportsDelegate;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Property_children__Property, _CR_ComponentPackage_children__ComponentPackage, _CR_ComponentPackageReference_children__ComponentPackageReference, _CR_Requirement_children__Requirement, _CR_Component_children__Component, _CR_ComponentAssembly_children__ComponentAssembly, _CR_ProvidedRequestPort_children__ProvidedRequestPort, _CR_RequiredRequestPort_children__RequiredRequestPort, _CR_InEventPort_children__InEventPort, _CR_OutEventPort_children__OutEventPort, _CR_emit_children__emit, _CR_EventSourceDelegate_children__EventSourceDelegate, _CR_EventSinkDelegate_children__EventSinkDelegate, _CR_deliverTo_children__deliverTo, _CR_publish_children__publish, _CR_AssemblyDeployRequirement_children__AssemblyDeployRequirement, _CR_ComponentAssemblyReference_children__ComponentAssemblyReference, _CR_ComponentRef_children__ComponentRef, _CR_AssemblyselectRequirement_children__AssemblyselectRequirement, _CR_AttributeValue_children__AttributeValue, _CR_AttributeDelegate_children__AttributeDelegate, _CR_AttributeMappingValue_children__AttributeMappingValue, _CR_AssemblyConfigProperty_children__AssemblyConfigProperty, _CR_FacetDelegate_children__FacetDelegate, _CR_invoke_children__invoke, _CR_ReceptacleDelegate_children__ReceptacleDelegate, _CR_AttributeMappingDelegate_children__AttributeMappingDelegate, _CR_ExternalDelegate_children__ExternalDelegate, _CR_AttributeMapping_children__AttributeMapping, _CR_PublishConnector_children__PublishConnector, _CR_ExternalPortReference_children__ExternalPortReference, _CR_SupportsDelegate_children__SupportsDelegate> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::RTRequirements, ::PICML::ECRequirements, ::PICML::ComponentAssemblyReference, ::PICML::ComponentAssembly, ::PICML::ExternalPortReference, ::PICML::invoke, ::PICML::AssemblyselectRequirement, ::PICML::AssemblyConfigProperty, ::PICML::PublishConnector, ::PICML::publish, ::PICML::deliverTo, ::PICML::AssemblyDeployRequirement, ::PICML::emit, ::PICML::ReceptacleDelegate, ::PICML::FacetDelegate, ::PICML::EventSourceDelegate, ::PICML::EventSinkDelegate, ::PICML::ExternalDelegate, ::PICML::AttributeValue, ::PICML::AttributeDelegate, ::PICML::AttributeMapping, ::PICML::AttributeMappingValue, ::PICML::AttributeMappingDelegate, ::PICML::SupportsDelegate, ::PICML::ComponentPackage, ::PICML::ComponentPackageReference, ::PICML::Requirement, ::PICML::Property, ::PICML::ComponentRef, ::PICML::ProvidedRequestPort, ::PICML::InEventPort, ::PICML::OutEventPort, ::PICML::RequiredRequestPort, ::PICML::Component> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyComponentAssemblyReference {};
		typedef boost::mpl::pair< ::PICML::ComponentAssemblyReference, AR_referedbyComponentAssemblyReference > _AR_referedbyComponentAssemblyReference__ComponentAssemblyReference;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyComponentAssemblyReference__ComponentAssemblyReference> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstCriticalPath {};
		typedef boost::mpl::pair< ::PICML::PathReference, boost::mpl::pair< ::PICML::CriticalPath, AR_dstCriticalPath > > _AR_dstCriticalPath__CriticalPath__PathReference;
		typedef boost::mpl::vector< _AR_dstCriticalPath__CriticalPath__PathReference> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentImplementationContainer :  public ImplementationContainer {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ComponentImplementationContainer() {}
		ComponentImplementationContainer(Udm::ObjectImpl *impl) : ImplementationContainer(impl) {}
		ComponentImplementationContainer(const ComponentImplementationContainer &master) : ImplementationContainer(master) {}

		static ComponentImplementationContainer Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentImplementationContainer Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentImplementationContainer CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentImplementationContainer> Instances() { return Udm::InstantiatedAttr<ComponentImplementationContainer>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentImplementationContainer, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentImplementationContainer, Pred>(impl); }
		ComponentImplementationContainer CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentImplementationContainer> Derived() { return Udm::DerivedAttr<ComponentImplementationContainer>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentImplementationContainer, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentImplementationContainer, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentImplementationContainer> Archetype() const { return Udm::ArchetypeAttr<ComponentImplementationContainer>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildAttr< ::PICML::Implements> Implements_child() const { return Udm::ChildAttr< ::PICML::Implements>(impl, meta_Implements_child); }
		Udm::ChildrenAttr< ::PICML::ImplementationDependsOn> ImplementationDependsOn_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationDependsOn>(impl, meta_ImplementationDependsOn_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationDependsOn, Pred> ImplementationDependsOn_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationDependsOn, Pred>(impl, meta_ImplementationDependsOn_children); }
		Udm::ChildAttr< ::PICML::ComponentRef> ComponentRef_child() const { return Udm::ChildAttr< ::PICML::ComponentRef>(impl, meta_ComponentRef_child); }
		Udm::ChildrenAttr< ::PICML::ImplementationDependency> ImplementationDependency_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationDependency>(impl, meta_ImplementationDependency_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationDependency, Pred> ImplementationDependency_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationDependency, Pred>(impl, meta_ImplementationDependency_children); }
		Udm::ChildrenAttr< ::PICML::ImplementationCapability> ImplementationCapability_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationCapability>(impl, meta_ImplementationCapability_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationCapability, Pred> ImplementationCapability_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationCapability, Pred>(impl, meta_ImplementationCapability_children); }
		Udm::ChildrenAttr< ::PICML::Capability> Capability_children() const { return Udm::ChildrenAttr< ::PICML::Capability>(impl, meta_Capability_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Capability, Pred> Capability_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Capability, Pred>(impl, meta_Capability_children); }
		Udm::ChildrenAttr< ::PICML::CriticalPath> CriticalPath_children() const { return Udm::ChildrenAttr< ::PICML::CriticalPath>(impl, meta_CriticalPath_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CriticalPath, Pred> CriticalPath_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CriticalPath, Pred>(impl, meta_CriticalPath_children); }
		Udm::ChildAttr< ::PICML::PathReference> PathReference_child() const { return Udm::ChildAttr< ::PICML::PathReference>(impl, meta_PathReference_child); }
		Udm::ChildrenAttr< ::PICML::ComponentImplementation> ComponentImplementation_children() const { return Udm::ChildrenAttr< ::PICML::ComponentImplementation>(impl, meta_ComponentImplementation_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentImplementation, Pred> ComponentImplementation_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentImplementation, Pred>(impl, meta_ComponentImplementation_children); }
		Udm::ChildrenAttr< ::PICML::Implemenation> Implemenation_kind_children() const { return Udm::ChildrenAttr< ::PICML::Implemenation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Implemenation, Pred> Implemenation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Implemenation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentAssembly> ComponentAssembly_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentAssembly>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentAssembly, Pred> ComponentAssembly_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentAssembly, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PathReference> PathReference_kind_children() const { return Udm::ChildrenAttr< ::PICML::PathReference>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PathReference, Pred> PathReference_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PathReference, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::CollocationGroupMember> CollocationGroupMember_kind_children() const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred> CollocationGroupMember_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ImplementationCapability> ImplementationCapability_kind_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationCapability>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationCapability, Pred> ImplementationCapability_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationCapability, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ImplementationDependsOn> ImplementationDependsOn_kind_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationDependsOn>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationDependsOn, Pred> ImplementationDependsOn_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationDependsOn, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Implements> Implements_kind_children() const { return Udm::ChildrenAttr< ::PICML::Implements>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Implements, Pred> Implements_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Implements, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentImplementation> ComponentImplementation_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentImplementation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentImplementation, Pred> ComponentImplementation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentImplementation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::CriticalPath> CriticalPath_kind_children() const { return Udm::ChildrenAttr< ::PICML::CriticalPath>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CriticalPath, Pred> CriticalPath_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CriticalPath, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MonolithicImplementation> MonolithicImplementation_kind_children() const { return Udm::ChildrenAttr< ::PICML::MonolithicImplementation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MonolithicImplementation, Pred> MonolithicImplementation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MonolithicImplementation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Capability> Capability_kind_children() const { return Udm::ChildrenAttr< ::PICML::Capability>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Capability, Pred> Capability_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Capability, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ImplementationDependency> ImplementationDependency_kind_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationDependency>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationDependency, Pred> ImplementationDependency_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationDependency, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RequirementSatisfier> RequirementSatisfier_kind_children() const { return Udm::ChildrenAttr< ::PICML::RequirementSatisfier>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred> RequirementSatisfier_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Manageable> Manageable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Manageable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Manageable, Pred> Manageable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Manageable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentRef>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::ComponentImplementations> ComponentImplementations_parent() const { return Udm::ParentAttr< ::PICML::ComponentImplementations>(impl, meta_ComponentImplementations_parent); }
		Udm::ParentAttr< ::PICML::ComponentImplementations> parent() const { return Udm::ParentAttr< ::PICML::ComponentImplementations>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentImplementationContainer(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Implements_child;
		static ::Uml::CompositionChildRole meta_ImplementationDependsOn_children;
		static ::Uml::CompositionChildRole meta_ComponentRef_child;
		static ::Uml::CompositionChildRole meta_ImplementationDependency_children;
		static ::Uml::CompositionChildRole meta_ImplementationCapability_children;
		static ::Uml::CompositionChildRole meta_Capability_children;
		static ::Uml::CompositionChildRole meta_CriticalPath_children;
		static ::Uml::CompositionChildRole meta_PathReference_child;
		static ::Uml::CompositionChildRole meta_ComponentImplementation_children;
		static ::Uml::CompositionParentRole meta_ComponentImplementations_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentImplementations_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementations, PR_ComponentImplementations_parent > _PR_ComponentImplementations_parent__ComponentImplementations;
		typedef boost::mpl::vector< _PR_ComponentImplementations_parent__ComponentImplementations> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentImplementations> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Implements_child {};
		class CR_ImplementationDependsOn_children {};
		class CR_ComponentRef_child {};
		class CR_ImplementationDependency_children {};
		class CR_ImplementationCapability_children {};
		class CR_Capability_children {};
		class CR_CriticalPath_children {};
		class CR_PathReference_child {};
		class CR_ComponentImplementation_children {};
		typedef boost::mpl::pair< ::PICML::Implements, CR_Implements_child > _CR_Implements_child__Implements;
		typedef boost::mpl::pair< ::PICML::ImplementationDependsOn, CR_ImplementationDependsOn_children > _CR_ImplementationDependsOn_children__ImplementationDependsOn;
		typedef boost::mpl::pair< ::PICML::ComponentRef, CR_ComponentRef_child > _CR_ComponentRef_child__ComponentRef;
		typedef boost::mpl::pair< ::PICML::ImplementationDependency, CR_ImplementationDependency_children > _CR_ImplementationDependency_children__ImplementationDependency;
		typedef boost::mpl::pair< ::PICML::ImplementationCapability, CR_ImplementationCapability_children > _CR_ImplementationCapability_children__ImplementationCapability;
		typedef boost::mpl::pair< ::PICML::Capability, CR_Capability_children > _CR_Capability_children__Capability;
		typedef boost::mpl::pair< ::PICML::CriticalPath, CR_CriticalPath_children > _CR_CriticalPath_children__CriticalPath;
		typedef boost::mpl::pair< ::PICML::PathReference, CR_PathReference_child > _CR_PathReference_child__PathReference;
		typedef boost::mpl::pair< ::PICML::ComponentImplementation, CR_ComponentImplementation_children > _CR_ComponentImplementation_children__ComponentImplementation;
		typedef boost::mpl::vector< _CR_Implements_child__Implements, _CR_ComponentRef_child__ComponentRef, _CR_PathReference_child__PathReference> ChildrenSingle;
		typedef boost::mpl::vector< _CR_ImplementationDependsOn_children__ImplementationDependsOn, _CR_ImplementationDependency_children__ImplementationDependency, _CR_ImplementationCapability_children__ImplementationCapability, _CR_Capability_children__Capability, _CR_CriticalPath_children__CriticalPath, _CR_ComponentImplementation_children__ComponentImplementation> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::InfoProperty, ::PICML::ConfigProperty, ::PICML::MonolithprimaryArtifact, ::PICML::MonolithDeployRequirement, ::PICML::MonolithExecParameter, ::PICML::ComponentServantArtifact, ::PICML::ComponentImplementationArtifact, ::PICML::ComponentAssembly, ::PICML::PathReference, ::PICML::ImplementationCapability, ::PICML::ImplementationDependsOn, ::PICML::Implements, ::PICML::ComponentImplementation, ::PICML::CriticalPath, ::PICML::MonolithicImplementation, ::PICML::ImplementationArtifactReference, ::PICML::Capability, ::PICML::ImplementationDependency, ::PICML::ImplementationRequirement, ::PICML::Property, ::PICML::ComponentRef> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export CriticalPath :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		CriticalPath() {}
		CriticalPath(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		CriticalPath(const CriticalPath &master) : MgaObject(master) {}

		static CriticalPath Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static CriticalPath Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		CriticalPath CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<CriticalPath> Instances() { return Udm::InstantiatedAttr<CriticalPath>(impl); }
		template <class Pred> Udm::InstantiatedAttr<CriticalPath, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<CriticalPath, Pred>(impl); }
		CriticalPath CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<CriticalPath> Derived() { return Udm::DerivedAttr<CriticalPath>(impl); }
		template <class Pred> Udm::DerivedAttr<CriticalPath, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<CriticalPath, Pred>(impl); }
		Udm::ArchetypeAttr<CriticalPath> Archetype() const { return Udm::ArchetypeAttr<CriticalPath>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ComponentImplementationContainer>(impl, meta_ComponentImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ComponentAssembly> srcCriticalPath_end() const { return Udm::AssocEndAttr< ::PICML::ComponentAssembly>(impl, meta_srcCriticalPath_end_); }
		Udm::AssocEndAttr< ::PICML::PathReference> dstCriticalPath_end() const { return Udm::AssocEndAttr< ::PICML::PathReference>(impl, meta_dstCriticalPath_end_); }
		void Accept(Visitor &v) { v.Visit_CriticalPath(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcCriticalPath_end_;
		static ::Uml::AssociationRole meta_dstCriticalPath_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentImplementationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementationContainer, PR_ComponentImplementationContainer_parent > _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer;
		typedef boost::mpl::vector< _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcCriticalPath {};
		class ACE_dstCriticalPath {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, ACE_srcCriticalPath > _ACE_srcCriticalPath__ComponentAssembly;
		typedef boost::mpl::pair< ::PICML::PathReference, ACE_dstCriticalPath > _ACE_dstCriticalPath__PathReference;
		typedef boost::mpl::vector< _ACE_srcCriticalPath__ComponentAssembly, _ACE_dstCriticalPath__PathReference> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentImplementationReference :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		ComponentImplementationReference() {}
		ComponentImplementationReference(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ComponentImplementationReference(const ComponentImplementationReference &master) : MgaObject(master) {}

		static ComponentImplementationReference Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentImplementationReference Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentImplementationReference CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentImplementationReference> Instances() { return Udm::InstantiatedAttr<ComponentImplementationReference>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentImplementationReference, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentImplementationReference, Pred>(impl); }
		ComponentImplementationReference CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentImplementationReference> Derived() { return Udm::DerivedAttr<ComponentImplementationReference>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentImplementationReference, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentImplementationReference, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentImplementationReference> Archetype() const { return Udm::ArchetypeAttr<ComponentImplementationReference>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::ComponentImplementation> ref() const { return Udm::PointerAttr< ::PICML::ComponentImplementation>(impl, meta_ref); }
		Udm::AClassAssocAttr< ::PICML::Implementation, ::PICML::ComponentPackage> srcImplementation() const { return Udm::AClassAssocAttr< ::PICML::Implementation, ::PICML::ComponentPackage>(impl, meta_srcImplementation, meta_srcImplementation_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::Implementation, ::PICML::ComponentPackage, Pred> srcImplementation_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::Implementation, ::PICML::ComponentPackage, Pred>(impl, meta_srcImplementation, meta_srcImplementation_rev); }
		Udm::ParentAttr< ::PICML::PackageContainer> PackageContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageContainer>(impl, meta_PackageContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentImplementationReference(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_srcImplementation;
		static ::Uml::AssociationRole meta_srcImplementation_rev;
		static ::Uml::CompositionParentRole meta_PackageContainer_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_PackageContainer_parent {};
		typedef boost::mpl::pair< ::PICML::PackageContainer, PR_PackageContainer_parent > _PR_PackageContainer_parent__PackageContainer;
		typedef boost::mpl::vector< _PR_PackageContainer_parent__PackageContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PackageContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementation, AR_ref > _AR_ref__ComponentImplementation;
		typedef boost::mpl::vector< _AR_ref__ComponentImplementation> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcImplementation {};
		typedef boost::mpl::pair< ::PICML::ComponentPackage, boost::mpl::pair< ::PICML::Implementation, AR_srcImplementation > > _AR_srcImplementation__Implementation__ComponentPackage;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcImplementation__Implementation__ComponentPackage> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export MonolithicImplementation :  public MonolithicImplementationBase,  public ComponentImplementation {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		MonolithicImplementation() {}
		MonolithicImplementation(Udm::ObjectImpl *impl) : MonolithicImplementationBase(impl),ComponentImplementation(impl), Implemenation(impl) {}
		MonolithicImplementation(const MonolithicImplementation &master) : MonolithicImplementationBase(master),ComponentImplementation(master), Implemenation(master) {}

		static MonolithicImplementation Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static MonolithicImplementation Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		MonolithicImplementation CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<MonolithicImplementation> Instances() { return Udm::InstantiatedAttr<MonolithicImplementation>(impl); }
		template <class Pred> Udm::InstantiatedAttr<MonolithicImplementation, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<MonolithicImplementation, Pred>(impl); }
		MonolithicImplementation CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<MonolithicImplementation> Derived() { return Udm::DerivedAttr<MonolithicImplementation>(impl); }
		template <class Pred> Udm::DerivedAttr<MonolithicImplementation, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<MonolithicImplementation, Pred>(impl); }
		Udm::ArchetypeAttr<MonolithicImplementation> Archetype() const { return Udm::ArchetypeAttr<MonolithicImplementation>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr defaultVersion() const { return Udm::StringAttr(impl, meta_defaultVersion); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_MonolithicImplementation(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_defaultVersion;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PackageConfBasePackage :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		PackageConfBasePackage() {}
		PackageConfBasePackage(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		PackageConfBasePackage(const PackageConfBasePackage &master) : MgaObject(master) {}

		static PackageConfBasePackage Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PackageConfBasePackage Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PackageConfBasePackage CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PackageConfBasePackage> Instances() { return Udm::InstantiatedAttr<PackageConfBasePackage>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PackageConfBasePackage, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PackageConfBasePackage, Pred>(impl); }
		PackageConfBasePackage CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PackageConfBasePackage> Derived() { return Udm::DerivedAttr<PackageConfBasePackage>(impl); }
		template <class Pred> Udm::DerivedAttr<PackageConfBasePackage, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PackageConfBasePackage, Pred>(impl); }
		Udm::ArchetypeAttr<PackageConfBasePackage> Archetype() const { return Udm::ArchetypeAttr<PackageConfBasePackage>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageConfigurationContainer>(impl, meta_PackageConfigurationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::PackageConfiguration> srcPackageConfBasePackage_end() const { return Udm::AssocEndAttr< ::PICML::PackageConfiguration>(impl, meta_srcPackageConfBasePackage_end_); }
		Udm::AssocEndAttr< ::PICML::ComponentPackage> dstPackageConfBasePackage_end() const { return Udm::AssocEndAttr< ::PICML::ComponentPackage>(impl, meta_dstPackageConfBasePackage_end_); }
		void Accept(Visitor &v) { v.Visit_PackageConfBasePackage(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::AssociationRole meta_srcPackageConfBasePackage_end_;
		static ::Uml::AssociationRole meta_dstPackageConfBasePackage_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_PackageConfigurationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::PackageConfigurationContainer, PR_PackageConfigurationContainer_parent > _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer;
		typedef boost::mpl::vector< _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PackageConfigurationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcPackageConfBasePackage {};
		class ACE_dstPackageConfBasePackage {};
		typedef boost::mpl::pair< ::PICML::PackageConfiguration, ACE_srcPackageConfBasePackage > _ACE_srcPackageConfBasePackage__PackageConfiguration;
		typedef boost::mpl::pair< ::PICML::ComponentPackage, ACE_dstPackageConfBasePackage > _ACE_dstPackageConfBasePackage__ComponentPackage;
		typedef boost::mpl::vector< _ACE_srcPackageConfBasePackage__PackageConfiguration, _ACE_dstPackageConfBasePackage__ComponentPackage> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PackageConfReference :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		PackageConfReference() {}
		PackageConfReference(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		PackageConfReference(const PackageConfReference &master) : MgaObject(master) {}

		static PackageConfReference Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PackageConfReference Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PackageConfReference CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PackageConfReference> Instances() { return Udm::InstantiatedAttr<PackageConfReference>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PackageConfReference, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PackageConfReference, Pred>(impl); }
		PackageConfReference CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PackageConfReference> Derived() { return Udm::DerivedAttr<PackageConfReference>(impl); }
		template <class Pred> Udm::DerivedAttr<PackageConfReference, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PackageConfReference, Pred>(impl); }
		Udm::ArchetypeAttr<PackageConfReference> Archetype() const { return Udm::ArchetypeAttr<PackageConfReference>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageConfigurationContainer>(impl, meta_PackageConfigurationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::PackageConfiguration> srcPackageConfReference_end() const { return Udm::AssocEndAttr< ::PICML::PackageConfiguration>(impl, meta_srcPackageConfReference_end_); }
		Udm::AssocEndAttr< ::PICML::ComponentPackageReference> dstPackageConfReference_end() const { return Udm::AssocEndAttr< ::PICML::ComponentPackageReference>(impl, meta_dstPackageConfReference_end_); }
		void Accept(Visitor &v) { v.Visit_PackageConfReference(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::AssociationRole meta_srcPackageConfReference_end_;
		static ::Uml::AssociationRole meta_dstPackageConfReference_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_PackageConfigurationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::PackageConfigurationContainer, PR_PackageConfigurationContainer_parent > _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer;
		typedef boost::mpl::vector< _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PackageConfigurationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcPackageConfReference {};
		class ACE_dstPackageConfReference {};
		typedef boost::mpl::pair< ::PICML::PackageConfiguration, ACE_srcPackageConfReference > _ACE_srcPackageConfReference__PackageConfiguration;
		typedef boost::mpl::pair< ::PICML::ComponentPackageReference, ACE_dstPackageConfReference > _ACE_dstPackageConfReference__ComponentPackageReference;
		typedef boost::mpl::vector< _ACE_srcPackageConfReference__PackageConfiguration, _ACE_dstPackageConfReference__ComponentPackageReference> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PackageConfigurationContainer :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		PackageConfigurationContainer() {}
		PackageConfigurationContainer(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		PackageConfigurationContainer(const PackageConfigurationContainer &master) : MgaObject(master) {}

		static PackageConfigurationContainer Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PackageConfigurationContainer Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PackageConfigurationContainer CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PackageConfigurationContainer> Instances() { return Udm::InstantiatedAttr<PackageConfigurationContainer>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PackageConfigurationContainer, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PackageConfigurationContainer, Pred>(impl); }
		PackageConfigurationContainer CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PackageConfigurationContainer> Derived() { return Udm::DerivedAttr<PackageConfigurationContainer>(impl); }
		template <class Pred> Udm::DerivedAttr<PackageConfigurationContainer, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PackageConfigurationContainer, Pred>(impl); }
		Udm::ArchetypeAttr<PackageConfigurationContainer> Archetype() const { return Udm::ArchetypeAttr<PackageConfigurationContainer>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildAttr< ::PICML::PackageConfReference> PackageConfReference_child() const { return Udm::ChildAttr< ::PICML::PackageConfReference>(impl, meta_PackageConfReference_child); }
		Udm::ChildAttr< ::PICML::PackageConfBasePackage> PackageConfBasePackage_child() const { return Udm::ChildAttr< ::PICML::PackageConfBasePackage>(impl, meta_PackageConfBasePackage_child); }
		Udm::ChildAttr< ::PICML::ComponentPackage> ComponentPackage_child() const { return Udm::ChildAttr< ::PICML::ComponentPackage>(impl, meta_ComponentPackage_child); }
		Udm::ChildAttr< ::PICML::ComponentPackageReference> ComponentPackageReference_child() const { return Udm::ChildAttr< ::PICML::ComponentPackageReference>(impl, meta_ComponentPackageReference_child); }
		Udm::ChildrenAttr< ::PICML::PackageConfConfigProperty> PackageConfConfigProperty_children() const { return Udm::ChildrenAttr< ::PICML::PackageConfConfigProperty>(impl, meta_PackageConfConfigProperty_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageConfConfigProperty, Pred> PackageConfConfigProperty_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageConfConfigProperty, Pred>(impl, meta_PackageConfConfigProperty_children); }
		Udm::ChildrenAttr< ::PICML::PackageConfSelectRequirement> PackageConfSelectRequirement_children() const { return Udm::ChildrenAttr< ::PICML::PackageConfSelectRequirement>(impl, meta_PackageConfSelectRequirement_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageConfSelectRequirement, Pred> PackageConfSelectRequirement_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageConfSelectRequirement, Pred>(impl, meta_PackageConfSelectRequirement_children); }
		Udm::ChildrenAttr< ::PICML::Requirement> Requirement_children() const { return Udm::ChildrenAttr< ::PICML::Requirement>(impl, meta_Requirement_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Requirement, Pred> Requirement_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Requirement, Pred>(impl, meta_Requirement_children); }
		Udm::ChildrenAttr< ::PICML::Property> Property_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, meta_Property_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); }
		Udm::ChildAttr< ::PICML::PackageConfSpecializedConfig> PackageConfSpecializedConfig_child() const { return Udm::ChildAttr< ::PICML::PackageConfSpecializedConfig>(impl, meta_PackageConfSpecializedConfig_child); }
		Udm::ChildrenAttr< ::PICML::PackageConfiguration> PackageConfiguration_children() const { return Udm::ChildrenAttr< ::PICML::PackageConfiguration>(impl, meta_PackageConfiguration_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageConfiguration, Pred> PackageConfiguration_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageConfiguration, Pred>(impl, meta_PackageConfiguration_children); }
		Udm::ChildrenAttr< ::PICML::RTRequirements> RTRequirements_kind_children() const { return Udm::ChildrenAttr< ::PICML::RTRequirements>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RTRequirements, Pred> RTRequirements_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RTRequirements, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ECRequirements> ECRequirements_kind_children() const { return Udm::ChildrenAttr< ::PICML::ECRequirements>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ECRequirements, Pred> ECRequirements_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ECRequirements, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PackageConfBasePackage> PackageConfBasePackage_kind_children() const { return Udm::ChildrenAttr< ::PICML::PackageConfBasePackage>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageConfBasePackage, Pred> PackageConfBasePackage_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageConfBasePackage, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PackageConfReference> PackageConfReference_kind_children() const { return Udm::ChildrenAttr< ::PICML::PackageConfReference>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageConfReference, Pred> PackageConfReference_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageConfReference, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PackageConfConfigProperty> PackageConfConfigProperty_kind_children() const { return Udm::ChildrenAttr< ::PICML::PackageConfConfigProperty>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageConfConfigProperty, Pred> PackageConfConfigProperty_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageConfConfigProperty, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PackageConfSelectRequirement> PackageConfSelectRequirement_kind_children() const { return Udm::ChildrenAttr< ::PICML::PackageConfSelectRequirement>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageConfSelectRequirement, Pred> PackageConfSelectRequirement_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageConfSelectRequirement, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PackageConfSpecializedConfig> PackageConfSpecializedConfig_kind_children() const { return Udm::ChildrenAttr< ::PICML::PackageConfSpecializedConfig>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageConfSpecializedConfig, Pred> PackageConfSpecializedConfig_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageConfSpecializedConfig, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PackageConfiguration> PackageConfiguration_kind_children() const { return Udm::ChildrenAttr< ::PICML::PackageConfiguration>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageConfiguration, Pred> PackageConfiguration_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageConfiguration, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentPackage> ComponentPackage_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentPackage>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentPackage, Pred> ComponentPackage_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentPackage, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentPackageReference> ComponentPackageReference_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentPackageReference>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentPackageReference, Pred> ComponentPackageReference_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentPackageReference, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Requirement> Requirement_kind_children() const { return Udm::ChildrenAttr< ::PICML::Requirement>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Requirement, Pred> Requirement_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Requirement, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RequirementBase> RequirementBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::RequirementBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RequirementBase, Pred> RequirementBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RequirementBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::PackageConfigurations> PackageConfigurations_parent() const { return Udm::ParentAttr< ::PICML::PackageConfigurations>(impl, meta_PackageConfigurations_parent); }
		Udm::ParentAttr< ::PICML::PackageConfigurations> parent() const { return Udm::ParentAttr< ::PICML::PackageConfigurations>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_PackageConfigurationContainer(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_PackageConfReference_child;
		static ::Uml::CompositionChildRole meta_PackageConfBasePackage_child;
		static ::Uml::CompositionChildRole meta_ComponentPackage_child;
		static ::Uml::CompositionChildRole meta_ComponentPackageReference_child;
		static ::Uml::CompositionChildRole meta_PackageConfConfigProperty_children;
		static ::Uml::CompositionChildRole meta_PackageConfSelectRequirement_children;
		static ::Uml::CompositionChildRole meta_Requirement_children;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_PackageConfSpecializedConfig_child;
		static ::Uml::CompositionChildRole meta_PackageConfiguration_children;
		static ::Uml::CompositionParentRole meta_PackageConfigurations_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_PackageConfigurations_parent {};
		typedef boost::mpl::pair< ::PICML::PackageConfigurations, PR_PackageConfigurations_parent > _PR_PackageConfigurations_parent__PackageConfigurations;
		typedef boost::mpl::vector< _PR_PackageConfigurations_parent__PackageConfigurations> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PackageConfigurations> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_PackageConfReference_child {};
		class CR_PackageConfBasePackage_child {};
		class CR_ComponentPackage_child {};
		class CR_ComponentPackageReference_child {};
		class CR_PackageConfConfigProperty_children {};
		class CR_PackageConfSelectRequirement_children {};
		class CR_Requirement_children {};
		class CR_Property_children {};
		class CR_PackageConfSpecializedConfig_child {};
		class CR_PackageConfiguration_children {};
		typedef boost::mpl::pair< ::PICML::PackageConfReference, CR_PackageConfReference_child > _CR_PackageConfReference_child__PackageConfReference;
		typedef boost::mpl::pair< ::PICML::PackageConfBasePackage, CR_PackageConfBasePackage_child > _CR_PackageConfBasePackage_child__PackageConfBasePackage;
		typedef boost::mpl::pair< ::PICML::ComponentPackage, CR_ComponentPackage_child > _CR_ComponentPackage_child__ComponentPackage;
		typedef boost::mpl::pair< ::PICML::ComponentPackageReference, CR_ComponentPackageReference_child > _CR_ComponentPackageReference_child__ComponentPackageReference;
		typedef boost::mpl::pair< ::PICML::PackageConfConfigProperty, CR_PackageConfConfigProperty_children > _CR_PackageConfConfigProperty_children__PackageConfConfigProperty;
		typedef boost::mpl::pair< ::PICML::PackageConfSelectRequirement, CR_PackageConfSelectRequirement_children > _CR_PackageConfSelectRequirement_children__PackageConfSelectRequirement;
		typedef boost::mpl::pair< ::PICML::Requirement, CR_Requirement_children > _CR_Requirement_children__Requirement;
		typedef boost::mpl::pair< ::PICML::Property, CR_Property_children > _CR_Property_children__Property;
		typedef boost::mpl::pair< ::PICML::PackageConfSpecializedConfig, CR_PackageConfSpecializedConfig_child > _CR_PackageConfSpecializedConfig_child__PackageConfSpecializedConfig;
		typedef boost::mpl::pair< ::PICML::PackageConfiguration, CR_PackageConfiguration_children > _CR_PackageConfiguration_children__PackageConfiguration;
		typedef boost::mpl::vector< _CR_PackageConfReference_child__PackageConfReference, _CR_PackageConfBasePackage_child__PackageConfBasePackage, _CR_ComponentPackage_child__ComponentPackage, _CR_ComponentPackageReference_child__ComponentPackageReference, _CR_PackageConfSpecializedConfig_child__PackageConfSpecializedConfig> ChildrenSingle;
		typedef boost::mpl::vector< _CR_PackageConfConfigProperty_children__PackageConfConfigProperty, _CR_PackageConfSelectRequirement_children__PackageConfSelectRequirement, _CR_Requirement_children__Requirement, _CR_Property_children__Property, _CR_PackageConfiguration_children__PackageConfiguration> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::RTRequirements, ::PICML::ECRequirements, ::PICML::PackageConfBasePackage, ::PICML::PackageConfReference, ::PICML::PackageConfConfigProperty, ::PICML::PackageConfSelectRequirement, ::PICML::PackageConfSpecializedConfig, ::PICML::PackageConfiguration, ::PICML::ComponentPackage, ::PICML::ComponentPackageReference, ::PICML::Requirement, ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PackageConfConfigProperty :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		PackageConfConfigProperty() {}
		PackageConfConfigProperty(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		PackageConfConfigProperty(const PackageConfConfigProperty &master) : MgaObject(master) {}

		static PackageConfConfigProperty Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PackageConfConfigProperty Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PackageConfConfigProperty CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PackageConfConfigProperty> Instances() { return Udm::InstantiatedAttr<PackageConfConfigProperty>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PackageConfConfigProperty, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PackageConfConfigProperty, Pred>(impl); }
		PackageConfConfigProperty CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PackageConfConfigProperty> Derived() { return Udm::DerivedAttr<PackageConfConfigProperty>(impl); }
		template <class Pred> Udm::DerivedAttr<PackageConfConfigProperty, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PackageConfConfigProperty, Pred>(impl); }
		Udm::ArchetypeAttr<PackageConfConfigProperty> Archetype() const { return Udm::ArchetypeAttr<PackageConfConfigProperty>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageConfigurationContainer>(impl, meta_PackageConfigurationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::PackageConfiguration> srcPackageConfConfigProperty_end() const { return Udm::AssocEndAttr< ::PICML::PackageConfiguration>(impl, meta_srcPackageConfConfigProperty_end_); }
		Udm::AssocEndAttr< ::PICML::Property> dstPackageConfConfigProperty_end() const { return Udm::AssocEndAttr< ::PICML::Property>(impl, meta_dstPackageConfConfigProperty_end_); }
		void Accept(Visitor &v) { v.Visit_PackageConfConfigProperty(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::AssociationRole meta_srcPackageConfConfigProperty_end_;
		static ::Uml::AssociationRole meta_dstPackageConfConfigProperty_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_PackageConfigurationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::PackageConfigurationContainer, PR_PackageConfigurationContainer_parent > _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer;
		typedef boost::mpl::vector< _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PackageConfigurationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcPackageConfConfigProperty {};
		class ACE_dstPackageConfConfigProperty {};
		typedef boost::mpl::pair< ::PICML::PackageConfiguration, ACE_srcPackageConfConfigProperty > _ACE_srcPackageConfConfigProperty__PackageConfiguration;
		typedef boost::mpl::pair< ::PICML::Property, ACE_dstPackageConfConfigProperty > _ACE_dstPackageConfConfigProperty__Property;
		typedef boost::mpl::vector< _ACE_srcPackageConfConfigProperty__PackageConfiguration, _ACE_dstPackageConfConfigProperty__Property> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PackageConfSelectRequirement :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		PackageConfSelectRequirement() {}
		PackageConfSelectRequirement(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		PackageConfSelectRequirement(const PackageConfSelectRequirement &master) : MgaObject(master) {}

		static PackageConfSelectRequirement Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PackageConfSelectRequirement Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PackageConfSelectRequirement CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PackageConfSelectRequirement> Instances() { return Udm::InstantiatedAttr<PackageConfSelectRequirement>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PackageConfSelectRequirement, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PackageConfSelectRequirement, Pred>(impl); }
		PackageConfSelectRequirement CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PackageConfSelectRequirement> Derived() { return Udm::DerivedAttr<PackageConfSelectRequirement>(impl); }
		template <class Pred> Udm::DerivedAttr<PackageConfSelectRequirement, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PackageConfSelectRequirement, Pred>(impl); }
		Udm::ArchetypeAttr<PackageConfSelectRequirement> Archetype() const { return Udm::ArchetypeAttr<PackageConfSelectRequirement>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageConfigurationContainer>(impl, meta_PackageConfigurationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::PackageConfiguration> srcPackageConfSelectRequirement_end() const { return Udm::AssocEndAttr< ::PICML::PackageConfiguration>(impl, meta_srcPackageConfSelectRequirement_end_); }
		Udm::AssocEndAttr< ::PICML::Requirement> dstPackageConfSelectRequirement_end() const { return Udm::AssocEndAttr< ::PICML::Requirement>(impl, meta_dstPackageConfSelectRequirement_end_); }
		void Accept(Visitor &v) { v.Visit_PackageConfSelectRequirement(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::AssociationRole meta_srcPackageConfSelectRequirement_end_;
		static ::Uml::AssociationRole meta_dstPackageConfSelectRequirement_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_PackageConfigurationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::PackageConfigurationContainer, PR_PackageConfigurationContainer_parent > _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer;
		typedef boost::mpl::vector< _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PackageConfigurationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcPackageConfSelectRequirement {};
		class ACE_dstPackageConfSelectRequirement {};
		typedef boost::mpl::pair< ::PICML::PackageConfiguration, ACE_srcPackageConfSelectRequirement > _ACE_srcPackageConfSelectRequirement__PackageConfiguration;
		typedef boost::mpl::pair< ::PICML::Requirement, ACE_dstPackageConfSelectRequirement > _ACE_dstPackageConfSelectRequirement__Requirement;
		typedef boost::mpl::vector< _ACE_srcPackageConfSelectRequirement__PackageConfiguration, _ACE_dstPackageConfSelectRequirement__Requirement> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PackageConfSpecializedConfig :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		PackageConfSpecializedConfig() {}
		PackageConfSpecializedConfig(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		PackageConfSpecializedConfig(const PackageConfSpecializedConfig &master) : MgaObject(master) {}

		static PackageConfSpecializedConfig Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PackageConfSpecializedConfig Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PackageConfSpecializedConfig CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PackageConfSpecializedConfig> Instances() { return Udm::InstantiatedAttr<PackageConfSpecializedConfig>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PackageConfSpecializedConfig, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PackageConfSpecializedConfig, Pred>(impl); }
		PackageConfSpecializedConfig CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PackageConfSpecializedConfig> Derived() { return Udm::DerivedAttr<PackageConfSpecializedConfig>(impl); }
		template <class Pred> Udm::DerivedAttr<PackageConfSpecializedConfig, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PackageConfSpecializedConfig, Pred>(impl); }
		Udm::ArchetypeAttr<PackageConfSpecializedConfig> Archetype() const { return Udm::ArchetypeAttr<PackageConfSpecializedConfig>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageConfigurationContainer>(impl, meta_PackageConfigurationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::PackageConfigurationReference> dstPackageConfSpecializedConfig_end() const { return Udm::AssocEndAttr< ::PICML::PackageConfigurationReference>(impl, meta_dstPackageConfSpecializedConfig_end_); }
		Udm::AssocEndAttr< ::PICML::PackageConfiguration> srcPackageConfSpecializedConfig_end() const { return Udm::AssocEndAttr< ::PICML::PackageConfiguration>(impl, meta_srcPackageConfSpecializedConfig_end_); }
		void Accept(Visitor &v) { v.Visit_PackageConfSpecializedConfig(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::AssociationRole meta_dstPackageConfSpecializedConfig_end_;
		static ::Uml::AssociationRole meta_srcPackageConfSpecializedConfig_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_PackageConfigurationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::PackageConfigurationContainer, PR_PackageConfigurationContainer_parent > _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer;
		typedef boost::mpl::vector< _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PackageConfigurationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstPackageConfSpecializedConfig {};
		class ACE_srcPackageConfSpecializedConfig {};
		typedef boost::mpl::pair< ::PICML::PackageConfigurationReference, ACE_dstPackageConfSpecializedConfig > _ACE_dstPackageConfSpecializedConfig__PackageConfigurationReference;
		typedef boost::mpl::pair< ::PICML::PackageConfiguration, ACE_srcPackageConfSpecializedConfig > _ACE_srcPackageConfSpecializedConfig__PackageConfiguration;
		typedef boost::mpl::vector< _ACE_dstPackageConfSpecializedConfig__PackageConfigurationReference, _ACE_srcPackageConfSpecializedConfig__PackageConfiguration> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PackageConfigurationReference :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		PackageConfigurationReference() {}
		PackageConfigurationReference(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		PackageConfigurationReference(const PackageConfigurationReference &master) : MgaObject(master) {}

		static PackageConfigurationReference Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PackageConfigurationReference Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PackageConfigurationReference CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PackageConfigurationReference> Instances() { return Udm::InstantiatedAttr<PackageConfigurationReference>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PackageConfigurationReference, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PackageConfigurationReference, Pred>(impl); }
		PackageConfigurationReference CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PackageConfigurationReference> Derived() { return Udm::DerivedAttr<PackageConfigurationReference>(impl); }
		template <class Pred> Udm::DerivedAttr<PackageConfigurationReference, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PackageConfigurationReference, Pred>(impl); }
		Udm::ArchetypeAttr<PackageConfigurationReference> Archetype() const { return Udm::ArchetypeAttr<PackageConfigurationReference>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::PackageConfSpecializedConfig, ::PICML::PackageConfiguration> srcPackageConfSpecializedConfig() const { return Udm::AClassAssocAttr< ::PICML::PackageConfSpecializedConfig, ::PICML::PackageConfiguration>(impl, meta_srcPackageConfSpecializedConfig, meta_srcPackageConfSpecializedConfig_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::PackageConfSpecializedConfig, ::PICML::PackageConfiguration, Pred> srcPackageConfSpecializedConfig_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::PackageConfSpecializedConfig, ::PICML::PackageConfiguration, Pred>(impl, meta_srcPackageConfSpecializedConfig, meta_srcPackageConfSpecializedConfig_rev); }
		Udm::PointerAttr< ::PICML::PackageConfiguration> ref() const { return Udm::PointerAttr< ::PICML::PackageConfiguration>(impl, meta_ref); }
		Udm::AClassPointerAttr< ::PICML::package, ::PICML::TopLevelPackage> srcpackage() const { return Udm::AClassPointerAttr< ::PICML::package, ::PICML::TopLevelPackage>(impl, meta_srcpackage, meta_srcpackage_rev); }
		Udm::ParentAttr< ::PICML::TopLevelPackageContainer> TopLevelPackageContainer_parent() const { return Udm::ParentAttr< ::PICML::TopLevelPackageContainer>(impl, meta_TopLevelPackageContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_PackageConfigurationReference(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcPackageConfSpecializedConfig;
		static ::Uml::AssociationRole meta_srcPackageConfSpecializedConfig_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_srcpackage;
		static ::Uml::AssociationRole meta_srcpackage_rev;
		static ::Uml::CompositionParentRole meta_TopLevelPackageContainer_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_TopLevelPackageContainer_parent {};
		typedef boost::mpl::pair< ::PICML::TopLevelPackageContainer, PR_TopLevelPackageContainer_parent > _PR_TopLevelPackageContainer_parent__TopLevelPackageContainer;
		typedef boost::mpl::vector< _PR_TopLevelPackageContainer_parent__TopLevelPackageContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::TopLevelPackageContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::PackageConfiguration, AR_ref > _AR_ref__PackageConfiguration;
		typedef boost::mpl::vector< _AR_ref__PackageConfiguration> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcPackageConfSpecializedConfig {};
		class AR_srcpackage {};
		typedef boost::mpl::pair< ::PICML::PackageConfiguration, boost::mpl::pair< ::PICML::PackageConfSpecializedConfig, AR_srcPackageConfSpecializedConfig > > _AR_srcPackageConfSpecializedConfig__PackageConfSpecializedConfig__PackageConfiguration;
		typedef boost::mpl::pair< ::PICML::TopLevelPackage, boost::mpl::pair< ::PICML::package, AR_srcpackage > > _AR_srcpackage__package__TopLevelPackage;
		typedef boost::mpl::vector< _AR_srcpackage__package__TopLevelPackage> AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcPackageConfSpecializedConfig__PackageConfSpecializedConfig__PackageConfiguration> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PackageConfiguration :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		PackageConfiguration() {}
		PackageConfiguration(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		PackageConfiguration(const PackageConfiguration &master) : MgaObject(master) {}

		static PackageConfiguration Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PackageConfiguration Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PackageConfiguration CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PackageConfiguration> Instances() { return Udm::InstantiatedAttr<PackageConfiguration>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PackageConfiguration, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PackageConfiguration, Pred>(impl); }
		PackageConfiguration CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PackageConfiguration> Derived() { return Udm::DerivedAttr<PackageConfiguration>(impl); }
		template <class Pred> Udm::DerivedAttr<PackageConfiguration, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PackageConfiguration, Pred>(impl); }
		Udm::ArchetypeAttr<PackageConfiguration> Archetype() const { return Udm::ArchetypeAttr<PackageConfiguration>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr UUID() const { return Udm::StringAttr(impl, meta_UUID); }
		Udm::StringAttr label() const { return Udm::StringAttr(impl, meta_label); }
		Udm::AClassPointerAttr< ::PICML::PackageConfSpecializedConfig, ::PICML::PackageConfigurationReference> dstPackageConfSpecializedConfig() const { return Udm::AClassPointerAttr< ::PICML::PackageConfSpecializedConfig, ::PICML::PackageConfigurationReference>(impl, meta_dstPackageConfSpecializedConfig, meta_dstPackageConfSpecializedConfig_rev); }
		Udm::AssocAttr< ::PICML::PackageConfigurationReference> referedbyPackageConfigurationReference() const { return Udm::AssocAttr< ::PICML::PackageConfigurationReference>(impl, meta_referedbyPackageConfigurationReference); }
		template <class Pred> Udm::AssocAttr< ::PICML::PackageConfigurationReference, Pred> referedbyPackageConfigurationReference_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::PackageConfigurationReference, Pred>(impl, meta_referedbyPackageConfigurationReference); }
		Udm::AClassPointerAttr< ::PICML::PackageConfBasePackage, ::PICML::ComponentPackage> dstPackageConfBasePackage() const { return Udm::AClassPointerAttr< ::PICML::PackageConfBasePackage, ::PICML::ComponentPackage>(impl, meta_dstPackageConfBasePackage, meta_dstPackageConfBasePackage_rev); }
		Udm::AClassPointerAttr< ::PICML::PackageConfReference, ::PICML::ComponentPackageReference> dstPackageConfReference() const { return Udm::AClassPointerAttr< ::PICML::PackageConfReference, ::PICML::ComponentPackageReference>(impl, meta_dstPackageConfReference, meta_dstPackageConfReference_rev); }
		Udm::AClassAssocAttr< ::PICML::PackageConfSelectRequirement, ::PICML::Requirement> dstPackageConfSelectRequirement() const { return Udm::AClassAssocAttr< ::PICML::PackageConfSelectRequirement, ::PICML::Requirement>(impl, meta_dstPackageConfSelectRequirement, meta_dstPackageConfSelectRequirement_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::PackageConfSelectRequirement, ::PICML::Requirement, Pred> dstPackageConfSelectRequirement_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::PackageConfSelectRequirement, ::PICML::Requirement, Pred>(impl, meta_dstPackageConfSelectRequirement, meta_dstPackageConfSelectRequirement_rev); }
		Udm::AClassAssocAttr< ::PICML::PackageConfConfigProperty, ::PICML::Property> dstPackageConfConfigProperty() const { return Udm::AClassAssocAttr< ::PICML::PackageConfConfigProperty, ::PICML::Property>(impl, meta_dstPackageConfConfigProperty, meta_dstPackageConfConfigProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::PackageConfConfigProperty, ::PICML::Property, Pred> dstPackageConfConfigProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::PackageConfConfigProperty, ::PICML::Property, Pred>(impl, meta_dstPackageConfConfigProperty, meta_dstPackageConfConfigProperty_rev); }
		Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageConfigurationContainer>(impl, meta_PackageConfigurationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_PackageConfiguration(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::Attribute meta_label;
		static ::Uml::AssociationRole meta_dstPackageConfSpecializedConfig;
		static ::Uml::AssociationRole meta_dstPackageConfSpecializedConfig_rev;
		static ::Uml::AssociationRole meta_referedbyPackageConfigurationReference;
		static ::Uml::AssociationRole meta_dstPackageConfBasePackage;
		static ::Uml::AssociationRole meta_dstPackageConfBasePackage_rev;
		static ::Uml::AssociationRole meta_dstPackageConfReference;
		static ::Uml::AssociationRole meta_dstPackageConfReference_rev;
		static ::Uml::AssociationRole meta_dstPackageConfSelectRequirement;
		static ::Uml::AssociationRole meta_dstPackageConfSelectRequirement_rev;
		static ::Uml::AssociationRole meta_dstPackageConfConfigProperty;
		static ::Uml::AssociationRole meta_dstPackageConfConfigProperty_rev;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_PackageConfigurationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::PackageConfigurationContainer, PR_PackageConfigurationContainer_parent > _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer;
		typedef boost::mpl::vector< _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PackageConfigurationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyPackageConfigurationReference {};
		typedef boost::mpl::pair< ::PICML::PackageConfigurationReference, AR_referedbyPackageConfigurationReference > _AR_referedbyPackageConfigurationReference__PackageConfigurationReference;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyPackageConfigurationReference__PackageConfigurationReference> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstPackageConfSpecializedConfig {};
		class AR_dstPackageConfBasePackage {};
		class AR_dstPackageConfReference {};
		class AR_dstPackageConfSelectRequirement {};
		class AR_dstPackageConfConfigProperty {};
		typedef boost::mpl::pair< ::PICML::PackageConfigurationReference, boost::mpl::pair< ::PICML::PackageConfSpecializedConfig, AR_dstPackageConfSpecializedConfig > > _AR_dstPackageConfSpecializedConfig__PackageConfSpecializedConfig__PackageConfigurationReference;
		typedef boost::mpl::pair< ::PICML::ComponentPackage, boost::mpl::pair< ::PICML::PackageConfBasePackage, AR_dstPackageConfBasePackage > > _AR_dstPackageConfBasePackage__PackageConfBasePackage__ComponentPackage;
		typedef boost::mpl::pair< ::PICML::ComponentPackageReference, boost::mpl::pair< ::PICML::PackageConfReference, AR_dstPackageConfReference > > _AR_dstPackageConfReference__PackageConfReference__ComponentPackageReference;
		typedef boost::mpl::pair< ::PICML::Requirement, boost::mpl::pair< ::PICML::PackageConfSelectRequirement, AR_dstPackageConfSelectRequirement > > _AR_dstPackageConfSelectRequirement__PackageConfSelectRequirement__Requirement;
		typedef boost::mpl::pair< ::PICML::Property, boost::mpl::pair< ::PICML::PackageConfConfigProperty, AR_dstPackageConfConfigProperty > > _AR_dstPackageConfConfigProperty__PackageConfConfigProperty__Property;
		typedef boost::mpl::vector< _AR_dstPackageConfSpecializedConfig__PackageConfSpecializedConfig__PackageConfigurationReference, _AR_dstPackageConfBasePackage__PackageConfBasePackage__ComponentPackage, _AR_dstPackageConfReference__PackageConfReference__ComponentPackageReference> AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstPackageConfSelectRequirement__PackageConfSelectRequirement__Requirement, _AR_dstPackageConfConfigProperty__PackageConfConfigProperty__Property> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ArtifactDependsOn :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		ArtifactDependsOn() {}
		ArtifactDependsOn(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ArtifactDependsOn(const ArtifactDependsOn &master) : MgaObject(master) {}

		static ArtifactDependsOn Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ArtifactDependsOn Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ArtifactDependsOn CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ArtifactDependsOn> Instances() { return Udm::InstantiatedAttr<ArtifactDependsOn>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ArtifactDependsOn, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ArtifactDependsOn, Pred>(impl); }
		ArtifactDependsOn CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ArtifactDependsOn> Derived() { return Udm::DerivedAttr<ArtifactDependsOn>(impl); }
		template <class Pred> Udm::DerivedAttr<ArtifactDependsOn, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ArtifactDependsOn, Pred>(impl); }
		Udm::ArchetypeAttr<ArtifactDependsOn> Archetype() const { return Udm::ArchetypeAttr<ArtifactDependsOn>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const { return Udm::ParentAttr< ::PICML::ArtifactContainer>(impl, meta_ArtifactContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ImplementationArtifactReference> dstArtifactDependsOn_end() const { return Udm::AssocEndAttr< ::PICML::ImplementationArtifactReference>(impl, meta_dstArtifactDependsOn_end_); }
		Udm::AssocEndAttr< ::PICML::ImplementationArtifact> srcArtifactDependsOn_end() const { return Udm::AssocEndAttr< ::PICML::ImplementationArtifact>(impl, meta_srcArtifactDependsOn_end_); }
		void Accept(Visitor &v) { v.Visit_ArtifactDependsOn(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::AssociationRole meta_dstArtifactDependsOn_end_;
		static ::Uml::AssociationRole meta_srcArtifactDependsOn_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ArtifactContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ArtifactContainer, PR_ArtifactContainer_parent > _PR_ArtifactContainer_parent__ArtifactContainer;
		typedef boost::mpl::vector< _PR_ArtifactContainer_parent__ArtifactContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ArtifactContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstArtifactDependsOn {};
		class ACE_srcArtifactDependsOn {};
		typedef boost::mpl::pair< ::PICML::ImplementationArtifactReference, ACE_dstArtifactDependsOn > _ACE_dstArtifactDependsOn__ImplementationArtifactReference;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, ACE_srcArtifactDependsOn > _ACE_srcArtifactDependsOn__ImplementationArtifact;
		typedef boost::mpl::vector< _ACE_dstArtifactDependsOn__ImplementationArtifactReference, _ACE_srcArtifactDependsOn__ImplementationArtifact> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ArtifactDeployRequirement :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		ArtifactDeployRequirement() {}
		ArtifactDeployRequirement(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ArtifactDeployRequirement(const ArtifactDeployRequirement &master) : MgaObject(master) {}

		static ArtifactDeployRequirement Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ArtifactDeployRequirement Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ArtifactDeployRequirement CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ArtifactDeployRequirement> Instances() { return Udm::InstantiatedAttr<ArtifactDeployRequirement>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ArtifactDeployRequirement, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ArtifactDeployRequirement, Pred>(impl); }
		ArtifactDeployRequirement CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ArtifactDeployRequirement> Derived() { return Udm::DerivedAttr<ArtifactDeployRequirement>(impl); }
		template <class Pred> Udm::DerivedAttr<ArtifactDeployRequirement, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ArtifactDeployRequirement, Pred>(impl); }
		Udm::ArchetypeAttr<ArtifactDeployRequirement> Archetype() const { return Udm::ArchetypeAttr<ArtifactDeployRequirement>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const { return Udm::ParentAttr< ::PICML::ArtifactContainer>(impl, meta_ArtifactContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ImplementationArtifact> srcArtifactDeployRequirement_end() const { return Udm::AssocEndAttr< ::PICML::ImplementationArtifact>(impl, meta_srcArtifactDeployRequirement_end_); }
		Udm::AssocEndAttr< ::PICML::Requirement> dstArtifactDeployRequirement_end() const { return Udm::AssocEndAttr< ::PICML::Requirement>(impl, meta_dstArtifactDeployRequirement_end_); }
		void Accept(Visitor &v) { v.Visit_ArtifactDeployRequirement(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::AssociationRole meta_srcArtifactDeployRequirement_end_;
		static ::Uml::AssociationRole meta_dstArtifactDeployRequirement_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ArtifactContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ArtifactContainer, PR_ArtifactContainer_parent > _PR_ArtifactContainer_parent__ArtifactContainer;
		typedef boost::mpl::vector< _PR_ArtifactContainer_parent__ArtifactContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ArtifactContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcArtifactDeployRequirement {};
		class ACE_dstArtifactDeployRequirement {};
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, ACE_srcArtifactDeployRequirement > _ACE_srcArtifactDeployRequirement__ImplementationArtifact;
		typedef boost::mpl::pair< ::PICML::Requirement, ACE_dstArtifactDeployRequirement > _ACE_dstArtifactDeployRequirement__Requirement;
		typedef boost::mpl::vector< _ACE_srcArtifactDeployRequirement__ImplementationArtifact, _ACE_dstArtifactDeployRequirement__Requirement> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ArtifactContainer :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ArtifactContainer() {}
		ArtifactContainer(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ArtifactContainer(const ArtifactContainer &master) : MgaObject(master) {}

		static ArtifactContainer Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ArtifactContainer Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ArtifactContainer CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ArtifactContainer> Instances() { return Udm::InstantiatedAttr<ArtifactContainer>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ArtifactContainer, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ArtifactContainer, Pred>(impl); }
		ArtifactContainer CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ArtifactContainer> Derived() { return Udm::DerivedAttr<ArtifactContainer>(impl); }
		template <class Pred> Udm::DerivedAttr<ArtifactContainer, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ArtifactContainer, Pred>(impl); }
		Udm::ArchetypeAttr<ArtifactContainer> Archetype() const { return Udm::ArchetypeAttr<ArtifactContainer>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference>(impl, meta_ImplementationArtifactReference_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred> ImplementationArtifactReference_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred>(impl, meta_ImplementationArtifactReference_children); }
		Udm::ChildrenAttr< ::PICML::ArtifactDependsOn> ArtifactDependsOn_children() const { return Udm::ChildrenAttr< ::PICML::ArtifactDependsOn>(impl, meta_ArtifactDependsOn_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ArtifactDependsOn, Pred> ArtifactDependsOn_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ArtifactDependsOn, Pred>(impl, meta_ArtifactDependsOn_children); }
		Udm::ChildrenAttr< ::PICML::ArtifactDeployRequirement> ArtifactDeployRequirement_children() const { return Udm::ChildrenAttr< ::PICML::ArtifactDeployRequirement>(impl, meta_ArtifactDeployRequirement_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ArtifactDeployRequirement, Pred> ArtifactDeployRequirement_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ArtifactDeployRequirement, Pred>(impl, meta_ArtifactDeployRequirement_children); }
		Udm::ChildrenAttr< ::PICML::Requirement> Requirement_children() const { return Udm::ChildrenAttr< ::PICML::Requirement>(impl, meta_Requirement_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Requirement, Pred> Requirement_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Requirement, Pred>(impl, meta_Requirement_children); }
		Udm::ChildrenAttr< ::PICML::ArtifactExecParameter> ArtifactExecParameter_children() const { return Udm::ChildrenAttr< ::PICML::ArtifactExecParameter>(impl, meta_ArtifactExecParameter_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ArtifactExecParameter, Pred> ArtifactExecParameter_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ArtifactExecParameter, Pred>(impl, meta_ArtifactExecParameter_children); }
		Udm::ChildrenAttr< ::PICML::ArtifactInfoProperty> ArtifactInfoProperty_children() const { return Udm::ChildrenAttr< ::PICML::ArtifactInfoProperty>(impl, meta_ArtifactInfoProperty_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ArtifactInfoProperty, Pred> ArtifactInfoProperty_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ArtifactInfoProperty, Pred>(impl, meta_ArtifactInfoProperty_children); }
		Udm::ChildrenAttr< ::PICML::Property> Property_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, meta_Property_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); }
		Udm::ChildrenAttr< ::PICML::ImplementationArtifact> ImplementationArtifact_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifact>(impl, meta_ImplementationArtifact_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationArtifact, Pred> ImplementationArtifact_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifact, Pred>(impl, meta_ImplementationArtifact_children); }
		Udm::ChildrenAttr< ::PICML::ArtifactDependency> ArtifactDependency_children() const { return Udm::ChildrenAttr< ::PICML::ArtifactDependency>(impl, meta_ArtifactDependency_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ArtifactDependency, Pred> ArtifactDependency_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ArtifactDependency, Pred>(impl, meta_ArtifactDependency_children); }
		Udm::ChildrenAttr< ::PICML::ComponentServantArtifact> ComponentServantArtifact_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentServantArtifact>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred> ComponentServantArtifact_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact> ComponentImplementationArtifact_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred> ComponentImplementationArtifact_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RTRequirements> RTRequirements_kind_children() const { return Udm::ChildrenAttr< ::PICML::RTRequirements>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RTRequirements, Pred> RTRequirements_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RTRequirements, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ECRequirements> ECRequirements_kind_children() const { return Udm::ChildrenAttr< ::PICML::ECRequirements>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ECRequirements, Pred> ECRequirements_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ECRequirements, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ArtifactDependsOn> ArtifactDependsOn_kind_children() const { return Udm::ChildrenAttr< ::PICML::ArtifactDependsOn>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ArtifactDependsOn, Pred> ArtifactDependsOn_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ArtifactDependsOn, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ArtifactDeployRequirement> ArtifactDeployRequirement_kind_children() const { return Udm::ChildrenAttr< ::PICML::ArtifactDeployRequirement>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ArtifactDeployRequirement, Pred> ArtifactDeployRequirement_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ArtifactDeployRequirement, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ArtifactExecParameter> ArtifactExecParameter_kind_children() const { return Udm::ChildrenAttr< ::PICML::ArtifactExecParameter>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ArtifactExecParameter, Pred> ArtifactExecParameter_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ArtifactExecParameter, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ArtifactInfoProperty> ArtifactInfoProperty_kind_children() const { return Udm::ChildrenAttr< ::PICML::ArtifactInfoProperty>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ArtifactInfoProperty, Pred> ArtifactInfoProperty_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ArtifactInfoProperty, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ArtifactDependency> ArtifactDependency_kind_children() const { return Udm::ChildrenAttr< ::PICML::ArtifactDependency>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ArtifactDependency, Pred> ArtifactDependency_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ArtifactDependency, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_kind_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred> ImplementationArtifactReference_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ImplementationArtifact> ImplementationArtifact_kind_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifact>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationArtifact, Pred> ImplementationArtifact_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifact, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Requirement> Requirement_kind_children() const { return Udm::ChildrenAttr< ::PICML::Requirement>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Requirement, Pred> Requirement_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Requirement, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RequirementBase> RequirementBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::RequirementBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RequirementBase, Pred> RequirementBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RequirementBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::ImplementationArtifacts> ImplementationArtifacts_parent() const { return Udm::ParentAttr< ::PICML::ImplementationArtifacts>(impl, meta_ImplementationArtifacts_parent); }
		Udm::ParentAttr< ::PICML::ImplementationArtifacts> parent() const { return Udm::ParentAttr< ::PICML::ImplementationArtifacts>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ArtifactContainer(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_ImplementationArtifactReference_children;
		static ::Uml::CompositionChildRole meta_ArtifactDependsOn_children;
		static ::Uml::CompositionChildRole meta_ArtifactDeployRequirement_children;
		static ::Uml::CompositionChildRole meta_Requirement_children;
		static ::Uml::CompositionChildRole meta_ArtifactExecParameter_children;
		static ::Uml::CompositionChildRole meta_ArtifactInfoProperty_children;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_ImplementationArtifact_children;
		static ::Uml::CompositionChildRole meta_ArtifactDependency_children;
		static ::Uml::CompositionParentRole meta_ImplementationArtifacts_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ImplementationArtifacts_parent {};
		typedef boost::mpl::pair< ::PICML::ImplementationArtifacts, PR_ImplementationArtifacts_parent > _PR_ImplementationArtifacts_parent__ImplementationArtifacts;
		typedef boost::mpl::vector< _PR_ImplementationArtifacts_parent__ImplementationArtifacts> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ImplementationArtifacts> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ImplementationArtifactReference_children {};
		class CR_ArtifactDependsOn_children {};
		class CR_ArtifactDeployRequirement_children {};
		class CR_Requirement_children {};
		class CR_ArtifactExecParameter_children {};
		class CR_ArtifactInfoProperty_children {};
		class CR_Property_children {};
		class CR_ImplementationArtifact_children {};
		class CR_ArtifactDependency_children {};
		typedef boost::mpl::pair< ::PICML::ImplementationArtifactReference, CR_ImplementationArtifactReference_children > _CR_ImplementationArtifactReference_children__ImplementationArtifactReference;
		typedef boost::mpl::pair< ::PICML::ArtifactDependsOn, CR_ArtifactDependsOn_children > _CR_ArtifactDependsOn_children__ArtifactDependsOn;
		typedef boost::mpl::pair< ::PICML::ArtifactDeployRequirement, CR_ArtifactDeployRequirement_children > _CR_ArtifactDeployRequirement_children__ArtifactDeployRequirement;
		typedef boost::mpl::pair< ::PICML::Requirement, CR_Requirement_children > _CR_Requirement_children__Requirement;
		typedef boost::mpl::pair< ::PICML::ArtifactExecParameter, CR_ArtifactExecParameter_children > _CR_ArtifactExecParameter_children__ArtifactExecParameter;
		typedef boost::mpl::pair< ::PICML::ArtifactInfoProperty, CR_ArtifactInfoProperty_children > _CR_ArtifactInfoProperty_children__ArtifactInfoProperty;
		typedef boost::mpl::pair< ::PICML::Property, CR_Property_children > _CR_Property_children__Property;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, CR_ImplementationArtifact_children > _CR_ImplementationArtifact_children__ImplementationArtifact;
		typedef boost::mpl::pair< ::PICML::ArtifactDependency, CR_ArtifactDependency_children > _CR_ArtifactDependency_children__ArtifactDependency;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_ImplementationArtifactReference_children__ImplementationArtifactReference, _CR_ArtifactDependsOn_children__ArtifactDependsOn, _CR_ArtifactDeployRequirement_children__ArtifactDeployRequirement, _CR_Requirement_children__Requirement, _CR_ArtifactExecParameter_children__ArtifactExecParameter, _CR_ArtifactInfoProperty_children__ArtifactInfoProperty, _CR_Property_children__Property, _CR_ImplementationArtifact_children__ImplementationArtifact, _CR_ArtifactDependency_children__ArtifactDependency> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentServantArtifact, ::PICML::ComponentImplementationArtifact, ::PICML::RTRequirements, ::PICML::ECRequirements, ::PICML::ArtifactDependsOn, ::PICML::ArtifactDeployRequirement, ::PICML::ArtifactExecParameter, ::PICML::ArtifactInfoProperty, ::PICML::ArtifactDependency, ::PICML::ImplementationArtifactReference, ::PICML::ImplementationArtifact, ::PICML::Requirement, ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ArtifactExecParameter :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		ArtifactExecParameter() {}
		ArtifactExecParameter(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ArtifactExecParameter(const ArtifactExecParameter &master) : MgaObject(master) {}

		static ArtifactExecParameter Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ArtifactExecParameter Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ArtifactExecParameter CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ArtifactExecParameter> Instances() { return Udm::InstantiatedAttr<ArtifactExecParameter>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ArtifactExecParameter, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ArtifactExecParameter, Pred>(impl); }
		ArtifactExecParameter CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ArtifactExecParameter> Derived() { return Udm::DerivedAttr<ArtifactExecParameter>(impl); }
		template <class Pred> Udm::DerivedAttr<ArtifactExecParameter, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ArtifactExecParameter, Pred>(impl); }
		Udm::ArchetypeAttr<ArtifactExecParameter> Archetype() const { return Udm::ArchetypeAttr<ArtifactExecParameter>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const { return Udm::ParentAttr< ::PICML::ArtifactContainer>(impl, meta_ArtifactContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ImplementationArtifact> srcArtifactExecParameter_end() const { return Udm::AssocEndAttr< ::PICML::ImplementationArtifact>(impl, meta_srcArtifactExecParameter_end_); }
		Udm::AssocEndAttr< ::PICML::Property> dstArtifactExecParameter_end() const { return Udm::AssocEndAttr< ::PICML::Property>(impl, meta_dstArtifactExecParameter_end_); }
		void Accept(Visitor &v) { v.Visit_ArtifactExecParameter(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::AssociationRole meta_srcArtifactExecParameter_end_;
		static ::Uml::AssociationRole meta_dstArtifactExecParameter_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ArtifactContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ArtifactContainer, PR_ArtifactContainer_parent > _PR_ArtifactContainer_parent__ArtifactContainer;
		typedef boost::mpl::vector< _PR_ArtifactContainer_parent__ArtifactContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ArtifactContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcArtifactExecParameter {};
		class ACE_dstArtifactExecParameter {};
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, ACE_srcArtifactExecParameter > _ACE_srcArtifactExecParameter__ImplementationArtifact;
		typedef boost::mpl::pair< ::PICML::Property, ACE_dstArtifactExecParameter > _ACE_dstArtifactExecParameter__Property;
		typedef boost::mpl::vector< _ACE_srcArtifactExecParameter__ImplementationArtifact, _ACE_dstArtifactExecParameter__Property> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ArtifactInfoProperty :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		ArtifactInfoProperty() {}
		ArtifactInfoProperty(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ArtifactInfoProperty(const ArtifactInfoProperty &master) : MgaObject(master) {}

		static ArtifactInfoProperty Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ArtifactInfoProperty Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ArtifactInfoProperty CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ArtifactInfoProperty> Instances() { return Udm::InstantiatedAttr<ArtifactInfoProperty>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ArtifactInfoProperty, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ArtifactInfoProperty, Pred>(impl); }
		ArtifactInfoProperty CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ArtifactInfoProperty> Derived() { return Udm::DerivedAttr<ArtifactInfoProperty>(impl); }
		template <class Pred> Udm::DerivedAttr<ArtifactInfoProperty, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ArtifactInfoProperty, Pred>(impl); }
		Udm::ArchetypeAttr<ArtifactInfoProperty> Archetype() const { return Udm::ArchetypeAttr<ArtifactInfoProperty>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const { return Udm::ParentAttr< ::PICML::ArtifactContainer>(impl, meta_ArtifactContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ImplementationArtifact> srcArtifactInfoProperty_end() const { return Udm::AssocEndAttr< ::PICML::ImplementationArtifact>(impl, meta_srcArtifactInfoProperty_end_); }
		Udm::AssocEndAttr< ::PICML::Property> dstArtifactInfoProperty_end() const { return Udm::AssocEndAttr< ::PICML::Property>(impl, meta_dstArtifactInfoProperty_end_); }
		void Accept(Visitor &v) { v.Visit_ArtifactInfoProperty(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::AssociationRole meta_srcArtifactInfoProperty_end_;
		static ::Uml::AssociationRole meta_dstArtifactInfoProperty_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ArtifactContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ArtifactContainer, PR_ArtifactContainer_parent > _PR_ArtifactContainer_parent__ArtifactContainer;
		typedef boost::mpl::vector< _PR_ArtifactContainer_parent__ArtifactContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ArtifactContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcArtifactInfoProperty {};
		class ACE_dstArtifactInfoProperty {};
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, ACE_srcArtifactInfoProperty > _ACE_srcArtifactInfoProperty__ImplementationArtifact;
		typedef boost::mpl::pair< ::PICML::Property, ACE_dstArtifactInfoProperty > _ACE_dstArtifactInfoProperty__Property;
		typedef boost::mpl::vector< _ACE_srcArtifactInfoProperty__ImplementationArtifact, _ACE_dstArtifactInfoProperty__Property> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ArtifactDependency :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		ArtifactDependency() {}
		ArtifactDependency(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ArtifactDependency(const ArtifactDependency &master) : MgaObject(master) {}

		static ArtifactDependency Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ArtifactDependency Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ArtifactDependency CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ArtifactDependency> Instances() { return Udm::InstantiatedAttr<ArtifactDependency>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ArtifactDependency, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ArtifactDependency, Pred>(impl); }
		ArtifactDependency CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ArtifactDependency> Derived() { return Udm::DerivedAttr<ArtifactDependency>(impl); }
		template <class Pred> Udm::DerivedAttr<ArtifactDependency, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ArtifactDependency, Pred>(impl); }
		Udm::ArchetypeAttr<ArtifactDependency> Archetype() const { return Udm::ArchetypeAttr<ArtifactDependency>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const { return Udm::ParentAttr< ::PICML::ArtifactContainer>(impl, meta_ArtifactContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ImplementationArtifact> srcArtifactDependency_end() const { return Udm::AssocEndAttr< ::PICML::ImplementationArtifact>(impl, meta_srcArtifactDependency_end_); }
		Udm::AssocEndAttr< ::PICML::ImplementationArtifact> dstArtifactDependency_end() const { return Udm::AssocEndAttr< ::PICML::ImplementationArtifact>(impl, meta_dstArtifactDependency_end_); }
		void Accept(Visitor &v) { v.Visit_ArtifactDependency(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::AssociationRole meta_srcArtifactDependency_end_;
		static ::Uml::AssociationRole meta_dstArtifactDependency_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ArtifactContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ArtifactContainer, PR_ArtifactContainer_parent > _PR_ArtifactContainer_parent__ArtifactContainer;
		typedef boost::mpl::vector< _PR_ArtifactContainer_parent__ArtifactContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ArtifactContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcArtifactDependency {};
		class ACE_dstArtifactDependency {};
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, ACE_srcArtifactDependency > _ACE_srcArtifactDependency__ImplementationArtifact;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, ACE_dstArtifactDependency > _ACE_dstArtifactDependency__ImplementationArtifact;
		typedef boost::mpl::vector< _ACE_srcArtifactDependency__ImplementationArtifact, _ACE_dstArtifactDependency__ImplementationArtifact> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ImplementationArtifactReference :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		ImplementationArtifactReference() {}
		ImplementationArtifactReference(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ImplementationArtifactReference(const ImplementationArtifactReference &master) : MgaObject(master) {}

		static ImplementationArtifactReference Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ImplementationArtifactReference Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ImplementationArtifactReference CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ImplementationArtifactReference> Instances() { return Udm::InstantiatedAttr<ImplementationArtifactReference>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ImplementationArtifactReference, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ImplementationArtifactReference, Pred>(impl); }
		ImplementationArtifactReference CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ImplementationArtifactReference> Derived() { return Udm::DerivedAttr<ImplementationArtifactReference>(impl); }
		template <class Pred> Udm::DerivedAttr<ImplementationArtifactReference, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ImplementationArtifactReference, Pred>(impl); }
		Udm::ArchetypeAttr<ImplementationArtifactReference> Archetype() const { return Udm::ArchetypeAttr<ImplementationArtifactReference>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::MonolithprimaryArtifact, ::PICML::MonolithicImplementationBase> srcMonolithprimaryArtifact() const { return Udm::AClassAssocAttr< ::PICML::MonolithprimaryArtifact, ::PICML::MonolithicImplementationBase>(impl, meta_srcMonolithprimaryArtifact, meta_srcMonolithprimaryArtifact_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::MonolithprimaryArtifact, ::PICML::MonolithicImplementationBase, Pred> srcMonolithprimaryArtifact_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::MonolithprimaryArtifact, ::PICML::MonolithicImplementationBase, Pred>(impl, meta_srcMonolithprimaryArtifact, meta_srcMonolithprimaryArtifact_rev); }
		Udm::PointerAttr< ::PICML::ImplementationArtifact> ref() const { return Udm::PointerAttr< ::PICML::ImplementationArtifact>(impl, meta_ref); }
		Udm::AClassAssocAttr< ::PICML::ArtifactDependsOn, ::PICML::ImplementationArtifact> srcArtifactDependsOn() const { return Udm::AClassAssocAttr< ::PICML::ArtifactDependsOn, ::PICML::ImplementationArtifact>(impl, meta_srcArtifactDependsOn, meta_srcArtifactDependsOn_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ArtifactDependsOn, ::PICML::ImplementationArtifact, Pred> srcArtifactDependsOn_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ArtifactDependsOn, ::PICML::ImplementationArtifact, Pred>(impl, meta_srcArtifactDependsOn, meta_srcArtifactDependsOn_rev); }
		Udm::ParentAttr< ::PICML::ImplementationContainer> ImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ImplementationContainer>(impl, meta_ImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const { return Udm::ParentAttr< ::PICML::ArtifactContainer>(impl, meta_ArtifactContainer_parent); }
		Udm::ParentAttr< ::PICML::StubProject> StubProject_parent() const { return Udm::ParentAttr< ::PICML::StubProject>(impl, meta_StubProject_parent); }
		Udm::ParentAttr< ::PICML::ServantProject> ServantProject_parent() const { return Udm::ParentAttr< ::PICML::ServantProject>(impl, meta_ServantProject_parent); }
		Udm::ParentAttr< ::PICML::ExecutorProject> ExecutorProject_parent() const { return Udm::ParentAttr< ::PICML::ExecutorProject>(impl, meta_ExecutorProject_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ImplementationArtifactReference(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcMonolithprimaryArtifact;
		static ::Uml::AssociationRole meta_srcMonolithprimaryArtifact_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_srcArtifactDependsOn;
		static ::Uml::AssociationRole meta_srcArtifactDependsOn_rev;
		static ::Uml::CompositionParentRole meta_ImplementationContainer_parent;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::CompositionParentRole meta_StubProject_parent;
		static ::Uml::CompositionParentRole meta_ServantProject_parent;
		static ::Uml::CompositionParentRole meta_ExecutorProject_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ImplementationContainer_parent {};
		class PR_ArtifactContainer_parent {};
		class PR_StubProject_parent {};
		class PR_ServantProject_parent {};
		class PR_ExecutorProject_parent {};
		typedef boost::mpl::pair< ::PICML::ImplementationContainer, PR_ImplementationContainer_parent > _PR_ImplementationContainer_parent__ImplementationContainer;
		typedef boost::mpl::pair< ::PICML::ArtifactContainer, PR_ArtifactContainer_parent > _PR_ArtifactContainer_parent__ArtifactContainer;
		typedef boost::mpl::pair< ::PICML::StubProject, PR_StubProject_parent > _PR_StubProject_parent__StubProject;
		typedef boost::mpl::pair< ::PICML::ServantProject, PR_ServantProject_parent > _PR_ServantProject_parent__ServantProject;
		typedef boost::mpl::pair< ::PICML::ExecutorProject, PR_ExecutorProject_parent > _PR_ExecutorProject_parent__ExecutorProject;
		typedef boost::mpl::vector< _PR_ImplementationContainer_parent__ImplementationContainer, _PR_ArtifactContainer_parent__ArtifactContainer, _PR_StubProject_parent__StubProject, _PR_ServantProject_parent__ServantProject, _PR_ExecutorProject_parent__ExecutorProject> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ImplementationContainer, ::PICML::ArtifactContainer, ::PICML::StubProject, ::PICML::ServantProject, ::PICML::ExecutorProject> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, AR_ref > _AR_ref__ImplementationArtifact;
		typedef boost::mpl::vector< _AR_ref__ImplementationArtifact> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcMonolithprimaryArtifact {};
		class AR_srcArtifactDependsOn {};
		typedef boost::mpl::pair< ::PICML::MonolithicImplementationBase, boost::mpl::pair< ::PICML::MonolithprimaryArtifact, AR_srcMonolithprimaryArtifact > > _AR_srcMonolithprimaryArtifact__MonolithprimaryArtifact__MonolithicImplementationBase;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, boost::mpl::pair< ::PICML::ArtifactDependsOn, AR_srcArtifactDependsOn > > _AR_srcArtifactDependsOn__ArtifactDependsOn__ImplementationArtifact;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcMonolithprimaryArtifact__MonolithprimaryArtifact__MonolithicImplementationBase, _AR_srcArtifactDependsOn__ArtifactDependsOn__ImplementationArtifact> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentServantArtifact :  public ImplementationArtifactReference {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		ComponentServantArtifact() {}
		ComponentServantArtifact(Udm::ObjectImpl *impl) : ImplementationArtifactReference(impl) {}
		ComponentServantArtifact(const ComponentServantArtifact &master) : ImplementationArtifactReference(master) {}

		static ComponentServantArtifact Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentServantArtifact Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentServantArtifact CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentServantArtifact> Instances() { return Udm::InstantiatedAttr<ComponentServantArtifact>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentServantArtifact, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentServantArtifact, Pred>(impl); }
		ComponentServantArtifact CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentServantArtifact> Derived() { return Udm::DerivedAttr<ComponentServantArtifact>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentServantArtifact, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentServantArtifact, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentServantArtifact> Archetype() const { return Udm::ArchetypeAttr<ComponentServantArtifact>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr EntryPoint() const { return Udm::StringAttr(impl, meta_EntryPoint); }
		Udm::PointerAttr< ::PICML::ImplementationArtifact> ref() const { return Udm::PointerAttr< ::PICML::ImplementationArtifact>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentServantArtifact(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_EntryPoint;
		static ::Uml::AssociationRole meta_ref;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ImplementationContainer, ::PICML::ArtifactContainer, ::PICML::StubProject, ::PICML::ServantProject, ::PICML::ExecutorProject> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, AR_ref > _AR_ref__ImplementationArtifact;
		typedef boost::mpl::vector< _AR_ref__ImplementationArtifact> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentImplementationArtifact :  public ImplementationArtifactReference {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		ComponentImplementationArtifact() {}
		ComponentImplementationArtifact(Udm::ObjectImpl *impl) : ImplementationArtifactReference(impl) {}
		ComponentImplementationArtifact(const ComponentImplementationArtifact &master) : ImplementationArtifactReference(master) {}

		static ComponentImplementationArtifact Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentImplementationArtifact Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentImplementationArtifact CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentImplementationArtifact> Instances() { return Udm::InstantiatedAttr<ComponentImplementationArtifact>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentImplementationArtifact, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentImplementationArtifact, Pred>(impl); }
		ComponentImplementationArtifact CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentImplementationArtifact> Derived() { return Udm::DerivedAttr<ComponentImplementationArtifact>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentImplementationArtifact, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentImplementationArtifact, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentImplementationArtifact> Archetype() const { return Udm::ArchetypeAttr<ComponentImplementationArtifact>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr EntryPoint() const { return Udm::StringAttr(impl, meta_EntryPoint); }
		Udm::PointerAttr< ::PICML::ImplementationArtifact> ref() const { return Udm::PointerAttr< ::PICML::ImplementationArtifact>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentImplementationArtifact(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_EntryPoint;
		static ::Uml::AssociationRole meta_ref;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ImplementationContainer, ::PICML::ArtifactContainer, ::PICML::StubProject, ::PICML::ServantProject, ::PICML::ExecutorProject> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, AR_ref > _AR_ref__ImplementationArtifact;
		typedef boost::mpl::vector< _AR_ref__ImplementationArtifact> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ImplementationArtifact :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		ImplementationArtifact() {}
		ImplementationArtifact(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ImplementationArtifact(const ImplementationArtifact &master) : MgaObject(master) {}

		static ImplementationArtifact Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ImplementationArtifact Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ImplementationArtifact CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ImplementationArtifact> Instances() { return Udm::InstantiatedAttr<ImplementationArtifact>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ImplementationArtifact, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ImplementationArtifact, Pred>(impl); }
		ImplementationArtifact CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ImplementationArtifact> Derived() { return Udm::DerivedAttr<ImplementationArtifact>(impl); }
		template <class Pred> Udm::DerivedAttr<ImplementationArtifact, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ImplementationArtifact, Pred>(impl); }
		Udm::ArchetypeAttr<ImplementationArtifact> Archetype() const { return Udm::ArchetypeAttr<ImplementationArtifact>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr configuration() const { return Udm::StringAttr(impl, meta_configuration); }
		Udm::StringAttr operatingSystem() const { return Udm::StringAttr(impl, meta_operatingSystem); }
		Udm::StringAttr artifactVersion() const { return Udm::StringAttr(impl, meta_artifactVersion); }
		Udm::StringAttr architecture() const { return Udm::StringAttr(impl, meta_architecture); }
		Udm::StringAttr label() const { return Udm::StringAttr(impl, meta_label); }
		Udm::StringAttr UUID() const { return Udm::StringAttr(impl, meta_UUID); }
		Udm::StringAttr location() const { return Udm::StringAttr(impl, meta_location); }
		Udm::AssocAttr< ::PICML::ComponentServantArtifact> referedbyComponentServantArtifact() const { return Udm::AssocAttr< ::PICML::ComponentServantArtifact>(impl, meta_referedbyComponentServantArtifact); }
		template <class Pred> Udm::AssocAttr< ::PICML::ComponentServantArtifact, Pred> referedbyComponentServantArtifact_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::ComponentServantArtifact, Pred>(impl, meta_referedbyComponentServantArtifact); }
		Udm::AssocAttr< ::PICML::ComponentImplementationArtifact> referedbyComponentImplemenationArtifact() const { return Udm::AssocAttr< ::PICML::ComponentImplementationArtifact>(impl, meta_referedbyComponentImplemenationArtifact); }
		template <class Pred> Udm::AssocAttr< ::PICML::ComponentImplementationArtifact, Pred> referedbyComponentImplemenationArtifact_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::ComponentImplementationArtifact, Pred>(impl, meta_referedbyComponentImplemenationArtifact); }
		Udm::AssocAttr< ::PICML::ImplementationArtifactReference> referedbyImplementationArtifactReference() const { return Udm::AssocAttr< ::PICML::ImplementationArtifactReference>(impl, meta_referedbyImplementationArtifactReference); }
		template <class Pred> Udm::AssocAttr< ::PICML::ImplementationArtifactReference, Pred> referedbyImplementationArtifactReference_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::ImplementationArtifactReference, Pred>(impl, meta_referedbyImplementationArtifactReference); }
		Udm::AClassAssocAttr< ::PICML::ArtifactDependsOn, ::PICML::ImplementationArtifactReference> dstArtifactDependsOn() const { return Udm::AClassAssocAttr< ::PICML::ArtifactDependsOn, ::PICML::ImplementationArtifactReference>(impl, meta_dstArtifactDependsOn, meta_dstArtifactDependsOn_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ArtifactDependsOn, ::PICML::ImplementationArtifactReference, Pred> dstArtifactDependsOn_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ArtifactDependsOn, ::PICML::ImplementationArtifactReference, Pred>(impl, meta_dstArtifactDependsOn, meta_dstArtifactDependsOn_rev); }
		Udm::AClassAssocAttr< ::PICML::ArtifactDeployRequirement, ::PICML::Requirement> dstArtifactDeployRequirement() const { return Udm::AClassAssocAttr< ::PICML::ArtifactDeployRequirement, ::PICML::Requirement>(impl, meta_dstArtifactDeployRequirement, meta_dstArtifactDeployRequirement_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ArtifactDeployRequirement, ::PICML::Requirement, Pred> dstArtifactDeployRequirement_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ArtifactDeployRequirement, ::PICML::Requirement, Pred>(impl, meta_dstArtifactDeployRequirement, meta_dstArtifactDeployRequirement_rev); }
		Udm::AClassAssocAttr< ::PICML::ArtifactExecParameter, ::PICML::Property> dstArtifactExecParameter() const { return Udm::AClassAssocAttr< ::PICML::ArtifactExecParameter, ::PICML::Property>(impl, meta_dstArtifactExecParameter, meta_dstArtifactExecParameter_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ArtifactExecParameter, ::PICML::Property, Pred> dstArtifactExecParameter_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ArtifactExecParameter, ::PICML::Property, Pred>(impl, meta_dstArtifactExecParameter, meta_dstArtifactExecParameter_rev); }
		Udm::AClassAssocAttr< ::PICML::ArtifactInfoProperty, ::PICML::Property> dstArtifactInfoProperty() const { return Udm::AClassAssocAttr< ::PICML::ArtifactInfoProperty, ::PICML::Property>(impl, meta_dstArtifactInfoProperty, meta_dstArtifactInfoProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ArtifactInfoProperty, ::PICML::Property, Pred> dstArtifactInfoProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ArtifactInfoProperty, ::PICML::Property, Pred>(impl, meta_dstArtifactInfoProperty, meta_dstArtifactInfoProperty_rev); }
		Udm::AClassAssocAttr< ::PICML::ArtifactDependency, ::PICML::ImplementationArtifact> dstArtifactDependency() const { return Udm::AClassAssocAttr< ::PICML::ArtifactDependency, ::PICML::ImplementationArtifact>(impl, meta_dstArtifactDependency, meta_dstArtifactDependency_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ArtifactDependency, ::PICML::ImplementationArtifact, Pred> dstArtifactDependency_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ArtifactDependency, ::PICML::ImplementationArtifact, Pred>(impl, meta_dstArtifactDependency, meta_dstArtifactDependency_rev); }
		Udm::AClassAssocAttr< ::PICML::ArtifactDependency, ::PICML::ImplementationArtifact> srcArtifactDependency() const { return Udm::AClassAssocAttr< ::PICML::ArtifactDependency, ::PICML::ImplementationArtifact>(impl, meta_srcArtifactDependency, meta_srcArtifactDependency_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ArtifactDependency, ::PICML::ImplementationArtifact, Pred> srcArtifactDependency_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ArtifactDependency, ::PICML::ImplementationArtifact, Pred>(impl, meta_srcArtifactDependency, meta_srcArtifactDependency_rev); }
		Udm::AssocAttr< ::PICML::ExternalResources> referedbyExternalResources() const { return Udm::AssocAttr< ::PICML::ExternalResources>(impl, meta_referedbyExternalResources); }
		template <class Pred> Udm::AssocAttr< ::PICML::ExternalResources, Pred> referedbyExternalResources_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::ExternalResources, Pred>(impl, meta_referedbyExternalResources); }
		Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const { return Udm::ParentAttr< ::PICML::ArtifactContainer>(impl, meta_ArtifactContainer_parent); }
		Udm::ParentAttr< ::PICML::Project> Project_parent() const { return Udm::ParentAttr< ::PICML::Project>(impl, meta_Project_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ImplementationArtifact(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_configuration;
		static ::Uml::Attribute meta_operatingSystem;
		static ::Uml::Attribute meta_artifactVersion;
		static ::Uml::Attribute meta_architecture;
		static ::Uml::Attribute meta_label;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::Attribute meta_location;
		static ::Uml::AssociationRole meta_referedbyComponentServantArtifact;
		static ::Uml::AssociationRole meta_referedbyComponentImplemenationArtifact;
		static ::Uml::AssociationRole meta_referedbyImplementationArtifactReference;
		static ::Uml::AssociationRole meta_dstArtifactDependsOn;
		static ::Uml::AssociationRole meta_dstArtifactDependsOn_rev;
		static ::Uml::AssociationRole meta_dstArtifactDeployRequirement;
		static ::Uml::AssociationRole meta_dstArtifactDeployRequirement_rev;
		static ::Uml::AssociationRole meta_dstArtifactExecParameter;
		static ::Uml::AssociationRole meta_dstArtifactExecParameter_rev;
		static ::Uml::AssociationRole meta_dstArtifactInfoProperty;
		static ::Uml::AssociationRole meta_dstArtifactInfoProperty_rev;
		static ::Uml::AssociationRole meta_dstArtifactDependency;
		static ::Uml::AssociationRole meta_dstArtifactDependency_rev;
		static ::Uml::AssociationRole meta_srcArtifactDependency;
		static ::Uml::AssociationRole meta_srcArtifactDependency_rev;
		static ::Uml::AssociationRole meta_referedbyExternalResources;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::CompositionParentRole meta_Project_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ArtifactContainer_parent {};
		class PR_Project_parent {};
		typedef boost::mpl::pair< ::PICML::ArtifactContainer, PR_ArtifactContainer_parent > _PR_ArtifactContainer_parent__ArtifactContainer;
		typedef boost::mpl::pair< ::PICML::Project, PR_Project_parent > _PR_Project_parent__Project;
		typedef boost::mpl::vector< _PR_ArtifactContainer_parent__ArtifactContainer, _PR_Project_parent__Project> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ArtifactContainer, ::PICML::Project> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyComponentServantArtifact {};
		class AR_referedbyComponentImplemenationArtifact {};
		class AR_referedbyImplementationArtifactReference {};
		class AR_referedbyExternalResources {};
		typedef boost::mpl::pair< ::PICML::ComponentServantArtifact, AR_referedbyComponentServantArtifact > _AR_referedbyComponentServantArtifact__ComponentServantArtifact;
		typedef boost::mpl::pair< ::PICML::ComponentImplementationArtifact, AR_referedbyComponentImplemenationArtifact > _AR_referedbyComponentImplemenationArtifact__ComponentImplementationArtifact;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifactReference, AR_referedbyImplementationArtifactReference > _AR_referedbyImplementationArtifactReference__ImplementationArtifactReference;
		typedef boost::mpl::pair< ::PICML::ExternalResources, AR_referedbyExternalResources > _AR_referedbyExternalResources__ExternalResources;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyComponentServantArtifact__ComponentServantArtifact, _AR_referedbyComponentImplemenationArtifact__ComponentImplementationArtifact, _AR_referedbyImplementationArtifactReference__ImplementationArtifactReference, _AR_referedbyExternalResources__ExternalResources> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstArtifactDependsOn {};
		class AR_dstArtifactDeployRequirement {};
		class AR_dstArtifactExecParameter {};
		class AR_dstArtifactInfoProperty {};
		class AR_dstArtifactDependency {};
		class AR_srcArtifactDependency {};
		typedef boost::mpl::pair< ::PICML::ImplementationArtifactReference, boost::mpl::pair< ::PICML::ArtifactDependsOn, AR_dstArtifactDependsOn > > _AR_dstArtifactDependsOn__ArtifactDependsOn__ImplementationArtifactReference;
		typedef boost::mpl::pair< ::PICML::Requirement, boost::mpl::pair< ::PICML::ArtifactDeployRequirement, AR_dstArtifactDeployRequirement > > _AR_dstArtifactDeployRequirement__ArtifactDeployRequirement__Requirement;
		typedef boost::mpl::pair< ::PICML::Property, boost::mpl::pair< ::PICML::ArtifactExecParameter, AR_dstArtifactExecParameter > > _AR_dstArtifactExecParameter__ArtifactExecParameter__Property;
		typedef boost::mpl::pair< ::PICML::Property, boost::mpl::pair< ::PICML::ArtifactInfoProperty, AR_dstArtifactInfoProperty > > _AR_dstArtifactInfoProperty__ArtifactInfoProperty__Property;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, boost::mpl::pair< ::PICML::ArtifactDependency, AR_dstArtifactDependency > > _AR_dstArtifactDependency__ArtifactDependency__ImplementationArtifact;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, boost::mpl::pair< ::PICML::ArtifactDependency, AR_srcArtifactDependency > > _AR_srcArtifactDependency__ArtifactDependency__ImplementationArtifact;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstArtifactDependsOn__ArtifactDependsOn__ImplementationArtifactReference, _AR_dstArtifactDeployRequirement__ArtifactDeployRequirement__Requirement, _AR_dstArtifactExecParameter__ArtifactExecParameter__Property, _AR_dstArtifactInfoProperty__ArtifactInfoProperty__Property, _AR_dstArtifactDependency__ArtifactDependency__ImplementationArtifact, _AR_srcArtifactDependency__ArtifactDependency__ImplementationArtifact> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentPropertyDescription :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ComponentPropertyDescription() {}
		ComponentPropertyDescription(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ComponentPropertyDescription(const ComponentPropertyDescription &master) : MgaObject(master) {}

		static ComponentPropertyDescription Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentPropertyDescription Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentPropertyDescription CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentPropertyDescription> Instances() { return Udm::InstantiatedAttr<ComponentPropertyDescription>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentPropertyDescription, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentPropertyDescription, Pred>(impl); }
		ComponentPropertyDescription CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentPropertyDescription> Derived() { return Udm::DerivedAttr<ComponentPropertyDescription>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentPropertyDescription, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentPropertyDescription, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentPropertyDescription> Archetype() const { return Udm::ArchetypeAttr<ComponentPropertyDescription>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::ComponentProperty, ::PICML::ComponentRef> srcComponentProperty() const { return Udm::AClassAssocAttr< ::PICML::ComponentProperty, ::PICML::ComponentRef>(impl, meta_srcComponentProperty, meta_srcComponentProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ComponentProperty, ::PICML::ComponentRef, Pred> srcComponentProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ComponentProperty, ::PICML::ComponentRef, Pred>(impl, meta_srcComponentProperty, meta_srcComponentProperty_rev); }
		Udm::ChildAttr< ::PICML::DataType> DataType_child() const { return Udm::ChildAttr< ::PICML::DataType>(impl, meta_DataType_child); }
		Udm::ChildrenAttr< ::PICML::DataType> DataType_kind_children() const { return Udm::ChildrenAttr< ::PICML::DataType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DataType, Pred> DataType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DataType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::ComponentContainer> ComponentContainer_parent() const { return Udm::ParentAttr< ::PICML::ComponentContainer>(impl, meta_ComponentContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentPropertyDescription(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcComponentProperty;
		static ::Uml::AssociationRole meta_srcComponentProperty_rev;
		static ::Uml::CompositionChildRole meta_DataType_child;
		static ::Uml::CompositionParentRole meta_ComponentContainer_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentContainer, PR_ComponentContainer_parent > _PR_ComponentContainer_parent__ComponentContainer;
		typedef boost::mpl::vector< _PR_ComponentContainer_parent__ComponentContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_DataType_child {};
		typedef boost::mpl::pair< ::PICML::DataType, CR_DataType_child > _CR_DataType_child__DataType;
		typedef boost::mpl::vector< _CR_DataType_child__DataType> ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::DataType> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcComponentProperty {};
		typedef boost::mpl::pair< ::PICML::ComponentRef, boost::mpl::pair< ::PICML::ComponentProperty, AR_srcComponentProperty > > _AR_srcComponentProperty__ComponentProperty__ComponentRef;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcComponentProperty__ComponentProperty__ComponentRef> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentProperty :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		ComponentProperty() {}
		ComponentProperty(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ComponentProperty(const ComponentProperty &master) : MgaObject(master) {}

		static ComponentProperty Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentProperty Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentProperty CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentProperty> Instances() { return Udm::InstantiatedAttr<ComponentProperty>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentProperty, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentProperty, Pred>(impl); }
		ComponentProperty CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentProperty> Derived() { return Udm::DerivedAttr<ComponentProperty>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentProperty, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentProperty, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentProperty> Archetype() const { return Udm::ArchetypeAttr<ComponentProperty>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentContainer> ComponentContainer_parent() const { return Udm::ParentAttr< ::PICML::ComponentContainer>(impl, meta_ComponentContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ComponentPropertyDescription> dstComponentProperty_end() const { return Udm::AssocEndAttr< ::PICML::ComponentPropertyDescription>(impl, meta_dstComponentProperty_end_); }
		Udm::AssocEndAttr< ::PICML::ComponentRef> srcComponentProperty_end() const { return Udm::AssocEndAttr< ::PICML::ComponentRef>(impl, meta_srcComponentProperty_end_); }
		void Accept(Visitor &v) { v.Visit_ComponentProperty(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentContainer_parent;
		static ::Uml::AssociationRole meta_dstComponentProperty_end_;
		static ::Uml::AssociationRole meta_srcComponentProperty_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentContainer, PR_ComponentContainer_parent > _PR_ComponentContainer_parent__ComponentContainer;
		typedef boost::mpl::vector< _PR_ComponentContainer_parent__ComponentContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstComponentProperty {};
		class ACE_srcComponentProperty {};
		typedef boost::mpl::pair< ::PICML::ComponentPropertyDescription, ACE_dstComponentProperty > _ACE_dstComponentProperty__ComponentPropertyDescription;
		typedef boost::mpl::pair< ::PICML::ComponentRef, ACE_srcComponentProperty > _ACE_srcComponentProperty__ComponentRef;
		typedef boost::mpl::vector< _ACE_dstComponentProperty__ComponentPropertyDescription, _ACE_srcComponentProperty__ComponentRef> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentContainer :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ComponentContainer() {}
		ComponentContainer(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ComponentContainer(const ComponentContainer &master) : MgaObject(master) {}

		static ComponentContainer Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentContainer Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentContainer CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentContainer> Instances() { return Udm::InstantiatedAttr<ComponentContainer>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentContainer, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentContainer, Pred>(impl); }
		ComponentContainer CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentContainer> Derived() { return Udm::DerivedAttr<ComponentContainer>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentContainer, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentContainer, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentContainer> Archetype() const { return Udm::ArchetypeAttr<ComponentContainer>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::ComponentConfigProperty> ComponentConfigProperty_children() const { return Udm::ChildrenAttr< ::PICML::ComponentConfigProperty>(impl, meta_ComponentConfigProperty_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentConfigProperty, Pred> ComponentConfigProperty_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentConfigProperty, Pred>(impl, meta_ComponentConfigProperty_children); }
		Udm::ChildrenAttr< ::PICML::Property> Property_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, meta_Property_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); }
		Udm::ChildrenAttr< ::PICML::ComponentInfoProperty> ComponentInfoProperty_children() const { return Udm::ChildrenAttr< ::PICML::ComponentInfoProperty>(impl, meta_ComponentInfoProperty_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentInfoProperty, Pred> ComponentInfoProperty_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentInfoProperty, Pred>(impl, meta_ComponentInfoProperty_children); }
		Udm::ChildrenAttr< ::PICML::ComponentProperty> ComponentProperty_children() const { return Udm::ChildrenAttr< ::PICML::ComponentProperty>(impl, meta_ComponentProperty_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentProperty, Pred> ComponentProperty_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentProperty, Pred>(impl, meta_ComponentProperty_children); }
		Udm::ChildrenAttr< ::PICML::ComponentPropertyDescription> ComponentPropertyDescription_children() const { return Udm::ChildrenAttr< ::PICML::ComponentPropertyDescription>(impl, meta_ComponentPropertyDescription_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentPropertyDescription, Pred> ComponentPropertyDescription_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentPropertyDescription, Pred>(impl, meta_ComponentPropertyDescription_children); }
		Udm::ChildAttr< ::PICML::ComponentRef> ComponentRef_child() const { return Udm::ChildAttr< ::PICML::ComponentRef>(impl, meta_ComponentRef_child); }
		Udm::ChildrenAttr< ::PICML::CollocationGroupMember> CollocationGroupMember_kind_children() const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred> CollocationGroupMember_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentPropertyDescription> ComponentPropertyDescription_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentPropertyDescription>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentPropertyDescription, Pred> ComponentPropertyDescription_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentPropertyDescription, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentProperty> ComponentProperty_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentProperty>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentProperty, Pred> ComponentProperty_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentProperty, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentConfigProperty> ComponentConfigProperty_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentConfigProperty>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentConfigProperty, Pred> ComponentConfigProperty_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentConfigProperty, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentInfoProperty> ComponentInfoProperty_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentInfoProperty>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentInfoProperty, Pred> ComponentInfoProperty_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentInfoProperty, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Manageable> Manageable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Manageable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Manageable, Pred> Manageable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Manageable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentRef>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::ComponentTypes> ComponentTypes_parent() const { return Udm::ParentAttr< ::PICML::ComponentTypes>(impl, meta_ComponentTypes_parent); }
		Udm::ParentAttr< ::PICML::ComponentTypes> parent() const { return Udm::ParentAttr< ::PICML::ComponentTypes>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentContainer(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_ComponentConfigProperty_children;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_ComponentInfoProperty_children;
		static ::Uml::CompositionChildRole meta_ComponentProperty_children;
		static ::Uml::CompositionChildRole meta_ComponentPropertyDescription_children;
		static ::Uml::CompositionChildRole meta_ComponentRef_child;
		static ::Uml::CompositionParentRole meta_ComponentTypes_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentTypes_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentTypes, PR_ComponentTypes_parent > _PR_ComponentTypes_parent__ComponentTypes;
		typedef boost::mpl::vector< _PR_ComponentTypes_parent__ComponentTypes> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentTypes> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ComponentConfigProperty_children {};
		class CR_Property_children {};
		class CR_ComponentInfoProperty_children {};
		class CR_ComponentProperty_children {};
		class CR_ComponentPropertyDescription_children {};
		class CR_ComponentRef_child {};
		typedef boost::mpl::pair< ::PICML::ComponentConfigProperty, CR_ComponentConfigProperty_children > _CR_ComponentConfigProperty_children__ComponentConfigProperty;
		typedef boost::mpl::pair< ::PICML::Property, CR_Property_children > _CR_Property_children__Property;
		typedef boost::mpl::pair< ::PICML::ComponentInfoProperty, CR_ComponentInfoProperty_children > _CR_ComponentInfoProperty_children__ComponentInfoProperty;
		typedef boost::mpl::pair< ::PICML::ComponentProperty, CR_ComponentProperty_children > _CR_ComponentProperty_children__ComponentProperty;
		typedef boost::mpl::pair< ::PICML::ComponentPropertyDescription, CR_ComponentPropertyDescription_children > _CR_ComponentPropertyDescription_children__ComponentPropertyDescription;
		typedef boost::mpl::pair< ::PICML::ComponentRef, CR_ComponentRef_child > _CR_ComponentRef_child__ComponentRef;
		typedef boost::mpl::vector< _CR_ComponentRef_child__ComponentRef> ChildrenSingle;
		typedef boost::mpl::vector< _CR_ComponentConfigProperty_children__ComponentConfigProperty, _CR_Property_children__Property, _CR_ComponentInfoProperty_children__ComponentInfoProperty, _CR_ComponentProperty_children__ComponentProperty, _CR_ComponentPropertyDescription_children__ComponentPropertyDescription> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentPropertyDescription, ::PICML::ComponentProperty, ::PICML::ComponentConfigProperty, ::PICML::ComponentInfoProperty, ::PICML::Property, ::PICML::ComponentRef> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentConfigProperty :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		ComponentConfigProperty() {}
		ComponentConfigProperty(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ComponentConfigProperty(const ComponentConfigProperty &master) : MgaObject(master) {}

		static ComponentConfigProperty Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentConfigProperty Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentConfigProperty CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentConfigProperty> Instances() { return Udm::InstantiatedAttr<ComponentConfigProperty>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentConfigProperty, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentConfigProperty, Pred>(impl); }
		ComponentConfigProperty CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentConfigProperty> Derived() { return Udm::DerivedAttr<ComponentConfigProperty>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentConfigProperty, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentConfigProperty, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentConfigProperty> Archetype() const { return Udm::ArchetypeAttr<ComponentConfigProperty>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentContainer> ComponentContainer_parent() const { return Udm::ParentAttr< ::PICML::ComponentContainer>(impl, meta_ComponentContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::Property> dstComponentConfigProperty_end() const { return Udm::AssocEndAttr< ::PICML::Property>(impl, meta_dstComponentConfigProperty_end_); }
		Udm::AssocEndAttr< ::PICML::ComponentRef> srcComponentConfigProperty_end() const { return Udm::AssocEndAttr< ::PICML::ComponentRef>(impl, meta_srcComponentConfigProperty_end_); }
		void Accept(Visitor &v) { v.Visit_ComponentConfigProperty(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentContainer_parent;
		static ::Uml::AssociationRole meta_dstComponentConfigProperty_end_;
		static ::Uml::AssociationRole meta_srcComponentConfigProperty_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentContainer, PR_ComponentContainer_parent > _PR_ComponentContainer_parent__ComponentContainer;
		typedef boost::mpl::vector< _PR_ComponentContainer_parent__ComponentContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstComponentConfigProperty {};
		class ACE_srcComponentConfigProperty {};
		typedef boost::mpl::pair< ::PICML::Property, ACE_dstComponentConfigProperty > _ACE_dstComponentConfigProperty__Property;
		typedef boost::mpl::pair< ::PICML::ComponentRef, ACE_srcComponentConfigProperty > _ACE_srcComponentConfigProperty__ComponentRef;
		typedef boost::mpl::vector< _ACE_dstComponentConfigProperty__Property, _ACE_srcComponentConfigProperty__ComponentRef> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentInfoProperty :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		ComponentInfoProperty() {}
		ComponentInfoProperty(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ComponentInfoProperty(const ComponentInfoProperty &master) : MgaObject(master) {}

		static ComponentInfoProperty Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentInfoProperty Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentInfoProperty CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentInfoProperty> Instances() { return Udm::InstantiatedAttr<ComponentInfoProperty>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentInfoProperty, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentInfoProperty, Pred>(impl); }
		ComponentInfoProperty CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentInfoProperty> Derived() { return Udm::DerivedAttr<ComponentInfoProperty>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentInfoProperty, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentInfoProperty, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentInfoProperty> Archetype() const { return Udm::ArchetypeAttr<ComponentInfoProperty>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentContainer> ComponentContainer_parent() const { return Udm::ParentAttr< ::PICML::ComponentContainer>(impl, meta_ComponentContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::Property> dstComponentInfoProperty_end() const { return Udm::AssocEndAttr< ::PICML::Property>(impl, meta_dstComponentInfoProperty_end_); }
		Udm::AssocEndAttr< ::PICML::ComponentRef> srcComponentInfoProperty_end() const { return Udm::AssocEndAttr< ::PICML::ComponentRef>(impl, meta_srcComponentInfoProperty_end_); }
		void Accept(Visitor &v) { v.Visit_ComponentInfoProperty(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentContainer_parent;
		static ::Uml::AssociationRole meta_dstComponentInfoProperty_end_;
		static ::Uml::AssociationRole meta_srcComponentInfoProperty_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentContainer, PR_ComponentContainer_parent > _PR_ComponentContainer_parent__ComponentContainer;
		typedef boost::mpl::vector< _PR_ComponentContainer_parent__ComponentContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstComponentInfoProperty {};
		class ACE_srcComponentInfoProperty {};
		typedef boost::mpl::pair< ::PICML::Property, ACE_dstComponentInfoProperty > _ACE_dstComponentInfoProperty__Property;
		typedef boost::mpl::pair< ::PICML::ComponentRef, ACE_srcComponentInfoProperty > _ACE_srcComponentInfoProperty__ComponentRef;
		typedef boost::mpl::vector< _ACE_dstComponentInfoProperty__Property, _ACE_srcComponentInfoProperty__ComponentRef> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export CommonPortAttrs :  virtual  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		CommonPortAttrs() {}
		CommonPortAttrs(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		CommonPortAttrs(const CommonPortAttrs &master) : MgaObject(master) {}

		static CommonPortAttrs Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static CommonPortAttrs Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		CommonPortAttrs CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<CommonPortAttrs> Instances() { return Udm::InstantiatedAttr<CommonPortAttrs>(impl); }
		template <class Pred> Udm::InstantiatedAttr<CommonPortAttrs, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<CommonPortAttrs, Pred>(impl); }
		CommonPortAttrs CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<CommonPortAttrs> Derived() { return Udm::DerivedAttr<CommonPortAttrs>(impl); }
		template <class Pred> Udm::DerivedAttr<CommonPortAttrs, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<CommonPortAttrs, Pred>(impl); }
		Udm::ArchetypeAttr<CommonPortAttrs> Archetype() const { return Udm::ArchetypeAttr<CommonPortAttrs>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::BooleanAttr exclusiveUser() const { return Udm::BooleanAttr(impl, meta_exclusiveUser); }
		Udm::BooleanAttr optional() const { return Udm::BooleanAttr(impl, meta_optional); }
		Udm::BooleanAttr exclusiveProvider() const { return Udm::BooleanAttr(impl, meta_exclusiveProvider); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_exclusiveUser;
		static ::Uml::Attribute meta_optional;
		static ::Uml::Attribute meta_exclusiveProvider;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export TopLevelPackageContainer :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		TopLevelPackageContainer() {}
		TopLevelPackageContainer(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		TopLevelPackageContainer(const TopLevelPackageContainer &master) : MgaObject(master) {}

		static TopLevelPackageContainer Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static TopLevelPackageContainer Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		TopLevelPackageContainer CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<TopLevelPackageContainer> Instances() { return Udm::InstantiatedAttr<TopLevelPackageContainer>(impl); }
		template <class Pred> Udm::InstantiatedAttr<TopLevelPackageContainer, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<TopLevelPackageContainer, Pred>(impl); }
		TopLevelPackageContainer CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<TopLevelPackageContainer> Derived() { return Udm::DerivedAttr<TopLevelPackageContainer>(impl); }
		template <class Pred> Udm::DerivedAttr<TopLevelPackageContainer, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<TopLevelPackageContainer, Pred>(impl); }
		Udm::ArchetypeAttr<TopLevelPackageContainer> Archetype() const { return Udm::ArchetypeAttr<TopLevelPackageContainer>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildAttr< ::PICML::TopLevelPackage> TopLevelPackage_child() const { return Udm::ChildAttr< ::PICML::TopLevelPackage>(impl, meta_TopLevelPackage_child); }
		Udm::ChildAttr< ::PICML::PackageConfigurationReference> PackageConfigurationReference_child() const { return Udm::ChildAttr< ::PICML::PackageConfigurationReference>(impl, meta_PackageConfigurationReference_child); }
		Udm::ChildAttr< ::PICML::package> package_child() const { return Udm::ChildAttr< ::PICML::package>(impl, meta_package_child); }
		Udm::ChildrenAttr< ::PICML::PackageConfigurationReference> PackageConfigurationReference_kind_children() const { return Udm::ChildrenAttr< ::PICML::PackageConfigurationReference>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageConfigurationReference, Pred> PackageConfigurationReference_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageConfigurationReference, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::TopLevelPackage> TopLevelPackage_kind_children() const { return Udm::ChildrenAttr< ::PICML::TopLevelPackage>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TopLevelPackage, Pred> TopLevelPackage_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TopLevelPackage, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::package> package_kind_children() const { return Udm::ChildrenAttr< ::PICML::package>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::package, Pred> package_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::package, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::TopLevelPackages> TopLevelPackages_parent() const { return Udm::ParentAttr< ::PICML::TopLevelPackages>(impl, meta_TopLevelPackages_parent); }
		Udm::ParentAttr< ::PICML::TopLevelPackages> parent() const { return Udm::ParentAttr< ::PICML::TopLevelPackages>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_TopLevelPackageContainer(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_TopLevelPackage_child;
		static ::Uml::CompositionChildRole meta_PackageConfigurationReference_child;
		static ::Uml::CompositionChildRole meta_package_child;
		static ::Uml::CompositionParentRole meta_TopLevelPackages_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_TopLevelPackages_parent {};
		typedef boost::mpl::pair< ::PICML::TopLevelPackages, PR_TopLevelPackages_parent > _PR_TopLevelPackages_parent__TopLevelPackages;
		typedef boost::mpl::vector< _PR_TopLevelPackages_parent__TopLevelPackages> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::TopLevelPackages> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_TopLevelPackage_child {};
		class CR_PackageConfigurationReference_child {};
		class CR_package_child {};
		typedef boost::mpl::pair< ::PICML::TopLevelPackage, CR_TopLevelPackage_child > _CR_TopLevelPackage_child__TopLevelPackage;
		typedef boost::mpl::pair< ::PICML::PackageConfigurationReference, CR_PackageConfigurationReference_child > _CR_PackageConfigurationReference_child__PackageConfigurationReference;
		typedef boost::mpl::pair< ::PICML::package, CR_package_child > _CR_package_child__package;
		typedef boost::mpl::vector< _CR_TopLevelPackage_child__TopLevelPackage, _CR_PackageConfigurationReference_child__PackageConfigurationReference, _CR_package_child__package> ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::PackageConfigurationReference, ::PICML::TopLevelPackage, ::PICML::package> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export TopLevelPackage :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		TopLevelPackage() {}
		TopLevelPackage(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		TopLevelPackage(const TopLevelPackage &master) : MgaObject(master) {}

		static TopLevelPackage Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static TopLevelPackage Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		TopLevelPackage CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<TopLevelPackage> Instances() { return Udm::InstantiatedAttr<TopLevelPackage>(impl); }
		template <class Pred> Udm::InstantiatedAttr<TopLevelPackage, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<TopLevelPackage, Pred>(impl); }
		TopLevelPackage CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<TopLevelPackage> Derived() { return Udm::DerivedAttr<TopLevelPackage>(impl); }
		template <class Pred> Udm::DerivedAttr<TopLevelPackage, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<TopLevelPackage, Pred>(impl); }
		Udm::ArchetypeAttr<TopLevelPackage> Archetype() const { return Udm::ArchetypeAttr<TopLevelPackage>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::package, ::PICML::PackageConfigurationReference> dstpackage() const { return Udm::AClassPointerAttr< ::PICML::package, ::PICML::PackageConfigurationReference>(impl, meta_dstpackage, meta_dstpackage_rev); }
		Udm::ParentAttr< ::PICML::TopLevelPackageContainer> TopLevelPackageContainer_parent() const { return Udm::ParentAttr< ::PICML::TopLevelPackageContainer>(impl, meta_TopLevelPackageContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_TopLevelPackage(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstpackage;
		static ::Uml::AssociationRole meta_dstpackage_rev;
		static ::Uml::CompositionParentRole meta_TopLevelPackageContainer_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_TopLevelPackageContainer_parent {};
		typedef boost::mpl::pair< ::PICML::TopLevelPackageContainer, PR_TopLevelPackageContainer_parent > _PR_TopLevelPackageContainer_parent__TopLevelPackageContainer;
		typedef boost::mpl::vector< _PR_TopLevelPackageContainer_parent__TopLevelPackageContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::TopLevelPackageContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstpackage {};
		typedef boost::mpl::pair< ::PICML::PackageConfigurationReference, boost::mpl::pair< ::PICML::package, AR_dstpackage > > _AR_dstpackage__package__PackageConfigurationReference;
		typedef boost::mpl::vector< _AR_dstpackage__package__PackageConfigurationReference> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export package :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		package() {}
		package(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		package(const package &master) : MgaObject(master) {}

		static package Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static package Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		package CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<package> Instances() { return Udm::InstantiatedAttr<package>(impl); }
		template <class Pred> Udm::InstantiatedAttr<package, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<package, Pred>(impl); }
		package CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<package> Derived() { return Udm::DerivedAttr<package>(impl); }
		template <class Pred> Udm::DerivedAttr<package, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<package, Pred>(impl); }
		Udm::ArchetypeAttr<package> Archetype() const { return Udm::ArchetypeAttr<package>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::TopLevelPackageContainer> TopLevelPackageContainer_parent() const { return Udm::ParentAttr< ::PICML::TopLevelPackageContainer>(impl, meta_TopLevelPackageContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::PackageConfigurationReference> dstpackage_end() const { return Udm::AssocEndAttr< ::PICML::PackageConfigurationReference>(impl, meta_dstpackage_end_); }
		Udm::AssocEndAttr< ::PICML::TopLevelPackage> srcpackage_end() const { return Udm::AssocEndAttr< ::PICML::TopLevelPackage>(impl, meta_srcpackage_end_); }
		void Accept(Visitor &v) { v.Visit_package(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_TopLevelPackageContainer_parent;
		static ::Uml::AssociationRole meta_dstpackage_end_;
		static ::Uml::AssociationRole meta_srcpackage_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_TopLevelPackageContainer_parent {};
		typedef boost::mpl::pair< ::PICML::TopLevelPackageContainer, PR_TopLevelPackageContainer_parent > _PR_TopLevelPackageContainer_parent__TopLevelPackageContainer;
		typedef boost::mpl::vector< _PR_TopLevelPackageContainer_parent__TopLevelPackageContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::TopLevelPackageContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstpackage {};
		class ACE_srcpackage {};
		typedef boost::mpl::pair< ::PICML::PackageConfigurationReference, ACE_dstpackage > _ACE_dstpackage__PackageConfigurationReference;
		typedef boost::mpl::pair< ::PICML::TopLevelPackage, ACE_srcpackage > _ACE_srcpackage__TopLevelPackage;
		typedef boost::mpl::vector< _ACE_dstpackage__PackageConfigurationReference, _ACE_srcpackage__TopLevelPackage> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PackageInterface :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		PackageInterface() {}
		PackageInterface(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		PackageInterface(const PackageInterface &master) : MgaObject(master) {}

		static PackageInterface Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PackageInterface Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PackageInterface CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PackageInterface> Instances() { return Udm::InstantiatedAttr<PackageInterface>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PackageInterface, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PackageInterface, Pred>(impl); }
		PackageInterface CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PackageInterface> Derived() { return Udm::DerivedAttr<PackageInterface>(impl); }
		template <class Pred> Udm::DerivedAttr<PackageInterface, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PackageInterface, Pred>(impl); }
		Udm::ArchetypeAttr<PackageInterface> Archetype() const { return Udm::ArchetypeAttr<PackageInterface>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PackageContainer> PackageContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageContainer>(impl, meta_PackageContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ComponentPackage> srcPackageInterface_end() const { return Udm::AssocEndAttr< ::PICML::ComponentPackage>(impl, meta_srcPackageInterface_end_); }
		Udm::AssocEndAttr< ::PICML::ComponentRef> dstPackageInterface_end() const { return Udm::AssocEndAttr< ::PICML::ComponentRef>(impl, meta_dstPackageInterface_end_); }
		void Accept(Visitor &v) { v.Visit_PackageInterface(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageContainer_parent;
		static ::Uml::AssociationRole meta_srcPackageInterface_end_;
		static ::Uml::AssociationRole meta_dstPackageInterface_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_PackageContainer_parent {};
		typedef boost::mpl::pair< ::PICML::PackageContainer, PR_PackageContainer_parent > _PR_PackageContainer_parent__PackageContainer;
		typedef boost::mpl::vector< _PR_PackageContainer_parent__PackageContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PackageContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcPackageInterface {};
		class ACE_dstPackageInterface {};
		typedef boost::mpl::pair< ::PICML::ComponentPackage, ACE_srcPackageInterface > _ACE_srcPackageInterface__ComponentPackage;
		typedef boost::mpl::pair< ::PICML::ComponentRef, ACE_dstPackageInterface > _ACE_dstPackageInterface__ComponentRef;
		typedef boost::mpl::vector< _ACE_srcPackageInterface__ComponentPackage, _ACE_dstPackageInterface__ComponentRef> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Implementation :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		Implementation() {}
		Implementation(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Implementation(const Implementation &master) : MgaObject(master) {}

		static Implementation Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Implementation Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Implementation CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Implementation> Instances() { return Udm::InstantiatedAttr<Implementation>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Implementation, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Implementation, Pred>(impl); }
		Implementation CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Implementation> Derived() { return Udm::DerivedAttr<Implementation>(impl); }
		template <class Pred> Udm::DerivedAttr<Implementation, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Implementation, Pred>(impl); }
		Udm::ArchetypeAttr<Implementation> Archetype() const { return Udm::ArchetypeAttr<Implementation>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PackageContainer> PackageContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageContainer>(impl, meta_PackageContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ComponentImplementationReference> dstImplementation_end() const { return Udm::AssocEndAttr< ::PICML::ComponentImplementationReference>(impl, meta_dstImplementation_end_); }
		Udm::AssocEndAttr< ::PICML::ComponentPackage> srcImplementation_end() const { return Udm::AssocEndAttr< ::PICML::ComponentPackage>(impl, meta_srcImplementation_end_); }
		void Accept(Visitor &v) { v.Visit_Implementation(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageContainer_parent;
		static ::Uml::AssociationRole meta_dstImplementation_end_;
		static ::Uml::AssociationRole meta_srcImplementation_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_PackageContainer_parent {};
		typedef boost::mpl::pair< ::PICML::PackageContainer, PR_PackageContainer_parent > _PR_PackageContainer_parent__PackageContainer;
		typedef boost::mpl::vector< _PR_PackageContainer_parent__PackageContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PackageContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstImplementation {};
		class ACE_srcImplementation {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementationReference, ACE_dstImplementation > _ACE_dstImplementation__ComponentImplementationReference;
		typedef boost::mpl::pair< ::PICML::ComponentPackage, ACE_srcImplementation > _ACE_srcImplementation__ComponentPackage;
		typedef boost::mpl::vector< _ACE_dstImplementation__ComponentImplementationReference, _ACE_srcImplementation__ComponentPackage> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PackageContainer :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		PackageContainer() {}
		PackageContainer(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		PackageContainer(const PackageContainer &master) : MgaObject(master) {}

		static PackageContainer Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PackageContainer Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PackageContainer CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PackageContainer> Instances() { return Udm::InstantiatedAttr<PackageContainer>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PackageContainer, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PackageContainer, Pred>(impl); }
		PackageContainer CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PackageContainer> Derived() { return Udm::DerivedAttr<PackageContainer>(impl); }
		template <class Pred> Udm::DerivedAttr<PackageContainer, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PackageContainer, Pred>(impl); }
		Udm::ArchetypeAttr<PackageContainer> Archetype() const { return Udm::ArchetypeAttr<PackageContainer>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::Implementation> Implementation_children() const { return Udm::ChildrenAttr< ::PICML::Implementation>(impl, meta_Implementation_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Implementation, Pred> Implementation_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Implementation, Pred>(impl, meta_Implementation_children); }
		Udm::ChildAttr< ::PICML::PackageInterface> PackageInterface_child() const { return Udm::ChildAttr< ::PICML::PackageInterface>(impl, meta_PackageInterface_child); }
		Udm::ChildrenAttr< ::PICML::ComponentImplementationReference> ComponentImplementationReference_children() const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationReference>(impl, meta_ComponentImplementationReference_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentImplementationReference, Pred> ComponentImplementationReference_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationReference, Pred>(impl, meta_ComponentImplementationReference_children); }
		Udm::ChildAttr< ::PICML::ComponentRef> ComponentRef_child() const { return Udm::ChildAttr< ::PICML::ComponentRef>(impl, meta_ComponentRef_child); }
		Udm::ChildrenAttr< ::PICML::PackageConfigProperty> PackageConfigProperty_children() const { return Udm::ChildrenAttr< ::PICML::PackageConfigProperty>(impl, meta_PackageConfigProperty_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageConfigProperty, Pred> PackageConfigProperty_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageConfigProperty, Pred>(impl, meta_PackageConfigProperty_children); }
		Udm::ChildrenAttr< ::PICML::Property> Property_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, meta_Property_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); }
		Udm::ChildrenAttr< ::PICML::PackageInfoProperty> PackageInfoProperty_children() const { return Udm::ChildrenAttr< ::PICML::PackageInfoProperty>(impl, meta_PackageInfoProperty_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageInfoProperty, Pred> PackageInfoProperty_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageInfoProperty, Pred>(impl, meta_PackageInfoProperty_children); }
		Udm::ChildAttr< ::PICML::ComponentPackage> ComponentPackage_child() const { return Udm::ChildAttr< ::PICML::ComponentPackage>(impl, meta_ComponentPackage_child); }
		Udm::ChildrenAttr< ::PICML::CollocationGroupMember> CollocationGroupMember_kind_children() const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred> CollocationGroupMember_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentImplementationReference> ComponentImplementationReference_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationReference>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentImplementationReference, Pred> ComponentImplementationReference_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationReference, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PackageInterface> PackageInterface_kind_children() const { return Udm::ChildrenAttr< ::PICML::PackageInterface>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageInterface, Pred> PackageInterface_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageInterface, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Implementation> Implementation_kind_children() const { return Udm::ChildrenAttr< ::PICML::Implementation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Implementation, Pred> Implementation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Implementation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PackageConfigProperty> PackageConfigProperty_kind_children() const { return Udm::ChildrenAttr< ::PICML::PackageConfigProperty>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageConfigProperty, Pred> PackageConfigProperty_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageConfigProperty, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PackageInfoProperty> PackageInfoProperty_kind_children() const { return Udm::ChildrenAttr< ::PICML::PackageInfoProperty>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PackageInfoProperty, Pred> PackageInfoProperty_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PackageInfoProperty, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentPackage> ComponentPackage_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentPackage>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentPackage, Pred> ComponentPackage_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentPackage, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Manageable> Manageable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Manageable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Manageable, Pred> Manageable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Manageable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentRef>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::ComponentPackages> ComponentPackages_parent() const { return Udm::ParentAttr< ::PICML::ComponentPackages>(impl, meta_ComponentPackages_parent); }
		Udm::ParentAttr< ::PICML::ComponentPackages> parent() const { return Udm::ParentAttr< ::PICML::ComponentPackages>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_PackageContainer(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Implementation_children;
		static ::Uml::CompositionChildRole meta_PackageInterface_child;
		static ::Uml::CompositionChildRole meta_ComponentImplementationReference_children;
		static ::Uml::CompositionChildRole meta_ComponentRef_child;
		static ::Uml::CompositionChildRole meta_PackageConfigProperty_children;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_PackageInfoProperty_children;
		static ::Uml::CompositionChildRole meta_ComponentPackage_child;
		static ::Uml::CompositionParentRole meta_ComponentPackages_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentPackages_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentPackages, PR_ComponentPackages_parent > _PR_ComponentPackages_parent__ComponentPackages;
		typedef boost::mpl::vector< _PR_ComponentPackages_parent__ComponentPackages> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentPackages> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Implementation_children {};
		class CR_PackageInterface_child {};
		class CR_ComponentImplementationReference_children {};
		class CR_ComponentRef_child {};
		class CR_PackageConfigProperty_children {};
		class CR_Property_children {};
		class CR_PackageInfoProperty_children {};
		class CR_ComponentPackage_child {};
		typedef boost::mpl::pair< ::PICML::Implementation, CR_Implementation_children > _CR_Implementation_children__Implementation;
		typedef boost::mpl::pair< ::PICML::PackageInterface, CR_PackageInterface_child > _CR_PackageInterface_child__PackageInterface;
		typedef boost::mpl::pair< ::PICML::ComponentImplementationReference, CR_ComponentImplementationReference_children > _CR_ComponentImplementationReference_children__ComponentImplementationReference;
		typedef boost::mpl::pair< ::PICML::ComponentRef, CR_ComponentRef_child > _CR_ComponentRef_child__ComponentRef;
		typedef boost::mpl::pair< ::PICML::PackageConfigProperty, CR_PackageConfigProperty_children > _CR_PackageConfigProperty_children__PackageConfigProperty;
		typedef boost::mpl::pair< ::PICML::Property, CR_Property_children > _CR_Property_children__Property;
		typedef boost::mpl::pair< ::PICML::PackageInfoProperty, CR_PackageInfoProperty_children > _CR_PackageInfoProperty_children__PackageInfoProperty;
		typedef boost::mpl::pair< ::PICML::ComponentPackage, CR_ComponentPackage_child > _CR_ComponentPackage_child__ComponentPackage;
		typedef boost::mpl::vector< _CR_PackageInterface_child__PackageInterface, _CR_ComponentRef_child__ComponentRef, _CR_ComponentPackage_child__ComponentPackage> ChildrenSingle;
		typedef boost::mpl::vector< _CR_Implementation_children__Implementation, _CR_ComponentImplementationReference_children__ComponentImplementationReference, _CR_PackageConfigProperty_children__PackageConfigProperty, _CR_Property_children__Property, _CR_PackageInfoProperty_children__PackageInfoProperty> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentImplementationReference, ::PICML::PackageInterface, ::PICML::Implementation, ::PICML::PackageConfigProperty, ::PICML::PackageInfoProperty, ::PICML::ComponentPackage, ::PICML::Property, ::PICML::ComponentRef> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PackageConfigProperty :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		PackageConfigProperty() {}
		PackageConfigProperty(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		PackageConfigProperty(const PackageConfigProperty &master) : MgaObject(master) {}

		static PackageConfigProperty Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PackageConfigProperty Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PackageConfigProperty CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PackageConfigProperty> Instances() { return Udm::InstantiatedAttr<PackageConfigProperty>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PackageConfigProperty, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PackageConfigProperty, Pred>(impl); }
		PackageConfigProperty CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PackageConfigProperty> Derived() { return Udm::DerivedAttr<PackageConfigProperty>(impl); }
		template <class Pred> Udm::DerivedAttr<PackageConfigProperty, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PackageConfigProperty, Pred>(impl); }
		Udm::ArchetypeAttr<PackageConfigProperty> Archetype() const { return Udm::ArchetypeAttr<PackageConfigProperty>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PackageContainer> PackageContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageContainer>(impl, meta_PackageContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ComponentPackage> srcPackageConfigProperty_end() const { return Udm::AssocEndAttr< ::PICML::ComponentPackage>(impl, meta_srcPackageConfigProperty_end_); }
		Udm::AssocEndAttr< ::PICML::Property> dstPackageConfigProperty_end() const { return Udm::AssocEndAttr< ::PICML::Property>(impl, meta_dstPackageConfigProperty_end_); }
		void Accept(Visitor &v) { v.Visit_PackageConfigProperty(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageContainer_parent;
		static ::Uml::AssociationRole meta_srcPackageConfigProperty_end_;
		static ::Uml::AssociationRole meta_dstPackageConfigProperty_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_PackageContainer_parent {};
		typedef boost::mpl::pair< ::PICML::PackageContainer, PR_PackageContainer_parent > _PR_PackageContainer_parent__PackageContainer;
		typedef boost::mpl::vector< _PR_PackageContainer_parent__PackageContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PackageContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcPackageConfigProperty {};
		class ACE_dstPackageConfigProperty {};
		typedef boost::mpl::pair< ::PICML::ComponentPackage, ACE_srcPackageConfigProperty > _ACE_srcPackageConfigProperty__ComponentPackage;
		typedef boost::mpl::pair< ::PICML::Property, ACE_dstPackageConfigProperty > _ACE_dstPackageConfigProperty__Property;
		typedef boost::mpl::vector< _ACE_srcPackageConfigProperty__ComponentPackage, _ACE_dstPackageConfigProperty__Property> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PackageInfoProperty :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		PackageInfoProperty() {}
		PackageInfoProperty(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		PackageInfoProperty(const PackageInfoProperty &master) : MgaObject(master) {}

		static PackageInfoProperty Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PackageInfoProperty Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PackageInfoProperty CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PackageInfoProperty> Instances() { return Udm::InstantiatedAttr<PackageInfoProperty>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PackageInfoProperty, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PackageInfoProperty, Pred>(impl); }
		PackageInfoProperty CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PackageInfoProperty> Derived() { return Udm::DerivedAttr<PackageInfoProperty>(impl); }
		template <class Pred> Udm::DerivedAttr<PackageInfoProperty, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PackageInfoProperty, Pred>(impl); }
		Udm::ArchetypeAttr<PackageInfoProperty> Archetype() const { return Udm::ArchetypeAttr<PackageInfoProperty>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PackageContainer> PackageContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageContainer>(impl, meta_PackageContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ComponentPackage> srcPackageInfoProperty_end() const { return Udm::AssocEndAttr< ::PICML::ComponentPackage>(impl, meta_srcPackageInfoProperty_end_); }
		Udm::AssocEndAttr< ::PICML::Property> dstPackageInfoProperty_end() const { return Udm::AssocEndAttr< ::PICML::Property>(impl, meta_dstPackageInfoProperty_end_); }
		void Accept(Visitor &v) { v.Visit_PackageInfoProperty(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageContainer_parent;
		static ::Uml::AssociationRole meta_srcPackageInfoProperty_end_;
		static ::Uml::AssociationRole meta_dstPackageInfoProperty_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_PackageContainer_parent {};
		typedef boost::mpl::pair< ::PICML::PackageContainer, PR_PackageContainer_parent > _PR_PackageContainer_parent__PackageContainer;
		typedef boost::mpl::vector< _PR_PackageContainer_parent__PackageContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PackageContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcPackageInfoProperty {};
		class ACE_dstPackageInfoProperty {};
		typedef boost::mpl::pair< ::PICML::ComponentPackage, ACE_srcPackageInfoProperty > _ACE_srcPackageInfoProperty__ComponentPackage;
		typedef boost::mpl::pair< ::PICML::Property, ACE_dstPackageInfoProperty > _ACE_dstPackageInfoProperty__Property;
		typedef boost::mpl::vector< _ACE_srcPackageInfoProperty__ComponentPackage, _ACE_dstPackageInfoProperty__Property> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentPackage :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		ComponentPackage() {}
		ComponentPackage(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ComponentPackage(const ComponentPackage &master) : MgaObject(master) {}

		static ComponentPackage Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentPackage Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentPackage CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentPackage> Instances() { return Udm::InstantiatedAttr<ComponentPackage>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentPackage, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentPackage, Pred>(impl); }
		ComponentPackage CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentPackage> Derived() { return Udm::DerivedAttr<ComponentPackage>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentPackage, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentPackage, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentPackage> Archetype() const { return Udm::ArchetypeAttr<ComponentPackage>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr UUID() const { return Udm::StringAttr(impl, meta_UUID); }
		Udm::StringAttr label() const { return Udm::StringAttr(impl, meta_label); }
		Udm::AClassAssocAttr< ::PICML::Implementation, ::PICML::ComponentImplementationReference> dstImplementation() const { return Udm::AClassAssocAttr< ::PICML::Implementation, ::PICML::ComponentImplementationReference>(impl, meta_dstImplementation, meta_dstImplementation_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::Implementation, ::PICML::ComponentImplementationReference, Pred> dstImplementation_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::Implementation, ::PICML::ComponentImplementationReference, Pred>(impl, meta_dstImplementation, meta_dstImplementation_rev); }
		Udm::AClassAssocAttr< ::PICML::PackageConfBasePackage, ::PICML::PackageConfiguration> srcPackageConfBasePackage() const { return Udm::AClassAssocAttr< ::PICML::PackageConfBasePackage, ::PICML::PackageConfiguration>(impl, meta_srcPackageConfBasePackage, meta_srcPackageConfBasePackage_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::PackageConfBasePackage, ::PICML::PackageConfiguration, Pred> srcPackageConfBasePackage_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::PackageConfBasePackage, ::PICML::PackageConfiguration, Pred>(impl, meta_srcPackageConfBasePackage, meta_srcPackageConfBasePackage_rev); }
		Udm::AClassPointerAttr< ::PICML::PackageInterface, ::PICML::ComponentRef> dstPackageInterface() const { return Udm::AClassPointerAttr< ::PICML::PackageInterface, ::PICML::ComponentRef>(impl, meta_dstPackageInterface, meta_dstPackageInterface_rev); }
		Udm::AClassAssocAttr< ::PICML::PackageConfigProperty, ::PICML::Property> dstPackageConfigProperty() const { return Udm::AClassAssocAttr< ::PICML::PackageConfigProperty, ::PICML::Property>(impl, meta_dstPackageConfigProperty, meta_dstPackageConfigProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::PackageConfigProperty, ::PICML::Property, Pred> dstPackageConfigProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::PackageConfigProperty, ::PICML::Property, Pred>(impl, meta_dstPackageConfigProperty, meta_dstPackageConfigProperty_rev); }
		Udm::AClassAssocAttr< ::PICML::PackageInfoProperty, ::PICML::Property> dstPackageInfoProperty() const { return Udm::AClassAssocAttr< ::PICML::PackageInfoProperty, ::PICML::Property>(impl, meta_dstPackageInfoProperty, meta_dstPackageInfoProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::PackageInfoProperty, ::PICML::Property, Pred> dstPackageInfoProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::PackageInfoProperty, ::PICML::Property, Pred>(impl, meta_dstPackageInfoProperty, meta_dstPackageInfoProperty_rev); }
		Udm::AssocAttr< ::PICML::ComponentPackageReference> referedbyComponentPackageReference() const { return Udm::AssocAttr< ::PICML::ComponentPackageReference>(impl, meta_referedbyComponentPackageReference); }
		template <class Pred> Udm::AssocAttr< ::PICML::ComponentPackageReference, Pred> referedbyComponentPackageReference_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::ComponentPackageReference, Pred>(impl, meta_referedbyComponentPackageReference); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageConfigurationContainer>(impl, meta_PackageConfigurationContainer_parent); }
		Udm::ParentAttr< ::PICML::PackageContainer> PackageContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageContainer>(impl, meta_PackageContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentPackage(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::Attribute meta_label;
		static ::Uml::AssociationRole meta_dstImplementation;
		static ::Uml::AssociationRole meta_dstImplementation_rev;
		static ::Uml::AssociationRole meta_srcPackageConfBasePackage;
		static ::Uml::AssociationRole meta_srcPackageConfBasePackage_rev;
		static ::Uml::AssociationRole meta_dstPackageInterface;
		static ::Uml::AssociationRole meta_dstPackageInterface_rev;
		static ::Uml::AssociationRole meta_dstPackageConfigProperty;
		static ::Uml::AssociationRole meta_dstPackageConfigProperty_rev;
		static ::Uml::AssociationRole meta_dstPackageInfoProperty;
		static ::Uml::AssociationRole meta_dstPackageInfoProperty_rev;
		static ::Uml::AssociationRole meta_referedbyComponentPackageReference;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::CompositionParentRole meta_PackageContainer_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		class PR_PackageConfigurationContainer_parent {};
		class PR_PackageContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::pair< ::PICML::PackageConfigurationContainer, PR_PackageConfigurationContainer_parent > _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer;
		typedef boost::mpl::pair< ::PICML::PackageContainer, PR_PackageContainer_parent > _PR_PackageContainer_parent__PackageContainer;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly, _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer, _PR_PackageContainer_parent__PackageContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly, ::PICML::PackageConfigurationContainer, ::PICML::PackageContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyComponentPackageReference {};
		typedef boost::mpl::pair< ::PICML::ComponentPackageReference, AR_referedbyComponentPackageReference > _AR_referedbyComponentPackageReference__ComponentPackageReference;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyComponentPackageReference__ComponentPackageReference> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstImplementation {};
		class AR_srcPackageConfBasePackage {};
		class AR_dstPackageInterface {};
		class AR_dstPackageConfigProperty {};
		class AR_dstPackageInfoProperty {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementationReference, boost::mpl::pair< ::PICML::Implementation, AR_dstImplementation > > _AR_dstImplementation__Implementation__ComponentImplementationReference;
		typedef boost::mpl::pair< ::PICML::PackageConfiguration, boost::mpl::pair< ::PICML::PackageConfBasePackage, AR_srcPackageConfBasePackage > > _AR_srcPackageConfBasePackage__PackageConfBasePackage__PackageConfiguration;
		typedef boost::mpl::pair< ::PICML::ComponentRef, boost::mpl::pair< ::PICML::PackageInterface, AR_dstPackageInterface > > _AR_dstPackageInterface__PackageInterface__ComponentRef;
		typedef boost::mpl::pair< ::PICML::Property, boost::mpl::pair< ::PICML::PackageConfigProperty, AR_dstPackageConfigProperty > > _AR_dstPackageConfigProperty__PackageConfigProperty__Property;
		typedef boost::mpl::pair< ::PICML::Property, boost::mpl::pair< ::PICML::PackageInfoProperty, AR_dstPackageInfoProperty > > _AR_dstPackageInfoProperty__PackageInfoProperty__Property;
		typedef boost::mpl::vector< _AR_dstPackageInterface__PackageInterface__ComponentRef> AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstImplementation__Implementation__ComponentImplementationReference, _AR_srcPackageConfBasePackage__PackageConfBasePackage__PackageConfiguration, _AR_dstPackageConfigProperty__PackageConfigProperty__Property, _AR_dstPackageInfoProperty__PackageInfoProperty__Property> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentPackageReference :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		ComponentPackageReference() {}
		ComponentPackageReference(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ComponentPackageReference(const ComponentPackageReference &master) : MgaObject(master) {}

		static ComponentPackageReference Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentPackageReference Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentPackageReference CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentPackageReference> Instances() { return Udm::InstantiatedAttr<ComponentPackageReference>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentPackageReference, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentPackageReference, Pred>(impl); }
		ComponentPackageReference CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentPackageReference> Derived() { return Udm::DerivedAttr<ComponentPackageReference>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentPackageReference, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentPackageReference, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentPackageReference> Archetype() const { return Udm::ArchetypeAttr<ComponentPackageReference>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr requiredName() const { return Udm::StringAttr(impl, meta_requiredName); }
		Udm::StringAttr requiredUUID() const { return Udm::StringAttr(impl, meta_requiredUUID); }
		Udm::StringAttr requiredType() const { return Udm::StringAttr(impl, meta_requiredType); }
		Udm::AClassAssocAttr< ::PICML::PackageConfReference, ::PICML::PackageConfiguration> srcPackageConfReference() const { return Udm::AClassAssocAttr< ::PICML::PackageConfReference, ::PICML::PackageConfiguration>(impl, meta_srcPackageConfReference, meta_srcPackageConfReference_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::PackageConfReference, ::PICML::PackageConfiguration, Pred> srcPackageConfReference_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::PackageConfReference, ::PICML::PackageConfiguration, Pred>(impl, meta_srcPackageConfReference, meta_srcPackageConfReference_rev); }
		Udm::PointerAttr< ::PICML::ComponentPackage> ref() const { return Udm::PointerAttr< ::PICML::ComponentPackage>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageConfigurationContainer>(impl, meta_PackageConfigurationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentPackageReference(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_requiredName;
		static ::Uml::Attribute meta_requiredUUID;
		static ::Uml::Attribute meta_requiredType;
		static ::Uml::AssociationRole meta_srcPackageConfReference;
		static ::Uml::AssociationRole meta_srcPackageConfReference_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		class PR_PackageConfigurationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::pair< ::PICML::PackageConfigurationContainer, PR_PackageConfigurationContainer_parent > _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly, _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly, ::PICML::PackageConfigurationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::ComponentPackage, AR_ref > _AR_ref__ComponentPackage;
		typedef boost::mpl::vector< _AR_ref__ComponentPackage> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcPackageConfReference {};
		typedef boost::mpl::pair< ::PICML::PackageConfiguration, boost::mpl::pair< ::PICML::PackageConfReference, AR_srcPackageConfReference > > _AR_srcPackageConfReference__PackageConfReference__PackageConfiguration;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcPackageConfReference__PackageConfReference__PackageConfiguration> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export DataType :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		DataType() {}
		DataType(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		DataType(const DataType &master) : MgaObject(master) {}

		static DataType Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static DataType Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		DataType CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<DataType> Instances() { return Udm::InstantiatedAttr<DataType>(impl); }
		template <class Pred> Udm::InstantiatedAttr<DataType, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<DataType, Pred>(impl); }
		DataType CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<DataType> Derived() { return Udm::DerivedAttr<DataType>(impl); }
		template <class Pred> Udm::DerivedAttr<DataType, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<DataType, Pred>(impl); }
		Udm::ArchetypeAttr<DataType> Archetype() const { return Udm::ArchetypeAttr<DataType>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::MemberType> ref() const { return Udm::PointerAttr< ::PICML::MemberType>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::ComponentPropertyDescription> ComponentPropertyDescription_parent() const { return Udm::ParentAttr< ::PICML::ComponentPropertyDescription>(impl, meta_ComponentPropertyDescription_parent); }
		Udm::ParentAttr< ::PICML::SatisfierProperty> SatisfierProperty_parent() const { return Udm::ParentAttr< ::PICML::SatisfierProperty>(impl, meta_SatisfierProperty_parent); }
		Udm::ParentAttr< ::PICML::Property> Property_parent() const { return Udm::ParentAttr< ::PICML::Property>(impl, meta_Property_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_DataType(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ComponentPropertyDescription_parent;
		static ::Uml::CompositionParentRole meta_SatisfierProperty_parent;
		static ::Uml::CompositionParentRole meta_Property_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentPropertyDescription_parent {};
		class PR_SatisfierProperty_parent {};
		class PR_Property_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentPropertyDescription, PR_ComponentPropertyDescription_parent > _PR_ComponentPropertyDescription_parent__ComponentPropertyDescription;
		typedef boost::mpl::pair< ::PICML::SatisfierProperty, PR_SatisfierProperty_parent > _PR_SatisfierProperty_parent__SatisfierProperty;
		typedef boost::mpl::pair< ::PICML::Property, PR_Property_parent > _PR_Property_parent__Property;
		typedef boost::mpl::vector< _PR_ComponentPropertyDescription_parent__ComponentPropertyDescription, _PR_SatisfierProperty_parent__SatisfierProperty, _PR_Property_parent__Property> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentPropertyDescription, ::PICML::SatisfierProperty, ::PICML::Property> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::MemberType, AR_ref > _AR_ref__MemberType;
		typedef boost::mpl::vector< _AR_ref__MemberType> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export SatisfierProperty :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		SatisfierProperty() {}
		SatisfierProperty(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		SatisfierProperty(const SatisfierProperty &master) : MgaObject(master) {}

		static SatisfierProperty Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static SatisfierProperty Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		SatisfierProperty CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<SatisfierProperty> Instances() { return Udm::InstantiatedAttr<SatisfierProperty>(impl); }
		template <class Pred> Udm::InstantiatedAttr<SatisfierProperty, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<SatisfierProperty, Pred>(impl); }
		SatisfierProperty CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<SatisfierProperty> Derived() { return Udm::DerivedAttr<SatisfierProperty>(impl); }
		template <class Pred> Udm::DerivedAttr<SatisfierProperty, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<SatisfierProperty, Pred>(impl); }
		Udm::ArchetypeAttr<SatisfierProperty> Archetype() const { return Udm::ArchetypeAttr<SatisfierProperty>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr DataValue() const { return Udm::StringAttr(impl, meta_DataValue); }
		Udm::StringAttr SatisfierPropertyKind() const { return Udm::StringAttr(impl, meta_SatisfierPropertyKind); }
		Udm::BooleanAttr dynamic() const { return Udm::BooleanAttr(impl, meta_dynamic); }
		Udm::ChildAttr< ::PICML::DataType> DataType_child() const { return Udm::ChildAttr< ::PICML::DataType>(impl, meta_DataType_child); }
		Udm::ChildrenAttr< ::PICML::DataType> DataType_kind_children() const { return Udm::ChildrenAttr< ::PICML::DataType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DataType, Pred> DataType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DataType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::RequirementSatisfier> RequirementSatisfier_parent() const { return Udm::ParentAttr< ::PICML::RequirementSatisfier>(impl, meta_RequirementSatisfier_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_SatisfierProperty(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_DataValue;
		static ::Uml::Attribute meta_SatisfierPropertyKind;
		static ::Uml::Attribute meta_dynamic;
		static ::Uml::CompositionChildRole meta_DataType_child;
		static ::Uml::CompositionParentRole meta_RequirementSatisfier_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_RequirementSatisfier_parent {};
		typedef boost::mpl::pair< ::PICML::RequirementSatisfier, PR_RequirementSatisfier_parent > _PR_RequirementSatisfier_parent__RequirementSatisfier;
		typedef boost::mpl::vector< _PR_RequirementSatisfier_parent__RequirementSatisfier> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::RequirementSatisfier> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_DataType_child {};
		typedef boost::mpl::pair< ::PICML::DataType, CR_DataType_child > _CR_DataType_child__DataType;
		typedef boost::mpl::vector< _CR_DataType_child__DataType> ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::DataType> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ImplementationDependency :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		ImplementationDependency() {}
		ImplementationDependency(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ImplementationDependency(const ImplementationDependency &master) : MgaObject(master) {}

		static ImplementationDependency Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ImplementationDependency Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ImplementationDependency CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ImplementationDependency> Instances() { return Udm::InstantiatedAttr<ImplementationDependency>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ImplementationDependency, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ImplementationDependency, Pred>(impl); }
		ImplementationDependency CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ImplementationDependency> Derived() { return Udm::DerivedAttr<ImplementationDependency>(impl); }
		template <class Pred> Udm::DerivedAttr<ImplementationDependency, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ImplementationDependency, Pred>(impl); }
		Udm::ArchetypeAttr<ImplementationDependency> Archetype() const { return Udm::ArchetypeAttr<ImplementationDependency>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr requiredType() const { return Udm::StringAttr(impl, meta_requiredType); }
		Udm::AClassAssocAttr< ::PICML::ImplementationDependsOn, ::PICML::ComponentImplementation> srcImplementationDependsOn() const { return Udm::AClassAssocAttr< ::PICML::ImplementationDependsOn, ::PICML::ComponentImplementation>(impl, meta_srcImplementationDependsOn, meta_srcImplementationDependsOn_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ImplementationDependsOn, ::PICML::ComponentImplementation, Pred> srcImplementationDependsOn_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ImplementationDependsOn, ::PICML::ComponentImplementation, Pred>(impl, meta_srcImplementationDependsOn, meta_srcImplementationDependsOn_rev); }
		Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ComponentImplementationContainer>(impl, meta_ComponentImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ImplementationDependency(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_requiredType;
		static ::Uml::AssociationRole meta_srcImplementationDependsOn;
		static ::Uml::AssociationRole meta_srcImplementationDependsOn_rev;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentImplementationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementationContainer, PR_ComponentImplementationContainer_parent > _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer;
		typedef boost::mpl::vector< _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcImplementationDependsOn {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementation, boost::mpl::pair< ::PICML::ImplementationDependsOn, AR_srcImplementationDependsOn > > _AR_srcImplementationDependsOn__ImplementationDependsOn__ComponentImplementation;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcImplementationDependsOn__ImplementationDependsOn__ComponentImplementation> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export RequirementSatisfier :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		RequirementSatisfier() {}
		RequirementSatisfier(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		RequirementSatisfier(const RequirementSatisfier &master) : MgaObject(master) {}

		static RequirementSatisfier Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static RequirementSatisfier Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		RequirementSatisfier CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<RequirementSatisfier> Instances() { return Udm::InstantiatedAttr<RequirementSatisfier>(impl); }
		template <class Pred> Udm::InstantiatedAttr<RequirementSatisfier, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<RequirementSatisfier, Pred>(impl); }
		RequirementSatisfier CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<RequirementSatisfier> Derived() { return Udm::DerivedAttr<RequirementSatisfier>(impl); }
		template <class Pred> Udm::DerivedAttr<RequirementSatisfier, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<RequirementSatisfier, Pred>(impl); }
		Udm::ArchetypeAttr<RequirementSatisfier> Archetype() const { return Udm::ArchetypeAttr<RequirementSatisfier>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr resourceType() const { return Udm::StringAttr(impl, meta_resourceType); }
		Udm::ChildrenAttr< ::PICML::SatisfierProperty> SatisfierProperty_children() const { return Udm::ChildrenAttr< ::PICML::SatisfierProperty>(impl, meta_SatisfierProperty_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SatisfierProperty, Pred> SatisfierProperty_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SatisfierProperty, Pred>(impl, meta_SatisfierProperty_children); }
		Udm::ChildrenAttr< ::PICML::SatisfierProperty> SatisfierProperty_kind_children() const { return Udm::ChildrenAttr< ::PICML::SatisfierProperty>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SatisfierProperty, Pred> SatisfierProperty_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SatisfierProperty, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_resourceType;
		static ::Uml::CompositionChildRole meta_SatisfierProperty_children;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_SatisfierProperty_children {};
		typedef boost::mpl::pair< ::PICML::SatisfierProperty, CR_SatisfierProperty_children > _CR_SatisfierProperty_children__SatisfierProperty;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_SatisfierProperty_children__SatisfierProperty> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::SatisfierProperty> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Resource :  public RequirementSatisfier {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Resource() {}
		Resource(Udm::ObjectImpl *impl) : RequirementSatisfier(impl) {}
		Resource(const Resource &master) : RequirementSatisfier(master) {}

		static Resource Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Resource Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Resource CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Resource> Instances() { return Udm::InstantiatedAttr<Resource>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Resource, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Resource, Pred>(impl); }
		Resource CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Resource> Derived() { return Udm::DerivedAttr<Resource>(impl); }
		template <class Pred> Udm::DerivedAttr<Resource, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Resource, Pred>(impl); }
		Udm::ArchetypeAttr<Resource> Archetype() const { return Udm::ArchetypeAttr<Resource>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::Interconnect> Interconnect_parent() const { return Udm::ParentAttr< ::PICML::Interconnect>(impl, meta_Interconnect_parent); }
		Udm::ParentAttr< ::PICML::Node> Node_parent() const { return Udm::ParentAttr< ::PICML::Node>(impl, meta_Node_parent); }
		Udm::ParentAttr< ::PICML::Bridge> Bridge_parent() const { return Udm::ParentAttr< ::PICML::Bridge>(impl, meta_Bridge_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Resource(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Interconnect_parent;
		static ::Uml::CompositionParentRole meta_Node_parent;
		static ::Uml::CompositionParentRole meta_Bridge_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Interconnect_parent {};
		class PR_Node_parent {};
		class PR_Bridge_parent {};
		typedef boost::mpl::pair< ::PICML::Interconnect, PR_Interconnect_parent > _PR_Interconnect_parent__Interconnect;
		typedef boost::mpl::pair< ::PICML::Node, PR_Node_parent > _PR_Node_parent__Node;
		typedef boost::mpl::pair< ::PICML::Bridge, PR_Bridge_parent > _PR_Bridge_parent__Bridge;
		typedef boost::mpl::vector< _PR_Interconnect_parent__Interconnect, _PR_Node_parent__Node, _PR_Bridge_parent__Bridge> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Interconnect, ::PICML::Node, ::PICML::Bridge> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::SatisfierProperty> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export SharedResource :  public RequirementSatisfier {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		SharedResource() {}
		SharedResource(Udm::ObjectImpl *impl) : RequirementSatisfier(impl) {}
		SharedResource(const SharedResource &master) : RequirementSatisfier(master) {}

		static SharedResource Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static SharedResource Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		SharedResource CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<SharedResource> Instances() { return Udm::InstantiatedAttr<SharedResource>(impl); }
		template <class Pred> Udm::InstantiatedAttr<SharedResource, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<SharedResource, Pred>(impl); }
		SharedResource CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<SharedResource> Derived() { return Udm::DerivedAttr<SharedResource>(impl); }
		template <class Pred> Udm::DerivedAttr<SharedResource, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<SharedResource, Pred>(impl); }
		Udm::ArchetypeAttr<SharedResource> Archetype() const { return Udm::ArchetypeAttr<SharedResource>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::Shares, ::PICML::Node> srcShares() const { return Udm::AClassAssocAttr< ::PICML::Shares, ::PICML::Node>(impl, meta_srcShares, meta_srcShares_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::Shares, ::PICML::Node, Pred> srcShares_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::Shares, ::PICML::Node, Pred>(impl, meta_srcShares, meta_srcShares_rev); }
		Udm::ParentAttr< ::PICML::Domain> Domain_parent() const { return Udm::ParentAttr< ::PICML::Domain>(impl, meta_Domain_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_SharedResource(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcShares;
		static ::Uml::AssociationRole meta_srcShares_rev;
		static ::Uml::CompositionParentRole meta_Domain_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Domain_parent {};
		typedef boost::mpl::pair< ::PICML::Domain, PR_Domain_parent > _PR_Domain_parent__Domain;
		typedef boost::mpl::vector< _PR_Domain_parent__Domain> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Domain> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::SatisfierProperty> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcShares {};
		typedef boost::mpl::pair< ::PICML::Node, boost::mpl::pair< ::PICML::Shares, AR_srcShares > > _AR_srcShares__Shares__Node;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcShares__Shares__Node> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Capability :  public RequirementSatisfier {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Capability() {}
		Capability(Udm::ObjectImpl *impl) : RequirementSatisfier(impl) {}
		Capability(const Capability &master) : RequirementSatisfier(master) {}

		static Capability Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Capability Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Capability CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Capability> Instances() { return Udm::InstantiatedAttr<Capability>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Capability, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Capability, Pred>(impl); }
		Capability CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Capability> Derived() { return Udm::DerivedAttr<Capability>(impl); }
		template <class Pred> Udm::DerivedAttr<Capability, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Capability, Pred>(impl); }
		Udm::ArchetypeAttr<Capability> Archetype() const { return Udm::ArchetypeAttr<Capability>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::ImplementationCapability, ::PICML::ComponentImplementation> srcImplementationCapability() const { return Udm::AClassAssocAttr< ::PICML::ImplementationCapability, ::PICML::ComponentImplementation>(impl, meta_srcImplementationCapability, meta_srcImplementationCapability_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ImplementationCapability, ::PICML::ComponentImplementation, Pred> srcImplementationCapability_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ImplementationCapability, ::PICML::ComponentImplementation, Pred>(impl, meta_srcImplementationCapability, meta_srcImplementationCapability_rev); }
		Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ComponentImplementationContainer>(impl, meta_ComponentImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Capability(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcImplementationCapability;
		static ::Uml::AssociationRole meta_srcImplementationCapability_rev;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentImplementationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementationContainer, PR_ComponentImplementationContainer_parent > _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer;
		typedef boost::mpl::vector< _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::SatisfierProperty> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcImplementationCapability {};
		typedef boost::mpl::pair< ::PICML::ComponentImplementation, boost::mpl::pair< ::PICML::ImplementationCapability, AR_srcImplementationCapability > > _AR_srcImplementationCapability__ImplementationCapability__ComponentImplementation;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcImplementationCapability__ImplementationCapability__ComponentImplementation> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export RequirementBase :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		RequirementBase() {}
		RequirementBase(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		RequirementBase(const RequirementBase &master) : MgaObject(master) {}

		static RequirementBase Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static RequirementBase Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		RequirementBase CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<RequirementBase> Instances() { return Udm::InstantiatedAttr<RequirementBase>(impl); }
		template <class Pred> Udm::InstantiatedAttr<RequirementBase, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<RequirementBase, Pred>(impl); }
		RequirementBase CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<RequirementBase> Derived() { return Udm::DerivedAttr<RequirementBase>(impl); }
		template <class Pred> Udm::DerivedAttr<RequirementBase, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<RequirementBase, Pred>(impl); }
		Udm::ArchetypeAttr<RequirementBase> Archetype() const { return Udm::ArchetypeAttr<RequirementBase>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr resourceType() const { return Udm::StringAttr(impl, meta_resourceType); }
		Udm::ChildrenAttr< ::PICML::Property> Property_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, meta_Property_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); }
		Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_resourceType;
		static ::Uml::CompositionChildRole meta_Property_children;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Property_children {};
		typedef boost::mpl::pair< ::PICML::Property, CR_Property_children > _CR_Property_children__Property;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Property_children__Property> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Requirement :  public RequirementBase {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Requirement() {}
		Requirement(Udm::ObjectImpl *impl) : RequirementBase(impl) {}
		Requirement(const Requirement &master) : RequirementBase(master) {}

		static Requirement Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Requirement Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Requirement CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Requirement> Instances() { return Udm::InstantiatedAttr<Requirement>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Requirement, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Requirement, Pred>(impl); }
		Requirement CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Requirement> Derived() { return Udm::DerivedAttr<Requirement>(impl); }
		template <class Pred> Udm::DerivedAttr<Requirement, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Requirement, Pred>(impl); }
		Udm::ArchetypeAttr<Requirement> Archetype() const { return Udm::ArchetypeAttr<Requirement>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::AssemblyDeployRequirement, ::PICML::PublishConnector> srcAssemblyDeployRequirement() const { return Udm::AClassAssocAttr< ::PICML::AssemblyDeployRequirement, ::PICML::PublishConnector>(impl, meta_srcAssemblyDeployRequirement, meta_srcAssemblyDeployRequirement_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::AssemblyDeployRequirement, ::PICML::PublishConnector, Pred> srcAssemblyDeployRequirement_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::AssemblyDeployRequirement, ::PICML::PublishConnector, Pred>(impl, meta_srcAssemblyDeployRequirement, meta_srcAssemblyDeployRequirement_rev); }
		Udm::AClassAssocAttr< ::PICML::PackageConfSelectRequirement, ::PICML::PackageConfiguration> srcPackageConfSelectRequirement() const { return Udm::AClassAssocAttr< ::PICML::PackageConfSelectRequirement, ::PICML::PackageConfiguration>(impl, meta_srcPackageConfSelectRequirement, meta_srcPackageConfSelectRequirement_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::PackageConfSelectRequirement, ::PICML::PackageConfiguration, Pred> srcPackageConfSelectRequirement_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::PackageConfSelectRequirement, ::PICML::PackageConfiguration, Pred>(impl, meta_srcPackageConfSelectRequirement, meta_srcPackageConfSelectRequirement_rev); }
		Udm::AClassAssocAttr< ::PICML::ArtifactDeployRequirement, ::PICML::ImplementationArtifact> srcArtifactDeployRequirement() const { return Udm::AClassAssocAttr< ::PICML::ArtifactDeployRequirement, ::PICML::ImplementationArtifact>(impl, meta_srcArtifactDeployRequirement, meta_srcArtifactDeployRequirement_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ArtifactDeployRequirement, ::PICML::ImplementationArtifact, Pred> srcArtifactDeployRequirement_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ArtifactDeployRequirement, ::PICML::ImplementationArtifact, Pred>(impl, meta_srcArtifactDeployRequirement, meta_srcArtifactDeployRequirement_rev); }
		Udm::AClassAssocAttr< ::PICML::AssemblyselectRequirement, ::PICML::Component> srcAssemblyselectRequirement() const { return Udm::AClassAssocAttr< ::PICML::AssemblyselectRequirement, ::PICML::Component>(impl, meta_srcAssemblyselectRequirement, meta_srcAssemblyselectRequirement_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::AssemblyselectRequirement, ::PICML::Component, Pred> srcAssemblyselectRequirement_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::AssemblyselectRequirement, ::PICML::Component, Pred>(impl, meta_srcAssemblyselectRequirement, meta_srcAssemblyselectRequirement_rev); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageConfigurationContainer>(impl, meta_PackageConfigurationContainer_parent); }
		Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const { return Udm::ParentAttr< ::PICML::ArtifactContainer>(impl, meta_ArtifactContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Requirement(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcAssemblyDeployRequirement;
		static ::Uml::AssociationRole meta_srcAssemblyDeployRequirement_rev;
		static ::Uml::AssociationRole meta_srcPackageConfSelectRequirement;
		static ::Uml::AssociationRole meta_srcPackageConfSelectRequirement_rev;
		static ::Uml::AssociationRole meta_srcArtifactDeployRequirement;
		static ::Uml::AssociationRole meta_srcArtifactDeployRequirement_rev;
		static ::Uml::AssociationRole meta_srcAssemblyselectRequirement;
		static ::Uml::AssociationRole meta_srcAssemblyselectRequirement_rev;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		class PR_PackageConfigurationContainer_parent {};
		class PR_ArtifactContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::pair< ::PICML::PackageConfigurationContainer, PR_PackageConfigurationContainer_parent > _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer;
		typedef boost::mpl::pair< ::PICML::ArtifactContainer, PR_ArtifactContainer_parent > _PR_ArtifactContainer_parent__ArtifactContainer;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly, _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer, _PR_ArtifactContainer_parent__ArtifactContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly, ::PICML::PackageConfigurationContainer, ::PICML::ArtifactContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcAssemblyDeployRequirement {};
		class AR_srcPackageConfSelectRequirement {};
		class AR_srcArtifactDeployRequirement {};
		class AR_srcAssemblyselectRequirement {};
		typedef boost::mpl::pair< ::PICML::PublishConnector, boost::mpl::pair< ::PICML::AssemblyDeployRequirement, AR_srcAssemblyDeployRequirement > > _AR_srcAssemblyDeployRequirement__AssemblyDeployRequirement__PublishConnector;
		typedef boost::mpl::pair< ::PICML::PackageConfiguration, boost::mpl::pair< ::PICML::PackageConfSelectRequirement, AR_srcPackageConfSelectRequirement > > _AR_srcPackageConfSelectRequirement__PackageConfSelectRequirement__PackageConfiguration;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, boost::mpl::pair< ::PICML::ArtifactDeployRequirement, AR_srcArtifactDeployRequirement > > _AR_srcArtifactDeployRequirement__ArtifactDeployRequirement__ImplementationArtifact;
		typedef boost::mpl::pair< ::PICML::Component, boost::mpl::pair< ::PICML::AssemblyselectRequirement, AR_srcAssemblyselectRequirement > > _AR_srcAssemblyselectRequirement__AssemblyselectRequirement__Component;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcAssemblyDeployRequirement__AssemblyDeployRequirement__PublishConnector, _AR_srcPackageConfSelectRequirement__PackageConfSelectRequirement__PackageConfiguration, _AR_srcArtifactDeployRequirement__ArtifactDeployRequirement__ImplementationArtifact, _AR_srcAssemblyselectRequirement__AssemblyselectRequirement__Component> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export RTRequirements :  public Requirement {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		RTRequirements() {}
		RTRequirements(Udm::ObjectImpl *impl) : Requirement(impl) {}
		RTRequirements(const RTRequirements &master) : Requirement(master) {}

		static RTRequirements Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static RTRequirements Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		RTRequirements CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<RTRequirements> Instances() { return Udm::InstantiatedAttr<RTRequirements>(impl); }
		template <class Pred> Udm::InstantiatedAttr<RTRequirements, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<RTRequirements, Pred>(impl); }
		RTRequirements CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<RTRequirements> Derived() { return Udm::DerivedAttr<RTRequirements>(impl); }
		template <class Pred> Udm::DerivedAttr<RTRequirements, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<RTRequirements, Pred>(impl); }
		Udm::ArchetypeAttr<RTRequirements> Archetype() const { return Udm::ArchetypeAttr<RTRequirements>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildAttr< ::PICML::ServiceProvider> ServiceProvider_child() const { return Udm::ChildAttr< ::PICML::ServiceProvider>(impl, meta_ServiceProvider_child); }
		Udm::ChildAttr< ::PICML::ServiceConsumer> ServiceConsumer_child() const { return Udm::ChildAttr< ::PICML::ServiceConsumer>(impl, meta_ServiceConsumer_child); }
		Udm::ChildrenAttr< ::PICML::ServiceProvider> ServiceProvider_kind_children() const { return Udm::ChildrenAttr< ::PICML::ServiceProvider>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ServiceProvider, Pred> ServiceProvider_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ServiceProvider, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ServiceConsumer> ServiceConsumer_kind_children() const { return Udm::ChildrenAttr< ::PICML::ServiceConsumer>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ServiceConsumer, Pred> ServiceConsumer_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ServiceConsumer, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_RTRequirements(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_ServiceProvider_child;
		static ::Uml::CompositionChildRole meta_ServiceConsumer_child;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly, ::PICML::PackageConfigurationContainer, ::PICML::ArtifactContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ServiceProvider_child {};
		class CR_ServiceConsumer_child {};
		typedef boost::mpl::pair< ::PICML::ServiceProvider, CR_ServiceProvider_child > _CR_ServiceProvider_child__ServiceProvider;
		typedef boost::mpl::pair< ::PICML::ServiceConsumer, CR_ServiceConsumer_child > _CR_ServiceConsumer_child__ServiceConsumer;
		typedef boost::mpl::vector< _CR_ServiceProvider_child__ServiceProvider, _CR_ServiceConsumer_child__ServiceConsumer> ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ServiceProvider, ::PICML::ServiceConsumer, ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ECRequirements :  public Requirement {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ECRequirements() {}
		ECRequirements(Udm::ObjectImpl *impl) : Requirement(impl) {}
		ECRequirements(const ECRequirements &master) : Requirement(master) {}

		static ECRequirements Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ECRequirements Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ECRequirements CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ECRequirements> Instances() { return Udm::InstantiatedAttr<ECRequirements>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ECRequirements, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ECRequirements, Pred>(impl); }
		ECRequirements CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ECRequirements> Derived() { return Udm::DerivedAttr<ECRequirements>(impl); }
		template <class Pred> Udm::DerivedAttr<ECRequirements, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ECRequirements, Pred>(impl); }
		Udm::ArchetypeAttr<ECRequirements> Archetype() const { return Udm::ArchetypeAttr<ECRequirements>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::BooleanAttr ConfigureRTQoS() const { return Udm::BooleanAttr(impl, meta_ConfigureRTQoS); }
		Udm::ChildrenAttr< ::PICML::ECRole> ECRole_children() const { return Udm::ChildrenAttr< ::PICML::ECRole>(impl, meta_ECRole_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ECRole, Pred> ECRole_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ECRole, Pred>(impl, meta_ECRole_children); }
		Udm::ChildAttr< ::PICML::ECBehavior> ECBehavior_child() const { return Udm::ChildAttr< ::PICML::ECBehavior>(impl, meta_ECBehavior_child); }
		Udm::ChildrenAttr< ::PICML::ECBehavior> ECBehavior_kind_children() const { return Udm::ChildrenAttr< ::PICML::ECBehavior>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ECBehavior, Pred> ECBehavior_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ECBehavior, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ECRole> ECRole_kind_children() const { return Udm::ChildrenAttr< ::PICML::ECRole>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ECRole, Pred> ECRole_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ECRole, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ECRequirements(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_ConfigureRTQoS;
		static ::Uml::CompositionChildRole meta_ECRole_children;
		static ::Uml::CompositionChildRole meta_ECBehavior_child;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly, ::PICML::PackageConfigurationContainer, ::PICML::ArtifactContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ECRole_children {};
		class CR_ECBehavior_child {};
		typedef boost::mpl::pair< ::PICML::ECRole, CR_ECRole_children > _CR_ECRole_children__ECRole;
		typedef boost::mpl::pair< ::PICML::ECBehavior, CR_ECBehavior_child > _CR_ECBehavior_child__ECBehavior;
		typedef boost::mpl::vector< _CR_ECBehavior_child__ECBehavior> ChildrenSingle;
		typedef boost::mpl::vector< _CR_ECRole_children__ECRole> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ECBehavior, ::PICML::ECRole, ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ImplementationRequirement :  public RequirementBase {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ImplementationRequirement() {}
		ImplementationRequirement(Udm::ObjectImpl *impl) : RequirementBase(impl) {}
		ImplementationRequirement(const ImplementationRequirement &master) : RequirementBase(master) {}

		static ImplementationRequirement Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ImplementationRequirement Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ImplementationRequirement CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ImplementationRequirement> Instances() { return Udm::InstantiatedAttr<ImplementationRequirement>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ImplementationRequirement, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ImplementationRequirement, Pred>(impl); }
		ImplementationRequirement CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ImplementationRequirement> Derived() { return Udm::DerivedAttr<ImplementationRequirement>(impl); }
		template <class Pred> Udm::DerivedAttr<ImplementationRequirement, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ImplementationRequirement, Pred>(impl); }
		Udm::ArchetypeAttr<ImplementationRequirement> Archetype() const { return Udm::ArchetypeAttr<ImplementationRequirement>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr ResourceUsageKind() const { return Udm::StringAttr(impl, meta_ResourceUsageKind); }
		Udm::StringAttr componentPort() const { return Udm::StringAttr(impl, meta_componentPort); }
		Udm::StringAttr resourcePort() const { return Udm::StringAttr(impl, meta_resourcePort); }
		Udm::AClassAssocAttr< ::PICML::MonolithDeployRequirement, ::PICML::MonolithicImplementationBase> srcMonolithDeployRequirement() const { return Udm::AClassAssocAttr< ::PICML::MonolithDeployRequirement, ::PICML::MonolithicImplementationBase>(impl, meta_srcMonolithDeployRequirement, meta_srcMonolithDeployRequirement_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::MonolithDeployRequirement, ::PICML::MonolithicImplementationBase, Pred> srcMonolithDeployRequirement_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::MonolithDeployRequirement, ::PICML::MonolithicImplementationBase, Pred>(impl, meta_srcMonolithDeployRequirement, meta_srcMonolithDeployRequirement_rev); }
		Udm::ParentAttr< ::PICML::ImplementationContainer> ImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ImplementationContainer>(impl, meta_ImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ImplementationRequirement(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_ResourceUsageKind;
		static ::Uml::Attribute meta_componentPort;
		static ::Uml::Attribute meta_resourcePort;
		static ::Uml::AssociationRole meta_srcMonolithDeployRequirement;
		static ::Uml::AssociationRole meta_srcMonolithDeployRequirement_rev;
		static ::Uml::CompositionParentRole meta_ImplementationContainer_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ImplementationContainer_parent {};
		typedef boost::mpl::pair< ::PICML::ImplementationContainer, PR_ImplementationContainer_parent > _PR_ImplementationContainer_parent__ImplementationContainer;
		typedef boost::mpl::vector< _PR_ImplementationContainer_parent__ImplementationContainer> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ImplementationContainer> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcMonolithDeployRequirement {};
		typedef boost::mpl::pair< ::PICML::MonolithicImplementationBase, boost::mpl::pair< ::PICML::MonolithDeployRequirement, AR_srcMonolithDeployRequirement > > _AR_srcMonolithDeployRequirement__MonolithDeployRequirement__MonolithicImplementationBase;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcMonolithDeployRequirement__MonolithDeployRequirement__MonolithicImplementationBase> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Property :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Property() {}
		Property(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Property(const Property &master) : MgaObject(master) {}

		static Property Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Property Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Property CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Property> Instances() { return Udm::InstantiatedAttr<Property>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Property, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Property, Pred>(impl); }
		Property CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Property> Derived() { return Udm::DerivedAttr<Property>(impl); }
		template <class Pred> Udm::DerivedAttr<Property, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Property, Pred>(impl); }
		Udm::ArchetypeAttr<Property> Archetype() const { return Udm::ArchetypeAttr<Property>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr DataValue() const { return Udm::StringAttr(impl, meta_DataValue); }
		Udm::AClassAssocAttr< ::PICML::MonolithExecParameter, ::PICML::MonolithicImplementationBase> srcMonolithExecParameter() const { return Udm::AClassAssocAttr< ::PICML::MonolithExecParameter, ::PICML::MonolithicImplementationBase>(impl, meta_srcMonolithExecParameter, meta_srcMonolithExecParameter_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::MonolithExecParameter, ::PICML::MonolithicImplementationBase, Pred> srcMonolithExecParameter_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::MonolithExecParameter, ::PICML::MonolithicImplementationBase, Pred>(impl, meta_srcMonolithExecParameter, meta_srcMonolithExecParameter_rev); }
		Udm::AClassAssocAttr< ::PICML::InfoProperty, ::PICML::Implemenation> srcInfoProperty() const { return Udm::AClassAssocAttr< ::PICML::InfoProperty, ::PICML::Implemenation>(impl, meta_srcInfoProperty, meta_srcInfoProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::InfoProperty, ::PICML::Implemenation, Pred> srcInfoProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::InfoProperty, ::PICML::Implemenation, Pred>(impl, meta_srcInfoProperty, meta_srcInfoProperty_rev); }
		Udm::AClassAssocAttr< ::PICML::ConfigProperty, ::PICML::Implemenation> srcConfigProperty() const { return Udm::AClassAssocAttr< ::PICML::ConfigProperty, ::PICML::Implemenation>(impl, meta_srcConfigProperty, meta_srcConfigProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ConfigProperty, ::PICML::Implemenation, Pred> srcConfigProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ConfigProperty, ::PICML::Implemenation, Pred>(impl, meta_srcConfigProperty, meta_srcConfigProperty_rev); }
		Udm::AClassAssocAttr< ::PICML::PathProperty, ::PICML::Path> srcPathProperty() const { return Udm::AClassAssocAttr< ::PICML::PathProperty, ::PICML::Path>(impl, meta_srcPathProperty, meta_srcPathProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::PathProperty, ::PICML::Path, Pred> srcPathProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::PathProperty, ::PICML::Path, Pred>(impl, meta_srcPathProperty, meta_srcPathProperty_rev); }
		Udm::AClassAssocAttr< ::PICML::EdgeProperty, ::PICML::Edge> dstPropertyConnector() const { return Udm::AClassAssocAttr< ::PICML::EdgeProperty, ::PICML::Edge>(impl, meta_dstPropertyConnector, meta_dstPropertyConnector_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::EdgeProperty, ::PICML::Edge, Pred> dstPropertyConnector_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::EdgeProperty, ::PICML::Edge, Pred>(impl, meta_dstPropertyConnector, meta_dstPropertyConnector_rev); }
		Udm::AClassPointerAttr< ::PICML::AttributeMappingValue, ::PICML::AttributeMapping> srcAttributeMappingValue() const { return Udm::AClassPointerAttr< ::PICML::AttributeMappingValue, ::PICML::AttributeMapping>(impl, meta_srcAttributeMappingValue, meta_srcAttributeMappingValue_rev); }
		Udm::AClassAssocAttr< ::PICML::PackageConfConfigProperty, ::PICML::PackageConfiguration> srcPackageConfConfigProperty() const { return Udm::AClassAssocAttr< ::PICML::PackageConfConfigProperty, ::PICML::PackageConfiguration>(impl, meta_srcPackageConfConfigProperty, meta_srcPackageConfConfigProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::PackageConfConfigProperty, ::PICML::PackageConfiguration, Pred> srcPackageConfConfigProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::PackageConfConfigProperty, ::PICML::PackageConfiguration, Pred>(impl, meta_srcPackageConfConfigProperty, meta_srcPackageConfConfigProperty_rev); }
		Udm::AClassAssocAttr< ::PICML::ArtifactExecParameter, ::PICML::ImplementationArtifact> srcArtifactExecParameter() const { return Udm::AClassAssocAttr< ::PICML::ArtifactExecParameter, ::PICML::ImplementationArtifact>(impl, meta_srcArtifactExecParameter, meta_srcArtifactExecParameter_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ArtifactExecParameter, ::PICML::ImplementationArtifact, Pred> srcArtifactExecParameter_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ArtifactExecParameter, ::PICML::ImplementationArtifact, Pred>(impl, meta_srcArtifactExecParameter, meta_srcArtifactExecParameter_rev); }
		Udm::AClassAssocAttr< ::PICML::ArtifactInfoProperty, ::PICML::ImplementationArtifact> srcArtifactInfoProperty() const { return Udm::AClassAssocAttr< ::PICML::ArtifactInfoProperty, ::PICML::ImplementationArtifact>(impl, meta_srcArtifactInfoProperty, meta_srcArtifactInfoProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ArtifactInfoProperty, ::PICML::ImplementationArtifact, Pred> srcArtifactInfoProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ArtifactInfoProperty, ::PICML::ImplementationArtifact, Pred>(impl, meta_srcArtifactInfoProperty, meta_srcArtifactInfoProperty_rev); }
		Udm::AClassAssocAttr< ::PICML::PackageConfigProperty, ::PICML::ComponentPackage> srcPackageConfigProperty() const { return Udm::AClassAssocAttr< ::PICML::PackageConfigProperty, ::PICML::ComponentPackage>(impl, meta_srcPackageConfigProperty, meta_srcPackageConfigProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::PackageConfigProperty, ::PICML::ComponentPackage, Pred> srcPackageConfigProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::PackageConfigProperty, ::PICML::ComponentPackage, Pred>(impl, meta_srcPackageConfigProperty, meta_srcPackageConfigProperty_rev); }
		Udm::AClassAssocAttr< ::PICML::PackageInfoProperty, ::PICML::ComponentPackage> srcPackageInfoProperty() const { return Udm::AClassAssocAttr< ::PICML::PackageInfoProperty, ::PICML::ComponentPackage>(impl, meta_srcPackageInfoProperty, meta_srcPackageInfoProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::PackageInfoProperty, ::PICML::ComponentPackage, Pred> srcPackageInfoProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::PackageInfoProperty, ::PICML::ComponentPackage, Pred>(impl, meta_srcPackageInfoProperty, meta_srcPackageInfoProperty_rev); }
		Udm::AClassAssocAttr< ::PICML::ComponentConfigProperty, ::PICML::ComponentRef> srcComponentConfigProperty() const { return Udm::AClassAssocAttr< ::PICML::ComponentConfigProperty, ::PICML::ComponentRef>(impl, meta_srcComponentConfigProperty, meta_srcComponentConfigProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ComponentConfigProperty, ::PICML::ComponentRef, Pred> srcComponentConfigProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ComponentConfigProperty, ::PICML::ComponentRef, Pred>(impl, meta_srcComponentConfigProperty, meta_srcComponentConfigProperty_rev); }
		Udm::AClassAssocAttr< ::PICML::ComponentInfoProperty, ::PICML::ComponentRef> srcComponentInfoProperty() const { return Udm::AClassAssocAttr< ::PICML::ComponentInfoProperty, ::PICML::ComponentRef>(impl, meta_srcComponentInfoProperty, meta_srcComponentInfoProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ComponentInfoProperty, ::PICML::ComponentRef, Pred> srcComponentInfoProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ComponentInfoProperty, ::PICML::ComponentRef, Pred>(impl, meta_srcComponentInfoProperty, meta_srcComponentInfoProperty_rev); }
		Udm::AClassAssocAttr< ::PICML::AssemblyConfigProperty, ::PICML::Component> srcAssemblyConfigProperty() const { return Udm::AClassAssocAttr< ::PICML::AssemblyConfigProperty, ::PICML::Component>(impl, meta_srcAssemblyConfigProperty, meta_srcAssemblyConfigProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::AssemblyConfigProperty, ::PICML::Component, Pred> srcAssemblyConfigProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::AssemblyConfigProperty, ::PICML::Component, Pred>(impl, meta_srcAssemblyConfigProperty, meta_srcAssemblyConfigProperty_rev); }
		Udm::AClassAssocAttr< ::PICML::AttributeValue, ::PICML::ReadonlyAttribute> srcAttributeValue() const { return Udm::AClassAssocAttr< ::PICML::AttributeValue, ::PICML::ReadonlyAttribute>(impl, meta_srcAttributeValue, meta_srcAttributeValue_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::AttributeValue, ::PICML::ReadonlyAttribute, Pred> srcAttributeValue_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::AttributeValue, ::PICML::ReadonlyAttribute, Pred>(impl, meta_srcAttributeValue, meta_srcAttributeValue_rev); }
		Udm::ChildAttr< ::PICML::DataType> DataType_child() const { return Udm::ChildAttr< ::PICML::DataType>(impl, meta_DataType_child); }
		Udm::ChildrenAttr< ::PICML::DataType> DataType_kind_children() const { return Udm::ChildrenAttr< ::PICML::DataType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DataType, Pred> DataType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DataType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::ImplementationContainer> ImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ImplementationContainer>(impl, meta_ImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::Path> Path_parent() const { return Udm::ParentAttr< ::PICML::Path>(impl, meta_Path_parent); }
		Udm::ParentAttr< ::PICML::Paths> Paths_parent() const { return Udm::ParentAttr< ::PICML::Paths>(impl, meta_Paths_parent); }
		Udm::ParentAttr< ::PICML::DeploymentPlan> DeploymentPlan_parent() const { return Udm::ParentAttr< ::PICML::DeploymentPlan>(impl, meta_DeploymentPlan_parent); }
		Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageConfigurationContainer>(impl, meta_PackageConfigurationContainer_parent); }
		Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const { return Udm::ParentAttr< ::PICML::ArtifactContainer>(impl, meta_ArtifactContainer_parent); }
		Udm::ParentAttr< ::PICML::ComponentContainer> ComponentContainer_parent() const { return Udm::ParentAttr< ::PICML::ComponentContainer>(impl, meta_ComponentContainer_parent); }
		Udm::ParentAttr< ::PICML::PackageContainer> PackageContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageContainer>(impl, meta_PackageContainer_parent); }
		Udm::ParentAttr< ::PICML::RequirementBase> RequirementBase_parent() const { return Udm::ParentAttr< ::PICML::RequirementBase>(impl, meta_RequirementBase_parent); }
		Udm::ParentAttr< ::PICML::Domain> Domain_parent() const { return Udm::ParentAttr< ::PICML::Domain>(impl, meta_Domain_parent); }
		Udm::ParentAttr< ::PICML::BehaviorInputAction> BehaviorInputAction_parent() const { return Udm::ParentAttr< ::PICML::BehaviorInputAction>(impl, meta_BehaviorInputAction_parent); }
		Udm::ParentAttr< ::PICML::QueryInputAction> QueryInputAction_parent() const { return Udm::ParentAttr< ::PICML::QueryInputAction>(impl, meta_QueryInputAction_parent); }
		Udm::ParentAttr< ::PICML::ActionBase> ActionBase_parent() const { return Udm::ParentAttr< ::PICML::ActionBase>(impl, meta_ActionBase_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Property(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_DataValue;
		static ::Uml::AssociationRole meta_srcMonolithExecParameter;
		static ::Uml::AssociationRole meta_srcMonolithExecParameter_rev;
		static ::Uml::AssociationRole meta_srcInfoProperty;
		static ::Uml::AssociationRole meta_srcInfoProperty_rev;
		static ::Uml::AssociationRole meta_srcConfigProperty;
		static ::Uml::AssociationRole meta_srcConfigProperty_rev;
		static ::Uml::AssociationRole meta_srcPathProperty;
		static ::Uml::AssociationRole meta_srcPathProperty_rev;
		static ::Uml::AssociationRole meta_dstPropertyConnector;
		static ::Uml::AssociationRole meta_dstPropertyConnector_rev;
		static ::Uml::AssociationRole meta_srcAttributeMappingValue;
		static ::Uml::AssociationRole meta_srcAttributeMappingValue_rev;
		static ::Uml::AssociationRole meta_srcPackageConfConfigProperty;
		static ::Uml::AssociationRole meta_srcPackageConfConfigProperty_rev;
		static ::Uml::AssociationRole meta_srcArtifactExecParameter;
		static ::Uml::AssociationRole meta_srcArtifactExecParameter_rev;
		static ::Uml::AssociationRole meta_srcArtifactInfoProperty;
		static ::Uml::AssociationRole meta_srcArtifactInfoProperty_rev;
		static ::Uml::AssociationRole meta_srcPackageConfigProperty;
		static ::Uml::AssociationRole meta_srcPackageConfigProperty_rev;
		static ::Uml::AssociationRole meta_srcPackageInfoProperty;
		static ::Uml::AssociationRole meta_srcPackageInfoProperty_rev;
		static ::Uml::AssociationRole meta_srcComponentConfigProperty;
		static ::Uml::AssociationRole meta_srcComponentConfigProperty_rev;
		static ::Uml::AssociationRole meta_srcComponentInfoProperty;
		static ::Uml::AssociationRole meta_srcComponentInfoProperty_rev;
		static ::Uml::AssociationRole meta_srcAssemblyConfigProperty;
		static ::Uml::AssociationRole meta_srcAssemblyConfigProperty_rev;
		static ::Uml::AssociationRole meta_srcAttributeValue;
		static ::Uml::AssociationRole meta_srcAttributeValue_rev;
		static ::Uml::CompositionChildRole meta_DataType_child;
		static ::Uml::CompositionParentRole meta_ImplementationContainer_parent;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::CompositionParentRole meta_Path_parent;
		static ::Uml::CompositionParentRole meta_Paths_parent;
		static ::Uml::CompositionParentRole meta_DeploymentPlan_parent;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::CompositionParentRole meta_ComponentContainer_parent;
		static ::Uml::CompositionParentRole meta_PackageContainer_parent;
		static ::Uml::CompositionParentRole meta_RequirementBase_parent;
		static ::Uml::CompositionParentRole meta_Domain_parent;
		static ::Uml::CompositionParentRole meta_BehaviorInputAction_parent;
		static ::Uml::CompositionParentRole meta_QueryInputAction_parent;
		static ::Uml::CompositionParentRole meta_ActionBase_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ImplementationContainer_parent {};
		class PR_ComponentAssembly_parent {};
		class PR_Path_parent {};
		class PR_Paths_parent {};
		class PR_DeploymentPlan_parent {};
		class PR_PackageConfigurationContainer_parent {};
		class PR_ArtifactContainer_parent {};
		class PR_ComponentContainer_parent {};
		class PR_PackageContainer_parent {};
		class PR_RequirementBase_parent {};
		class PR_Domain_parent {};
		class PR_BehaviorInputAction_parent {};
		class PR_QueryInputAction_parent {};
		class PR_ActionBase_parent {};
		typedef boost::mpl::pair< ::PICML::ImplementationContainer, PR_ImplementationContainer_parent > _PR_ImplementationContainer_parent__ImplementationContainer;
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::pair< ::PICML::Path, PR_Path_parent > _PR_Path_parent__Path;
		typedef boost::mpl::pair< ::PICML::Paths, PR_Paths_parent > _PR_Paths_parent__Paths;
		typedef boost::mpl::pair< ::PICML::DeploymentPlan, PR_DeploymentPlan_parent > _PR_DeploymentPlan_parent__DeploymentPlan;
		typedef boost::mpl::pair< ::PICML::PackageConfigurationContainer, PR_PackageConfigurationContainer_parent > _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer;
		typedef boost::mpl::pair< ::PICML::ArtifactContainer, PR_ArtifactContainer_parent > _PR_ArtifactContainer_parent__ArtifactContainer;
		typedef boost::mpl::pair< ::PICML::ComponentContainer, PR_ComponentContainer_parent > _PR_ComponentContainer_parent__ComponentContainer;
		typedef boost::mpl::pair< ::PICML::PackageContainer, PR_PackageContainer_parent > _PR_PackageContainer_parent__PackageContainer;
		typedef boost::mpl::pair< ::PICML::RequirementBase, PR_RequirementBase_parent > _PR_RequirementBase_parent__RequirementBase;
		typedef boost::mpl::pair< ::PICML::Domain, PR_Domain_parent > _PR_Domain_parent__Domain;
		typedef boost::mpl::pair< ::PICML::BehaviorInputAction, PR_BehaviorInputAction_parent > _PR_BehaviorInputAction_parent__BehaviorInputAction;
		typedef boost::mpl::pair< ::PICML::QueryInputAction, PR_QueryInputAction_parent > _PR_QueryInputAction_parent__QueryInputAction;
		typedef boost::mpl::pair< ::PICML::ActionBase, PR_ActionBase_parent > _PR_ActionBase_parent__ActionBase;
		typedef boost::mpl::vector< _PR_ImplementationContainer_parent__ImplementationContainer, _PR_ComponentAssembly_parent__ComponentAssembly, _PR_Path_parent__Path, _PR_Paths_parent__Paths, _PR_DeploymentPlan_parent__DeploymentPlan, _PR_PackageConfigurationContainer_parent__PackageConfigurationContainer, _PR_ArtifactContainer_parent__ArtifactContainer, _PR_ComponentContainer_parent__ComponentContainer, _PR_PackageContainer_parent__PackageContainer, _PR_RequirementBase_parent__RequirementBase, _PR_Domain_parent__Domain, _PR_BehaviorInputAction_parent__BehaviorInputAction, _PR_QueryInputAction_parent__QueryInputAction, _PR_ActionBase_parent__ActionBase> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ImplementationContainer, ::PICML::ComponentAssembly, ::PICML::Path, ::PICML::Paths, ::PICML::DeploymentPlan, ::PICML::PackageConfigurationContainer, ::PICML::ArtifactContainer, ::PICML::ComponentContainer, ::PICML::PackageContainer, ::PICML::RequirementBase, ::PICML::Domain, ::PICML::BehaviorInputAction, ::PICML::QueryInputAction, ::PICML::ActionBase> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_DataType_child {};
		typedef boost::mpl::pair< ::PICML::DataType, CR_DataType_child > _CR_DataType_child__DataType;
		typedef boost::mpl::vector< _CR_DataType_child__DataType> ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::DataType> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcMonolithExecParameter {};
		class AR_srcInfoProperty {};
		class AR_srcConfigProperty {};
		class AR_srcPathProperty {};
		class AR_dstPropertyConnector {};
		class AR_srcAttributeMappingValue {};
		class AR_srcPackageConfConfigProperty {};
		class AR_srcArtifactExecParameter {};
		class AR_srcArtifactInfoProperty {};
		class AR_srcPackageConfigProperty {};
		class AR_srcPackageInfoProperty {};
		class AR_srcComponentConfigProperty {};
		class AR_srcComponentInfoProperty {};
		class AR_srcAssemblyConfigProperty {};
		class AR_srcAttributeValue {};
		typedef boost::mpl::pair< ::PICML::MonolithicImplementationBase, boost::mpl::pair< ::PICML::MonolithExecParameter, AR_srcMonolithExecParameter > > _AR_srcMonolithExecParameter__MonolithExecParameter__MonolithicImplementationBase;
		typedef boost::mpl::pair< ::PICML::Implemenation, boost::mpl::pair< ::PICML::InfoProperty, AR_srcInfoProperty > > _AR_srcInfoProperty__InfoProperty__Implemenation;
		typedef boost::mpl::pair< ::PICML::Implemenation, boost::mpl::pair< ::PICML::ConfigProperty, AR_srcConfigProperty > > _AR_srcConfigProperty__ConfigProperty__Implemenation;
		typedef boost::mpl::pair< ::PICML::Path, boost::mpl::pair< ::PICML::PathProperty, AR_srcPathProperty > > _AR_srcPathProperty__PathProperty__Path;
		typedef boost::mpl::pair< ::PICML::Edge, boost::mpl::pair< ::PICML::EdgeProperty, AR_dstPropertyConnector > > _AR_dstPropertyConnector__EdgeProperty__Edge;
		typedef boost::mpl::pair< ::PICML::AttributeMapping, boost::mpl::pair< ::PICML::AttributeMappingValue, AR_srcAttributeMappingValue > > _AR_srcAttributeMappingValue__AttributeMappingValue__AttributeMapping;
		typedef boost::mpl::pair< ::PICML::PackageConfiguration, boost::mpl::pair< ::PICML::PackageConfConfigProperty, AR_srcPackageConfConfigProperty > > _AR_srcPackageConfConfigProperty__PackageConfConfigProperty__PackageConfiguration;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, boost::mpl::pair< ::PICML::ArtifactExecParameter, AR_srcArtifactExecParameter > > _AR_srcArtifactExecParameter__ArtifactExecParameter__ImplementationArtifact;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, boost::mpl::pair< ::PICML::ArtifactInfoProperty, AR_srcArtifactInfoProperty > > _AR_srcArtifactInfoProperty__ArtifactInfoProperty__ImplementationArtifact;
		typedef boost::mpl::pair< ::PICML::ComponentPackage, boost::mpl::pair< ::PICML::PackageConfigProperty, AR_srcPackageConfigProperty > > _AR_srcPackageConfigProperty__PackageConfigProperty__ComponentPackage;
		typedef boost::mpl::pair< ::PICML::ComponentPackage, boost::mpl::pair< ::PICML::PackageInfoProperty, AR_srcPackageInfoProperty > > _AR_srcPackageInfoProperty__PackageInfoProperty__ComponentPackage;
		typedef boost::mpl::pair< ::PICML::ComponentRef, boost::mpl::pair< ::PICML::ComponentConfigProperty, AR_srcComponentConfigProperty > > _AR_srcComponentConfigProperty__ComponentConfigProperty__ComponentRef;
		typedef boost::mpl::pair< ::PICML::ComponentRef, boost::mpl::pair< ::PICML::ComponentInfoProperty, AR_srcComponentInfoProperty > > _AR_srcComponentInfoProperty__ComponentInfoProperty__ComponentRef;
		typedef boost::mpl::pair< ::PICML::Component, boost::mpl::pair< ::PICML::AssemblyConfigProperty, AR_srcAssemblyConfigProperty > > _AR_srcAssemblyConfigProperty__AssemblyConfigProperty__Component;
		typedef boost::mpl::pair< ::PICML::ReadonlyAttribute, boost::mpl::pair< ::PICML::AttributeValue, AR_srcAttributeValue > > _AR_srcAttributeValue__AttributeValue__ReadonlyAttribute;
		typedef boost::mpl::vector< _AR_srcAttributeMappingValue__AttributeMappingValue__AttributeMapping> AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcMonolithExecParameter__MonolithExecParameter__MonolithicImplementationBase, _AR_srcInfoProperty__InfoProperty__Implemenation, _AR_srcConfigProperty__ConfigProperty__Implemenation, _AR_srcPathProperty__PathProperty__Path, _AR_dstPropertyConnector__EdgeProperty__Edge, _AR_srcPackageConfConfigProperty__PackageConfConfigProperty__PackageConfiguration, _AR_srcArtifactExecParameter__ArtifactExecParameter__ImplementationArtifact, _AR_srcArtifactInfoProperty__ArtifactInfoProperty__ImplementationArtifact, _AR_srcPackageConfigProperty__PackageConfigProperty__ComponentPackage, _AR_srcPackageInfoProperty__PackageInfoProperty__ComponentPackage, _AR_srcComponentConfigProperty__ComponentConfigProperty__ComponentRef, _AR_srcComponentInfoProperty__ComponentInfoProperty__ComponentRef, _AR_srcAssemblyConfigProperty__AssemblyConfigProperty__Component, _AR_srcAttributeValue__AttributeValue__ReadonlyAttribute> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Shares :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		Shares() {}
		Shares(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Shares(const Shares &master) : MgaObject(master) {}

		static Shares Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Shares Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Shares CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Shares> Instances() { return Udm::InstantiatedAttr<Shares>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Shares, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Shares, Pred>(impl); }
		Shares CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Shares> Derived() { return Udm::DerivedAttr<Shares>(impl); }
		template <class Pred> Udm::DerivedAttr<Shares, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Shares, Pred>(impl); }
		Udm::ArchetypeAttr<Shares> Archetype() const { return Udm::ArchetypeAttr<Shares>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::Domain> Domain_parent() const { return Udm::ParentAttr< ::PICML::Domain>(impl, meta_Domain_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::Node> srcShares_end() const { return Udm::AssocEndAttr< ::PICML::Node>(impl, meta_srcShares_end_); }
		Udm::AssocEndAttr< ::PICML::SharedResource> dstShares_end() const { return Udm::AssocEndAttr< ::PICML::SharedResource>(impl, meta_dstShares_end_); }
		void Accept(Visitor &v) { v.Visit_Shares(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Domain_parent;
		static ::Uml::AssociationRole meta_srcShares_end_;
		static ::Uml::AssociationRole meta_dstShares_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_Domain_parent {};
		typedef boost::mpl::pair< ::PICML::Domain, PR_Domain_parent > _PR_Domain_parent__Domain;
		typedef boost::mpl::vector< _PR_Domain_parent__Domain> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Domain> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcShares {};
		class ACE_dstShares {};
		typedef boost::mpl::pair< ::PICML::Node, ACE_srcShares > _ACE_srcShares__Node;
		typedef boost::mpl::pair< ::PICML::SharedResource, ACE_dstShares > _ACE_dstShares__SharedResource;
		typedef boost::mpl::vector< _ACE_srcShares__Node, _ACE_dstShares__SharedResource> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export InterconnectConnection :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		InterconnectConnection() {}
		InterconnectConnection(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		InterconnectConnection(const InterconnectConnection &master) : MgaObject(master) {}

		static InterconnectConnection Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static InterconnectConnection Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		InterconnectConnection CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<InterconnectConnection> Instances() { return Udm::InstantiatedAttr<InterconnectConnection>(impl); }
		template <class Pred> Udm::InstantiatedAttr<InterconnectConnection, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<InterconnectConnection, Pred>(impl); }
		InterconnectConnection CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<InterconnectConnection> Derived() { return Udm::DerivedAttr<InterconnectConnection>(impl); }
		template <class Pred> Udm::DerivedAttr<InterconnectConnection, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<InterconnectConnection, Pred>(impl); }
		Udm::ArchetypeAttr<InterconnectConnection> Archetype() const { return Udm::ArchetypeAttr<InterconnectConnection>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::Domain> Domain_parent() const { return Udm::ParentAttr< ::PICML::Domain>(impl, meta_Domain_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::Interconnect> dstInterconnectConnection_end() const { return Udm::AssocEndAttr< ::PICML::Interconnect>(impl, meta_dstInterconnectConnection_end_); }
		Udm::AssocEndAttr< ::PICML::Node> srcInterconnectConnection_end() const { return Udm::AssocEndAttr< ::PICML::Node>(impl, meta_srcInterconnectConnection_end_); }
		void Accept(Visitor &v) { v.Visit_InterconnectConnection(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Domain_parent;
		static ::Uml::AssociationRole meta_dstInterconnectConnection_end_;
		static ::Uml::AssociationRole meta_srcInterconnectConnection_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_Domain_parent {};
		typedef boost::mpl::pair< ::PICML::Domain, PR_Domain_parent > _PR_Domain_parent__Domain;
		typedef boost::mpl::vector< _PR_Domain_parent__Domain> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Domain> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstInterconnectConnection {};
		class ACE_srcInterconnectConnection {};
		typedef boost::mpl::pair< ::PICML::Interconnect, ACE_dstInterconnectConnection > _ACE_dstInterconnectConnection__Interconnect;
		typedef boost::mpl::pair< ::PICML::Node, ACE_srcInterconnectConnection > _ACE_srcInterconnectConnection__Node;
		typedef boost::mpl::vector< _ACE_dstInterconnectConnection__Interconnect, _ACE_srcInterconnectConnection__Node> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export BridgeConnection :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		BridgeConnection() {}
		BridgeConnection(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		BridgeConnection(const BridgeConnection &master) : MgaObject(master) {}

		static BridgeConnection Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static BridgeConnection Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		BridgeConnection CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<BridgeConnection> Instances() { return Udm::InstantiatedAttr<BridgeConnection>(impl); }
		template <class Pred> Udm::InstantiatedAttr<BridgeConnection, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<BridgeConnection, Pred>(impl); }
		BridgeConnection CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<BridgeConnection> Derived() { return Udm::DerivedAttr<BridgeConnection>(impl); }
		template <class Pred> Udm::DerivedAttr<BridgeConnection, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<BridgeConnection, Pred>(impl); }
		Udm::ArchetypeAttr<BridgeConnection> Archetype() const { return Udm::ArchetypeAttr<BridgeConnection>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::Domain> Domain_parent() const { return Udm::ParentAttr< ::PICML::Domain>(impl, meta_Domain_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::Interconnect> srcBridgeConnection_end() const { return Udm::AssocEndAttr< ::PICML::Interconnect>(impl, meta_srcBridgeConnection_end_); }
		Udm::AssocEndAttr< ::PICML::Bridge> dstBridgeConnection_end() const { return Udm::AssocEndAttr< ::PICML::Bridge>(impl, meta_dstBridgeConnection_end_); }
		void Accept(Visitor &v) { v.Visit_BridgeConnection(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Domain_parent;
		static ::Uml::AssociationRole meta_srcBridgeConnection_end_;
		static ::Uml::AssociationRole meta_dstBridgeConnection_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_Domain_parent {};
		typedef boost::mpl::pair< ::PICML::Domain, PR_Domain_parent > _PR_Domain_parent__Domain;
		typedef boost::mpl::vector< _PR_Domain_parent__Domain> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Domain> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcBridgeConnection {};
		class ACE_dstBridgeConnection {};
		typedef boost::mpl::pair< ::PICML::Interconnect, ACE_srcBridgeConnection > _ACE_srcBridgeConnection__Interconnect;
		typedef boost::mpl::pair< ::PICML::Bridge, ACE_dstBridgeConnection > _ACE_dstBridgeConnection__Bridge;
		typedef boost::mpl::vector< _ACE_srcBridgeConnection__Interconnect, _ACE_dstBridgeConnection__Bridge> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Domain :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Domain() {}
		Domain(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Domain(const Domain &master) : MgaObject(master) {}

		static Domain Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Domain Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Domain CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Domain> Instances() { return Udm::InstantiatedAttr<Domain>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Domain, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Domain, Pred>(impl); }
		Domain CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Domain> Derived() { return Udm::DerivedAttr<Domain>(impl); }
		template <class Pred> Udm::DerivedAttr<Domain, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Domain, Pred>(impl); }
		Udm::ArchetypeAttr<Domain> Archetype() const { return Udm::ArchetypeAttr<Domain>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr label() const { return Udm::StringAttr(impl, meta_label); }
		Udm::StringAttr UUID() const { return Udm::StringAttr(impl, meta_UUID); }
		Udm::ChildrenAttr< ::PICML::Interconnect> Interconnect_children() const { return Udm::ChildrenAttr< ::PICML::Interconnect>(impl, meta_Interconnect_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Interconnect, Pred> Interconnect_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Interconnect, Pred>(impl, meta_Interconnect_children); }
		Udm::ChildrenAttr< ::PICML::InterconnectConnection> InterconnectConnection_children() const { return Udm::ChildrenAttr< ::PICML::InterconnectConnection>(impl, meta_InterconnectConnection_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InterconnectConnection, Pred> InterconnectConnection_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InterconnectConnection, Pred>(impl, meta_InterconnectConnection_children); }
		Udm::ChildrenAttr< ::PICML::Node> Node_children() const { return Udm::ChildrenAttr< ::PICML::Node>(impl, meta_Node_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Node, Pred> Node_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Node, Pred>(impl, meta_Node_children); }
		Udm::ChildrenAttr< ::PICML::BridgeConnection> BridgeConnection_children() const { return Udm::ChildrenAttr< ::PICML::BridgeConnection>(impl, meta_BridgeConnection_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::BridgeConnection, Pred> BridgeConnection_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::BridgeConnection, Pred>(impl, meta_BridgeConnection_children); }
		Udm::ChildrenAttr< ::PICML::Bridge> Bridge_children() const { return Udm::ChildrenAttr< ::PICML::Bridge>(impl, meta_Bridge_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Bridge, Pred> Bridge_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Bridge, Pred>(impl, meta_Bridge_children); }
		Udm::ChildrenAttr< ::PICML::SharedResource> SharedResource_children() const { return Udm::ChildrenAttr< ::PICML::SharedResource>(impl, meta_SharedResource_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SharedResource, Pred> SharedResource_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SharedResource, Pred>(impl, meta_SharedResource_children); }
		Udm::ChildrenAttr< ::PICML::Shares> Shares_children() const { return Udm::ChildrenAttr< ::PICML::Shares>(impl, meta_Shares_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Shares, Pred> Shares_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Shares, Pred>(impl, meta_Shares_children); }
		Udm::ChildrenAttr< ::PICML::Property> Property_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, meta_Property_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); }
		Udm::ChildrenAttr< ::PICML::Interconnect> Interconnect_kind_children() const { return Udm::ChildrenAttr< ::PICML::Interconnect>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Interconnect, Pred> Interconnect_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Interconnect, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Node> Node_kind_children() const { return Udm::ChildrenAttr< ::PICML::Node>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Node, Pred> Node_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Node, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Bridge> Bridge_kind_children() const { return Udm::ChildrenAttr< ::PICML::Bridge>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Bridge, Pred> Bridge_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Bridge, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::SharedResource> SharedResource_kind_children() const { return Udm::ChildrenAttr< ::PICML::SharedResource>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SharedResource, Pred> SharedResource_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SharedResource, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RequirementSatisfier> RequirementSatisfier_kind_children() const { return Udm::ChildrenAttr< ::PICML::RequirementSatisfier>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred> RequirementSatisfier_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Shares> Shares_kind_children() const { return Udm::ChildrenAttr< ::PICML::Shares>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Shares, Pred> Shares_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Shares, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::InterconnectConnection> InterconnectConnection_kind_children() const { return Udm::ChildrenAttr< ::PICML::InterconnectConnection>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InterconnectConnection, Pred> InterconnectConnection_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InterconnectConnection, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::BridgeConnection> BridgeConnection_kind_children() const { return Udm::ChildrenAttr< ::PICML::BridgeConnection>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::BridgeConnection, Pred> BridgeConnection_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::BridgeConnection, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::Targets> Targets_parent() const { return Udm::ParentAttr< ::PICML::Targets>(impl, meta_Targets_parent); }
		Udm::ParentAttr< ::PICML::Targets> parent() const { return Udm::ParentAttr< ::PICML::Targets>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Domain(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_label;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::CompositionChildRole meta_Interconnect_children;
		static ::Uml::CompositionChildRole meta_InterconnectConnection_children;
		static ::Uml::CompositionChildRole meta_Node_children;
		static ::Uml::CompositionChildRole meta_BridgeConnection_children;
		static ::Uml::CompositionChildRole meta_Bridge_children;
		static ::Uml::CompositionChildRole meta_SharedResource_children;
		static ::Uml::CompositionChildRole meta_Shares_children;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionParentRole meta_Targets_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Targets_parent {};
		typedef boost::mpl::pair< ::PICML::Targets, PR_Targets_parent > _PR_Targets_parent__Targets;
		typedef boost::mpl::vector< _PR_Targets_parent__Targets> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Targets> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Interconnect_children {};
		class CR_InterconnectConnection_children {};
		class CR_Node_children {};
		class CR_BridgeConnection_children {};
		class CR_Bridge_children {};
		class CR_SharedResource_children {};
		class CR_Shares_children {};
		class CR_Property_children {};
		typedef boost::mpl::pair< ::PICML::Interconnect, CR_Interconnect_children > _CR_Interconnect_children__Interconnect;
		typedef boost::mpl::pair< ::PICML::InterconnectConnection, CR_InterconnectConnection_children > _CR_InterconnectConnection_children__InterconnectConnection;
		typedef boost::mpl::pair< ::PICML::Node, CR_Node_children > _CR_Node_children__Node;
		typedef boost::mpl::pair< ::PICML::BridgeConnection, CR_BridgeConnection_children > _CR_BridgeConnection_children__BridgeConnection;
		typedef boost::mpl::pair< ::PICML::Bridge, CR_Bridge_children > _CR_Bridge_children__Bridge;
		typedef boost::mpl::pair< ::PICML::SharedResource, CR_SharedResource_children > _CR_SharedResource_children__SharedResource;
		typedef boost::mpl::pair< ::PICML::Shares, CR_Shares_children > _CR_Shares_children__Shares;
		typedef boost::mpl::pair< ::PICML::Property, CR_Property_children > _CR_Property_children__Property;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Interconnect_children__Interconnect, _CR_InterconnectConnection_children__InterconnectConnection, _CR_Node_children__Node, _CR_BridgeConnection_children__BridgeConnection, _CR_Bridge_children__Bridge, _CR_SharedResource_children__SharedResource, _CR_Shares_children__Shares, _CR_Property_children__Property> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Interconnect, ::PICML::Node, ::PICML::Bridge, ::PICML::SharedResource, ::PICML::Property, ::PICML::Shares, ::PICML::InterconnectConnection, ::PICML::BridgeConnection> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Prefixable :  virtual  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Prefixable() {}
		Prefixable(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Prefixable(const Prefixable &master) : MgaObject(master) {}

		static Prefixable Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Prefixable Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Prefixable CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Prefixable> Instances() { return Udm::InstantiatedAttr<Prefixable>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Prefixable, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Prefixable, Pred>(impl); }
		Prefixable CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Prefixable> Derived() { return Udm::DerivedAttr<Prefixable>(impl); }
		template <class Pred> Udm::DerivedAttr<Prefixable, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Prefixable, Pred>(impl); }
		Udm::ArchetypeAttr<Prefixable> Archetype() const { return Udm::ArchetypeAttr<Prefixable>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr PrefixTag() const { return Udm::StringAttr(impl, meta_PrefixTag); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_PrefixTag;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Taggable :  virtual  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		Taggable() {}
		Taggable(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Taggable(const Taggable &master) : MgaObject(master) {}

		static Taggable Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Taggable Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Taggable CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Taggable> Instances() { return Udm::InstantiatedAttr<Taggable>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Taggable, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Taggable, Pred>(impl); }
		Taggable CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Taggable> Derived() { return Udm::DerivedAttr<Taggable>(impl); }
		template <class Pred> Udm::DerivedAttr<Taggable, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Taggable, Pred>(impl); }
		Udm::ArchetypeAttr<Taggable> Archetype() const { return Udm::ArchetypeAttr<Taggable>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr SpecifyIdTag() const { return Udm::StringAttr(impl, meta_SpecifyIdTag); }
		Udm::StringAttr VersionTag() const { return Udm::StringAttr(impl, meta_VersionTag); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_SpecifyIdTag;
		static ::Uml::Attribute meta_VersionTag;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Port :  public GraphVertex,  public CommonPortAttrs,  public Taggable {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		Port() {}
		Port(Udm::ObjectImpl *impl) : GraphVertex(impl),CommonPortAttrs(impl),Taggable(impl), MgaObject(impl) {}
		Port(const Port &master) : GraphVertex(master),CommonPortAttrs(master),Taggable(master), MgaObject(master) {}

		static Port Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Port Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Port CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Port> Instances() { return Udm::InstantiatedAttr<Port>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Port, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Port, Pred>(impl); }
		Port CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Port> Derived() { return Udm::DerivedAttr<Port>(impl); }
		template <class Pred> Udm::DerivedAttr<Port, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Port, Pred>(impl); }
		Udm::ArchetypeAttr<Port> Archetype() const { return Udm::ArchetypeAttr<Port>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::ExternalDelegate, ::PICML::ExternalPortReference> srcExternalDelegate() const { return Udm::AClassAssocAttr< ::PICML::ExternalDelegate, ::PICML::ExternalPortReference>(impl, meta_srcExternalDelegate, meta_srcExternalDelegate_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ExternalDelegate, ::PICML::ExternalPortReference, Pred> srcExternalDelegate_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ExternalDelegate, ::PICML::ExternalPortReference, Pred>(impl, meta_srcExternalDelegate, meta_srcExternalDelegate_rev); }
		Udm::ParentAttr< ::PICML::ConnectedComponent> ConnectedComponent_parent() const { return Udm::ParentAttr< ::PICML::ConnectedComponent>(impl, meta_ConnectedComponent_parent); }
		Udm::ParentAttr< ::PICML::Component> Component_parent() const { return Udm::ParentAttr< ::PICML::Component>(impl, meta_Component_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcExternalDelegate;
		static ::Uml::AssociationRole meta_srcExternalDelegate_rev;
		static ::Uml::CompositionParentRole meta_ConnectedComponent_parent;
		static ::Uml::CompositionParentRole meta_Component_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ConnectedComponent_parent {};
		class PR_Component_parent {};
		typedef boost::mpl::pair< ::PICML::ConnectedComponent, PR_ConnectedComponent_parent > _PR_ConnectedComponent_parent__ConnectedComponent;
		typedef boost::mpl::pair< ::PICML::Component, PR_Component_parent > _PR_Component_parent__Component;
		typedef boost::mpl::vector< _PR_ConnectedComponent_parent__ConnectedComponent, _PR_Component_parent__Component> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ConnectedComponent, ::PICML::Path, ::PICML::Component> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcExternalDelegate {};
		typedef boost::mpl::pair< ::PICML::ExternalPortReference, boost::mpl::pair< ::PICML::ExternalDelegate, AR_srcExternalDelegate > > _AR_srcExternalDelegate__ExternalDelegate__ExternalPortReference;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcExternalDelegate__ExternalDelegate__ExternalPortReference> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Manageable :  virtual  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		Manageable() {}
		Manageable(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Manageable(const Manageable &master) : MgaObject(master) {}

		static Manageable Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Manageable Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Manageable CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Manageable> Instances() { return Udm::InstantiatedAttr<Manageable>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Manageable, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Manageable, Pred>(impl); }
		Manageable CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Manageable> Derived() { return Udm::DerivedAttr<Manageable>(impl); }
		template <class Pred> Udm::DerivedAttr<Manageable, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Manageable, Pred>(impl); }
		Udm::ArchetypeAttr<Manageable> Archetype() const { return Udm::ArchetypeAttr<Manageable>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::ManagesComponent, ::PICML::ComponentFactory> srcManagesComponent() const { return Udm::AClassAssocAttr< ::PICML::ManagesComponent, ::PICML::ComponentFactory>(impl, meta_srcManagesComponent, meta_srcManagesComponent_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ManagesComponent, ::PICML::ComponentFactory, Pred> srcManagesComponent_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ManagesComponent, ::PICML::ComponentFactory, Pred>(impl, meta_srcManagesComponent, meta_srcManagesComponent_rev); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcManagesComponent;
		static ::Uml::AssociationRole meta_srcManagesComponent_rev;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcManagesComponent {};
		typedef boost::mpl::pair< ::PICML::ComponentFactory, boost::mpl::pair< ::PICML::ManagesComponent, AR_srcManagesComponent > > _AR_srcManagesComponent__ManagesComponent__ComponentFactory;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcManagesComponent__ManagesComponent__ComponentFactory> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Provideable :  public ExternalPortReferenceType {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		Provideable() {}
		Provideable(Udm::ObjectImpl *impl) : ExternalPortReferenceType(impl), MgaObject(impl) {}
		Provideable(const Provideable &master) : ExternalPortReferenceType(master), MgaObject(master) {}

		static Provideable Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Provideable Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Provideable CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Provideable> Instances() { return Udm::InstantiatedAttr<Provideable>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Provideable, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Provideable, Pred>(impl); }
		Provideable CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Provideable> Derived() { return Udm::DerivedAttr<Provideable>(impl); }
		template <class Pred> Udm::DerivedAttr<Provideable, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Provideable, Pred>(impl); }
		Udm::ArchetypeAttr<Provideable> Archetype() const { return Udm::ArchetypeAttr<Provideable>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::RequiredRequestPort> referedbyRequiredRequestPort() const { return Udm::AssocAttr< ::PICML::RequiredRequestPort>(impl, meta_referedbyRequiredRequestPort); }
		template <class Pred> Udm::AssocAttr< ::PICML::RequiredRequestPort, Pred> referedbyRequiredRequestPort_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::RequiredRequestPort, Pred>(impl, meta_referedbyRequiredRequestPort); }
		Udm::AssocAttr< ::PICML::ProvidedRequestPort> referedbyProvidedRequestPort() const { return Udm::AssocAttr< ::PICML::ProvidedRequestPort>(impl, meta_referedbyProvidedRequestPort); }
		template <class Pred> Udm::AssocAttr< ::PICML::ProvidedRequestPort, Pred> referedbyProvidedRequestPort_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::ProvidedRequestPort, Pred>(impl, meta_referedbyProvidedRequestPort); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyRequiredRequestPort;
		static ::Uml::AssociationRole meta_referedbyProvidedRequestPort;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyRequiredRequestPort {};
		class AR_referedbyProvidedRequestPort {};
		typedef boost::mpl::pair< ::PICML::RequiredRequestPort, AR_referedbyRequiredRequestPort > _AR_referedbyRequiredRequestPort__RequiredRequestPort;
		typedef boost::mpl::pair< ::PICML::ProvidedRequestPort, AR_referedbyProvidedRequestPort > _AR_referedbyProvidedRequestPort__ProvidedRequestPort;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyRequiredRequestPort__RequiredRequestPort, _AR_referedbyProvidedRequestPort__ProvidedRequestPort> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentRef :  public CollocationGroupMember,  public Manageable {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		ComponentRef() {}
		ComponentRef(Udm::ObjectImpl *impl) : CollocationGroupMember(impl),Manageable(impl), MgaObject(impl) {}
		ComponentRef(const ComponentRef &master) : CollocationGroupMember(master),Manageable(master), MgaObject(master) {}

		static ComponentRef Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentRef Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentRef CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentRef> Instances() { return Udm::InstantiatedAttr<ComponentRef>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentRef, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentRef, Pred>(impl); }
		ComponentRef CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentRef> Derived() { return Udm::DerivedAttr<ComponentRef>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentRef, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentRef, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentRef> Archetype() const { return Udm::ArchetypeAttr<ComponentRef>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::SharedComponentReference> referedbySharedComponentReference() const { return Udm::AssocAttr< ::PICML::SharedComponentReference>(impl, meta_referedbySharedComponentReference); }
		template <class Pred> Udm::AssocAttr< ::PICML::SharedComponentReference, Pred> referedbySharedComponentReference_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::SharedComponentReference, Pred>(impl, meta_referedbySharedComponentReference); }
		Udm::AClassPointerAttr< ::PICML::Deploys, ::PICML::ComponentFactoryRef> srcDeploys() const { return Udm::AClassPointerAttr< ::PICML::Deploys, ::PICML::ComponentFactoryRef>(impl, meta_srcDeploys, meta_srcDeploys_rev); }
		Udm::AClassPointerAttr< ::PICML::Implements, ::PICML::ComponentImplementation> srcImplements() const { return Udm::AClassPointerAttr< ::PICML::Implements, ::PICML::ComponentImplementation>(impl, meta_srcImplements, meta_srcImplements_rev); }
		Udm::AClassAssocAttr< ::PICML::ComponentProperty, ::PICML::ComponentPropertyDescription> dstComponentProperty() const { return Udm::AClassAssocAttr< ::PICML::ComponentProperty, ::PICML::ComponentPropertyDescription>(impl, meta_dstComponentProperty, meta_dstComponentProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ComponentProperty, ::PICML::ComponentPropertyDescription, Pred> dstComponentProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ComponentProperty, ::PICML::ComponentPropertyDescription, Pred>(impl, meta_dstComponentProperty, meta_dstComponentProperty_rev); }
		Udm::AClassPointerAttr< ::PICML::PackageInterface, ::PICML::ComponentPackage> srcPackageInterface() const { return Udm::AClassPointerAttr< ::PICML::PackageInterface, ::PICML::ComponentPackage>(impl, meta_srcPackageInterface, meta_srcPackageInterface_rev); }
		Udm::AClassAssocAttr< ::PICML::ComponentConfigProperty, ::PICML::Property> dstComponentConfigProperty() const { return Udm::AClassAssocAttr< ::PICML::ComponentConfigProperty, ::PICML::Property>(impl, meta_dstComponentConfigProperty, meta_dstComponentConfigProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ComponentConfigProperty, ::PICML::Property, Pred> dstComponentConfigProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ComponentConfigProperty, ::PICML::Property, Pred>(impl, meta_dstComponentConfigProperty, meta_dstComponentConfigProperty_rev); }
		Udm::AClassAssocAttr< ::PICML::ComponentInfoProperty, ::PICML::Property> dstComponentInfoProperty() const { return Udm::AClassAssocAttr< ::PICML::ComponentInfoProperty, ::PICML::Property>(impl, meta_dstComponentInfoProperty, meta_dstComponentInfoProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ComponentInfoProperty, ::PICML::Property, Pred> dstComponentInfoProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ComponentInfoProperty, ::PICML::Property, Pred>(impl, meta_dstComponentInfoProperty, meta_dstComponentInfoProperty_rev); }
		Udm::PointerAttr< ::PICML::Component> ref() const { return Udm::PointerAttr< ::PICML::Component>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::Path> Path_parent() const { return Udm::ParentAttr< ::PICML::Path>(impl, meta_Path_parent); }
		Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const { return Udm::ParentAttr< ::PICML::ComponentImplementationContainer>(impl, meta_ComponentImplementationContainer_parent); }
		Udm::ParentAttr< ::PICML::ComponentContainer> ComponentContainer_parent() const { return Udm::ParentAttr< ::PICML::ComponentContainer>(impl, meta_ComponentContainer_parent); }
		Udm::ParentAttr< ::PICML::PackageContainer> PackageContainer_parent() const { return Udm::ParentAttr< ::PICML::PackageContainer>(impl, meta_PackageContainer_parent); }
		Udm::ParentAttr< ::PICML::Package> Package_parent() const { return Udm::ParentAttr< ::PICML::Package>(impl, meta_Package_parent); }
		Udm::ParentAttr< ::PICML::File> File_parent() const { return Udm::ParentAttr< ::PICML::File>(impl, meta_File_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentRef(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbySharedComponentReference;
		static ::Uml::AssociationRole meta_srcDeploys;
		static ::Uml::AssociationRole meta_srcDeploys_rev;
		static ::Uml::AssociationRole meta_srcImplements;
		static ::Uml::AssociationRole meta_srcImplements_rev;
		static ::Uml::AssociationRole meta_dstComponentProperty;
		static ::Uml::AssociationRole meta_dstComponentProperty_rev;
		static ::Uml::AssociationRole meta_srcPackageInterface;
		static ::Uml::AssociationRole meta_srcPackageInterface_rev;
		static ::Uml::AssociationRole meta_dstComponentConfigProperty;
		static ::Uml::AssociationRole meta_dstComponentConfigProperty_rev;
		static ::Uml::AssociationRole meta_dstComponentInfoProperty;
		static ::Uml::AssociationRole meta_dstComponentInfoProperty_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::CompositionParentRole meta_Path_parent;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;
		static ::Uml::CompositionParentRole meta_ComponentContainer_parent;
		static ::Uml::CompositionParentRole meta_PackageContainer_parent;
		static ::Uml::CompositionParentRole meta_Package_parent;
		static ::Uml::CompositionParentRole meta_File_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		class PR_Path_parent {};
		class PR_ComponentImplementationContainer_parent {};
		class PR_ComponentContainer_parent {};
		class PR_PackageContainer_parent {};
		class PR_Package_parent {};
		class PR_File_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::pair< ::PICML::Path, PR_Path_parent > _PR_Path_parent__Path;
		typedef boost::mpl::pair< ::PICML::ComponentImplementationContainer, PR_ComponentImplementationContainer_parent > _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer;
		typedef boost::mpl::pair< ::PICML::ComponentContainer, PR_ComponentContainer_parent > _PR_ComponentContainer_parent__ComponentContainer;
		typedef boost::mpl::pair< ::PICML::PackageContainer, PR_PackageContainer_parent > _PR_PackageContainer_parent__PackageContainer;
		typedef boost::mpl::pair< ::PICML::Package, PR_Package_parent > _PR_Package_parent__Package;
		typedef boost::mpl::pair< ::PICML::File, PR_File_parent > _PR_File_parent__File;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly, _PR_Path_parent__Path, _PR_ComponentImplementationContainer_parent__ComponentImplementationContainer, _PR_ComponentContainer_parent__ComponentContainer, _PR_PackageContainer_parent__PackageContainer, _PR_Package_parent__Package, _PR_File_parent__File> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly, ::PICML::Path, ::PICML::DeploymentPlan, ::PICML::ComponentImplementationContainer, ::PICML::ComponentContainer, ::PICML::PackageContainer, ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbySharedComponentReference {};
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::SharedComponentReference, AR_referedbySharedComponentReference > _AR_referedbySharedComponentReference__SharedComponentReference;
		typedef boost::mpl::pair< ::PICML::Component, AR_ref > _AR_ref__Component;
		typedef boost::mpl::vector< _AR_ref__Component> AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbySharedComponentReference__SharedComponentReference> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcDeploys {};
		class AR_srcImplements {};
		class AR_dstComponentProperty {};
		class AR_srcPackageInterface {};
		class AR_dstComponentConfigProperty {};
		class AR_dstComponentInfoProperty {};
		typedef boost::mpl::pair< ::PICML::ComponentFactoryRef, boost::mpl::pair< ::PICML::Deploys, AR_srcDeploys > > _AR_srcDeploys__Deploys__ComponentFactoryRef;
		typedef boost::mpl::pair< ::PICML::ComponentImplementation, boost::mpl::pair< ::PICML::Implements, AR_srcImplements > > _AR_srcImplements__Implements__ComponentImplementation;
		typedef boost::mpl::pair< ::PICML::ComponentPropertyDescription, boost::mpl::pair< ::PICML::ComponentProperty, AR_dstComponentProperty > > _AR_dstComponentProperty__ComponentProperty__ComponentPropertyDescription;
		typedef boost::mpl::pair< ::PICML::ComponentPackage, boost::mpl::pair< ::PICML::PackageInterface, AR_srcPackageInterface > > _AR_srcPackageInterface__PackageInterface__ComponentPackage;
		typedef boost::mpl::pair< ::PICML::Property, boost::mpl::pair< ::PICML::ComponentConfigProperty, AR_dstComponentConfigProperty > > _AR_dstComponentConfigProperty__ComponentConfigProperty__Property;
		typedef boost::mpl::pair< ::PICML::Property, boost::mpl::pair< ::PICML::ComponentInfoProperty, AR_dstComponentInfoProperty > > _AR_dstComponentInfoProperty__ComponentInfoProperty__Property;
		typedef boost::mpl::vector< _AR_srcDeploys__Deploys__ComponentFactoryRef, _AR_srcImplements__Implements__ComponentImplementation, _AR_srcPackageInterface__PackageInterface__ComponentPackage> AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstComponentProperty__ComponentProperty__ComponentPropertyDescription, _AR_dstComponentConfigProperty__ComponentConfigProperty__Property, _AR_dstComponentInfoProperty__ComponentInfoProperty__Property> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ManagesComponent :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		ManagesComponent() {}
		ManagesComponent(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ManagesComponent(const ManagesComponent &master) : MgaObject(master) {}

		static ManagesComponent Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ManagesComponent Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ManagesComponent CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ManagesComponent> Instances() { return Udm::InstantiatedAttr<ManagesComponent>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ManagesComponent, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ManagesComponent, Pred>(impl); }
		ManagesComponent CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ManagesComponent> Derived() { return Udm::DerivedAttr<ManagesComponent>(impl); }
		template <class Pred> Udm::DerivedAttr<ManagesComponent, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ManagesComponent, Pred>(impl); }
		Udm::ArchetypeAttr<ManagesComponent> Archetype() const { return Udm::ArchetypeAttr<ManagesComponent>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::File> File_parent() const { return Udm::ParentAttr< ::PICML::File>(impl, meta_File_parent); }
		Udm::ParentAttr< ::PICML::Package> Package_parent() const { return Udm::ParentAttr< ::PICML::Package>(impl, meta_Package_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::Manageable> dstManagesComponent_end() const { return Udm::AssocEndAttr< ::PICML::Manageable>(impl, meta_dstManagesComponent_end_); }
		Udm::AssocEndAttr< ::PICML::ComponentFactory> srcManagesComponent_end() const { return Udm::AssocEndAttr< ::PICML::ComponentFactory>(impl, meta_srcManagesComponent_end_); }
		void Accept(Visitor &v) { v.Visit_ManagesComponent(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_File_parent;
		static ::Uml::CompositionParentRole meta_Package_parent;
		static ::Uml::AssociationRole meta_dstManagesComponent_end_;
		static ::Uml::AssociationRole meta_srcManagesComponent_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_File_parent {};
		class PR_Package_parent {};
		typedef boost::mpl::pair< ::PICML::File, PR_File_parent > _PR_File_parent__File;
		typedef boost::mpl::pair< ::PICML::Package, PR_Package_parent > _PR_Package_parent__Package;
		typedef boost::mpl::vector< _PR_File_parent__File, _PR_Package_parent__Package> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstManagesComponent {};
		class ACE_srcManagesComponent {};
		typedef boost::mpl::pair< ::PICML::Manageable, ACE_dstManagesComponent > _ACE_dstManagesComponent__Manageable;
		typedef boost::mpl::pair< ::PICML::ComponentFactory, ACE_srcManagesComponent > _ACE_srcManagesComponent__ComponentFactory;
		typedef boost::mpl::vector< _ACE_dstManagesComponent__Manageable, _ACE_srcManagesComponent__ComponentFactory> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export OperationBase :  public Taggable {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		OperationBase() {}
		OperationBase(Udm::ObjectImpl *impl) : Taggable(impl), MgaObject(impl) {}
		OperationBase(const OperationBase &master) : Taggable(master), MgaObject(master) {}

		static OperationBase Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static OperationBase Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		OperationBase CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<OperationBase> Instances() { return Udm::InstantiatedAttr<OperationBase>(impl); }
		template <class Pred> Udm::InstantiatedAttr<OperationBase, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<OperationBase, Pred>(impl); }
		OperationBase CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<OperationBase> Derived() { return Udm::DerivedAttr<OperationBase>(impl); }
		template <class Pred> Udm::DerivedAttr<OperationBase, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<OperationBase, Pred>(impl); }
		Udm::ArchetypeAttr<OperationBase> Archetype() const { return Udm::ArchetypeAttr<OperationBase>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::OperationRef> referedbyOperationRef() const { return Udm::AssocAttr< ::PICML::OperationRef>(impl, meta_referedbyOperationRef); }
		template <class Pred> Udm::AssocAttr< ::PICML::OperationRef, Pred> referedbyOperationRef_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::OperationRef, Pred>(impl, meta_referedbyOperationRef); }
		Udm::ChildrenAttr< ::PICML::InParameter> InParameter_children() const { return Udm::ChildrenAttr< ::PICML::InParameter>(impl, meta_InParameter_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InParameter, Pred> InParameter_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InParameter, Pred>(impl, meta_InParameter_children); }
		Udm::ChildrenAttr< ::PICML::InParameter> InParameter_kind_children() const { return Udm::ChildrenAttr< ::PICML::InParameter>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InParameter, Pred> InParameter_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InParameter, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ParameterType> ParameterType_kind_children() const { return Udm::ChildrenAttr< ::PICML::ParameterType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ParameterType, Pred> ParameterType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ParameterType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyOperationRef;
		static ::Uml::CompositionChildRole meta_InParameter_children;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_InParameter_children {};
		typedef boost::mpl::pair< ::PICML::InParameter, CR_InParameter_children > _CR_InParameter_children__InParameter;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_InParameter_children__InParameter> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::InParameter> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyOperationRef {};
		typedef boost::mpl::pair< ::PICML::OperationRef, AR_referedbyOperationRef > _AR_referedbyOperationRef__OperationRef;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyOperationRef__OperationRef> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export HasExceptions :  public OperationBase {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		HasExceptions() {}
		HasExceptions(Udm::ObjectImpl *impl) : OperationBase(impl), MgaObject(impl) {}
		HasExceptions(const HasExceptions &master) : OperationBase(master), MgaObject(master) {}

		static HasExceptions Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static HasExceptions Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		HasExceptions CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<HasExceptions> Instances() { return Udm::InstantiatedAttr<HasExceptions>(impl); }
		template <class Pred> Udm::InstantiatedAttr<HasExceptions, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<HasExceptions, Pred>(impl); }
		HasExceptions CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<HasExceptions> Derived() { return Udm::DerivedAttr<HasExceptions>(impl); }
		template <class Pred> Udm::DerivedAttr<HasExceptions, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<HasExceptions, Pred>(impl); }
		Udm::ArchetypeAttr<HasExceptions> Archetype() const { return Udm::ArchetypeAttr<HasExceptions>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::ExceptionRef> ExceptionRef_children() const { return Udm::ChildrenAttr< ::PICML::ExceptionRef>(impl, meta_ExceptionRef_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ExceptionRef, Pred> ExceptionRef_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ExceptionRef, Pred>(impl, meta_ExceptionRef_children); }
		Udm::ChildrenAttr< ::PICML::ExceptionRef> ExceptionRef_kind_children() const { return Udm::ChildrenAttr< ::PICML::ExceptionRef>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ExceptionRef, Pred> ExceptionRef_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ExceptionRef, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_ExceptionRef_children;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ExceptionRef_children {};
		typedef boost::mpl::pair< ::PICML::ExceptionRef, CR_ExceptionRef_children > _CR_ExceptionRef_children__ExceptionRef;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_ExceptionRef_children__ExceptionRef> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::InParameter, ::PICML::ExceptionRef> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ReturnType :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		ReturnType() {}
		ReturnType(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ReturnType(const ReturnType &master) : MgaObject(master) {}

		static ReturnType Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ReturnType Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ReturnType CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ReturnType> Instances() { return Udm::InstantiatedAttr<ReturnType>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ReturnType, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ReturnType, Pred>(impl); }
		ReturnType CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ReturnType> Derived() { return Udm::DerivedAttr<ReturnType>(impl); }
		template <class Pred> Udm::DerivedAttr<ReturnType, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ReturnType, Pred>(impl); }
		Udm::ArchetypeAttr<ReturnType> Archetype() const { return Udm::ArchetypeAttr<ReturnType>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::MemberType> ref() const { return Udm::PointerAttr< ::PICML::MemberType>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::TwowayOperation> TwowayOperation_parent() const { return Udm::ParentAttr< ::PICML::TwowayOperation>(impl, meta_TwowayOperation_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ReturnType(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_TwowayOperation_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_TwowayOperation_parent {};
		typedef boost::mpl::pair< ::PICML::TwowayOperation, PR_TwowayOperation_parent > _PR_TwowayOperation_parent__TwowayOperation;
		typedef boost::mpl::vector< _PR_TwowayOperation_parent__TwowayOperation> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::TwowayOperation> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::MemberType, AR_ref > _AR_ref__MemberType;
		typedef boost::mpl::vector< _AR_ref__MemberType> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ParameterType :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		ParameterType() {}
		ParameterType(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ParameterType(const ParameterType &master) : MgaObject(master) {}

		static ParameterType Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ParameterType Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ParameterType CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ParameterType> Instances() { return Udm::InstantiatedAttr<ParameterType>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ParameterType, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ParameterType, Pred>(impl); }
		ParameterType CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ParameterType> Derived() { return Udm::DerivedAttr<ParameterType>(impl); }
		template <class Pred> Udm::DerivedAttr<ParameterType, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ParameterType, Pred>(impl); }
		Udm::ArchetypeAttr<ParameterType> Archetype() const { return Udm::ArchetypeAttr<ParameterType>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::MemberType> ref() const { return Udm::PointerAttr< ::PICML::MemberType>(impl, meta_ref); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::MemberType, AR_ref > _AR_ref__MemberType;
		typedef boost::mpl::vector< _AR_ref__MemberType> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export InParameter :  public ParameterType {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		InParameter() {}
		InParameter(Udm::ObjectImpl *impl) : ParameterType(impl) {}
		InParameter(const InParameter &master) : ParameterType(master) {}

		static InParameter Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static InParameter Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		InParameter CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<InParameter> Instances() { return Udm::InstantiatedAttr<InParameter>(impl); }
		template <class Pred> Udm::InstantiatedAttr<InParameter, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<InParameter, Pred>(impl); }
		InParameter CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<InParameter> Derived() { return Udm::DerivedAttr<InParameter>(impl); }
		template <class Pred> Udm::DerivedAttr<InParameter, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<InParameter, Pred>(impl); }
		Udm::ArchetypeAttr<InParameter> Archetype() const { return Udm::ArchetypeAttr<InParameter>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::MemberType> ref() const { return Udm::PointerAttr< ::PICML::MemberType>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::OperationBase> OperationBase_parent() const { return Udm::ParentAttr< ::PICML::OperationBase>(impl, meta_OperationBase_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_InParameter(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_OperationBase_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_OperationBase_parent {};
		typedef boost::mpl::pair< ::PICML::OperationBase, PR_OperationBase_parent > _PR_OperationBase_parent__OperationBase;
		typedef boost::mpl::vector< _PR_OperationBase_parent__OperationBase> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::OperationBase> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::MemberType, AR_ref > _AR_ref__MemberType;
		typedef boost::mpl::vector< _AR_ref__MemberType> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export InoutParameter :  public ParameterType {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		InoutParameter() {}
		InoutParameter(Udm::ObjectImpl *impl) : ParameterType(impl) {}
		InoutParameter(const InoutParameter &master) : ParameterType(master) {}

		static InoutParameter Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static InoutParameter Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		InoutParameter CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<InoutParameter> Instances() { return Udm::InstantiatedAttr<InoutParameter>(impl); }
		template <class Pred> Udm::InstantiatedAttr<InoutParameter, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<InoutParameter, Pred>(impl); }
		InoutParameter CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<InoutParameter> Derived() { return Udm::DerivedAttr<InoutParameter>(impl); }
		template <class Pred> Udm::DerivedAttr<InoutParameter, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<InoutParameter, Pred>(impl); }
		Udm::ArchetypeAttr<InoutParameter> Archetype() const { return Udm::ArchetypeAttr<InoutParameter>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::MemberType> ref() const { return Udm::PointerAttr< ::PICML::MemberType>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::TwowayOperation> TwowayOperation_parent() const { return Udm::ParentAttr< ::PICML::TwowayOperation>(impl, meta_TwowayOperation_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_InoutParameter(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_TwowayOperation_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_TwowayOperation_parent {};
		typedef boost::mpl::pair< ::PICML::TwowayOperation, PR_TwowayOperation_parent > _PR_TwowayOperation_parent__TwowayOperation;
		typedef boost::mpl::vector< _PR_TwowayOperation_parent__TwowayOperation> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::TwowayOperation> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::MemberType, AR_ref > _AR_ref__MemberType;
		typedef boost::mpl::vector< _AR_ref__MemberType> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export OutParameter :  public ParameterType {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		OutParameter() {}
		OutParameter(Udm::ObjectImpl *impl) : ParameterType(impl) {}
		OutParameter(const OutParameter &master) : ParameterType(master) {}

		static OutParameter Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static OutParameter Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		OutParameter CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<OutParameter> Instances() { return Udm::InstantiatedAttr<OutParameter>(impl); }
		template <class Pred> Udm::InstantiatedAttr<OutParameter, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<OutParameter, Pred>(impl); }
		OutParameter CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<OutParameter> Derived() { return Udm::DerivedAttr<OutParameter>(impl); }
		template <class Pred> Udm::DerivedAttr<OutParameter, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<OutParameter, Pred>(impl); }
		Udm::ArchetypeAttr<OutParameter> Archetype() const { return Udm::ArchetypeAttr<OutParameter>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::MemberType> ref() const { return Udm::PointerAttr< ::PICML::MemberType>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::TwowayOperation> TwowayOperation_parent() const { return Udm::ParentAttr< ::PICML::TwowayOperation>(impl, meta_TwowayOperation_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_OutParameter(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_TwowayOperation_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_TwowayOperation_parent {};
		typedef boost::mpl::pair< ::PICML::TwowayOperation, PR_TwowayOperation_parent > _PR_TwowayOperation_parent__TwowayOperation;
		typedef boost::mpl::vector< _PR_TwowayOperation_parent__TwowayOperation> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::TwowayOperation> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::MemberType, AR_ref > _AR_ref__MemberType;
		typedef boost::mpl::vector< _AR_ref__MemberType> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export OnewayOperation :  public OperationBase {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		OnewayOperation() {}
		OnewayOperation(Udm::ObjectImpl *impl) : OperationBase(impl), MgaObject(impl) {}
		OnewayOperation(const OnewayOperation &master) : OperationBase(master), MgaObject(master) {}

		static OnewayOperation Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static OnewayOperation Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		OnewayOperation CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<OnewayOperation> Instances() { return Udm::InstantiatedAttr<OnewayOperation>(impl); }
		template <class Pred> Udm::InstantiatedAttr<OnewayOperation, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<OnewayOperation, Pred>(impl); }
		OnewayOperation CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<OnewayOperation> Derived() { return Udm::DerivedAttr<OnewayOperation>(impl); }
		template <class Pred> Udm::DerivedAttr<OnewayOperation, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<OnewayOperation, Pred>(impl); }
		Udm::ArchetypeAttr<OnewayOperation> Archetype() const { return Udm::ArchetypeAttr<OnewayOperation>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::HasOperations> HasOperations_parent() const { return Udm::ParentAttr< ::PICML::HasOperations>(impl, meta_HasOperations_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_OnewayOperation(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_HasOperations_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_HasOperations_parent {};
		typedef boost::mpl::pair< ::PICML::HasOperations, PR_HasOperations_parent > _PR_HasOperations_parent__HasOperations;
		typedef boost::mpl::vector< _PR_HasOperations_parent__HasOperations> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis, ::PICML::HasOperations> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::InParameter> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export LookupOperation :  public HasExceptions {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		LookupOperation() {}
		LookupOperation(Udm::ObjectImpl *impl) : HasExceptions(impl), MgaObject(impl) {}
		LookupOperation(const LookupOperation &master) : HasExceptions(master), MgaObject(master) {}

		static LookupOperation Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static LookupOperation Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		LookupOperation CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<LookupOperation> Instances() { return Udm::InstantiatedAttr<LookupOperation>(impl); }
		template <class Pred> Udm::InstantiatedAttr<LookupOperation, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<LookupOperation, Pred>(impl); }
		LookupOperation CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<LookupOperation> Derived() { return Udm::DerivedAttr<LookupOperation>(impl); }
		template <class Pred> Udm::DerivedAttr<LookupOperation, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<LookupOperation, Pred>(impl); }
		Udm::ArchetypeAttr<LookupOperation> Archetype() const { return Udm::ArchetypeAttr<LookupOperation>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentFactory> ComponentFactory_parent() const { return Udm::ParentAttr< ::PICML::ComponentFactory>(impl, meta_ComponentFactory_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_LookupOperation(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentFactory_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentFactory_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentFactory, PR_ComponentFactory_parent > _PR_ComponentFactory_parent__ComponentFactory;
		typedef boost::mpl::vector< _PR_ComponentFactory_parent__ComponentFactory> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis, ::PICML::ComponentFactory> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::InParameter, ::PICML::ExceptionRef> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export FactoryOperation :  public HasExceptions {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		FactoryOperation() {}
		FactoryOperation(Udm::ObjectImpl *impl) : HasExceptions(impl), MgaObject(impl) {}
		FactoryOperation(const FactoryOperation &master) : HasExceptions(master), MgaObject(master) {}

		static FactoryOperation Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static FactoryOperation Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		FactoryOperation CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<FactoryOperation> Instances() { return Udm::InstantiatedAttr<FactoryOperation>(impl); }
		template <class Pred> Udm::InstantiatedAttr<FactoryOperation, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<FactoryOperation, Pred>(impl); }
		FactoryOperation CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<FactoryOperation> Derived() { return Udm::DerivedAttr<FactoryOperation>(impl); }
		template <class Pred> Udm::DerivedAttr<FactoryOperation, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<FactoryOperation, Pred>(impl); }
		Udm::ArchetypeAttr<FactoryOperation> Archetype() const { return Udm::ArchetypeAttr<FactoryOperation>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ComponentFactory> ComponentFactory_parent() const { return Udm::ParentAttr< ::PICML::ComponentFactory>(impl, meta_ComponentFactory_parent); }
		Udm::ParentAttr< ::PICML::ObjectByValue> ObjectByValue_parent() const { return Udm::ParentAttr< ::PICML::ObjectByValue>(impl, meta_ObjectByValue_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_FactoryOperation(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentFactory_parent;
		static ::Uml::CompositionParentRole meta_ObjectByValue_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentFactory_parent {};
		class PR_ObjectByValue_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentFactory, PR_ComponentFactory_parent > _PR_ComponentFactory_parent__ComponentFactory;
		typedef boost::mpl::pair< ::PICML::ObjectByValue, PR_ObjectByValue_parent > _PR_ObjectByValue_parent__ObjectByValue;
		typedef boost::mpl::vector< _PR_ComponentFactory_parent__ComponentFactory, _PR_ObjectByValue_parent__ObjectByValue> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis, ::PICML::ComponentFactory, ::PICML::ObjectByValue> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::InParameter, ::PICML::ExceptionRef> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export TwowayOperation :  public HasExceptions {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		TwowayOperation() {}
		TwowayOperation(Udm::ObjectImpl *impl) : HasExceptions(impl), MgaObject(impl) {}
		TwowayOperation(const TwowayOperation &master) : HasExceptions(master), MgaObject(master) {}

		static TwowayOperation Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static TwowayOperation Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		TwowayOperation CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<TwowayOperation> Instances() { return Udm::InstantiatedAttr<TwowayOperation>(impl); }
		template <class Pred> Udm::InstantiatedAttr<TwowayOperation, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<TwowayOperation, Pred>(impl); }
		TwowayOperation CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<TwowayOperation> Derived() { return Udm::DerivedAttr<TwowayOperation>(impl); }
		template <class Pred> Udm::DerivedAttr<TwowayOperation, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<TwowayOperation, Pred>(impl); }
		Udm::ArchetypeAttr<TwowayOperation> Archetype() const { return Udm::ArchetypeAttr<TwowayOperation>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::OutParameter> OutParameter_children() const { return Udm::ChildrenAttr< ::PICML::OutParameter>(impl, meta_OutParameter_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OutParameter, Pred> OutParameter_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OutParameter, Pred>(impl, meta_OutParameter_children); }
		Udm::ChildrenAttr< ::PICML::InoutParameter> InoutParameter_children() const { return Udm::ChildrenAttr< ::PICML::InoutParameter>(impl, meta_InoutParameter_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InoutParameter, Pred> InoutParameter_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InoutParameter, Pred>(impl, meta_InoutParameter_children); }
		Udm::ChildAttr< ::PICML::ReturnType> ReturnType_child() const { return Udm::ChildAttr< ::PICML::ReturnType>(impl, meta_ReturnType_child); }
		Udm::ChildrenAttr< ::PICML::InoutParameter> InoutParameter_kind_children() const { return Udm::ChildrenAttr< ::PICML::InoutParameter>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InoutParameter, Pred> InoutParameter_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InoutParameter, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::OutParameter> OutParameter_kind_children() const { return Udm::ChildrenAttr< ::PICML::OutParameter>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OutParameter, Pred> OutParameter_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OutParameter, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ReturnType> ReturnType_kind_children() const { return Udm::ChildrenAttr< ::PICML::ReturnType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ReturnType, Pred> ReturnType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ReturnType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ParameterType> ParameterType_kind_children() const { return Udm::ChildrenAttr< ::PICML::ParameterType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ParameterType, Pred> ParameterType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ParameterType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::HasOperations> HasOperations_parent() const { return Udm::ParentAttr< ::PICML::HasOperations>(impl, meta_HasOperations_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_TwowayOperation(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_OutParameter_children;
		static ::Uml::CompositionChildRole meta_InoutParameter_children;
		static ::Uml::CompositionChildRole meta_ReturnType_child;
		static ::Uml::CompositionParentRole meta_HasOperations_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_HasOperations_parent {};
		typedef boost::mpl::pair< ::PICML::HasOperations, PR_HasOperations_parent > _PR_HasOperations_parent__HasOperations;
		typedef boost::mpl::vector< _PR_HasOperations_parent__HasOperations> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis, ::PICML::HasOperations> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_OutParameter_children {};
		class CR_InoutParameter_children {};
		class CR_ReturnType_child {};
		typedef boost::mpl::pair< ::PICML::OutParameter, CR_OutParameter_children > _CR_OutParameter_children__OutParameter;
		typedef boost::mpl::pair< ::PICML::InoutParameter, CR_InoutParameter_children > _CR_InoutParameter_children__InoutParameter;
		typedef boost::mpl::pair< ::PICML::ReturnType, CR_ReturnType_child > _CR_ReturnType_child__ReturnType;
		typedef boost::mpl::vector< _CR_ReturnType_child__ReturnType> ChildrenSingle;
		typedef boost::mpl::vector< _CR_OutParameter_children__OutParameter, _CR_InoutParameter_children__InoutParameter> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::InParameter, ::PICML::InoutParameter, ::PICML::OutParameter, ::PICML::ReturnType, ::PICML::ExceptionRef> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Inherits :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		Inherits() {}
		Inherits(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Inherits(const Inherits &master) : MgaObject(master) {}

		static Inherits Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Inherits Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Inherits CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Inherits> Instances() { return Udm::InstantiatedAttr<Inherits>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Inherits, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Inherits, Pred>(impl); }
		Inherits CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Inherits> Derived() { return Udm::DerivedAttr<Inherits>(impl); }
		template <class Pred> Udm::DerivedAttr<Inherits, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Inherits, Pred>(impl); }
		Udm::ArchetypeAttr<Inherits> Archetype() const { return Udm::ArchetypeAttr<Inherits>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::Inheritable> ref() const { return Udm::PointerAttr< ::PICML::Inheritable>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::Inheritable> Inheritable_parent() const { return Udm::ParentAttr< ::PICML::Inheritable>(impl, meta_Inheritable_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Inherits(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_Inheritable_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Inheritable_parent {};
		typedef boost::mpl::pair< ::PICML::Inheritable, PR_Inheritable_parent > _PR_Inheritable_parent__Inheritable;
		typedef boost::mpl::vector< _PR_Inheritable_parent__Inheritable> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Inheritable> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::Inheritable, AR_ref > _AR_ref__Inheritable;
		typedef boost::mpl::vector< _AR_ref__Inheritable> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export SupportsInterfaces :  virtual  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		SupportsInterfaces() {}
		SupportsInterfaces(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		SupportsInterfaces(const SupportsInterfaces &master) : MgaObject(master) {}

		static SupportsInterfaces Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static SupportsInterfaces Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		SupportsInterfaces CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<SupportsInterfaces> Instances() { return Udm::InstantiatedAttr<SupportsInterfaces>(impl); }
		template <class Pred> Udm::InstantiatedAttr<SupportsInterfaces, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<SupportsInterfaces, Pred>(impl); }
		SupportsInterfaces CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<SupportsInterfaces> Derived() { return Udm::DerivedAttr<SupportsInterfaces>(impl); }
		template <class Pred> Udm::DerivedAttr<SupportsInterfaces, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<SupportsInterfaces, Pred>(impl); }
		Udm::ArchetypeAttr<SupportsInterfaces> Archetype() const { return Udm::ArchetypeAttr<SupportsInterfaces>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::Supports> Supports_children() const { return Udm::ChildrenAttr< ::PICML::Supports>(impl, meta_Supports_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Supports, Pred> Supports_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Supports, Pred>(impl, meta_Supports_children); }
		Udm::ChildrenAttr< ::PICML::InvokePortBase> InvokePortBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::InvokePortBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InvokePortBase, Pred> InvokePortBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InvokePortBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Supports> Supports_kind_children() const { return Udm::ChildrenAttr< ::PICML::Supports>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Supports, Pred> Supports_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Supports, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Supports_children;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Supports_children {};
		typedef boost::mpl::pair< ::PICML::Supports, CR_Supports_children > _CR_Supports_children__Supports;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Supports_children__Supports> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Supports> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Supports :  public InvokePortBase {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		Supports() {}
		Supports(Udm::ObjectImpl *impl) : InvokePortBase(impl), MgaObject(impl) {}
		Supports(const Supports &master) : InvokePortBase(master), MgaObject(master) {}

		static Supports Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Supports Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Supports CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Supports> Instances() { return Udm::InstantiatedAttr<Supports>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Supports, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Supports, Pred>(impl); }
		Supports CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Supports> Derived() { return Udm::DerivedAttr<Supports>(impl); }
		template <class Pred> Udm::DerivedAttr<Supports, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Supports, Pred>(impl); }
		Udm::ArchetypeAttr<Supports> Archetype() const { return Udm::ArchetypeAttr<Supports>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::SupportsDelegate, ::PICML::ProvidedRequestPort> dstSupportsDelegate() const { return Udm::AClassAssocAttr< ::PICML::SupportsDelegate, ::PICML::ProvidedRequestPort>(impl, meta_dstSupportsDelegate, meta_dstSupportsDelegate_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::SupportsDelegate, ::PICML::ProvidedRequestPort, Pred> dstSupportsDelegate_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::SupportsDelegate, ::PICML::ProvidedRequestPort, Pred>(impl, meta_dstSupportsDelegate, meta_dstSupportsDelegate_rev); }
		Udm::PointerAttr< ::PICML::Object> ref() const { return Udm::PointerAttr< ::PICML::Object>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::SupportsInterfaces> SupportsInterfaces_parent() const { return Udm::ParentAttr< ::PICML::SupportsInterfaces>(impl, meta_SupportsInterfaces_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Supports(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstSupportsDelegate;
		static ::Uml::AssociationRole meta_dstSupportsDelegate_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_SupportsInterfaces_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_SupportsInterfaces_parent {};
		typedef boost::mpl::pair< ::PICML::SupportsInterfaces, PR_SupportsInterfaces_parent > _PR_SupportsInterfaces_parent__SupportsInterfaces;
		typedef boost::mpl::vector< _PR_SupportsInterfaces_parent__SupportsInterfaces> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::SupportsInterfaces> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::Object, AR_ref > _AR_ref__Object;
		typedef boost::mpl::vector< _AR_ref__Object> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstSupportsDelegate {};
		typedef boost::mpl::pair< ::PICML::ProvidedRequestPort, boost::mpl::pair< ::PICML::SupportsDelegate, AR_dstSupportsDelegate > > _AR_dstSupportsDelegate__SupportsDelegate__ProvidedRequestPort;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstSupportsDelegate__SupportsDelegate__ProvidedRequestPort> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export LookupKey :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		LookupKey() {}
		LookupKey(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		LookupKey(const LookupKey &master) : MgaObject(master) {}

		static LookupKey Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static LookupKey Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		LookupKey CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<LookupKey> Instances() { return Udm::InstantiatedAttr<LookupKey>(impl); }
		template <class Pred> Udm::InstantiatedAttr<LookupKey, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<LookupKey, Pred>(impl); }
		LookupKey CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<LookupKey> Derived() { return Udm::DerivedAttr<LookupKey>(impl); }
		template <class Pred> Udm::DerivedAttr<LookupKey, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<LookupKey, Pred>(impl); }
		Udm::ArchetypeAttr<LookupKey> Archetype() const { return Udm::ArchetypeAttr<LookupKey>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::ValueObject> ref() const { return Udm::PointerAttr< ::PICML::ValueObject>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::ComponentFactory> ComponentFactory_parent() const { return Udm::ParentAttr< ::PICML::ComponentFactory>(impl, meta_ComponentFactory_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_LookupKey(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ComponentFactory_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentFactory_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentFactory, PR_ComponentFactory_parent > _PR_ComponentFactory_parent__ComponentFactory;
		typedef boost::mpl::vector< _PR_ComponentFactory_parent__ComponentFactory> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentFactory> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::ValueObject, AR_ref > _AR_ref__ValueObject;
		typedef boost::mpl::vector< _AR_ref__ValueObject> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export SetException :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		SetException() {}
		SetException(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		SetException(const SetException &master) : MgaObject(master) {}

		static SetException Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static SetException Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		SetException CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<SetException> Instances() { return Udm::InstantiatedAttr<SetException>(impl); }
		template <class Pred> Udm::InstantiatedAttr<SetException, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<SetException, Pred>(impl); }
		SetException CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<SetException> Derived() { return Udm::DerivedAttr<SetException>(impl); }
		template <class Pred> Udm::DerivedAttr<SetException, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<SetException, Pred>(impl); }
		Udm::ArchetypeAttr<SetException> Archetype() const { return Udm::ArchetypeAttr<SetException>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::Exception> ref() const { return Udm::PointerAttr< ::PICML::Exception>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::Attribute> Attribute_parent() const { return Udm::ParentAttr< ::PICML::Attribute>(impl, meta_Attribute_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_SetException(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_Attribute_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Attribute_parent {};
		typedef boost::mpl::pair< ::PICML::Attribute, PR_Attribute_parent > _PR_Attribute_parent__Attribute;
		typedef boost::mpl::vector< _PR_Attribute_parent__Attribute> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Attribute> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::Exception, AR_ref > _AR_ref__Exception;
		typedef boost::mpl::vector< _AR_ref__Exception> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export GetException :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		GetException() {}
		GetException(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		GetException(const GetException &master) : MgaObject(master) {}

		static GetException Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static GetException Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		GetException CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<GetException> Instances() { return Udm::InstantiatedAttr<GetException>(impl); }
		template <class Pred> Udm::InstantiatedAttr<GetException, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<GetException, Pred>(impl); }
		GetException CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<GetException> Derived() { return Udm::DerivedAttr<GetException>(impl); }
		template <class Pred> Udm::DerivedAttr<GetException, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<GetException, Pred>(impl); }
		Udm::ArchetypeAttr<GetException> Archetype() const { return Udm::ArchetypeAttr<GetException>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::Exception> ref() const { return Udm::PointerAttr< ::PICML::Exception>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::ReadonlyAttribute> ReadonlyAttribute_parent() const { return Udm::ParentAttr< ::PICML::ReadonlyAttribute>(impl, meta_ReadonlyAttribute_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_GetException(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ReadonlyAttribute_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ReadonlyAttribute_parent {};
		typedef boost::mpl::pair< ::PICML::ReadonlyAttribute, PR_ReadonlyAttribute_parent > _PR_ReadonlyAttribute_parent__ReadonlyAttribute;
		typedef boost::mpl::vector< _PR_ReadonlyAttribute_parent__ReadonlyAttribute> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ReadonlyAttribute> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::Exception, AR_ref > _AR_ref__Exception;
		typedef boost::mpl::vector< _AR_ref__Exception> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PrivateFlag :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		PrivateFlag() {}
		PrivateFlag(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		PrivateFlag(const PrivateFlag &master) : MgaObject(master) {}

		static PrivateFlag Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PrivateFlag Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PrivateFlag CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PrivateFlag> Instances() { return Udm::InstantiatedAttr<PrivateFlag>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PrivateFlag, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PrivateFlag, Pred>(impl); }
		PrivateFlag CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PrivateFlag> Derived() { return Udm::DerivedAttr<PrivateFlag>(impl); }
		template <class Pred> Udm::DerivedAttr<PrivateFlag, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PrivateFlag, Pred>(impl); }
		Udm::ArchetypeAttr<PrivateFlag> Archetype() const { return Udm::ArchetypeAttr<PrivateFlag>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::MakeMemberPrivate, ::PICML::Member> srcMakeMemberPrivate() const { return Udm::AClassPointerAttr< ::PICML::MakeMemberPrivate, ::PICML::Member>(impl, meta_srcMakeMemberPrivate, meta_srcMakeMemberPrivate_rev); }
		Udm::ParentAttr< ::PICML::ObjectByValue> ObjectByValue_parent() const { return Udm::ParentAttr< ::PICML::ObjectByValue>(impl, meta_ObjectByValue_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_PrivateFlag(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcMakeMemberPrivate;
		static ::Uml::AssociationRole meta_srcMakeMemberPrivate_rev;
		static ::Uml::CompositionParentRole meta_ObjectByValue_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ObjectByValue_parent {};
		typedef boost::mpl::pair< ::PICML::ObjectByValue, PR_ObjectByValue_parent > _PR_ObjectByValue_parent__ObjectByValue;
		typedef boost::mpl::vector< _PR_ObjectByValue_parent__ObjectByValue> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ObjectByValue> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcMakeMemberPrivate {};
		typedef boost::mpl::pair< ::PICML::Member, boost::mpl::pair< ::PICML::MakeMemberPrivate, AR_srcMakeMemberPrivate > > _AR_srcMakeMemberPrivate__MakeMemberPrivate__Member;
		typedef boost::mpl::vector< _AR_srcMakeMemberPrivate__MakeMemberPrivate__Member> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export MakeMemberPrivate :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		MakeMemberPrivate() {}
		MakeMemberPrivate(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		MakeMemberPrivate(const MakeMemberPrivate &master) : MgaObject(master) {}

		static MakeMemberPrivate Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static MakeMemberPrivate Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		MakeMemberPrivate CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<MakeMemberPrivate> Instances() { return Udm::InstantiatedAttr<MakeMemberPrivate>(impl); }
		template <class Pred> Udm::InstantiatedAttr<MakeMemberPrivate, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<MakeMemberPrivate, Pred>(impl); }
		MakeMemberPrivate CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<MakeMemberPrivate> Derived() { return Udm::DerivedAttr<MakeMemberPrivate>(impl); }
		template <class Pred> Udm::DerivedAttr<MakeMemberPrivate, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<MakeMemberPrivate, Pred>(impl); }
		Udm::ArchetypeAttr<MakeMemberPrivate> Archetype() const { return Udm::ArchetypeAttr<MakeMemberPrivate>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::ObjectByValue> ObjectByValue_parent() const { return Udm::ParentAttr< ::PICML::ObjectByValue>(impl, meta_ObjectByValue_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::PrivateFlag> dstMakeMemberPrivate_end() const { return Udm::AssocEndAttr< ::PICML::PrivateFlag>(impl, meta_dstMakeMemberPrivate_end_); }
		Udm::AssocEndAttr< ::PICML::Member> srcMakeMemberPrivate_end() const { return Udm::AssocEndAttr< ::PICML::Member>(impl, meta_srcMakeMemberPrivate_end_); }
		void Accept(Visitor &v) { v.Visit_MakeMemberPrivate(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ObjectByValue_parent;
		static ::Uml::AssociationRole meta_dstMakeMemberPrivate_end_;
		static ::Uml::AssociationRole meta_srcMakeMemberPrivate_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_ObjectByValue_parent {};
		typedef boost::mpl::pair< ::PICML::ObjectByValue, PR_ObjectByValue_parent > _PR_ObjectByValue_parent__ObjectByValue;
		typedef boost::mpl::vector< _PR_ObjectByValue_parent__ObjectByValue> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ObjectByValue> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstMakeMemberPrivate {};
		class ACE_srcMakeMemberPrivate {};
		typedef boost::mpl::pair< ::PICML::PrivateFlag, ACE_dstMakeMemberPrivate > _ACE_dstMakeMemberPrivate__PrivateFlag;
		typedef boost::mpl::pair< ::PICML::Member, ACE_srcMakeMemberPrivate > _ACE_srcMakeMemberPrivate__Member;
		typedef boost::mpl::vector< _ACE_dstMakeMemberPrivate__PrivateFlag, _ACE_srcMakeMemberPrivate__Member> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export AttributeMember :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		AttributeMember() {}
		AttributeMember(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		AttributeMember(const AttributeMember &master) : MgaObject(master) {}

		static AttributeMember Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static AttributeMember Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		AttributeMember CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<AttributeMember> Instances() { return Udm::InstantiatedAttr<AttributeMember>(impl); }
		template <class Pred> Udm::InstantiatedAttr<AttributeMember, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<AttributeMember, Pred>(impl); }
		AttributeMember CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<AttributeMember> Derived() { return Udm::DerivedAttr<AttributeMember>(impl); }
		template <class Pred> Udm::DerivedAttr<AttributeMember, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<AttributeMember, Pred>(impl); }
		Udm::ArchetypeAttr<AttributeMember> Archetype() const { return Udm::ArchetypeAttr<AttributeMember>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::MemberType> ref() const { return Udm::PointerAttr< ::PICML::MemberType>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::ReadonlyAttribute> ReadonlyAttribute_parent() const { return Udm::ParentAttr< ::PICML::ReadonlyAttribute>(impl, meta_ReadonlyAttribute_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_AttributeMember(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ReadonlyAttribute_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ReadonlyAttribute_parent {};
		typedef boost::mpl::pair< ::PICML::ReadonlyAttribute, PR_ReadonlyAttribute_parent > _PR_ReadonlyAttribute_parent__ReadonlyAttribute;
		typedef boost::mpl::vector< _PR_ReadonlyAttribute_parent__ReadonlyAttribute> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ReadonlyAttribute> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::MemberType, AR_ref > _AR_ref__MemberType;
		typedef boost::mpl::vector< _AR_ref__MemberType> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ReadonlyAttribute :  public Taggable {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ReadonlyAttribute() {}
		ReadonlyAttribute(Udm::ObjectImpl *impl) : Taggable(impl), MgaObject(impl) {}
		ReadonlyAttribute(const ReadonlyAttribute &master) : Taggable(master), MgaObject(master) {}

		static ReadonlyAttribute Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ReadonlyAttribute Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ReadonlyAttribute CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ReadonlyAttribute> Instances() { return Udm::InstantiatedAttr<ReadonlyAttribute>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ReadonlyAttribute, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ReadonlyAttribute, Pred>(impl); }
		ReadonlyAttribute CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ReadonlyAttribute> Derived() { return Udm::DerivedAttr<ReadonlyAttribute>(impl); }
		template <class Pred> Udm::DerivedAttr<ReadonlyAttribute, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ReadonlyAttribute, Pred>(impl); }
		Udm::ArchetypeAttr<ReadonlyAttribute> Archetype() const { return Udm::ArchetypeAttr<ReadonlyAttribute>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::AttributeDelegate, ::PICML::AttributeMapping> srcAttributeDelegate() const { return Udm::AClassPointerAttr< ::PICML::AttributeDelegate, ::PICML::AttributeMapping>(impl, meta_srcAttributeDelegate, meta_srcAttributeDelegate_rev); }
		Udm::AssocAttr< ::PICML::AttributeMapping> referedbyAttributeMapping() const { return Udm::AssocAttr< ::PICML::AttributeMapping>(impl, meta_referedbyAttributeMapping); }
		template <class Pred> Udm::AssocAttr< ::PICML::AttributeMapping, Pred> referedbyAttributeMapping_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::AttributeMapping, Pred>(impl, meta_referedbyAttributeMapping); }
		Udm::AClassPointerAttr< ::PICML::AttributeValue, ::PICML::Property> dstAttributeValue() const { return Udm::AClassPointerAttr< ::PICML::AttributeValue, ::PICML::Property>(impl, meta_dstAttributeValue, meta_dstAttributeValue_rev); }
		Udm::ChildAttr< ::PICML::AttributeMember> AttributeMember_child() const { return Udm::ChildAttr< ::PICML::AttributeMember>(impl, meta_AttributeMember_child); }
		Udm::ChildrenAttr< ::PICML::GetException> GetException_children() const { return Udm::ChildrenAttr< ::PICML::GetException>(impl, meta_GetException_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::GetException, Pred> GetException_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::GetException, Pred>(impl, meta_GetException_children); }
		Udm::ChildrenAttr< ::PICML::GetException> GetException_kind_children() const { return Udm::ChildrenAttr< ::PICML::GetException>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::GetException, Pred> GetException_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::GetException, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::AttributeMember> AttributeMember_kind_children() const { return Udm::ChildrenAttr< ::PICML::AttributeMember>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::AttributeMember, Pred> AttributeMember_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::AttributeMember, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::Component> Component_parent() const { return Udm::ParentAttr< ::PICML::Component>(impl, meta_Component_parent); }
		Udm::ParentAttr< ::PICML::Inheritable> Inheritable_parent() const { return Udm::ParentAttr< ::PICML::Inheritable>(impl, meta_Inheritable_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ReadonlyAttribute(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcAttributeDelegate;
		static ::Uml::AssociationRole meta_srcAttributeDelegate_rev;
		static ::Uml::AssociationRole meta_referedbyAttributeMapping;
		static ::Uml::AssociationRole meta_dstAttributeValue;
		static ::Uml::AssociationRole meta_dstAttributeValue_rev;
		static ::Uml::CompositionChildRole meta_AttributeMember_child;
		static ::Uml::CompositionChildRole meta_GetException_children;
		static ::Uml::CompositionParentRole meta_Component_parent;
		static ::Uml::CompositionParentRole meta_Inheritable_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Component_parent {};
		class PR_Inheritable_parent {};
		typedef boost::mpl::pair< ::PICML::Component, PR_Component_parent > _PR_Component_parent__Component;
		typedef boost::mpl::pair< ::PICML::Inheritable, PR_Inheritable_parent > _PR_Inheritable_parent__Inheritable;
		typedef boost::mpl::vector< _PR_Component_parent__Component, _PR_Inheritable_parent__Inheritable> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Component, ::PICML::Inheritable> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_AttributeMember_child {};
		class CR_GetException_children {};
		typedef boost::mpl::pair< ::PICML::AttributeMember, CR_AttributeMember_child > _CR_AttributeMember_child__AttributeMember;
		typedef boost::mpl::pair< ::PICML::GetException, CR_GetException_children > _CR_GetException_children__GetException;
		typedef boost::mpl::vector< _CR_AttributeMember_child__AttributeMember> ChildrenSingle;
		typedef boost::mpl::vector< _CR_GetException_children__GetException> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::GetException, ::PICML::AttributeMember> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyAttributeMapping {};
		typedef boost::mpl::pair< ::PICML::AttributeMapping, AR_referedbyAttributeMapping > _AR_referedbyAttributeMapping__AttributeMapping;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyAttributeMapping__AttributeMapping> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcAttributeDelegate {};
		class AR_dstAttributeValue {};
		typedef boost::mpl::pair< ::PICML::AttributeMapping, boost::mpl::pair< ::PICML::AttributeDelegate, AR_srcAttributeDelegate > > _AR_srcAttributeDelegate__AttributeDelegate__AttributeMapping;
		typedef boost::mpl::pair< ::PICML::Property, boost::mpl::pair< ::PICML::AttributeValue, AR_dstAttributeValue > > _AR_dstAttributeValue__AttributeValue__Property;
		typedef boost::mpl::vector< _AR_srcAttributeDelegate__AttributeDelegate__AttributeMapping, _AR_dstAttributeValue__AttributeValue__Property> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Attribute :  public ReadonlyAttribute {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Attribute() {}
		Attribute(Udm::ObjectImpl *impl) : ReadonlyAttribute(impl), MgaObject(impl) {}
		Attribute(const Attribute &master) : ReadonlyAttribute(master), MgaObject(master) {}

		static Attribute Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Attribute Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Attribute CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Attribute> Instances() { return Udm::InstantiatedAttr<Attribute>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Attribute, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Attribute, Pred>(impl); }
		Attribute CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Attribute> Derived() { return Udm::DerivedAttr<Attribute>(impl); }
		template <class Pred> Udm::DerivedAttr<Attribute, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Attribute, Pred>(impl); }
		Udm::ArchetypeAttr<Attribute> Archetype() const { return Udm::ArchetypeAttr<Attribute>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::SetException> SetException_children() const { return Udm::ChildrenAttr< ::PICML::SetException>(impl, meta_SetException_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SetException, Pred> SetException_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SetException, Pred>(impl, meta_SetException_children); }
		Udm::ChildrenAttr< ::PICML::SetException> SetException_kind_children() const { return Udm::ChildrenAttr< ::PICML::SetException>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SetException, Pred> SetException_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SetException, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Attribute(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_SetException_children;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Component, ::PICML::Inheritable> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_SetException_children {};
		typedef boost::mpl::pair< ::PICML::SetException, CR_SetException_children > _CR_SetException_children__SetException;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_SetException_children__SetException> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::SetException, ::PICML::GetException, ::PICML::AttributeMember> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export EnumValue :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		EnumValue() {}
		EnumValue(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		EnumValue(const EnumValue &master) : MgaObject(master) {}

		static EnumValue Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static EnumValue Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		EnumValue CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<EnumValue> Instances() { return Udm::InstantiatedAttr<EnumValue>(impl); }
		template <class Pred> Udm::InstantiatedAttr<EnumValue, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<EnumValue, Pred>(impl); }
		EnumValue CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<EnumValue> Derived() { return Udm::DerivedAttr<EnumValue>(impl); }
		template <class Pred> Udm::DerivedAttr<EnumValue, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<EnumValue, Pred>(impl); }
		Udm::ArchetypeAttr<EnumValue> Archetype() const { return Udm::ArchetypeAttr<EnumValue>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::Enum> Enum_parent() const { return Udm::ParentAttr< ::PICML::Enum>(impl, meta_Enum_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_EnumValue(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Enum_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Enum_parent {};
		typedef boost::mpl::pair< ::PICML::Enum, PR_Enum_parent > _PR_Enum_parent__Enum;
		typedef boost::mpl::vector< _PR_Enum_parent__Enum> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Enum> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Label :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		Label() {}
		Label(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Label(const Label &master) : MgaObject(master) {}

		static Label Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Label Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Label CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Label> Instances() { return Udm::InstantiatedAttr<Label>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Label, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Label, Pred>(impl); }
		Label CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Label> Derived() { return Udm::DerivedAttr<Label>(impl); }
		template <class Pred> Udm::DerivedAttr<Label, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Label, Pred>(impl); }
		Udm::ArchetypeAttr<Label> Archetype() const { return Udm::ArchetypeAttr<Label>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::LabelConnection, ::PICML::Member> srcLabelConnection() const { return Udm::AClassPointerAttr< ::PICML::LabelConnection, ::PICML::Member>(impl, meta_srcLabelConnection, meta_srcLabelConnection_rev); }
		Udm::ParentAttr< ::PICML::SwitchedAggregate> SwitchedAggregate_parent() const { return Udm::ParentAttr< ::PICML::SwitchedAggregate>(impl, meta_SwitchedAggregate_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Label(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcLabelConnection;
		static ::Uml::AssociationRole meta_srcLabelConnection_rev;
		static ::Uml::CompositionParentRole meta_SwitchedAggregate_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_SwitchedAggregate_parent {};
		typedef boost::mpl::pair< ::PICML::SwitchedAggregate, PR_SwitchedAggregate_parent > _PR_SwitchedAggregate_parent__SwitchedAggregate;
		typedef boost::mpl::vector< _PR_SwitchedAggregate_parent__SwitchedAggregate> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::SwitchedAggregate> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcLabelConnection {};
		typedef boost::mpl::pair< ::PICML::Member, boost::mpl::pair< ::PICML::LabelConnection, AR_srcLabelConnection > > _AR_srcLabelConnection__LabelConnection__Member;
		typedef boost::mpl::vector< _AR_srcLabelConnection__LabelConnection__Member> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export LabelConnection :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		LabelConnection() {}
		LabelConnection(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		LabelConnection(const LabelConnection &master) : MgaObject(master) {}

		static LabelConnection Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static LabelConnection Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		LabelConnection CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<LabelConnection> Instances() { return Udm::InstantiatedAttr<LabelConnection>(impl); }
		template <class Pred> Udm::InstantiatedAttr<LabelConnection, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<LabelConnection, Pred>(impl); }
		LabelConnection CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<LabelConnection> Derived() { return Udm::DerivedAttr<LabelConnection>(impl); }
		template <class Pred> Udm::DerivedAttr<LabelConnection, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<LabelConnection, Pred>(impl); }
		Udm::ArchetypeAttr<LabelConnection> Archetype() const { return Udm::ArchetypeAttr<LabelConnection>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::SwitchedAggregate> SwitchedAggregate_parent() const { return Udm::ParentAttr< ::PICML::SwitchedAggregate>(impl, meta_SwitchedAggregate_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::Label> dstLabelConnection_end() const { return Udm::AssocEndAttr< ::PICML::Label>(impl, meta_dstLabelConnection_end_); }
		Udm::AssocEndAttr< ::PICML::Member> srcLabelConnection_end() const { return Udm::AssocEndAttr< ::PICML::Member>(impl, meta_srcLabelConnection_end_); }
		void Accept(Visitor &v) { v.Visit_LabelConnection(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_SwitchedAggregate_parent;
		static ::Uml::AssociationRole meta_dstLabelConnection_end_;
		static ::Uml::AssociationRole meta_srcLabelConnection_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_SwitchedAggregate_parent {};
		typedef boost::mpl::pair< ::PICML::SwitchedAggregate, PR_SwitchedAggregate_parent > _PR_SwitchedAggregate_parent__SwitchedAggregate;
		typedef boost::mpl::vector< _PR_SwitchedAggregate_parent__SwitchedAggregate> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::SwitchedAggregate> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstLabelConnection {};
		class ACE_srcLabelConnection {};
		typedef boost::mpl::pair< ::PICML::Label, ACE_dstLabelConnection > _ACE_dstLabelConnection__Label;
		typedef boost::mpl::pair< ::PICML::Member, ACE_srcLabelConnection > _ACE_srcLabelConnection__Member;
		typedef boost::mpl::vector< _ACE_dstLabelConnection__Label, _ACE_srcLabelConnection__Member> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export MemberType :  virtual  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		MemberType() {}
		MemberType(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		MemberType(const MemberType &master) : MgaObject(master) {}

		static MemberType Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static MemberType Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		MemberType CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<MemberType> Instances() { return Udm::InstantiatedAttr<MemberType>(impl); }
		template <class Pred> Udm::InstantiatedAttr<MemberType, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<MemberType, Pred>(impl); }
		MemberType CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<MemberType> Derived() { return Udm::DerivedAttr<MemberType>(impl); }
		template <class Pred> Udm::DerivedAttr<MemberType, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<MemberType, Pred>(impl); }
		Udm::ArchetypeAttr<MemberType> Archetype() const { return Udm::ArchetypeAttr<MemberType>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::DataType> referedbyDataType() const { return Udm::AssocAttr< ::PICML::DataType>(impl, meta_referedbyDataType); }
		template <class Pred> Udm::AssocAttr< ::PICML::DataType, Pred> referedbyDataType_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::DataType, Pred>(impl, meta_referedbyDataType); }
		Udm::AssocAttr< ::PICML::InParameter> referedbyInParameter() const { return Udm::AssocAttr< ::PICML::InParameter>(impl, meta_referedbyInParameter); }
		template <class Pred> Udm::AssocAttr< ::PICML::InParameter, Pred> referedbyInParameter_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::InParameter, Pred>(impl, meta_referedbyInParameter); }
		Udm::AssocAttr< ::PICML::InoutParameter> referedbyInoutParameter() const { return Udm::AssocAttr< ::PICML::InoutParameter>(impl, meta_referedbyInoutParameter); }
		template <class Pred> Udm::AssocAttr< ::PICML::InoutParameter, Pred> referedbyInoutParameter_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::InoutParameter, Pred>(impl, meta_referedbyInoutParameter); }
		Udm::AssocAttr< ::PICML::OutParameter> referedbyOutParameter() const { return Udm::AssocAttr< ::PICML::OutParameter>(impl, meta_referedbyOutParameter); }
		template <class Pred> Udm::AssocAttr< ::PICML::OutParameter, Pred> referedbyOutParameter_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::OutParameter, Pred>(impl, meta_referedbyOutParameter); }
		Udm::AssocAttr< ::PICML::ReturnType> referedbyReturnType() const { return Udm::AssocAttr< ::PICML::ReturnType>(impl, meta_referedbyReturnType); }
		template <class Pred> Udm::AssocAttr< ::PICML::ReturnType, Pred> referedbyReturnType_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::ReturnType, Pred>(impl, meta_referedbyReturnType); }
		Udm::AssocAttr< ::PICML::ParameterType> referedbyParameterType() const { return Udm::AssocAttr< ::PICML::ParameterType>(impl, meta_referedbyParameterType); }
		template <class Pred> Udm::AssocAttr< ::PICML::ParameterType, Pred> referedbyParameterType_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::ParameterType, Pred>(impl, meta_referedbyParameterType); }
		Udm::AssocAttr< ::PICML::AttributeMember> referedbyAttributeMember() const { return Udm::AssocAttr< ::PICML::AttributeMember>(impl, meta_referedbyAttributeMember); }
		template <class Pred> Udm::AssocAttr< ::PICML::AttributeMember, Pred> referedbyAttributeMember_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::AttributeMember, Pred>(impl, meta_referedbyAttributeMember); }
		Udm::AssocAttr< ::PICML::Alias> referedbyAlias() const { return Udm::AssocAttr< ::PICML::Alias>(impl, meta_referedbyAlias); }
		template <class Pred> Udm::AssocAttr< ::PICML::Alias, Pred> referedbyAlias_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::Alias, Pred>(impl, meta_referedbyAlias); }
		Udm::AssocAttr< ::PICML::Boxed> referedbyBoxed() const { return Udm::AssocAttr< ::PICML::Boxed>(impl, meta_referedbyBoxed); }
		template <class Pred> Udm::AssocAttr< ::PICML::Boxed, Pred> referedbyBoxed_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::Boxed, Pred>(impl, meta_referedbyBoxed); }
		Udm::AssocAttr< ::PICML::Collection> referedbyCollection() const { return Udm::AssocAttr< ::PICML::Collection>(impl, meta_referedbyCollection); }
		template <class Pred> Udm::AssocAttr< ::PICML::Collection, Pred> referedbyCollection_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::Collection, Pred>(impl, meta_referedbyCollection); }
		Udm::AssocAttr< ::PICML::Member> referedbyMember() const { return Udm::AssocAttr< ::PICML::Member>(impl, meta_referedbyMember); }
		template <class Pred> Udm::AssocAttr< ::PICML::Member, Pred> referedbyMember_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::Member, Pred>(impl, meta_referedbyMember); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyDataType;
		static ::Uml::AssociationRole meta_referedbyInParameter;
		static ::Uml::AssociationRole meta_referedbyInoutParameter;
		static ::Uml::AssociationRole meta_referedbyOutParameter;
		static ::Uml::AssociationRole meta_referedbyReturnType;
		static ::Uml::AssociationRole meta_referedbyParameterType;
		static ::Uml::AssociationRole meta_referedbyAttributeMember;
		static ::Uml::AssociationRole meta_referedbyAlias;
		static ::Uml::AssociationRole meta_referedbyBoxed;
		static ::Uml::AssociationRole meta_referedbyCollection;
		static ::Uml::AssociationRole meta_referedbyMember;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyDataType {};
		class AR_referedbyInParameter {};
		class AR_referedbyInoutParameter {};
		class AR_referedbyOutParameter {};
		class AR_referedbyReturnType {};
		class AR_referedbyParameterType {};
		class AR_referedbyAttributeMember {};
		class AR_referedbyAlias {};
		class AR_referedbyBoxed {};
		class AR_referedbyCollection {};
		class AR_referedbyMember {};
		typedef boost::mpl::pair< ::PICML::DataType, AR_referedbyDataType > _AR_referedbyDataType__DataType;
		typedef boost::mpl::pair< ::PICML::InParameter, AR_referedbyInParameter > _AR_referedbyInParameter__InParameter;
		typedef boost::mpl::pair< ::PICML::InoutParameter, AR_referedbyInoutParameter > _AR_referedbyInoutParameter__InoutParameter;
		typedef boost::mpl::pair< ::PICML::OutParameter, AR_referedbyOutParameter > _AR_referedbyOutParameter__OutParameter;
		typedef boost::mpl::pair< ::PICML::ReturnType, AR_referedbyReturnType > _AR_referedbyReturnType__ReturnType;
		typedef boost::mpl::pair< ::PICML::ParameterType, AR_referedbyParameterType > _AR_referedbyParameterType__ParameterType;
		typedef boost::mpl::pair< ::PICML::AttributeMember, AR_referedbyAttributeMember > _AR_referedbyAttributeMember__AttributeMember;
		typedef boost::mpl::pair< ::PICML::Alias, AR_referedbyAlias > _AR_referedbyAlias__Alias;
		typedef boost::mpl::pair< ::PICML::Boxed, AR_referedbyBoxed > _AR_referedbyBoxed__Boxed;
		typedef boost::mpl::pair< ::PICML::Collection, AR_referedbyCollection > _AR_referedbyCollection__Collection;
		typedef boost::mpl::pair< ::PICML::Member, AR_referedbyMember > _AR_referedbyMember__Member;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyDataType__DataType, _AR_referedbyInParameter__InParameter, _AR_referedbyInoutParameter__InoutParameter, _AR_referedbyOutParameter__OutParameter, _AR_referedbyReturnType__ReturnType, _AR_referedbyParameterType__ParameterType, _AR_referedbyAttributeMember__AttributeMember, _AR_referedbyAlias__Alias, _AR_referedbyBoxed__Boxed, _AR_referedbyCollection__Collection, _AR_referedbyMember__Member> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Discriminator :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		Discriminator() {}
		Discriminator(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Discriminator(const Discriminator &master) : MgaObject(master) {}

		static Discriminator Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Discriminator Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Discriminator CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Discriminator> Instances() { return Udm::InstantiatedAttr<Discriminator>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Discriminator, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Discriminator, Pred>(impl); }
		Discriminator CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Discriminator> Derived() { return Udm::DerivedAttr<Discriminator>(impl); }
		template <class Pred> Udm::DerivedAttr<Discriminator, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Discriminator, Pred>(impl); }
		Udm::ArchetypeAttr<Discriminator> Archetype() const { return Udm::ArchetypeAttr<Discriminator>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::ConstantType> ref() const { return Udm::PointerAttr< ::PICML::ConstantType>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::SwitchedAggregate> SwitchedAggregate_parent() const { return Udm::ParentAttr< ::PICML::SwitchedAggregate>(impl, meta_SwitchedAggregate_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Discriminator(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_SwitchedAggregate_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_SwitchedAggregate_parent {};
		typedef boost::mpl::pair< ::PICML::SwitchedAggregate, PR_SwitchedAggregate_parent > _PR_SwitchedAggregate_parent__SwitchedAggregate;
		typedef boost::mpl::vector< _PR_SwitchedAggregate_parent__SwitchedAggregate> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::SwitchedAggregate> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::ConstantType, AR_ref > _AR_ref__ConstantType;
		typedef boost::mpl::vector< _AR_ref__ConstantType> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Member :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		Member() {}
		Member(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Member(const Member &master) : MgaObject(master) {}

		static Member Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Member Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Member CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Member> Instances() { return Udm::InstantiatedAttr<Member>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Member, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Member, Pred>(impl); }
		Member CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Member> Derived() { return Udm::DerivedAttr<Member>(impl); }
		template <class Pred> Udm::DerivedAttr<Member, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Member, Pred>(impl); }
		Udm::ArchetypeAttr<Member> Archetype() const { return Udm::ArchetypeAttr<Member>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::MakeMemberPrivate, ::PICML::PrivateFlag> dstMakeMemberPrivate() const { return Udm::AClassPointerAttr< ::PICML::MakeMemberPrivate, ::PICML::PrivateFlag>(impl, meta_dstMakeMemberPrivate, meta_dstMakeMemberPrivate_rev); }
		Udm::AClassAssocAttr< ::PICML::LabelConnection, ::PICML::Label> dstLabelConnection() const { return Udm::AClassAssocAttr< ::PICML::LabelConnection, ::PICML::Label>(impl, meta_dstLabelConnection, meta_dstLabelConnection_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::LabelConnection, ::PICML::Label, Pred> dstLabelConnection_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::LabelConnection, ::PICML::Label, Pred>(impl, meta_dstLabelConnection, meta_dstLabelConnection_rev); }
		Udm::PointerAttr< ::PICML::MemberType> ref() const { return Udm::PointerAttr< ::PICML::MemberType>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::ObjectByValue> ObjectByValue_parent() const { return Udm::ParentAttr< ::PICML::ObjectByValue>(impl, meta_ObjectByValue_parent); }
		Udm::ParentAttr< ::PICML::Aggregate> Aggregate_parent() const { return Udm::ParentAttr< ::PICML::Aggregate>(impl, meta_Aggregate_parent); }
		Udm::ParentAttr< ::PICML::SwitchedAggregate> SwitchedAggregate_parent() const { return Udm::ParentAttr< ::PICML::SwitchedAggregate>(impl, meta_SwitchedAggregate_parent); }
		Udm::ParentAttr< ::PICML::Exception> Exception_parent() const { return Udm::ParentAttr< ::PICML::Exception>(impl, meta_Exception_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Member(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstMakeMemberPrivate;
		static ::Uml::AssociationRole meta_dstMakeMemberPrivate_rev;
		static ::Uml::AssociationRole meta_dstLabelConnection;
		static ::Uml::AssociationRole meta_dstLabelConnection_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ObjectByValue_parent;
		static ::Uml::CompositionParentRole meta_Aggregate_parent;
		static ::Uml::CompositionParentRole meta_SwitchedAggregate_parent;
		static ::Uml::CompositionParentRole meta_Exception_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ObjectByValue_parent {};
		class PR_Aggregate_parent {};
		class PR_SwitchedAggregate_parent {};
		class PR_Exception_parent {};
		typedef boost::mpl::pair< ::PICML::ObjectByValue, PR_ObjectByValue_parent > _PR_ObjectByValue_parent__ObjectByValue;
		typedef boost::mpl::pair< ::PICML::Aggregate, PR_Aggregate_parent > _PR_Aggregate_parent__Aggregate;
		typedef boost::mpl::pair< ::PICML::SwitchedAggregate, PR_SwitchedAggregate_parent > _PR_SwitchedAggregate_parent__SwitchedAggregate;
		typedef boost::mpl::pair< ::PICML::Exception, PR_Exception_parent > _PR_Exception_parent__Exception;
		typedef boost::mpl::vector< _PR_ObjectByValue_parent__ObjectByValue, _PR_Aggregate_parent__Aggregate, _PR_SwitchedAggregate_parent__SwitchedAggregate, _PR_Exception_parent__Exception> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ObjectByValue, ::PICML::Aggregate, ::PICML::SwitchedAggregate, ::PICML::Exception> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::MemberType, AR_ref > _AR_ref__MemberType;
		typedef boost::mpl::vector< _AR_ref__MemberType> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstMakeMemberPrivate {};
		class AR_dstLabelConnection {};
		typedef boost::mpl::pair< ::PICML::PrivateFlag, boost::mpl::pair< ::PICML::MakeMemberPrivate, AR_dstMakeMemberPrivate > > _AR_dstMakeMemberPrivate__MakeMemberPrivate__PrivateFlag;
		typedef boost::mpl::pair< ::PICML::Label, boost::mpl::pair< ::PICML::LabelConnection, AR_dstLabelConnection > > _AR_dstLabelConnection__LabelConnection__Label;
		typedef boost::mpl::vector< _AR_dstMakeMemberPrivate__MakeMemberPrivate__PrivateFlag> AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstLabelConnection__LabelConnection__Label> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export NamedType :  public Taggable,  public MemberType {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		NamedType() {}
		NamedType(Udm::ObjectImpl *impl) : Taggable(impl),MemberType(impl), MgaObject(impl) {}
		NamedType(const NamedType &master) : Taggable(master),MemberType(master), MgaObject(master) {}

		static NamedType Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static NamedType Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		NamedType CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<NamedType> Instances() { return Udm::InstantiatedAttr<NamedType>(impl); }
		template <class Pred> Udm::InstantiatedAttr<NamedType, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<NamedType, Pred>(impl); }
		NamedType CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<NamedType> Derived() { return Udm::DerivedAttr<NamedType>(impl); }
		template <class Pred> Udm::DerivedAttr<NamedType, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<NamedType, Pred>(impl); }
		Udm::ArchetypeAttr<NamedType> Archetype() const { return Udm::ArchetypeAttr<NamedType>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::File> File_parent() const { return Udm::ParentAttr< ::PICML::File>(impl, meta_File_parent); }
		Udm::ParentAttr< ::PICML::Package> Package_parent() const { return Udm::ParentAttr< ::PICML::Package>(impl, meta_Package_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_File_parent;
		static ::Uml::CompositionParentRole meta_Package_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_File_parent {};
		class PR_Package_parent {};
		typedef boost::mpl::pair< ::PICML::File, PR_File_parent > _PR_File_parent__File;
		typedef boost::mpl::pair< ::PICML::Package, PR_Package_parent > _PR_Package_parent__Package;
		typedef boost::mpl::vector< _PR_File_parent__File, _PR_Package_parent__Package> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Inheritable :  public NamedType {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Inheritable() {}
		Inheritable(Udm::ObjectImpl *impl) : NamedType(impl), MgaObject(impl) {}
		Inheritable(const Inheritable &master) : NamedType(master), MgaObject(master) {}

		static Inheritable Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Inheritable Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Inheritable CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Inheritable> Instances() { return Udm::InstantiatedAttr<Inheritable>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Inheritable, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Inheritable, Pred>(impl); }
		Inheritable CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Inheritable> Derived() { return Udm::DerivedAttr<Inheritable>(impl); }
		template <class Pred> Udm::DerivedAttr<Inheritable, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Inheritable, Pred>(impl); }
		Udm::ArchetypeAttr<Inheritable> Archetype() const { return Udm::ArchetypeAttr<Inheritable>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::Inherits> referedbyInherits() const { return Udm::AssocAttr< ::PICML::Inherits>(impl, meta_referedbyInherits); }
		template <class Pred> Udm::AssocAttr< ::PICML::Inherits, Pred> referedbyInherits_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::Inherits, Pred>(impl, meta_referedbyInherits); }
		Udm::ChildrenAttr< ::PICML::ReadonlyAttribute> ReadonlyAttribute_children() const { return Udm::ChildrenAttr< ::PICML::ReadonlyAttribute>(impl, meta_ReadonlyAttribute_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred> ReadonlyAttribute_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred>(impl, meta_ReadonlyAttribute_children); }
		Udm::ChildrenAttr< ::PICML::Inherits> Inherits_children() const { return Udm::ChildrenAttr< ::PICML::Inherits>(impl, meta_Inherits_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Inherits, Pred> Inherits_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Inherits, Pred>(impl, meta_Inherits_children); }
		Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Taggable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Inherits> Inherits_kind_children() const { return Udm::ChildrenAttr< ::PICML::Inherits>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Inherits, Pred> Inherits_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Inherits, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Attribute> Attribute_kind_children() const { return Udm::ChildrenAttr< ::PICML::Attribute>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Attribute, Pred> Attribute_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Attribute, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ReadonlyAttribute> ReadonlyAttribute_kind_children() const { return Udm::ChildrenAttr< ::PICML::ReadonlyAttribute>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred> ReadonlyAttribute_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyInherits;
		static ::Uml::CompositionChildRole meta_ReadonlyAttribute_children;
		static ::Uml::CompositionChildRole meta_Inherits_children;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ReadonlyAttribute_children {};
		class CR_Inherits_children {};
		typedef boost::mpl::pair< ::PICML::ReadonlyAttribute, CR_ReadonlyAttribute_children > _CR_ReadonlyAttribute_children__ReadonlyAttribute;
		typedef boost::mpl::pair< ::PICML::Inherits, CR_Inherits_children > _CR_Inherits_children__Inherits;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_ReadonlyAttribute_children__ReadonlyAttribute, _CR_Inherits_children__Inherits> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Inherits, ::PICML::Attribute, ::PICML::ReadonlyAttribute> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyInherits {};
		typedef boost::mpl::pair< ::PICML::Inherits, AR_referedbyInherits > _AR_referedbyInherits__Inherits;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyInherits__Inherits> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export HasOperations :  public Inheritable {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		HasOperations() {}
		HasOperations(Udm::ObjectImpl *impl) : Inheritable(impl), MgaObject(impl) {}
		HasOperations(const HasOperations &master) : Inheritable(master), MgaObject(master) {}

		static HasOperations Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static HasOperations Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		HasOperations CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<HasOperations> Instances() { return Udm::InstantiatedAttr<HasOperations>(impl); }
		template <class Pred> Udm::InstantiatedAttr<HasOperations, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<HasOperations, Pred>(impl); }
		HasOperations CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<HasOperations> Derived() { return Udm::DerivedAttr<HasOperations>(impl); }
		template <class Pred> Udm::DerivedAttr<HasOperations, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<HasOperations, Pred>(impl); }
		Udm::ArchetypeAttr<HasOperations> Archetype() const { return Udm::ArchetypeAttr<HasOperations>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::TwowayOperation> TwowayOperation_children() const { return Udm::ChildrenAttr< ::PICML::TwowayOperation>(impl, meta_TwowayOperation_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TwowayOperation, Pred> TwowayOperation_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TwowayOperation, Pred>(impl, meta_TwowayOperation_children); }
		Udm::ChildrenAttr< ::PICML::OnewayOperation> OnewayOperation_children() const { return Udm::ChildrenAttr< ::PICML::OnewayOperation>(impl, meta_OnewayOperation_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OnewayOperation, Pred> OnewayOperation_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OnewayOperation, Pred>(impl, meta_OnewayOperation_children); }
		Udm::ChildrenAttr< ::PICML::Exception> Exception_children() const { return Udm::ChildrenAttr< ::PICML::Exception>(impl, meta_Exception_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Exception, Pred> Exception_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Exception, Pred>(impl, meta_Exception_children); }
		Udm::ChildrenAttr< ::PICML::Constant> Constant_children() const { return Udm::ChildrenAttr< ::PICML::Constant>(impl, meta_Constant_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Constant, Pred> Constant_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Constant, Pred>(impl, meta_Constant_children); }
		Udm::ChildrenAttr< ::PICML::NoInheritable> NoInheritable_children() const { return Udm::ChildrenAttr< ::PICML::NoInheritable>(impl, meta_NoInheritable_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::NoInheritable, Pred> NoInheritable_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::NoInheritable, Pred>(impl, meta_NoInheritable_children); }
		Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Taggable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::OperationBase> OperationBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::OperationBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OperationBase, Pred> OperationBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OperationBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::HasExceptions> HasExceptions_kind_children() const { return Udm::ChildrenAttr< ::PICML::HasExceptions>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::HasExceptions, Pred> HasExceptions_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::HasExceptions, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::OnewayOperation> OnewayOperation_kind_children() const { return Udm::ChildrenAttr< ::PICML::OnewayOperation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OnewayOperation, Pred> OnewayOperation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OnewayOperation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::TwowayOperation> TwowayOperation_kind_children() const { return Udm::ChildrenAttr< ::PICML::TwowayOperation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TwowayOperation, Pred> TwowayOperation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TwowayOperation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Aggregate> Aggregate_kind_children() const { return Udm::ChildrenAttr< ::PICML::Aggregate>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Aggregate, Pred> Aggregate_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Aggregate, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::SwitchedAggregate> SwitchedAggregate_kind_children() const { return Udm::ChildrenAttr< ::PICML::SwitchedAggregate>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SwitchedAggregate, Pred> SwitchedAggregate_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SwitchedAggregate, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MemberType> MemberType_kind_children() const { return Udm::ChildrenAttr< ::PICML::MemberType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MemberType, Pred> MemberType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MemberType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Alias> Alias_kind_children() const { return Udm::ChildrenAttr< ::PICML::Alias>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Alias, Pred> Alias_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Alias, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::NoInheritable> NoInheritable_kind_children() const { return Udm::ChildrenAttr< ::PICML::NoInheritable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::NoInheritable, Pred> NoInheritable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::NoInheritable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Collection> Collection_kind_children() const { return Udm::ChildrenAttr< ::PICML::Collection>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Collection, Pred> Collection_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Collection, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Enum> Enum_kind_children() const { return Udm::ChildrenAttr< ::PICML::Enum>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Enum, Pred> Enum_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Enum, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::NamedType> NamedType_kind_children() const { return Udm::ChildrenAttr< ::PICML::NamedType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::NamedType, Pred> NamedType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::NamedType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Exception> Exception_kind_children() const { return Udm::ChildrenAttr< ::PICML::Exception>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Exception, Pred> Exception_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Exception, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Constant> Constant_kind_children() const { return Udm::ChildrenAttr< ::PICML::Constant>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Constant, Pred> Constant_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Constant, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_TwowayOperation_children;
		static ::Uml::CompositionChildRole meta_OnewayOperation_children;
		static ::Uml::CompositionChildRole meta_Exception_children;
		static ::Uml::CompositionChildRole meta_Constant_children;
		static ::Uml::CompositionChildRole meta_NoInheritable_children;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_TwowayOperation_children {};
		class CR_OnewayOperation_children {};
		class CR_Exception_children {};
		class CR_Constant_children {};
		class CR_NoInheritable_children {};
		typedef boost::mpl::pair< ::PICML::TwowayOperation, CR_TwowayOperation_children > _CR_TwowayOperation_children__TwowayOperation;
		typedef boost::mpl::pair< ::PICML::OnewayOperation, CR_OnewayOperation_children > _CR_OnewayOperation_children__OnewayOperation;
		typedef boost::mpl::pair< ::PICML::Exception, CR_Exception_children > _CR_Exception_children__Exception;
		typedef boost::mpl::pair< ::PICML::Constant, CR_Constant_children > _CR_Constant_children__Constant;
		typedef boost::mpl::pair< ::PICML::NoInheritable, CR_NoInheritable_children > _CR_NoInheritable_children__NoInheritable;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_TwowayOperation_children__TwowayOperation, _CR_OnewayOperation_children__OnewayOperation, _CR_Exception_children__Exception, _CR_Constant_children__Constant, _CR_NoInheritable_children__NoInheritable> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::OnewayOperation, ::PICML::TwowayOperation, ::PICML::Inherits, ::PICML::Attribute, ::PICML::ReadonlyAttribute, ::PICML::Aggregate, ::PICML::SwitchedAggregate, ::PICML::Alias, ::PICML::Collection, ::PICML::Enum, ::PICML::NoInheritable, ::PICML::Exception, ::PICML::Constant> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentFactory :  public HasOperations,  public SupportsInterfaces {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ComponentFactory() {}
		ComponentFactory(Udm::ObjectImpl *impl) : HasOperations(impl),SupportsInterfaces(impl), MgaObject(impl) {}
		ComponentFactory(const ComponentFactory &master) : HasOperations(master),SupportsInterfaces(master), MgaObject(master) {}

		static ComponentFactory Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentFactory Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentFactory CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentFactory> Instances() { return Udm::InstantiatedAttr<ComponentFactory>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentFactory, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentFactory, Pred>(impl); }
		ComponentFactory CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentFactory> Derived() { return Udm::DerivedAttr<ComponentFactory>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentFactory, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentFactory, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentFactory> Archetype() const { return Udm::ArchetypeAttr<ComponentFactory>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::ComponentFactoryInstance> referedbyComponentFactoryInstance() const { return Udm::AssocAttr< ::PICML::ComponentFactoryInstance>(impl, meta_referedbyComponentFactoryInstance); }
		template <class Pred> Udm::AssocAttr< ::PICML::ComponentFactoryInstance, Pred> referedbyComponentFactoryInstance_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::ComponentFactoryInstance, Pred>(impl, meta_referedbyComponentFactoryInstance); }
		Udm::AClassPointerAttr< ::PICML::ManagesComponent, ::PICML::Manageable> dstManagesComponent() const { return Udm::AClassPointerAttr< ::PICML::ManagesComponent, ::PICML::Manageable>(impl, meta_dstManagesComponent, meta_dstManagesComponent_rev); }
		Udm::ChildAttr< ::PICML::LookupKey> LookupKey_child() const { return Udm::ChildAttr< ::PICML::LookupKey>(impl, meta_LookupKey_child); }
		Udm::ChildrenAttr< ::PICML::FactoryOperation> FactoryOperation_children() const { return Udm::ChildrenAttr< ::PICML::FactoryOperation>(impl, meta_FactoryOperation_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred> FactoryOperation_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred>(impl, meta_FactoryOperation_children); }
		Udm::ChildrenAttr< ::PICML::LookupOperation> LookupOperation_children() const { return Udm::ChildrenAttr< ::PICML::LookupOperation>(impl, meta_LookupOperation_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::LookupOperation, Pred> LookupOperation_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::LookupOperation, Pred>(impl, meta_LookupOperation_children); }
		Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Taggable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::OperationBase> OperationBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::OperationBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OperationBase, Pred> OperationBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OperationBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::HasExceptions> HasExceptions_kind_children() const { return Udm::ChildrenAttr< ::PICML::HasExceptions>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::HasExceptions, Pred> HasExceptions_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::HasExceptions, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::LookupOperation> LookupOperation_kind_children() const { return Udm::ChildrenAttr< ::PICML::LookupOperation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::LookupOperation, Pred> LookupOperation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::LookupOperation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::FactoryOperation> FactoryOperation_kind_children() const { return Udm::ChildrenAttr< ::PICML::FactoryOperation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred> FactoryOperation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::LookupKey> LookupKey_kind_children() const { return Udm::ChildrenAttr< ::PICML::LookupKey>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::LookupKey, Pred> LookupKey_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::LookupKey, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ComponentFactory(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyComponentFactoryInstance;
		static ::Uml::AssociationRole meta_dstManagesComponent;
		static ::Uml::AssociationRole meta_dstManagesComponent_rev;
		static ::Uml::CompositionChildRole meta_LookupKey_child;
		static ::Uml::CompositionChildRole meta_FactoryOperation_children;
		static ::Uml::CompositionChildRole meta_LookupOperation_children;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_LookupKey_child {};
		class CR_FactoryOperation_children {};
		class CR_LookupOperation_children {};
		typedef boost::mpl::pair< ::PICML::LookupKey, CR_LookupKey_child > _CR_LookupKey_child__LookupKey;
		typedef boost::mpl::pair< ::PICML::FactoryOperation, CR_FactoryOperation_children > _CR_FactoryOperation_children__FactoryOperation;
		typedef boost::mpl::pair< ::PICML::LookupOperation, CR_LookupOperation_children > _CR_LookupOperation_children__LookupOperation;
		typedef boost::mpl::vector< _CR_LookupKey_child__LookupKey> ChildrenSingle;
		typedef boost::mpl::vector< _CR_FactoryOperation_children__FactoryOperation, _CR_LookupOperation_children__LookupOperation> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::OnewayOperation, ::PICML::LookupOperation, ::PICML::FactoryOperation, ::PICML::TwowayOperation, ::PICML::Inherits, ::PICML::Supports, ::PICML::Attribute, ::PICML::LookupKey, ::PICML::ReadonlyAttribute, ::PICML::Aggregate, ::PICML::SwitchedAggregate, ::PICML::Alias, ::PICML::Collection, ::PICML::Enum, ::PICML::NoInheritable, ::PICML::Exception, ::PICML::Constant> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyComponentFactoryInstance {};
		typedef boost::mpl::pair< ::PICML::ComponentFactoryInstance, AR_referedbyComponentFactoryInstance > _AR_referedbyComponentFactoryInstance__ComponentFactoryInstance;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyComponentFactoryInstance__ComponentFactoryInstance> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstManagesComponent {};
		typedef boost::mpl::pair< ::PICML::Manageable, boost::mpl::pair< ::PICML::ManagesComponent, AR_dstManagesComponent > > _AR_dstManagesComponent__ManagesComponent__Manageable;
		typedef boost::mpl::vector< _AR_dstManagesComponent__ManagesComponent__Manageable> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Object :  public Prefixable,  public Provideable,  public HasOperations {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Object() {}
		Object(Udm::ObjectImpl *impl) : Prefixable(impl),Provideable(impl),HasOperations(impl), MgaObject(impl) {}
		Object(const Object &master) : Prefixable(master),Provideable(master),HasOperations(master), MgaObject(master) {}

		static Object Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Object Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Object CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Object> Instances() { return Udm::InstantiatedAttr<Object>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Object, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Object, Pred>(impl); }
		Object CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Object> Derived() { return Udm::DerivedAttr<Object>(impl); }
		template <class Pred> Udm::DerivedAttr<Object, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Object, Pred>(impl); }
		Udm::ArchetypeAttr<Object> Archetype() const { return Udm::ArchetypeAttr<Object>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::BooleanAttr local() const { return Udm::BooleanAttr(impl, meta_local); }
		Udm::BooleanAttr abstract() const { return Udm::BooleanAttr(impl, meta_abstract); }
		Udm::AssocAttr< ::PICML::Supports> referedbySupports() const { return Udm::AssocAttr< ::PICML::Supports>(impl, meta_referedbySupports); }
		template <class Pred> Udm::AssocAttr< ::PICML::Supports, Pred> referedbySupports_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::Supports, Pred>(impl, meta_referedbySupports); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Object(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_local;
		static ::Uml::Attribute meta_abstract;
		static ::Uml::AssociationRole meta_referedbySupports;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::OnewayOperation, ::PICML::TwowayOperation, ::PICML::Inherits, ::PICML::Attribute, ::PICML::ReadonlyAttribute, ::PICML::Aggregate, ::PICML::SwitchedAggregate, ::PICML::Alias, ::PICML::Collection, ::PICML::Enum, ::PICML::NoInheritable, ::PICML::Exception, ::PICML::Constant> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbySupports {};
		typedef boost::mpl::pair< ::PICML::Supports, AR_referedbySupports > _AR_referedbySupports__Supports;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbySupports__Supports> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ObjectByValue :  public Prefixable,  public HasOperations,  public SupportsInterfaces {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ObjectByValue() {}
		ObjectByValue(Udm::ObjectImpl *impl) : Prefixable(impl),HasOperations(impl),SupportsInterfaces(impl), MgaObject(impl) {}
		ObjectByValue(const ObjectByValue &master) : Prefixable(master),HasOperations(master),SupportsInterfaces(master), MgaObject(master) {}

		static ObjectByValue Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ObjectByValue Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ObjectByValue CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ObjectByValue> Instances() { return Udm::InstantiatedAttr<ObjectByValue>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ObjectByValue, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ObjectByValue, Pred>(impl); }
		ObjectByValue CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ObjectByValue> Derived() { return Udm::DerivedAttr<ObjectByValue>(impl); }
		template <class Pred> Udm::DerivedAttr<ObjectByValue, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ObjectByValue, Pred>(impl); }
		Udm::ArchetypeAttr<ObjectByValue> Archetype() const { return Udm::ArchetypeAttr<ObjectByValue>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::BooleanAttr abstract() const { return Udm::BooleanAttr(impl, meta_abstract); }
		Udm::ChildrenAttr< ::PICML::PrivateFlag> PrivateFlag_children() const { return Udm::ChildrenAttr< ::PICML::PrivateFlag>(impl, meta_PrivateFlag_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PrivateFlag, Pred> PrivateFlag_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PrivateFlag, Pred>(impl, meta_PrivateFlag_children); }
		Udm::ChildrenAttr< ::PICML::FactoryOperation> FactoryOperation_children() const { return Udm::ChildrenAttr< ::PICML::FactoryOperation>(impl, meta_FactoryOperation_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred> FactoryOperation_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred>(impl, meta_FactoryOperation_children); }
		Udm::ChildrenAttr< ::PICML::MakeMemberPrivate> MakeMemberPrivate_children() const { return Udm::ChildrenAttr< ::PICML::MakeMemberPrivate>(impl, meta_MakeMemberPrivate_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MakeMemberPrivate, Pred> MakeMemberPrivate_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MakeMemberPrivate, Pred>(impl, meta_MakeMemberPrivate_children); }
		Udm::ChildrenAttr< ::PICML::Member> Member_children() const { return Udm::ChildrenAttr< ::PICML::Member>(impl, meta_Member_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Member, Pred> Member_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Member, Pred>(impl, meta_Member_children); }
		Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Taggable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::OperationBase> OperationBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::OperationBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OperationBase, Pred> OperationBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OperationBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::HasExceptions> HasExceptions_kind_children() const { return Udm::ChildrenAttr< ::PICML::HasExceptions>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::HasExceptions, Pred> HasExceptions_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::HasExceptions, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::FactoryOperation> FactoryOperation_kind_children() const { return Udm::ChildrenAttr< ::PICML::FactoryOperation>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred> FactoryOperation_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PrivateFlag> PrivateFlag_kind_children() const { return Udm::ChildrenAttr< ::PICML::PrivateFlag>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PrivateFlag, Pred> PrivateFlag_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PrivateFlag, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MakeMemberPrivate> MakeMemberPrivate_kind_children() const { return Udm::ChildrenAttr< ::PICML::MakeMemberPrivate>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MakeMemberPrivate, Pred> MakeMemberPrivate_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MakeMemberPrivate, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Member> Member_kind_children() const { return Udm::ChildrenAttr< ::PICML::Member>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Member, Pred> Member_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Member, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_abstract;
		static ::Uml::CompositionChildRole meta_PrivateFlag_children;
		static ::Uml::CompositionChildRole meta_FactoryOperation_children;
		static ::Uml::CompositionChildRole meta_MakeMemberPrivate_children;
		static ::Uml::CompositionChildRole meta_Member_children;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_PrivateFlag_children {};
		class CR_FactoryOperation_children {};
		class CR_MakeMemberPrivate_children {};
		class CR_Member_children {};
		typedef boost::mpl::pair< ::PICML::PrivateFlag, CR_PrivateFlag_children > _CR_PrivateFlag_children__PrivateFlag;
		typedef boost::mpl::pair< ::PICML::FactoryOperation, CR_FactoryOperation_children > _CR_FactoryOperation_children__FactoryOperation;
		typedef boost::mpl::pair< ::PICML::MakeMemberPrivate, CR_MakeMemberPrivate_children > _CR_MakeMemberPrivate_children__MakeMemberPrivate;
		typedef boost::mpl::pair< ::PICML::Member, CR_Member_children > _CR_Member_children__Member;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_PrivateFlag_children__PrivateFlag, _CR_FactoryOperation_children__FactoryOperation, _CR_MakeMemberPrivate_children__MakeMemberPrivate, _CR_Member_children__Member> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::OnewayOperation, ::PICML::FactoryOperation, ::PICML::TwowayOperation, ::PICML::Inherits, ::PICML::Supports, ::PICML::Attribute, ::PICML::PrivateFlag, ::PICML::MakeMemberPrivate, ::PICML::ReadonlyAttribute, ::PICML::Aggregate, ::PICML::SwitchedAggregate, ::PICML::Alias, ::PICML::Collection, ::PICML::Enum, ::PICML::NoInheritable, ::PICML::Member, ::PICML::Exception, ::PICML::Constant> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Event :  public ExternalPortReferenceType,  public ObjectByValue {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Event() {}
		Event(Udm::ObjectImpl *impl) : ExternalPortReferenceType(impl),ObjectByValue(impl), MgaObject(impl) {}
		Event(const Event &master) : ExternalPortReferenceType(master),ObjectByValue(master), MgaObject(master) {}

		static Event Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Event Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Event CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Event> Instances() { return Udm::InstantiatedAttr<Event>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Event, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Event, Pred>(impl); }
		Event CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Event> Derived() { return Udm::DerivedAttr<Event>(impl); }
		template <class Pred> Udm::DerivedAttr<Event, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Event, Pred>(impl); }
		Udm::ArchetypeAttr<Event> Archetype() const { return Udm::ArchetypeAttr<Event>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::EventRef> referedbyEventRef() const { return Udm::AssocAttr< ::PICML::EventRef>(impl, meta_referedbyEventRef); }
		template <class Pred> Udm::AssocAttr< ::PICML::EventRef, Pred> referedbyEventRef_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::EventRef, Pred>(impl, meta_referedbyEventRef); }
		Udm::AssocAttr< ::PICML::InEventPort> referedbyInEventPort() const { return Udm::AssocAttr< ::PICML::InEventPort>(impl, meta_referedbyInEventPort); }
		template <class Pred> Udm::AssocAttr< ::PICML::InEventPort, Pred> referedbyInEventPort_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::InEventPort, Pred>(impl, meta_referedbyInEventPort); }
		Udm::AssocAttr< ::PICML::OutEventPort> referedbyOutEventPort() const { return Udm::AssocAttr< ::PICML::OutEventPort>(impl, meta_referedbyOutEventPort); }
		template <class Pred> Udm::AssocAttr< ::PICML::OutEventPort, Pred> referedbyOutEventPort_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::OutEventPort, Pred>(impl, meta_referedbyOutEventPort); }
		Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const { return Udm::ParentAttr< ::PICML::BenchmarkAnalysis>(impl, meta_BenchmarkAnalysis_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Event(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyEventRef;
		static ::Uml::AssociationRole meta_referedbyInEventPort;
		static ::Uml::AssociationRole meta_referedbyOutEventPort;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_BenchmarkAnalysis_parent {};
		typedef boost::mpl::pair< ::PICML::BenchmarkAnalysis, PR_BenchmarkAnalysis_parent > _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis;
		typedef boost::mpl::vector< _PR_BenchmarkAnalysis_parent__BenchmarkAnalysis> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BenchmarkAnalysis, ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::OnewayOperation, ::PICML::FactoryOperation, ::PICML::TwowayOperation, ::PICML::Inherits, ::PICML::Supports, ::PICML::Attribute, ::PICML::PrivateFlag, ::PICML::MakeMemberPrivate, ::PICML::ReadonlyAttribute, ::PICML::Aggregate, ::PICML::SwitchedAggregate, ::PICML::Alias, ::PICML::Collection, ::PICML::Enum, ::PICML::NoInheritable, ::PICML::Member, ::PICML::Exception, ::PICML::Constant> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyEventRef {};
		class AR_referedbyInEventPort {};
		class AR_referedbyOutEventPort {};
		typedef boost::mpl::pair< ::PICML::EventRef, AR_referedbyEventRef > _AR_referedbyEventRef__EventRef;
		typedef boost::mpl::pair< ::PICML::InEventPort, AR_referedbyInEventPort > _AR_referedbyInEventPort__InEventPort;
		typedef boost::mpl::pair< ::PICML::OutEventPort, AR_referedbyOutEventPort > _AR_referedbyOutEventPort__OutEventPort;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyEventRef__EventRef, _AR_referedbyInEventPort__InEventPort, _AR_referedbyOutEventPort__OutEventPort> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ValueObject :  public ObjectByValue {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ValueObject() {}
		ValueObject(Udm::ObjectImpl *impl) : ObjectByValue(impl), MgaObject(impl) {}
		ValueObject(const ValueObject &master) : ObjectByValue(master), MgaObject(master) {}

		static ValueObject Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ValueObject Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ValueObject CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ValueObject> Instances() { return Udm::InstantiatedAttr<ValueObject>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ValueObject, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ValueObject, Pred>(impl); }
		ValueObject CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ValueObject> Derived() { return Udm::DerivedAttr<ValueObject>(impl); }
		template <class Pred> Udm::DerivedAttr<ValueObject, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ValueObject, Pred>(impl); }
		Udm::ArchetypeAttr<ValueObject> Archetype() const { return Udm::ArchetypeAttr<ValueObject>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::LookupKey> referedbyLookupKey() const { return Udm::AssocAttr< ::PICML::LookupKey>(impl, meta_referedbyLookupKey); }
		template <class Pred> Udm::AssocAttr< ::PICML::LookupKey, Pred> referedbyLookupKey_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::LookupKey, Pred>(impl, meta_referedbyLookupKey); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ValueObject(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyLookupKey;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::OnewayOperation, ::PICML::FactoryOperation, ::PICML::TwowayOperation, ::PICML::Inherits, ::PICML::Supports, ::PICML::Attribute, ::PICML::PrivateFlag, ::PICML::MakeMemberPrivate, ::PICML::ReadonlyAttribute, ::PICML::Aggregate, ::PICML::SwitchedAggregate, ::PICML::Alias, ::PICML::Collection, ::PICML::Enum, ::PICML::NoInheritable, ::PICML::Member, ::PICML::Exception, ::PICML::Constant> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyLookupKey {};
		typedef boost::mpl::pair< ::PICML::LookupKey, AR_referedbyLookupKey > _AR_referedbyLookupKey__LookupKey;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyLookupKey__LookupKey> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Boxed :  public NamedType {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		Boxed() {}
		Boxed(Udm::ObjectImpl *impl) : NamedType(impl), MgaObject(impl) {}
		Boxed(const Boxed &master) : NamedType(master), MgaObject(master) {}

		static Boxed Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Boxed Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Boxed CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Boxed> Instances() { return Udm::InstantiatedAttr<Boxed>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Boxed, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Boxed, Pred>(impl); }
		Boxed CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Boxed> Derived() { return Udm::DerivedAttr<Boxed>(impl); }
		template <class Pred> Udm::DerivedAttr<Boxed, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Boxed, Pred>(impl); }
		Udm::ArchetypeAttr<Boxed> Archetype() const { return Udm::ArchetypeAttr<Boxed>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::MemberType> ref() const { return Udm::PointerAttr< ::PICML::MemberType>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Boxed(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::MemberType, AR_ref > _AR_ref__MemberType;
		typedef boost::mpl::vector< _AR_ref__MemberType> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export NoInheritable :  public NamedType {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		NoInheritable() {}
		NoInheritable(Udm::ObjectImpl *impl) : NamedType(impl), MgaObject(impl) {}
		NoInheritable(const NoInheritable &master) : NamedType(master), MgaObject(master) {}

		static NoInheritable Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static NoInheritable Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		NoInheritable CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<NoInheritable> Instances() { return Udm::InstantiatedAttr<NoInheritable>(impl); }
		template <class Pred> Udm::InstantiatedAttr<NoInheritable, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<NoInheritable, Pred>(impl); }
		NoInheritable CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<NoInheritable> Derived() { return Udm::DerivedAttr<NoInheritable>(impl); }
		template <class Pred> Udm::DerivedAttr<NoInheritable, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<NoInheritable, Pred>(impl); }
		Udm::ArchetypeAttr<NoInheritable> Archetype() const { return Udm::ArchetypeAttr<NoInheritable>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::HasOperations> HasOperations_parent() const { return Udm::ParentAttr< ::PICML::HasOperations>(impl, meta_HasOperations_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_HasOperations_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_HasOperations_parent {};
		typedef boost::mpl::pair< ::PICML::HasOperations, PR_HasOperations_parent > _PR_HasOperations_parent__HasOperations;
		typedef boost::mpl::vector< _PR_HasOperations_parent__HasOperations> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::HasOperations, ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Aggregate :  public NoInheritable {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Aggregate() {}
		Aggregate(Udm::ObjectImpl *impl) : NoInheritable(impl), MgaObject(impl) {}
		Aggregate(const Aggregate &master) : NoInheritable(master), MgaObject(master) {}

		static Aggregate Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Aggregate Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Aggregate CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Aggregate> Instances() { return Udm::InstantiatedAttr<Aggregate>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Aggregate, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Aggregate, Pred>(impl); }
		Aggregate CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Aggregate> Derived() { return Udm::DerivedAttr<Aggregate>(impl); }
		template <class Pred> Udm::DerivedAttr<Aggregate, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Aggregate, Pred>(impl); }
		Udm::ArchetypeAttr<Aggregate> Archetype() const { return Udm::ArchetypeAttr<Aggregate>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::Member> Member_children() const { return Udm::ChildrenAttr< ::PICML::Member>(impl, meta_Member_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Member, Pred> Member_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Member, Pred>(impl, meta_Member_children); }
		Udm::ChildrenAttr< ::PICML::Member> Member_kind_children() const { return Udm::ChildrenAttr< ::PICML::Member>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Member, Pred> Member_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Member, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Aggregate(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Member_children;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::HasOperations, ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Member_children {};
		typedef boost::mpl::pair< ::PICML::Member, CR_Member_children > _CR_Member_children__Member;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Member_children__Member> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Member> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export SwitchedAggregate :  public NoInheritable {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		SwitchedAggregate() {}
		SwitchedAggregate(Udm::ObjectImpl *impl) : NoInheritable(impl), MgaObject(impl) {}
		SwitchedAggregate(const SwitchedAggregate &master) : NoInheritable(master), MgaObject(master) {}

		static SwitchedAggregate Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static SwitchedAggregate Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		SwitchedAggregate CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<SwitchedAggregate> Instances() { return Udm::InstantiatedAttr<SwitchedAggregate>(impl); }
		template <class Pred> Udm::InstantiatedAttr<SwitchedAggregate, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<SwitchedAggregate, Pred>(impl); }
		SwitchedAggregate CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<SwitchedAggregate> Derived() { return Udm::DerivedAttr<SwitchedAggregate>(impl); }
		template <class Pred> Udm::DerivedAttr<SwitchedAggregate, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<SwitchedAggregate, Pred>(impl); }
		Udm::ArchetypeAttr<SwitchedAggregate> Archetype() const { return Udm::ArchetypeAttr<SwitchedAggregate>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::Label> Label_children() const { return Udm::ChildrenAttr< ::PICML::Label>(impl, meta_Label_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Label, Pred> Label_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Label, Pred>(impl, meta_Label_children); }
		Udm::ChildrenAttr< ::PICML::LabelConnection> LabelConnection_children() const { return Udm::ChildrenAttr< ::PICML::LabelConnection>(impl, meta_LabelConnection_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::LabelConnection, Pred> LabelConnection_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::LabelConnection, Pred>(impl, meta_LabelConnection_children); }
		Udm::ChildrenAttr< ::PICML::Member> Member_children() const { return Udm::ChildrenAttr< ::PICML::Member>(impl, meta_Member_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Member, Pred> Member_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Member, Pred>(impl, meta_Member_children); }
		Udm::ChildAttr< ::PICML::Discriminator> Discriminator_child() const { return Udm::ChildAttr< ::PICML::Discriminator>(impl, meta_Discriminator_child); }
		Udm::ChildrenAttr< ::PICML::Label> Label_kind_children() const { return Udm::ChildrenAttr< ::PICML::Label>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Label, Pred> Label_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Label, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::LabelConnection> LabelConnection_kind_children() const { return Udm::ChildrenAttr< ::PICML::LabelConnection>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::LabelConnection, Pred> LabelConnection_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::LabelConnection, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Discriminator> Discriminator_kind_children() const { return Udm::ChildrenAttr< ::PICML::Discriminator>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Discriminator, Pred> Discriminator_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Discriminator, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Member> Member_kind_children() const { return Udm::ChildrenAttr< ::PICML::Member>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Member, Pred> Member_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Member, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_SwitchedAggregate(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Label_children;
		static ::Uml::CompositionChildRole meta_LabelConnection_children;
		static ::Uml::CompositionChildRole meta_Member_children;
		static ::Uml::CompositionChildRole meta_Discriminator_child;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::HasOperations, ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Label_children {};
		class CR_LabelConnection_children {};
		class CR_Member_children {};
		class CR_Discriminator_child {};
		typedef boost::mpl::pair< ::PICML::Label, CR_Label_children > _CR_Label_children__Label;
		typedef boost::mpl::pair< ::PICML::LabelConnection, CR_LabelConnection_children > _CR_LabelConnection_children__LabelConnection;
		typedef boost::mpl::pair< ::PICML::Member, CR_Member_children > _CR_Member_children__Member;
		typedef boost::mpl::pair< ::PICML::Discriminator, CR_Discriminator_child > _CR_Discriminator_child__Discriminator;
		typedef boost::mpl::vector< _CR_Discriminator_child__Discriminator> ChildrenSingle;
		typedef boost::mpl::vector< _CR_Label_children__Label, _CR_LabelConnection_children__LabelConnection, _CR_Member_children__Member> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Label, ::PICML::LabelConnection, ::PICML::Discriminator, ::PICML::Member> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Alias :  public NoInheritable {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		Alias() {}
		Alias(Udm::ObjectImpl *impl) : NoInheritable(impl), MgaObject(impl) {}
		Alias(const Alias &master) : NoInheritable(master), MgaObject(master) {}

		static Alias Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Alias Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Alias CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Alias> Instances() { return Udm::InstantiatedAttr<Alias>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Alias, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Alias, Pred>(impl); }
		Alias CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Alias> Derived() { return Udm::DerivedAttr<Alias>(impl); }
		template <class Pred> Udm::DerivedAttr<Alias, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Alias, Pred>(impl); }
		Udm::ArchetypeAttr<Alias> Archetype() const { return Udm::ArchetypeAttr<Alias>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::MemberType> ref() const { return Udm::PointerAttr< ::PICML::MemberType>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Alias(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::HasOperations, ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::MemberType, AR_ref > _AR_ref__MemberType;
		typedef boost::mpl::vector< _AR_ref__MemberType> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Collection :  public NoInheritable {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		Collection() {}
		Collection(Udm::ObjectImpl *impl) : NoInheritable(impl), MgaObject(impl) {}
		Collection(const Collection &master) : NoInheritable(master), MgaObject(master) {}

		static Collection Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Collection Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Collection CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Collection> Instances() { return Udm::InstantiatedAttr<Collection>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Collection, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Collection, Pred>(impl); }
		Collection CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Collection> Derived() { return Udm::DerivedAttr<Collection>(impl); }
		template <class Pred> Udm::DerivedAttr<Collection, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Collection, Pred>(impl); }
		Udm::ArchetypeAttr<Collection> Archetype() const { return Udm::ArchetypeAttr<Collection>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr bound() const { return Udm::StringAttr(impl, meta_bound); }
		Udm::PointerAttr< ::PICML::MemberType> ref() const { return Udm::PointerAttr< ::PICML::MemberType>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::PredefinedTypes> PredefinedTypes_parent() const { return Udm::ParentAttr< ::PICML::PredefinedTypes>(impl, meta_PredefinedTypes_parent); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Collection(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_bound;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_PredefinedTypes_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_PredefinedTypes_parent {};
		typedef boost::mpl::pair< ::PICML::PredefinedTypes, PR_PredefinedTypes_parent > _PR_PredefinedTypes_parent__PredefinedTypes;
		typedef boost::mpl::vector< _PR_PredefinedTypes_parent__PredefinedTypes> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::HasOperations, ::PICML::PredefinedTypes, ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::MemberType, AR_ref > _AR_ref__MemberType;
		typedef boost::mpl::vector< _AR_ref__MemberType> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Package :  public Prefixable,  public Taggable {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Package() {}
		Package(Udm::ObjectImpl *impl) : Prefixable(impl),Taggable(impl), MgaObject(impl) {}
		Package(const Package &master) : Prefixable(master),Taggable(master), MgaObject(master) {}

		static Package Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Package Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Package CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Package> Instances() { return Udm::InstantiatedAttr<Package>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Package, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Package, Pred>(impl); }
		Package CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Package> Derived() { return Udm::DerivedAttr<Package>(impl); }
		template <class Pred> Udm::DerivedAttr<Package, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Package, Pred>(impl); }
		Udm::ArchetypeAttr<Package> Archetype() const { return Udm::ArchetypeAttr<Package>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_children() const { return Udm::ChildrenAttr< ::PICML::ComponentRef>(impl, meta_ComponentRef_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, meta_ComponentRef_children); }
		Udm::ChildrenAttr< ::PICML::NamedType> NamedType_children() const { return Udm::ChildrenAttr< ::PICML::NamedType>(impl, meta_NamedType_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::NamedType, Pred> NamedType_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::NamedType, Pred>(impl, meta_NamedType_children); }
		Udm::ChildrenAttr< ::PICML::ManagesComponent> ManagesComponent_children() const { return Udm::ChildrenAttr< ::PICML::ManagesComponent>(impl, meta_ManagesComponent_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ManagesComponent, Pred> ManagesComponent_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ManagesComponent, Pred>(impl, meta_ManagesComponent_children); }
		Udm::ChildrenAttr< ::PICML::Package> Package_children() const { return Udm::ChildrenAttr< ::PICML::Package>(impl, meta_Package_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Package, Pred> Package_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Package, Pred>(impl, meta_Package_children); }
		Udm::ChildrenAttr< ::PICML::Exception> Exception_children() const { return Udm::ChildrenAttr< ::PICML::Exception>(impl, meta_Exception_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Exception, Pred> Exception_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Exception, Pred>(impl, meta_Exception_children); }
		Udm::ChildrenAttr< ::PICML::Constant> Constant_children() const { return Udm::ChildrenAttr< ::PICML::Constant>(impl, meta_Constant_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Constant, Pred> Constant_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Constant, Pred>(impl, meta_Constant_children); }
		Udm::ChildrenAttr< ::PICML::CollocationGroupMember> CollocationGroupMember_kind_children() const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred> CollocationGroupMember_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Prefixable> Prefixable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Prefixable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Prefixable, Pred> Prefixable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Prefixable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Taggable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Manageable> Manageable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Manageable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Manageable, Pred> Manageable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Manageable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentFactory> ComponentFactory_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentFactory>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentFactory, Pred> ComponentFactory_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentFactory, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentRef>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ManagesComponent> ManagesComponent_kind_children() const { return Udm::ChildrenAttr< ::PICML::ManagesComponent>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ManagesComponent, Pred> ManagesComponent_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ManagesComponent, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Component> Component_kind_children() const { return Udm::ChildrenAttr< ::PICML::Component>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Component, Pred> Component_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Component, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Object> Object_kind_children() const { return Udm::ChildrenAttr< ::PICML::Object>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Object, Pred> Object_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Object, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Event> Event_kind_children() const { return Udm::ChildrenAttr< ::PICML::Event>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Event, Pred> Event_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Event, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ValueObject> ValueObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::ValueObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ValueObject, Pred> ValueObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ValueObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::HasOperations> HasOperations_kind_children() const { return Udm::ChildrenAttr< ::PICML::HasOperations>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::HasOperations, Pred> HasOperations_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::HasOperations, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ObjectByValue> ObjectByValue_kind_children() const { return Udm::ChildrenAttr< ::PICML::ObjectByValue>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ObjectByValue, Pred> ObjectByValue_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ObjectByValue, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Inheritable> Inheritable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Inheritable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Inheritable, Pred> Inheritable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Inheritable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Aggregate> Aggregate_kind_children() const { return Udm::ChildrenAttr< ::PICML::Aggregate>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Aggregate, Pred> Aggregate_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Aggregate, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::SwitchedAggregate> SwitchedAggregate_kind_children() const { return Udm::ChildrenAttr< ::PICML::SwitchedAggregate>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SwitchedAggregate, Pred> SwitchedAggregate_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SwitchedAggregate, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MemberType> MemberType_kind_children() const { return Udm::ChildrenAttr< ::PICML::MemberType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MemberType, Pred> MemberType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MemberType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Alias> Alias_kind_children() const { return Udm::ChildrenAttr< ::PICML::Alias>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Alias, Pred> Alias_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Alias, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Boxed> Boxed_kind_children() const { return Udm::ChildrenAttr< ::PICML::Boxed>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Boxed, Pred> Boxed_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Boxed, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::NoInheritable> NoInheritable_kind_children() const { return Udm::ChildrenAttr< ::PICML::NoInheritable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::NoInheritable, Pred> NoInheritable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::NoInheritable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Collection> Collection_kind_children() const { return Udm::ChildrenAttr< ::PICML::Collection>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Collection, Pred> Collection_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Collection, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Enum> Enum_kind_children() const { return Udm::ChildrenAttr< ::PICML::Enum>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Enum, Pred> Enum_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Enum, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::NamedType> NamedType_kind_children() const { return Udm::ChildrenAttr< ::PICML::NamedType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::NamedType, Pred> NamedType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::NamedType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Package> Package_kind_children() const { return Udm::ChildrenAttr< ::PICML::Package>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Package, Pred> Package_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Package, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Exception> Exception_kind_children() const { return Udm::ChildrenAttr< ::PICML::Exception>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Exception, Pred> Exception_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Exception, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Constant> Constant_kind_children() const { return Udm::ChildrenAttr< ::PICML::Constant>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Constant, Pred> Constant_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Constant, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::Package> Package_parent() const { return Udm::ParentAttr< ::PICML::Package>(impl, meta_Package_parent); }
		Udm::ParentAttr< ::PICML::File> File_parent() const { return Udm::ParentAttr< ::PICML::File>(impl, meta_File_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Package(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_ComponentRef_children;
		static ::Uml::CompositionChildRole meta_NamedType_children;
		static ::Uml::CompositionChildRole meta_ManagesComponent_children;
		static ::Uml::CompositionChildRole meta_Package_children;
		static ::Uml::CompositionChildRole meta_Exception_children;
		static ::Uml::CompositionChildRole meta_Constant_children;
		static ::Uml::CompositionParentRole meta_Package_parent;
		static ::Uml::CompositionParentRole meta_File_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Package_parent {};
		class PR_File_parent {};
		typedef boost::mpl::pair< ::PICML::Package, PR_Package_parent > _PR_Package_parent__Package;
		typedef boost::mpl::pair< ::PICML::File, PR_File_parent > _PR_File_parent__File;
		typedef boost::mpl::vector< _PR_Package_parent__Package, _PR_File_parent__File> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ComponentRef_children {};
		class CR_NamedType_children {};
		class CR_ManagesComponent_children {};
		class CR_Package_children {};
		class CR_Exception_children {};
		class CR_Constant_children {};
		typedef boost::mpl::pair< ::PICML::ComponentRef, CR_ComponentRef_children > _CR_ComponentRef_children__ComponentRef;
		typedef boost::mpl::pair< ::PICML::NamedType, CR_NamedType_children > _CR_NamedType_children__NamedType;
		typedef boost::mpl::pair< ::PICML::ManagesComponent, CR_ManagesComponent_children > _CR_ManagesComponent_children__ManagesComponent;
		typedef boost::mpl::pair< ::PICML::Package, CR_Package_children > _CR_Package_children__Package;
		typedef boost::mpl::pair< ::PICML::Exception, CR_Exception_children > _CR_Exception_children__Exception;
		typedef boost::mpl::pair< ::PICML::Constant, CR_Constant_children > _CR_Constant_children__Constant;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_ComponentRef_children__ComponentRef, _CR_NamedType_children__NamedType, _CR_ManagesComponent_children__ManagesComponent, _CR_Package_children__Package, _CR_Exception_children__Exception, _CR_Constant_children__Constant> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentFactory, ::PICML::ComponentRef, ::PICML::ManagesComponent, ::PICML::Component, ::PICML::Object, ::PICML::Event, ::PICML::ValueObject, ::PICML::ObjectByValue, ::PICML::HasOperations, ::PICML::Inheritable, ::PICML::Aggregate, ::PICML::SwitchedAggregate, ::PICML::Alias, ::PICML::Boxed, ::PICML::Collection, ::PICML::Enum, ::PICML::NoInheritable, ::PICML::NamedType, ::PICML::Package, ::PICML::Exception, ::PICML::Constant> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export File :  public Prefixable {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		File() {}
		File(Udm::ObjectImpl *impl) : Prefixable(impl), MgaObject(impl) {}
		File(const File &master) : Prefixable(master), MgaObject(master) {}

		static File Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static File Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		File CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<File> Instances() { return Udm::InstantiatedAttr<File>(impl); }
		template <class Pred> Udm::InstantiatedAttr<File, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<File, Pred>(impl); }
		File CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<File> Derived() { return Udm::DerivedAttr<File>(impl); }
		template <class Pred> Udm::DerivedAttr<File, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<File, Pred>(impl); }
		Udm::ArchetypeAttr<File> Archetype() const { return Udm::ArchetypeAttr<File>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr path() const { return Udm::StringAttr(impl, meta_path); }
		Udm::AssocAttr< ::PICML::FileRef> referedbyFileRef() const { return Udm::AssocAttr< ::PICML::FileRef>(impl, meta_referedbyFileRef); }
		template <class Pred> Udm::AssocAttr< ::PICML::FileRef, Pred> referedbyFileRef_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::FileRef, Pred>(impl, meta_referedbyFileRef); }
		Udm::ChildrenAttr< ::PICML::ManagesComponent> ManagesComponent_children() const { return Udm::ChildrenAttr< ::PICML::ManagesComponent>(impl, meta_ManagesComponent_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ManagesComponent, Pred> ManagesComponent_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ManagesComponent, Pred>(impl, meta_ManagesComponent_children); }
		Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_children() const { return Udm::ChildrenAttr< ::PICML::ComponentRef>(impl, meta_ComponentRef_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, meta_ComponentRef_children); }
		Udm::ChildrenAttr< ::PICML::Package> Package_children() const { return Udm::ChildrenAttr< ::PICML::Package>(impl, meta_Package_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Package, Pred> Package_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Package, Pred>(impl, meta_Package_children); }
		Udm::ChildrenAttr< ::PICML::Exception> Exception_children() const { return Udm::ChildrenAttr< ::PICML::Exception>(impl, meta_Exception_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Exception, Pred> Exception_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Exception, Pred>(impl, meta_Exception_children); }
		Udm::ChildrenAttr< ::PICML::FileRef> FileRef_children() const { return Udm::ChildrenAttr< ::PICML::FileRef>(impl, meta_FileRef_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::FileRef, Pred> FileRef_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::FileRef, Pred>(impl, meta_FileRef_children); }
		Udm::ChildrenAttr< ::PICML::Constant> Constant_children() const { return Udm::ChildrenAttr< ::PICML::Constant>(impl, meta_Constant_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Constant, Pred> Constant_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Constant, Pred>(impl, meta_Constant_children); }
		Udm::ChildrenAttr< ::PICML::NamedType> NamedType_children() const { return Udm::ChildrenAttr< ::PICML::NamedType>(impl, meta_NamedType_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::NamedType, Pred> NamedType_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::NamedType, Pred>(impl, meta_NamedType_children); }
		Udm::ChildrenAttr< ::PICML::CollocationGroupMember> CollocationGroupMember_kind_children() const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred> CollocationGroupMember_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Prefixable> Prefixable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Prefixable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Prefixable, Pred> Prefixable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Prefixable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Taggable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Manageable> Manageable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Manageable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Manageable, Pred> Manageable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Manageable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentFactory> ComponentFactory_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentFactory>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentFactory, Pred> ComponentFactory_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentFactory, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentRef>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ManagesComponent> ManagesComponent_kind_children() const { return Udm::ChildrenAttr< ::PICML::ManagesComponent>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ManagesComponent, Pred> ManagesComponent_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ManagesComponent, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Component> Component_kind_children() const { return Udm::ChildrenAttr< ::PICML::Component>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Component, Pred> Component_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Component, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Object> Object_kind_children() const { return Udm::ChildrenAttr< ::PICML::Object>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Object, Pred> Object_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Object, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Event> Event_kind_children() const { return Udm::ChildrenAttr< ::PICML::Event>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Event, Pred> Event_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Event, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ValueObject> ValueObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::ValueObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ValueObject, Pred> ValueObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ValueObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::HasOperations> HasOperations_kind_children() const { return Udm::ChildrenAttr< ::PICML::HasOperations>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::HasOperations, Pred> HasOperations_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::HasOperations, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ObjectByValue> ObjectByValue_kind_children() const { return Udm::ChildrenAttr< ::PICML::ObjectByValue>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ObjectByValue, Pred> ObjectByValue_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ObjectByValue, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Inheritable> Inheritable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Inheritable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Inheritable, Pred> Inheritable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Inheritable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Aggregate> Aggregate_kind_children() const { return Udm::ChildrenAttr< ::PICML::Aggregate>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Aggregate, Pred> Aggregate_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Aggregate, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::SwitchedAggregate> SwitchedAggregate_kind_children() const { return Udm::ChildrenAttr< ::PICML::SwitchedAggregate>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SwitchedAggregate, Pred> SwitchedAggregate_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SwitchedAggregate, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MemberType> MemberType_kind_children() const { return Udm::ChildrenAttr< ::PICML::MemberType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MemberType, Pred> MemberType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MemberType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Alias> Alias_kind_children() const { return Udm::ChildrenAttr< ::PICML::Alias>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Alias, Pred> Alias_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Alias, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Boxed> Boxed_kind_children() const { return Udm::ChildrenAttr< ::PICML::Boxed>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Boxed, Pred> Boxed_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Boxed, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::NoInheritable> NoInheritable_kind_children() const { return Udm::ChildrenAttr< ::PICML::NoInheritable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::NoInheritable, Pred> NoInheritable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::NoInheritable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Collection> Collection_kind_children() const { return Udm::ChildrenAttr< ::PICML::Collection>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Collection, Pred> Collection_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Collection, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Enum> Enum_kind_children() const { return Udm::ChildrenAttr< ::PICML::Enum>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Enum, Pred> Enum_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Enum, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::NamedType> NamedType_kind_children() const { return Udm::ChildrenAttr< ::PICML::NamedType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::NamedType, Pred> NamedType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::NamedType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Package> Package_kind_children() const { return Udm::ChildrenAttr< ::PICML::Package>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Package, Pred> Package_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Package, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Exception> Exception_kind_children() const { return Udm::ChildrenAttr< ::PICML::Exception>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Exception, Pred> Exception_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Exception, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Constant> Constant_kind_children() const { return Udm::ChildrenAttr< ::PICML::Constant>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Constant, Pred> Constant_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Constant, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::FileRef> FileRef_kind_children() const { return Udm::ChildrenAttr< ::PICML::FileRef>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::FileRef, Pred> FileRef_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::FileRef, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::InterfaceDefinitions> InterfaceDefinitions_parent() const { return Udm::ParentAttr< ::PICML::InterfaceDefinitions>(impl, meta_InterfaceDefinitions_parent); }
		Udm::ParentAttr< ::PICML::InterfaceDefinitions> parent() const { return Udm::ParentAttr< ::PICML::InterfaceDefinitions>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_File(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_path;
		static ::Uml::AssociationRole meta_referedbyFileRef;
		static ::Uml::CompositionChildRole meta_ManagesComponent_children;
		static ::Uml::CompositionChildRole meta_ComponentRef_children;
		static ::Uml::CompositionChildRole meta_Package_children;
		static ::Uml::CompositionChildRole meta_Exception_children;
		static ::Uml::CompositionChildRole meta_FileRef_children;
		static ::Uml::CompositionChildRole meta_Constant_children;
		static ::Uml::CompositionChildRole meta_NamedType_children;
		static ::Uml::CompositionParentRole meta_InterfaceDefinitions_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_InterfaceDefinitions_parent {};
		typedef boost::mpl::pair< ::PICML::InterfaceDefinitions, PR_InterfaceDefinitions_parent > _PR_InterfaceDefinitions_parent__InterfaceDefinitions;
		typedef boost::mpl::vector< _PR_InterfaceDefinitions_parent__InterfaceDefinitions> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::InterfaceDefinitions> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ManagesComponent_children {};
		class CR_ComponentRef_children {};
		class CR_Package_children {};
		class CR_Exception_children {};
		class CR_FileRef_children {};
		class CR_Constant_children {};
		class CR_NamedType_children {};
		typedef boost::mpl::pair< ::PICML::ManagesComponent, CR_ManagesComponent_children > _CR_ManagesComponent_children__ManagesComponent;
		typedef boost::mpl::pair< ::PICML::ComponentRef, CR_ComponentRef_children > _CR_ComponentRef_children__ComponentRef;
		typedef boost::mpl::pair< ::PICML::Package, CR_Package_children > _CR_Package_children__Package;
		typedef boost::mpl::pair< ::PICML::Exception, CR_Exception_children > _CR_Exception_children__Exception;
		typedef boost::mpl::pair< ::PICML::FileRef, CR_FileRef_children > _CR_FileRef_children__FileRef;
		typedef boost::mpl::pair< ::PICML::Constant, CR_Constant_children > _CR_Constant_children__Constant;
		typedef boost::mpl::pair< ::PICML::NamedType, CR_NamedType_children > _CR_NamedType_children__NamedType;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_ManagesComponent_children__ManagesComponent, _CR_ComponentRef_children__ComponentRef, _CR_Package_children__Package, _CR_Exception_children__Exception, _CR_FileRef_children__FileRef, _CR_Constant_children__Constant, _CR_NamedType_children__NamedType> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentFactory, ::PICML::ComponentRef, ::PICML::ManagesComponent, ::PICML::Component, ::PICML::Object, ::PICML::Event, ::PICML::ValueObject, ::PICML::ObjectByValue, ::PICML::HasOperations, ::PICML::Inheritable, ::PICML::Aggregate, ::PICML::SwitchedAggregate, ::PICML::Alias, ::PICML::Boxed, ::PICML::Collection, ::PICML::Enum, ::PICML::NoInheritable, ::PICML::NamedType, ::PICML::Package, ::PICML::Exception, ::PICML::Constant, ::PICML::FileRef> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyFileRef {};
		typedef boost::mpl::pair< ::PICML::FileRef, AR_referedbyFileRef > _AR_referedbyFileRef__FileRef;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyFileRef__FileRef> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Exception :  public Taggable {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Exception() {}
		Exception(Udm::ObjectImpl *impl) : Taggable(impl), MgaObject(impl) {}
		Exception(const Exception &master) : Taggable(master), MgaObject(master) {}

		static Exception Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Exception Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Exception CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Exception> Instances() { return Udm::InstantiatedAttr<Exception>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Exception, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Exception, Pred>(impl); }
		Exception CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Exception> Derived() { return Udm::DerivedAttr<Exception>(impl); }
		template <class Pred> Udm::DerivedAttr<Exception, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Exception, Pred>(impl); }
		Udm::ArchetypeAttr<Exception> Archetype() const { return Udm::ArchetypeAttr<Exception>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::SetException> referedbySetException() const { return Udm::AssocAttr< ::PICML::SetException>(impl, meta_referedbySetException); }
		template <class Pred> Udm::AssocAttr< ::PICML::SetException, Pred> referedbySetException_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::SetException, Pred>(impl, meta_referedbySetException); }
		Udm::AssocAttr< ::PICML::GetException> referedbyGetException() const { return Udm::AssocAttr< ::PICML::GetException>(impl, meta_referedbyGetException); }
		template <class Pred> Udm::AssocAttr< ::PICML::GetException, Pred> referedbyGetException_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::GetException, Pred>(impl, meta_referedbyGetException); }
		Udm::AssocAttr< ::PICML::ExceptionRef> referedbyExceptionRef() const { return Udm::AssocAttr< ::PICML::ExceptionRef>(impl, meta_referedbyExceptionRef); }
		template <class Pred> Udm::AssocAttr< ::PICML::ExceptionRef, Pred> referedbyExceptionRef_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::ExceptionRef, Pred>(impl, meta_referedbyExceptionRef); }
		Udm::ChildrenAttr< ::PICML::Member> Member_children() const { return Udm::ChildrenAttr< ::PICML::Member>(impl, meta_Member_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Member, Pred> Member_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Member, Pred>(impl, meta_Member_children); }
		Udm::ChildrenAttr< ::PICML::Member> Member_kind_children() const { return Udm::ChildrenAttr< ::PICML::Member>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Member, Pred> Member_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Member, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::HasOperations> HasOperations_parent() const { return Udm::ParentAttr< ::PICML::HasOperations>(impl, meta_HasOperations_parent); }
		Udm::ParentAttr< ::PICML::Package> Package_parent() const { return Udm::ParentAttr< ::PICML::Package>(impl, meta_Package_parent); }
		Udm::ParentAttr< ::PICML::File> File_parent() const { return Udm::ParentAttr< ::PICML::File>(impl, meta_File_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Exception(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbySetException;
		static ::Uml::AssociationRole meta_referedbyGetException;
		static ::Uml::AssociationRole meta_referedbyExceptionRef;
		static ::Uml::CompositionChildRole meta_Member_children;
		static ::Uml::CompositionParentRole meta_HasOperations_parent;
		static ::Uml::CompositionParentRole meta_Package_parent;
		static ::Uml::CompositionParentRole meta_File_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_HasOperations_parent {};
		class PR_Package_parent {};
		class PR_File_parent {};
		typedef boost::mpl::pair< ::PICML::HasOperations, PR_HasOperations_parent > _PR_HasOperations_parent__HasOperations;
		typedef boost::mpl::pair< ::PICML::Package, PR_Package_parent > _PR_Package_parent__Package;
		typedef boost::mpl::pair< ::PICML::File, PR_File_parent > _PR_File_parent__File;
		typedef boost::mpl::vector< _PR_HasOperations_parent__HasOperations, _PR_Package_parent__Package, _PR_File_parent__File> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::HasOperations, ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Member_children {};
		typedef boost::mpl::pair< ::PICML::Member, CR_Member_children > _CR_Member_children__Member;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Member_children__Member> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Member> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbySetException {};
		class AR_referedbyGetException {};
		class AR_referedbyExceptionRef {};
		typedef boost::mpl::pair< ::PICML::SetException, AR_referedbySetException > _AR_referedbySetException__SetException;
		typedef boost::mpl::pair< ::PICML::GetException, AR_referedbyGetException > _AR_referedbyGetException__GetException;
		typedef boost::mpl::pair< ::PICML::ExceptionRef, AR_referedbyExceptionRef > _AR_referedbyExceptionRef__ExceptionRef;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbySetException__SetException, _AR_referedbyGetException__GetException, _AR_referedbyExceptionRef__ExceptionRef> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ExceptionRef :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		ExceptionRef() {}
		ExceptionRef(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ExceptionRef(const ExceptionRef &master) : MgaObject(master) {}

		static ExceptionRef Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ExceptionRef Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ExceptionRef CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ExceptionRef> Instances() { return Udm::InstantiatedAttr<ExceptionRef>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ExceptionRef, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ExceptionRef, Pred>(impl); }
		ExceptionRef CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ExceptionRef> Derived() { return Udm::DerivedAttr<ExceptionRef>(impl); }
		template <class Pred> Udm::DerivedAttr<ExceptionRef, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ExceptionRef, Pred>(impl); }
		Udm::ArchetypeAttr<ExceptionRef> Archetype() const { return Udm::ArchetypeAttr<ExceptionRef>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::Exception> ref() const { return Udm::PointerAttr< ::PICML::Exception>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::HasExceptions> HasExceptions_parent() const { return Udm::ParentAttr< ::PICML::HasExceptions>(impl, meta_HasExceptions_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ExceptionRef(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_HasExceptions_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_HasExceptions_parent {};
		typedef boost::mpl::pair< ::PICML::HasExceptions, PR_HasExceptions_parent > _PR_HasExceptions_parent__HasExceptions;
		typedef boost::mpl::vector< _PR_HasExceptions_parent__HasExceptions> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::HasExceptions> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::Exception, AR_ref > _AR_ref__Exception;
		typedef boost::mpl::vector< _AR_ref__Exception> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ConstantType :  virtual  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		ConstantType() {}
		ConstantType(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ConstantType(const ConstantType &master) : MgaObject(master) {}

		static ConstantType Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ConstantType Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ConstantType CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ConstantType> Instances() { return Udm::InstantiatedAttr<ConstantType>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ConstantType, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ConstantType, Pred>(impl); }
		ConstantType CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ConstantType> Derived() { return Udm::DerivedAttr<ConstantType>(impl); }
		template <class Pred> Udm::DerivedAttr<ConstantType, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ConstantType, Pred>(impl); }
		Udm::ArchetypeAttr<ConstantType> Archetype() const { return Udm::ArchetypeAttr<ConstantType>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::Discriminator> referedbyDiscriminator() const { return Udm::AssocAttr< ::PICML::Discriminator>(impl, meta_referedbyDiscriminator); }
		template <class Pred> Udm::AssocAttr< ::PICML::Discriminator, Pred> referedbyDiscriminator_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::Discriminator, Pred>(impl, meta_referedbyDiscriminator); }
		Udm::AssocAttr< ::PICML::Constant> referedbyConstant() const { return Udm::AssocAttr< ::PICML::Constant>(impl, meta_referedbyConstant); }
		template <class Pred> Udm::AssocAttr< ::PICML::Constant, Pred> referedbyConstant_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::Constant, Pred>(impl, meta_referedbyConstant); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyDiscriminator;
		static ::Uml::AssociationRole meta_referedbyConstant;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyDiscriminator {};
		class AR_referedbyConstant {};
		typedef boost::mpl::pair< ::PICML::Discriminator, AR_referedbyDiscriminator > _AR_referedbyDiscriminator__Discriminator;
		typedef boost::mpl::pair< ::PICML::Constant, AR_referedbyConstant > _AR_referedbyConstant__Constant;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyDiscriminator__Discriminator, _AR_referedbyConstant__Constant> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Enum :  public NoInheritable,  public ConstantType {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Enum() {}
		Enum(Udm::ObjectImpl *impl) : NoInheritable(impl),ConstantType(impl), MgaObject(impl) {}
		Enum(const Enum &master) : NoInheritable(master),ConstantType(master), MgaObject(master) {}

		static Enum Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Enum Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Enum CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Enum> Instances() { return Udm::InstantiatedAttr<Enum>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Enum, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Enum, Pred>(impl); }
		Enum CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Enum> Derived() { return Udm::DerivedAttr<Enum>(impl); }
		template <class Pred> Udm::DerivedAttr<Enum, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Enum, Pred>(impl); }
		Udm::ArchetypeAttr<Enum> Archetype() const { return Udm::ArchetypeAttr<Enum>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::EnumValue> EnumValue_children() const { return Udm::ChildrenAttr< ::PICML::EnumValue>(impl, meta_EnumValue_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::EnumValue, Pred> EnumValue_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::EnumValue, Pred>(impl, meta_EnumValue_children); }
		Udm::ChildrenAttr< ::PICML::EnumValue> EnumValue_kind_children() const { return Udm::ChildrenAttr< ::PICML::EnumValue>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::EnumValue, Pred> EnumValue_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::EnumValue, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Enum(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_EnumValue_children;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::HasOperations, ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_EnumValue_children {};
		typedef boost::mpl::pair< ::PICML::EnumValue, CR_EnumValue_children > _CR_EnumValue_children__EnumValue;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_EnumValue_children__EnumValue> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::EnumValue> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PredefinedType :  public MemberType,  public ConstantType {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		PredefinedType() {}
		PredefinedType(Udm::ObjectImpl *impl) : MemberType(impl),ConstantType(impl), MgaObject(impl) {}
		PredefinedType(const PredefinedType &master) : MemberType(master),ConstantType(master), MgaObject(master) {}

		static PredefinedType Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PredefinedType Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PredefinedType CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PredefinedType> Instances() { return Udm::InstantiatedAttr<PredefinedType>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PredefinedType, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PredefinedType, Pred>(impl); }
		PredefinedType CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PredefinedType> Derived() { return Udm::DerivedAttr<PredefinedType>(impl); }
		template <class Pred> Udm::DerivedAttr<PredefinedType, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PredefinedType, Pred>(impl); }
		Udm::ArchetypeAttr<PredefinedType> Archetype() const { return Udm::ArchetypeAttr<PredefinedType>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::Variable> referedbyVariable() const { return Udm::AssocAttr< ::PICML::Variable>(impl, meta_referedbyVariable); }
		template <class Pred> Udm::AssocAttr< ::PICML::Variable, Pred> referedbyVariable_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::Variable, Pred>(impl, meta_referedbyVariable); }
		Udm::ParentAttr< ::PICML::PredefinedTypes> PredefinedTypes_parent() const { return Udm::ParentAttr< ::PICML::PredefinedTypes>(impl, meta_PredefinedTypes_parent); }
		Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const { return Udm::ParentAttr< ::PICML::PredefinedTypes>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyVariable;
		static ::Uml::CompositionParentRole meta_PredefinedTypes_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_PredefinedTypes_parent {};
		typedef boost::mpl::pair< ::PICML::PredefinedTypes, PR_PredefinedTypes_parent > _PR_PredefinedTypes_parent__PredefinedTypes;
		typedef boost::mpl::vector< _PR_PredefinedTypes_parent__PredefinedTypes> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PredefinedTypes> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyVariable {};
		typedef boost::mpl::pair< ::PICML::Variable, AR_referedbyVariable > _AR_referedbyVariable__Variable;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyVariable__Variable> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Byte :  public PredefinedType {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		Byte() {}
		Byte(Udm::ObjectImpl *impl) : PredefinedType(impl), MgaObject(impl) {}
		Byte(const Byte &master) : PredefinedType(master), MgaObject(master) {}

		static Byte Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Byte Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Byte CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Byte> Instances() { return Udm::InstantiatedAttr<Byte>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Byte, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Byte, Pred>(impl); }
		Byte CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Byte> Derived() { return Udm::DerivedAttr<Byte>(impl); }
		template <class Pred> Udm::DerivedAttr<Byte, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Byte, Pred>(impl); }
		Udm::ArchetypeAttr<Byte> Archetype() const { return Udm::ArchetypeAttr<Byte>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const { return Udm::ParentAttr< ::PICML::PredefinedTypes>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Byte(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PredefinedTypes> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Boolean :  public PredefinedType {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		Boolean() {}
		Boolean(Udm::ObjectImpl *impl) : PredefinedType(impl), MgaObject(impl) {}
		Boolean(const Boolean &master) : PredefinedType(master), MgaObject(master) {}

		static Boolean Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Boolean Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Boolean CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Boolean> Instances() { return Udm::InstantiatedAttr<Boolean>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Boolean, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Boolean, Pred>(impl); }
		Boolean CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Boolean> Derived() { return Udm::DerivedAttr<Boolean>(impl); }
		template <class Pred> Udm::DerivedAttr<Boolean, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Boolean, Pred>(impl); }
		Udm::ArchetypeAttr<Boolean> Archetype() const { return Udm::ArchetypeAttr<Boolean>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const { return Udm::ParentAttr< ::PICML::PredefinedTypes>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Boolean(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PredefinedTypes> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ShortInteger :  public PredefinedType {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		ShortInteger() {}
		ShortInteger(Udm::ObjectImpl *impl) : PredefinedType(impl), MgaObject(impl) {}
		ShortInteger(const ShortInteger &master) : PredefinedType(master), MgaObject(master) {}

		static ShortInteger Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ShortInteger Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ShortInteger CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ShortInteger> Instances() { return Udm::InstantiatedAttr<ShortInteger>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ShortInteger, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ShortInteger, Pred>(impl); }
		ShortInteger CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ShortInteger> Derived() { return Udm::DerivedAttr<ShortInteger>(impl); }
		template <class Pred> Udm::DerivedAttr<ShortInteger, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ShortInteger, Pred>(impl); }
		Udm::ArchetypeAttr<ShortInteger> Archetype() const { return Udm::ArchetypeAttr<ShortInteger>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const { return Udm::ParentAttr< ::PICML::PredefinedTypes>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ShortInteger(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PredefinedTypes> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export LongInteger :  public PredefinedType {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		LongInteger() {}
		LongInteger(Udm::ObjectImpl *impl) : PredefinedType(impl), MgaObject(impl) {}
		LongInteger(const LongInteger &master) : PredefinedType(master), MgaObject(master) {}

		static LongInteger Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static LongInteger Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		LongInteger CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<LongInteger> Instances() { return Udm::InstantiatedAttr<LongInteger>(impl); }
		template <class Pred> Udm::InstantiatedAttr<LongInteger, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<LongInteger, Pred>(impl); }
		LongInteger CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<LongInteger> Derived() { return Udm::DerivedAttr<LongInteger>(impl); }
		template <class Pred> Udm::DerivedAttr<LongInteger, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<LongInteger, Pred>(impl); }
		Udm::ArchetypeAttr<LongInteger> Archetype() const { return Udm::ArchetypeAttr<LongInteger>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const { return Udm::ParentAttr< ::PICML::PredefinedTypes>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_LongInteger(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PredefinedTypes> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export RealNumber :  public PredefinedType {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		RealNumber() {}
		RealNumber(Udm::ObjectImpl *impl) : PredefinedType(impl), MgaObject(impl) {}
		RealNumber(const RealNumber &master) : PredefinedType(master), MgaObject(master) {}

		static RealNumber Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static RealNumber Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		RealNumber CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<RealNumber> Instances() { return Udm::InstantiatedAttr<RealNumber>(impl); }
		template <class Pred> Udm::InstantiatedAttr<RealNumber, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<RealNumber, Pred>(impl); }
		RealNumber CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<RealNumber> Derived() { return Udm::DerivedAttr<RealNumber>(impl); }
		template <class Pred> Udm::DerivedAttr<RealNumber, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<RealNumber, Pred>(impl); }
		Udm::ArchetypeAttr<RealNumber> Archetype() const { return Udm::ArchetypeAttr<RealNumber>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const { return Udm::ParentAttr< ::PICML::PredefinedTypes>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_RealNumber(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PredefinedTypes> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export String :  public PredefinedType {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		String() {}
		String(Udm::ObjectImpl *impl) : PredefinedType(impl), MgaObject(impl) {}
		String(const String &master) : PredefinedType(master), MgaObject(master) {}

		static String Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static String Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		String CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<String> Instances() { return Udm::InstantiatedAttr<String>(impl); }
		template <class Pred> Udm::InstantiatedAttr<String, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<String, Pred>(impl); }
		String CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<String> Derived() { return Udm::DerivedAttr<String>(impl); }
		template <class Pred> Udm::DerivedAttr<String, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<String, Pred>(impl); }
		Udm::ArchetypeAttr<String> Archetype() const { return Udm::ArchetypeAttr<String>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const { return Udm::ParentAttr< ::PICML::PredefinedTypes>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_String(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PredefinedTypes> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export GenericObject :  public Provideable,  public PredefinedType {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		GenericObject() {}
		GenericObject(Udm::ObjectImpl *impl) : Provideable(impl),PredefinedType(impl), MgaObject(impl) {}
		GenericObject(const GenericObject &master) : Provideable(master),PredefinedType(master), MgaObject(master) {}

		static GenericObject Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static GenericObject Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		GenericObject CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<GenericObject> Instances() { return Udm::InstantiatedAttr<GenericObject>(impl); }
		template <class Pred> Udm::InstantiatedAttr<GenericObject, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<GenericObject, Pred>(impl); }
		GenericObject CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<GenericObject> Derived() { return Udm::DerivedAttr<GenericObject>(impl); }
		template <class Pred> Udm::DerivedAttr<GenericObject, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<GenericObject, Pred>(impl); }
		Udm::ArchetypeAttr<GenericObject> Archetype() const { return Udm::ArchetypeAttr<GenericObject>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const { return Udm::ParentAttr< ::PICML::PredefinedTypes>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_GenericObject(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PredefinedTypes> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export GenericValueObject :  public PredefinedType {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		GenericValueObject() {}
		GenericValueObject(Udm::ObjectImpl *impl) : PredefinedType(impl), MgaObject(impl) {}
		GenericValueObject(const GenericValueObject &master) : PredefinedType(master), MgaObject(master) {}

		static GenericValueObject Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static GenericValueObject Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		GenericValueObject CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<GenericValueObject> Instances() { return Udm::InstantiatedAttr<GenericValueObject>(impl); }
		template <class Pred> Udm::InstantiatedAttr<GenericValueObject, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<GenericValueObject, Pred>(impl); }
		GenericValueObject CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<GenericValueObject> Derived() { return Udm::DerivedAttr<GenericValueObject>(impl); }
		template <class Pred> Udm::DerivedAttr<GenericValueObject, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<GenericValueObject, Pred>(impl); }
		Udm::ArchetypeAttr<GenericValueObject> Archetype() const { return Udm::ArchetypeAttr<GenericValueObject>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const { return Udm::ParentAttr< ::PICML::PredefinedTypes>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_GenericValueObject(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PredefinedTypes> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export GenericValue :  public PredefinedType {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		GenericValue() {}
		GenericValue(Udm::ObjectImpl *impl) : PredefinedType(impl), MgaObject(impl) {}
		GenericValue(const GenericValue &master) : PredefinedType(master), MgaObject(master) {}

		static GenericValue Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static GenericValue Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		GenericValue CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<GenericValue> Instances() { return Udm::InstantiatedAttr<GenericValue>(impl); }
		template <class Pred> Udm::InstantiatedAttr<GenericValue, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<GenericValue, Pred>(impl); }
		GenericValue CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<GenericValue> Derived() { return Udm::DerivedAttr<GenericValue>(impl); }
		template <class Pred> Udm::DerivedAttr<GenericValue, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<GenericValue, Pred>(impl); }
		Udm::ArchetypeAttr<GenericValue> Archetype() const { return Udm::ArchetypeAttr<GenericValue>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const { return Udm::ParentAttr< ::PICML::PredefinedTypes>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_GenericValue(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PredefinedTypes> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export TypeEncoding :  public PredefinedType {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		TypeEncoding() {}
		TypeEncoding(Udm::ObjectImpl *impl) : PredefinedType(impl), MgaObject(impl) {}
		TypeEncoding(const TypeEncoding &master) : PredefinedType(master), MgaObject(master) {}

		static TypeEncoding Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static TypeEncoding Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		TypeEncoding CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<TypeEncoding> Instances() { return Udm::InstantiatedAttr<TypeEncoding>(impl); }
		template <class Pred> Udm::InstantiatedAttr<TypeEncoding, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<TypeEncoding, Pred>(impl); }
		TypeEncoding CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<TypeEncoding> Derived() { return Udm::DerivedAttr<TypeEncoding>(impl); }
		template <class Pred> Udm::DerivedAttr<TypeEncoding, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<TypeEncoding, Pred>(impl); }
		Udm::ArchetypeAttr<TypeEncoding> Archetype() const { return Udm::ArchetypeAttr<TypeEncoding>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const { return Udm::ParentAttr< ::PICML::PredefinedTypes>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_TypeEncoding(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PredefinedTypes> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export TypeKind :  public PredefinedType {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		TypeKind() {}
		TypeKind(Udm::ObjectImpl *impl) : PredefinedType(impl), MgaObject(impl) {}
		TypeKind(const TypeKind &master) : PredefinedType(master), MgaObject(master) {}

		static TypeKind Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static TypeKind Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		TypeKind CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<TypeKind> Instances() { return Udm::InstantiatedAttr<TypeKind>(impl); }
		template <class Pred> Udm::InstantiatedAttr<TypeKind, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<TypeKind, Pred>(impl); }
		TypeKind CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<TypeKind> Derived() { return Udm::DerivedAttr<TypeKind>(impl); }
		template <class Pred> Udm::DerivedAttr<TypeKind, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<TypeKind, Pred>(impl); }
		Udm::ArchetypeAttr<TypeKind> Archetype() const { return Udm::ArchetypeAttr<TypeKind>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const { return Udm::ParentAttr< ::PICML::PredefinedTypes>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_TypeKind(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::PredefinedTypes> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Constant :  public Taggable {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		Constant() {}
		Constant(Udm::ObjectImpl *impl) : Taggable(impl), MgaObject(impl) {}
		Constant(const Constant &master) : Taggable(master), MgaObject(master) {}

		static Constant Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Constant Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Constant CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Constant> Instances() { return Udm::InstantiatedAttr<Constant>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Constant, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Constant, Pred>(impl); }
		Constant CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Constant> Derived() { return Udm::DerivedAttr<Constant>(impl); }
		template <class Pred> Udm::DerivedAttr<Constant, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Constant, Pred>(impl); }
		Udm::ArchetypeAttr<Constant> Archetype() const { return Udm::ArchetypeAttr<Constant>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr value() const { return Udm::StringAttr(impl, meta_value); }
		Udm::PointerAttr< ::PICML::ConstantType> ref() const { return Udm::PointerAttr< ::PICML::ConstantType>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::HasOperations> HasOperations_parent() const { return Udm::ParentAttr< ::PICML::HasOperations>(impl, meta_HasOperations_parent); }
		Udm::ParentAttr< ::PICML::Package> Package_parent() const { return Udm::ParentAttr< ::PICML::Package>(impl, meta_Package_parent); }
		Udm::ParentAttr< ::PICML::File> File_parent() const { return Udm::ParentAttr< ::PICML::File>(impl, meta_File_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Constant(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_value;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_HasOperations_parent;
		static ::Uml::CompositionParentRole meta_Package_parent;
		static ::Uml::CompositionParentRole meta_File_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_HasOperations_parent {};
		class PR_Package_parent {};
		class PR_File_parent {};
		typedef boost::mpl::pair< ::PICML::HasOperations, PR_HasOperations_parent > _PR_HasOperations_parent__HasOperations;
		typedef boost::mpl::pair< ::PICML::Package, PR_Package_parent > _PR_Package_parent__Package;
		typedef boost::mpl::pair< ::PICML::File, PR_File_parent > _PR_File_parent__File;
		typedef boost::mpl::vector< _PR_HasOperations_parent__HasOperations, _PR_Package_parent__Package, _PR_File_parent__File> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::HasOperations, ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::ConstantType, AR_ref > _AR_ref__ConstantType;
		typedef boost::mpl::vector< _AR_ref__ConstantType> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export FileRef :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		FileRef() {}
		FileRef(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		FileRef(const FileRef &master) : MgaObject(master) {}

		static FileRef Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static FileRef Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		FileRef CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<FileRef> Instances() { return Udm::InstantiatedAttr<FileRef>(impl); }
		template <class Pred> Udm::InstantiatedAttr<FileRef, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<FileRef, Pred>(impl); }
		FileRef CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<FileRef> Derived() { return Udm::DerivedAttr<FileRef>(impl); }
		template <class Pred> Udm::DerivedAttr<FileRef, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<FileRef, Pred>(impl); }
		Udm::ArchetypeAttr<FileRef> Archetype() const { return Udm::ArchetypeAttr<FileRef>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::File> ref() const { return Udm::PointerAttr< ::PICML::File>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::File> File_parent() const { return Udm::ParentAttr< ::PICML::File>(impl, meta_File_parent); }
		Udm::ParentAttr< ::PICML::StubProject> StubProject_parent() const { return Udm::ParentAttr< ::PICML::StubProject>(impl, meta_StubProject_parent); }
		Udm::ParentAttr< ::PICML::ServantProject> ServantProject_parent() const { return Udm::ParentAttr< ::PICML::ServantProject>(impl, meta_ServantProject_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_FileRef(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_File_parent;
		static ::Uml::CompositionParentRole meta_StubProject_parent;
		static ::Uml::CompositionParentRole meta_ServantProject_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_File_parent {};
		class PR_StubProject_parent {};
		class PR_ServantProject_parent {};
		typedef boost::mpl::pair< ::PICML::File, PR_File_parent > _PR_File_parent__File;
		typedef boost::mpl::pair< ::PICML::StubProject, PR_StubProject_parent > _PR_StubProject_parent__StubProject;
		typedef boost::mpl::pair< ::PICML::ServantProject, PR_ServantProject_parent > _PR_ServantProject_parent__ServantProject;
		typedef boost::mpl::vector< _PR_File_parent__File, _PR_StubProject_parent__StubProject, _PR_ServantProject_parent__ServantProject> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::File, ::PICML::StubProject, ::PICML::ServantProject> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::File, AR_ref > _AR_ref__File;
		typedef boost::mpl::vector< _AR_ref__File> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Project :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Project() {}
		Project(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Project(const Project &master) : MgaObject(master) {}

		static Project Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Project Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Project CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Project> Instances() { return Udm::InstantiatedAttr<Project>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Project, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Project, Pred>(impl); }
		Project CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Project> Derived() { return Udm::DerivedAttr<Project>(impl); }
		template <class Pred> Udm::DerivedAttr<Project, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Project, Pred>(impl); }
		Udm::ArchetypeAttr<Project> Archetype() const { return Udm::ArchetypeAttr<Project>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::Workspaces> setWorkspace() const { return Udm::AssocAttr< ::PICML::Workspaces>(impl, meta_setWorkspace); }
		template <class Pred> Udm::AssocAttr< ::PICML::Workspaces, Pred> setWorkspace_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::Workspaces, Pred>(impl, meta_setWorkspace); }
		Udm::ChildrenAttr< ::PICML::ExtResourceConn> ExtResourceConn_children() const { return Udm::ChildrenAttr< ::PICML::ExtResourceConn>(impl, meta_ExtResourceConn_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ExtResourceConn, Pred> ExtResourceConn_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ExtResourceConn, Pred>(impl, meta_ExtResourceConn_children); }
		Udm::ChildrenAttr< ::PICML::ExternalResources> ExternalResources_children() const { return Udm::ChildrenAttr< ::PICML::ExternalResources>(impl, meta_ExternalResources_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ExternalResources, Pred> ExternalResources_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ExternalResources, Pred>(impl, meta_ExternalResources_children); }
		Udm::ChildrenAttr< ::PICML::ComponentLib> ComponentLib_children() const { return Udm::ChildrenAttr< ::PICML::ComponentLib>(impl, meta_ComponentLib_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentLib, Pred> ComponentLib_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentLib, Pred>(impl, meta_ComponentLib_children); }
		Udm::ChildrenAttr< ::PICML::ImplementationArtifact> ImplementationArtifact_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifact>(impl, meta_ImplementationArtifact_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationArtifact, Pred> ImplementationArtifact_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifact, Pred>(impl, meta_ImplementationArtifact_children); }
		Udm::ChildrenAttr< ::PICML::ImplementationArtifact> ImplementationArtifact_kind_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifact>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationArtifact, Pred> ImplementationArtifact_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifact, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ExternalResources> ExternalResources_kind_children() const { return Udm::ChildrenAttr< ::PICML::ExternalResources>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ExternalResources, Pred> ExternalResources_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ExternalResources, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ExtResourceConn> ExtResourceConn_kind_children() const { return Udm::ChildrenAttr< ::PICML::ExtResourceConn>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ExtResourceConn, Pred> ExtResourceConn_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ExtResourceConn, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentLib> ComponentLib_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentLib>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentLib, Pred> ComponentLib_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentLib, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::StubProject> StubProject_kind_children() const { return Udm::ChildrenAttr< ::PICML::StubProject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::StubProject, Pred> StubProject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::StubProject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ServantProject> ServantProject_kind_children() const { return Udm::ChildrenAttr< ::PICML::ServantProject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ServantProject, Pred> ServantProject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ServantProject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ExecutorProject> ExecutorProject_kind_children() const { return Udm::ChildrenAttr< ::PICML::ExecutorProject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ExecutorProject, Pred> ExecutorProject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ExecutorProject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::MPC> MPC_parent() const { return Udm::ParentAttr< ::PICML::MPC>(impl, meta_MPC_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Project(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_setWorkspace;
		static ::Uml::CompositionChildRole meta_ExtResourceConn_children;
		static ::Uml::CompositionChildRole meta_ExternalResources_children;
		static ::Uml::CompositionChildRole meta_ComponentLib_children;
		static ::Uml::CompositionChildRole meta_ImplementationArtifact_children;
		static ::Uml::CompositionParentRole meta_MPC_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_MPC_parent {};
		typedef boost::mpl::pair< ::PICML::MPC, PR_MPC_parent > _PR_MPC_parent__MPC;
		typedef boost::mpl::vector< _PR_MPC_parent__MPC> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::MPC> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ExtResourceConn_children {};
		class CR_ExternalResources_children {};
		class CR_ComponentLib_children {};
		class CR_ImplementationArtifact_children {};
		typedef boost::mpl::pair< ::PICML::ExtResourceConn, CR_ExtResourceConn_children > _CR_ExtResourceConn_children__ExtResourceConn;
		typedef boost::mpl::pair< ::PICML::ExternalResources, CR_ExternalResources_children > _CR_ExternalResources_children__ExternalResources;
		typedef boost::mpl::pair< ::PICML::ComponentLib, CR_ComponentLib_children > _CR_ComponentLib_children__ComponentLib;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, CR_ImplementationArtifact_children > _CR_ImplementationArtifact_children__ImplementationArtifact;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_ExtResourceConn_children__ExtResourceConn, _CR_ExternalResources_children__ExternalResources, _CR_ComponentLib_children__ComponentLib, _CR_ImplementationArtifact_children__ImplementationArtifact> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ImplementationArtifact, ::PICML::ExternalResources, ::PICML::ExtResourceConn, ::PICML::StubProject, ::PICML::ServantProject, ::PICML::ExecutorProject, ::PICML::ComponentLib> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_setWorkspace {};
		typedef boost::mpl::pair< ::PICML::Workspaces, AR_setWorkspace > _AR_setWorkspace__Workspaces;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_setWorkspace__Workspaces> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ExternalResources :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		ExternalResources() {}
		ExternalResources(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ExternalResources(const ExternalResources &master) : MgaObject(master) {}

		static ExternalResources Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ExternalResources Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ExternalResources CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ExternalResources> Instances() { return Udm::InstantiatedAttr<ExternalResources>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ExternalResources, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ExternalResources, Pred>(impl); }
		ExternalResources CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ExternalResources> Derived() { return Udm::DerivedAttr<ExternalResources>(impl); }
		template <class Pred> Udm::DerivedAttr<ExternalResources, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ExternalResources, Pred>(impl); }
		Udm::ArchetypeAttr<ExternalResources> Archetype() const { return Udm::ArchetypeAttr<ExternalResources>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::ImplementationArtifact> ref() const { return Udm::PointerAttr< ::PICML::ImplementationArtifact>(impl, meta_ref); }
		Udm::AClassAssocAttr< ::PICML::ExtResourceConn, ::PICML::ComponentLib> srcExtResourceConn() const { return Udm::AClassAssocAttr< ::PICML::ExtResourceConn, ::PICML::ComponentLib>(impl, meta_srcExtResourceConn, meta_srcExtResourceConn_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ExtResourceConn, ::PICML::ComponentLib, Pred> srcExtResourceConn_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ExtResourceConn, ::PICML::ComponentLib, Pred>(impl, meta_srcExtResourceConn, meta_srcExtResourceConn_rev); }
		Udm::ParentAttr< ::PICML::Project> Project_parent() const { return Udm::ParentAttr< ::PICML::Project>(impl, meta_Project_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ExternalResources(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_srcExtResourceConn;
		static ::Uml::AssociationRole meta_srcExtResourceConn_rev;
		static ::Uml::CompositionParentRole meta_Project_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Project_parent {};
		typedef boost::mpl::pair< ::PICML::Project, PR_Project_parent > _PR_Project_parent__Project;
		typedef boost::mpl::vector< _PR_Project_parent__Project> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Project> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::ImplementationArtifact, AR_ref > _AR_ref__ImplementationArtifact;
		typedef boost::mpl::vector< _AR_ref__ImplementationArtifact> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcExtResourceConn {};
		typedef boost::mpl::pair< ::PICML::ComponentLib, boost::mpl::pair< ::PICML::ExtResourceConn, AR_srcExtResourceConn > > _AR_srcExtResourceConn__ExtResourceConn__ComponentLib;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcExtResourceConn__ExtResourceConn__ComponentLib> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ExtResourceConn :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		ExtResourceConn() {}
		ExtResourceConn(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ExtResourceConn(const ExtResourceConn &master) : MgaObject(master) {}

		static ExtResourceConn Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ExtResourceConn Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ExtResourceConn CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ExtResourceConn> Instances() { return Udm::InstantiatedAttr<ExtResourceConn>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ExtResourceConn, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ExtResourceConn, Pred>(impl); }
		ExtResourceConn CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ExtResourceConn> Derived() { return Udm::DerivedAttr<ExtResourceConn>(impl); }
		template <class Pred> Udm::DerivedAttr<ExtResourceConn, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ExtResourceConn, Pred>(impl); }
		Udm::ArchetypeAttr<ExtResourceConn> Archetype() const { return Udm::ArchetypeAttr<ExtResourceConn>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::Project> Project_parent() const { return Udm::ParentAttr< ::PICML::Project>(impl, meta_Project_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ExternalResources> dstExtResourceConn_end() const { return Udm::AssocEndAttr< ::PICML::ExternalResources>(impl, meta_dstExtResourceConn_end_); }
		Udm::AssocEndAttr< ::PICML::ComponentLib> srcExtResourceConn_end() const { return Udm::AssocEndAttr< ::PICML::ComponentLib>(impl, meta_srcExtResourceConn_end_); }
		void Accept(Visitor &v) { v.Visit_ExtResourceConn(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Project_parent;
		static ::Uml::AssociationRole meta_dstExtResourceConn_end_;
		static ::Uml::AssociationRole meta_srcExtResourceConn_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_Project_parent {};
		typedef boost::mpl::pair< ::PICML::Project, PR_Project_parent > _PR_Project_parent__Project;
		typedef boost::mpl::vector< _PR_Project_parent__Project> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Project> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstExtResourceConn {};
		class ACE_srcExtResourceConn {};
		typedef boost::mpl::pair< ::PICML::ExternalResources, ACE_dstExtResourceConn > _ACE_dstExtResourceConn__ExternalResources;
		typedef boost::mpl::pair< ::PICML::ComponentLib, ACE_srcExtResourceConn > _ACE_srcExtResourceConn__ComponentLib;
		typedef boost::mpl::vector< _ACE_dstExtResourceConn__ExternalResources, _ACE_srcExtResourceConn__ComponentLib> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ComponentLib :  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		ComponentLib() {}
		ComponentLib(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ComponentLib(const ComponentLib &master) : MgaObject(master) {}

		static ComponentLib Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ComponentLib Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ComponentLib CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ComponentLib> Instances() { return Udm::InstantiatedAttr<ComponentLib>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ComponentLib, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ComponentLib, Pred>(impl); }
		ComponentLib CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ComponentLib> Derived() { return Udm::DerivedAttr<ComponentLib>(impl); }
		template <class Pred> Udm::DerivedAttr<ComponentLib, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ComponentLib, Pred>(impl); }
		Udm::ArchetypeAttr<ComponentLib> Archetype() const { return Udm::ArchetypeAttr<ComponentLib>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr sharedname() const { return Udm::StringAttr(impl, meta_sharedname); }
		Udm::StringAttr libraryexport() const { return Udm::StringAttr(impl, meta_libraryexport); }
		Udm::StringAttr ORBServices() const { return Udm::StringAttr(impl, meta_ORBServices); }
		Udm::AClassAssocAttr< ::PICML::ExtResourceConn, ::PICML::ExternalResources> dstExtResourceConn() const { return Udm::AClassAssocAttr< ::PICML::ExtResourceConn, ::PICML::ExternalResources>(impl, meta_dstExtResourceConn, meta_dstExtResourceConn_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ExtResourceConn, ::PICML::ExternalResources, Pred> dstExtResourceConn_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ExtResourceConn, ::PICML::ExternalResources, Pred>(impl, meta_dstExtResourceConn, meta_dstExtResourceConn_rev); }
		Udm::ParentAttr< ::PICML::Project> Project_parent() const { return Udm::ParentAttr< ::PICML::Project>(impl, meta_Project_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_sharedname;
		static ::Uml::Attribute meta_libraryexport;
		static ::Uml::Attribute meta_ORBServices;
		static ::Uml::AssociationRole meta_dstExtResourceConn;
		static ::Uml::AssociationRole meta_dstExtResourceConn_rev;
		static ::Uml::CompositionParentRole meta_Project_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Project_parent {};
		typedef boost::mpl::pair< ::PICML::Project, PR_Project_parent > _PR_Project_parent__Project;
		typedef boost::mpl::vector< _PR_Project_parent__Project> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Project> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstExtResourceConn {};
		typedef boost::mpl::pair< ::PICML::ExternalResources, boost::mpl::pair< ::PICML::ExtResourceConn, AR_dstExtResourceConn > > _AR_dstExtResourceConn__ExtResourceConn__ExternalResources;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstExtResourceConn__ExtResourceConn__ExternalResources> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export MPC :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		MPC() {}
		MPC(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		MPC(const MPC &master) : MgaObject(master) {}

		static MPC Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static MPC Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		MPC CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<MPC> Instances() { return Udm::InstantiatedAttr<MPC>(impl); }
		template <class Pred> Udm::InstantiatedAttr<MPC, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<MPC, Pred>(impl); }
		MPC CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<MPC> Derived() { return Udm::DerivedAttr<MPC>(impl); }
		template <class Pred> Udm::DerivedAttr<MPC, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<MPC, Pred>(impl); }
		Udm::ArchetypeAttr<MPC> Archetype() const { return Udm::ArchetypeAttr<MPC>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::Project> Project_children() const { return Udm::ChildrenAttr< ::PICML::Project>(impl, meta_Project_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Project, Pred> Project_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Project, Pred>(impl, meta_Project_children); }
		Udm::ChildrenAttr< ::PICML::Workspaces> Workspaces_children() const { return Udm::ChildrenAttr< ::PICML::Workspaces>(impl, meta_Workspaces_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Workspaces, Pred> Workspaces_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Workspaces, Pred>(impl, meta_Workspaces_children); }
		Udm::ChildrenAttr< ::PICML::Project> Project_kind_children() const { return Udm::ChildrenAttr< ::PICML::Project>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Project, Pred> Project_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Project, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Workspaces> Workspaces_kind_children() const { return Udm::ChildrenAttr< ::PICML::Workspaces>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Workspaces, Pred> Workspaces_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Workspaces, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::ComponentBuild> ComponentBuild_parent() const { return Udm::ParentAttr< ::PICML::ComponentBuild>(impl, meta_ComponentBuild_parent); }
		Udm::ParentAttr< ::PICML::ComponentBuild> parent() const { return Udm::ParentAttr< ::PICML::ComponentBuild>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_MPC(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Project_children;
		static ::Uml::CompositionChildRole meta_Workspaces_children;
		static ::Uml::CompositionParentRole meta_ComponentBuild_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentBuild_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentBuild, PR_ComponentBuild_parent > _PR_ComponentBuild_parent__ComponentBuild;
		typedef boost::mpl::vector< _PR_ComponentBuild_parent__ComponentBuild> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentBuild> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Project_children {};
		class CR_Workspaces_children {};
		typedef boost::mpl::pair< ::PICML::Project, CR_Project_children > _CR_Project_children__Project;
		typedef boost::mpl::pair< ::PICML::Workspaces, CR_Workspaces_children > _CR_Workspaces_children__Workspaces;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Project_children__Project, _CR_Workspaces_children__Workspaces> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Project, ::PICML::Workspaces> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export StubProject :  public ComponentLib {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		StubProject() {}
		StubProject(Udm::ObjectImpl *impl) : ComponentLib(impl) {}
		StubProject(const StubProject &master) : ComponentLib(master) {}

		static StubProject Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static StubProject Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		StubProject CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<StubProject> Instances() { return Udm::InstantiatedAttr<StubProject>(impl); }
		template <class Pred> Udm::InstantiatedAttr<StubProject, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<StubProject, Pred>(impl); }
		StubProject CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<StubProject> Derived() { return Udm::DerivedAttr<StubProject>(impl); }
		template <class Pred> Udm::DerivedAttr<StubProject, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<StubProject, Pred>(impl); }
		Udm::ArchetypeAttr<StubProject> Archetype() const { return Udm::ArchetypeAttr<StubProject>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildAttr< ::PICML::FileRef> FileRef_child() const { return Udm::ChildAttr< ::PICML::FileRef>(impl, meta_FileRef_child); }
		Udm::ChildAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_child() const { return Udm::ChildAttr< ::PICML::ImplementationArtifactReference>(impl, meta_ImplementationArtifactReference_child); }
		Udm::ChildrenAttr< ::PICML::ComponentServantArtifact> ComponentServantArtifact_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentServantArtifact>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred> ComponentServantArtifact_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact> ComponentImplementationArtifact_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred> ComponentImplementationArtifact_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_kind_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred> ImplementationArtifactReference_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::FileRef> FileRef_kind_children() const { return Udm::ChildrenAttr< ::PICML::FileRef>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::FileRef, Pred> FileRef_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::FileRef, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_StubProject(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_FileRef_child;
		static ::Uml::CompositionChildRole meta_ImplementationArtifactReference_child;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Project> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_FileRef_child {};
		class CR_ImplementationArtifactReference_child {};
		typedef boost::mpl::pair< ::PICML::FileRef, CR_FileRef_child > _CR_FileRef_child__FileRef;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifactReference, CR_ImplementationArtifactReference_child > _CR_ImplementationArtifactReference_child__ImplementationArtifactReference;
		typedef boost::mpl::vector< _CR_FileRef_child__FileRef, _CR_ImplementationArtifactReference_child__ImplementationArtifactReference> ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentServantArtifact, ::PICML::ComponentImplementationArtifact, ::PICML::ImplementationArtifactReference, ::PICML::FileRef> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ServantProject :  public ComponentLib {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ServantProject() {}
		ServantProject(Udm::ObjectImpl *impl) : ComponentLib(impl) {}
		ServantProject(const ServantProject &master) : ComponentLib(master) {}

		static ServantProject Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ServantProject Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ServantProject CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ServantProject> Instances() { return Udm::InstantiatedAttr<ServantProject>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ServantProject, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ServantProject, Pred>(impl); }
		ServantProject CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ServantProject> Derived() { return Udm::DerivedAttr<ServantProject>(impl); }
		template <class Pred> Udm::DerivedAttr<ServantProject, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ServantProject, Pred>(impl); }
		Udm::ArchetypeAttr<ServantProject> Archetype() const { return Udm::ArchetypeAttr<ServantProject>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildAttr< ::PICML::FileRef> FileRef_child() const { return Udm::ChildAttr< ::PICML::FileRef>(impl, meta_FileRef_child); }
		Udm::ChildAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_child() const { return Udm::ChildAttr< ::PICML::ImplementationArtifactReference>(impl, meta_ImplementationArtifactReference_child); }
		Udm::ChildrenAttr< ::PICML::ComponentServantArtifact> ComponentServantArtifact_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentServantArtifact>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred> ComponentServantArtifact_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact> ComponentImplementationArtifact_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred> ComponentImplementationArtifact_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_kind_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred> ImplementationArtifactReference_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::FileRef> FileRef_kind_children() const { return Udm::ChildrenAttr< ::PICML::FileRef>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::FileRef, Pred> FileRef_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::FileRef, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ServantProject(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_FileRef_child;
		static ::Uml::CompositionChildRole meta_ImplementationArtifactReference_child;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Project> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_FileRef_child {};
		class CR_ImplementationArtifactReference_child {};
		typedef boost::mpl::pair< ::PICML::FileRef, CR_FileRef_child > _CR_FileRef_child__FileRef;
		typedef boost::mpl::pair< ::PICML::ImplementationArtifactReference, CR_ImplementationArtifactReference_child > _CR_ImplementationArtifactReference_child__ImplementationArtifactReference;
		typedef boost::mpl::vector< _CR_FileRef_child__FileRef, _CR_ImplementationArtifactReference_child__ImplementationArtifactReference> ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentServantArtifact, ::PICML::ComponentImplementationArtifact, ::PICML::ImplementationArtifactReference, ::PICML::FileRef> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ExecutorProject :  public ComponentLib {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ExecutorProject() {}
		ExecutorProject(Udm::ObjectImpl *impl) : ComponentLib(impl) {}
		ExecutorProject(const ExecutorProject &master) : ComponentLib(master) {}

		static ExecutorProject Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ExecutorProject Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ExecutorProject CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ExecutorProject> Instances() { return Udm::InstantiatedAttr<ExecutorProject>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ExecutorProject, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ExecutorProject, Pred>(impl); }
		ExecutorProject CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ExecutorProject> Derived() { return Udm::DerivedAttr<ExecutorProject>(impl); }
		template <class Pred> Udm::DerivedAttr<ExecutorProject, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ExecutorProject, Pred>(impl); }
		Udm::ArchetypeAttr<ExecutorProject> Archetype() const { return Udm::ArchetypeAttr<ExecutorProject>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_child() const { return Udm::ChildAttr< ::PICML::ImplementationArtifactReference>(impl, meta_ImplementationArtifactReference_child); }
		Udm::ChildrenAttr< ::PICML::ComponentServantArtifact> ComponentServantArtifact_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentServantArtifact>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred> ComponentServantArtifact_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact> ComponentImplementationArtifact_kind_children() const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred> ComponentImplementationArtifact_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_kind_children() const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred> ImplementationArtifactReference_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ExecutorProject(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_ImplementationArtifactReference_child;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Project> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ImplementationArtifactReference_child {};
		typedef boost::mpl::pair< ::PICML::ImplementationArtifactReference, CR_ImplementationArtifactReference_child > _CR_ImplementationArtifactReference_child__ImplementationArtifactReference;
		typedef boost::mpl::vector< _CR_ImplementationArtifactReference_child__ImplementationArtifactReference> ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentServantArtifact, ::PICML::ComponentImplementationArtifact, ::PICML::ImplementationArtifactReference> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Workspaces :  public MgaObject {
	public:
		typedef ::Udm::SetMetaTag MetaKind;

		Workspaces() {}
		Workspaces(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Workspaces(const Workspaces &master) : MgaObject(master) {}

		static Workspaces Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Workspaces Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Workspaces CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Workspaces> Instances() { return Udm::InstantiatedAttr<Workspaces>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Workspaces, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Workspaces, Pred>(impl); }
		Workspaces CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Workspaces> Derived() { return Udm::DerivedAttr<Workspaces>(impl); }
		template <class Pred> Udm::DerivedAttr<Workspaces, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Workspaces, Pred>(impl); }
		Udm::ArchetypeAttr<Workspaces> Archetype() const { return Udm::ArchetypeAttr<Workspaces>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AssocAttr< ::PICML::Project> members() const { return Udm::AssocAttr< ::PICML::Project>(impl, meta_members); }
		template <class Pred> Udm::AssocAttr< ::PICML::Project, Pred> members_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::Project, Pred>(impl, meta_members); }
		Udm::ParentAttr< ::PICML::MPC> MPC_parent() const { return Udm::ParentAttr< ::PICML::MPC>(impl, meta_MPC_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Workspaces(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_members;
		static ::Uml::CompositionParentRole meta_MPC_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_MPC_parent {};
		typedef boost::mpl::pair< ::PICML::MPC, PR_MPC_parent > _PR_MPC_parent__MPC;
		typedef boost::mpl::vector< _PR_MPC_parent__MPC> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::MPC> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_members {};
		typedef boost::mpl::pair< ::PICML::Project, AR_members > _AR_members__Project;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_members__Project> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export WorkerLibrary :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		WorkerLibrary() {}
		WorkerLibrary(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		WorkerLibrary(const WorkerLibrary &master) : MgaObject(master) {}

		static WorkerLibrary Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static WorkerLibrary Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		WorkerLibrary CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<WorkerLibrary> Instances() { return Udm::InstantiatedAttr<WorkerLibrary>(impl); }
		template <class Pred> Udm::InstantiatedAttr<WorkerLibrary, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<WorkerLibrary, Pred>(impl); }
		WorkerLibrary CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<WorkerLibrary> Derived() { return Udm::DerivedAttr<WorkerLibrary>(impl); }
		template <class Pred> Udm::DerivedAttr<WorkerLibrary, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<WorkerLibrary, Pred>(impl); }
		Udm::ArchetypeAttr<WorkerLibrary> Archetype() const { return Udm::ArchetypeAttr<WorkerLibrary>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr Location() const { return Udm::StringAttr(impl, meta_Location); }
		Udm::ChildrenAttr< ::PICML::WorkerFile> WorkerFile_children() const { return Udm::ChildrenAttr< ::PICML::WorkerFile>(impl, meta_WorkerFile_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkerFile, Pred> WorkerFile_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkerFile, Pred>(impl, meta_WorkerFile_children); }
		Udm::ChildrenAttr< ::PICML::WorkerFile> WorkerFile_kind_children() const { return Udm::ChildrenAttr< ::PICML::WorkerFile>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkerFile, Pred> WorkerFile_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkerFile, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::WorkerPackageBase> WorkerPackageBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::WorkerPackageBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkerPackageBase, Pred> WorkerPackageBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkerPackageBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::WorkerLibraries> WorkerLibraries_parent() const { return Udm::ParentAttr< ::PICML::WorkerLibraries>(impl, meta_WorkerLibraries_parent); }
		Udm::ParentAttr< ::PICML::WorkerLibraries> parent() const { return Udm::ParentAttr< ::PICML::WorkerLibraries>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_WorkerLibrary(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Location;
		static ::Uml::CompositionChildRole meta_WorkerFile_children;
		static ::Uml::CompositionParentRole meta_WorkerLibraries_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_WorkerLibraries_parent {};
		typedef boost::mpl::pair< ::PICML::WorkerLibraries, PR_WorkerLibraries_parent > _PR_WorkerLibraries_parent__WorkerLibraries;
		typedef boost::mpl::vector< _PR_WorkerLibraries_parent__WorkerLibraries> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::WorkerLibraries> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_WorkerFile_children {};
		typedef boost::mpl::pair< ::PICML::WorkerFile, CR_WorkerFile_children > _CR_WorkerFile_children__WorkerFile;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_WorkerFile_children__WorkerFile> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::WorkerFile> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Worker :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Worker() {}
		Worker(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Worker(const Worker &master) : MgaObject(master) {}

		static Worker Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Worker Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Worker CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Worker> Instances() { return Udm::InstantiatedAttr<Worker>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Worker, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Worker, Pred>(impl); }
		Worker CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Worker> Derived() { return Udm::DerivedAttr<Worker>(impl); }
		template <class Pred> Udm::DerivedAttr<Worker, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Worker, Pred>(impl); }
		Udm::ArchetypeAttr<Worker> Archetype() const { return Udm::ArchetypeAttr<Worker>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::BooleanAttr Abstract() const { return Udm::BooleanAttr(impl, meta_Abstract); }
		Udm::AssocAttr< ::PICML::WorkerType> referedbyWorkerType() const { return Udm::AssocAttr< ::PICML::WorkerType>(impl, meta_referedbyWorkerType); }
		template <class Pred> Udm::AssocAttr< ::PICML::WorkerType, Pred> referedbyWorkerType_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::WorkerType, Pred>(impl, meta_referedbyWorkerType); }
		Udm::ChildrenAttr< ::PICML::Action> Action_children() const { return Udm::ChildrenAttr< ::PICML::Action>(impl, meta_Action_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Action, Pred> Action_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Action, Pred>(impl, meta_Action_children); }
		Udm::ChildrenAttr< ::PICML::Action> Action_kind_children() const { return Udm::ChildrenAttr< ::PICML::Action>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Action, Pred> Action_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Action, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ActionBase> ActionBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::ActionBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ActionBase, Pred> ActionBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ActionBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::WorkerPackageBase> WorkerPackageBase_parent() const { return Udm::ParentAttr< ::PICML::WorkerPackageBase>(impl, meta_WorkerPackageBase_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Worker(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Abstract;
		static ::Uml::AssociationRole meta_referedbyWorkerType;
		static ::Uml::CompositionChildRole meta_Action_children;
		static ::Uml::CompositionParentRole meta_WorkerPackageBase_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_WorkerPackageBase_parent {};
		typedef boost::mpl::pair< ::PICML::WorkerPackageBase, PR_WorkerPackageBase_parent > _PR_WorkerPackageBase_parent__WorkerPackageBase;
		typedef boost::mpl::vector< _PR_WorkerPackageBase_parent__WorkerPackageBase> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::WorkerPackageBase> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Action_children {};
		typedef boost::mpl::pair< ::PICML::Action, CR_Action_children > _CR_Action_children__Action;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Action_children__Action> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Action> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyWorkerType {};
		typedef boost::mpl::pair< ::PICML::WorkerType, AR_referedbyWorkerType > _AR_referedbyWorkerType__WorkerType;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyWorkerType__WorkerType> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export WorkerType :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		WorkerType() {}
		WorkerType(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		WorkerType(const WorkerType &master) : MgaObject(master) {}

		static WorkerType Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static WorkerType Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		WorkerType CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<WorkerType> Instances() { return Udm::InstantiatedAttr<WorkerType>(impl); }
		template <class Pred> Udm::InstantiatedAttr<WorkerType, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<WorkerType, Pred>(impl); }
		WorkerType CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<WorkerType> Derived() { return Udm::DerivedAttr<WorkerType>(impl); }
		template <class Pred> Udm::DerivedAttr<WorkerType, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<WorkerType, Pred>(impl); }
		Udm::ArchetypeAttr<WorkerType> Archetype() const { return Udm::ArchetypeAttr<WorkerType>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::Worker> ref() const { return Udm::PointerAttr< ::PICML::Worker>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::Component> Component_parent() const { return Udm::ParentAttr< ::PICML::Component>(impl, meta_Component_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_WorkerType(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_Component_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Component_parent {};
		typedef boost::mpl::pair< ::PICML::Component, PR_Component_parent > _PR_Component_parent__Component;
		typedef boost::mpl::vector< _PR_Component_parent__Component> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Component> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::Worker, AR_ref > _AR_ref__Worker;
		typedef boost::mpl::vector< _AR_ref__Worker> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export WorkerPackageBase :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		WorkerPackageBase() {}
		WorkerPackageBase(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		WorkerPackageBase(const WorkerPackageBase &master) : MgaObject(master) {}

		static WorkerPackageBase Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static WorkerPackageBase Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		WorkerPackageBase CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<WorkerPackageBase> Instances() { return Udm::InstantiatedAttr<WorkerPackageBase>(impl); }
		template <class Pred> Udm::InstantiatedAttr<WorkerPackageBase, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<WorkerPackageBase, Pred>(impl); }
		WorkerPackageBase CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<WorkerPackageBase> Derived() { return Udm::DerivedAttr<WorkerPackageBase>(impl); }
		template <class Pred> Udm::DerivedAttr<WorkerPackageBase, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<WorkerPackageBase, Pred>(impl); }
		Udm::ArchetypeAttr<WorkerPackageBase> Archetype() const { return Udm::ArchetypeAttr<WorkerPackageBase>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::Worker> Worker_children() const { return Udm::ChildrenAttr< ::PICML::Worker>(impl, meta_Worker_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Worker, Pred> Worker_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Worker, Pred>(impl, meta_Worker_children); }
		Udm::ChildrenAttr< ::PICML::Worker> Worker_kind_children() const { return Udm::ChildrenAttr< ::PICML::Worker>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Worker, Pred> Worker_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Worker, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Worker_children;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Worker_children {};
		typedef boost::mpl::pair< ::PICML::Worker, CR_Worker_children > _CR_Worker_children__Worker;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Worker_children__Worker> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Worker> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export WorkerFile :  public WorkerPackageBase {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		WorkerFile() {}
		WorkerFile(Udm::ObjectImpl *impl) : WorkerPackageBase(impl) {}
		WorkerFile(const WorkerFile &master) : WorkerPackageBase(master) {}

		static WorkerFile Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static WorkerFile Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		WorkerFile CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<WorkerFile> Instances() { return Udm::InstantiatedAttr<WorkerFile>(impl); }
		template <class Pred> Udm::InstantiatedAttr<WorkerFile, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<WorkerFile, Pred>(impl); }
		WorkerFile CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<WorkerFile> Derived() { return Udm::DerivedAttr<WorkerFile>(impl); }
		template <class Pred> Udm::DerivedAttr<WorkerFile, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<WorkerFile, Pred>(impl); }
		Udm::ArchetypeAttr<WorkerFile> Archetype() const { return Udm::ArchetypeAttr<WorkerFile>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr Location() const { return Udm::StringAttr(impl, meta_Location); }
		Udm::ChildrenAttr< ::PICML::WorkerPackage> WorkerPackage_children() const { return Udm::ChildrenAttr< ::PICML::WorkerPackage>(impl, meta_WorkerPackage_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkerPackage, Pred> WorkerPackage_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkerPackage, Pred>(impl, meta_WorkerPackage_children); }
		Udm::ChildrenAttr< ::PICML::WorkerPackage> WorkerPackage_kind_children() const { return Udm::ChildrenAttr< ::PICML::WorkerPackage>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkerPackage, Pred> WorkerPackage_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkerPackage, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::WorkerPackageBase> WorkerPackageBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::WorkerPackageBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkerPackageBase, Pred> WorkerPackageBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkerPackageBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::WorkerLibrary> WorkerLibrary_parent() const { return Udm::ParentAttr< ::PICML::WorkerLibrary>(impl, meta_WorkerLibrary_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_WorkerFile(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Location;
		static ::Uml::CompositionChildRole meta_WorkerPackage_children;
		static ::Uml::CompositionParentRole meta_WorkerLibrary_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_WorkerLibrary_parent {};
		typedef boost::mpl::pair< ::PICML::WorkerLibrary, PR_WorkerLibrary_parent > _PR_WorkerLibrary_parent__WorkerLibrary;
		typedef boost::mpl::vector< _PR_WorkerLibrary_parent__WorkerLibrary> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::WorkerLibrary> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_WorkerPackage_children {};
		typedef boost::mpl::pair< ::PICML::WorkerPackage, CR_WorkerPackage_children > _CR_WorkerPackage_children__WorkerPackage;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_WorkerPackage_children__WorkerPackage> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Worker, ::PICML::WorkerPackage> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export WorkerPackage :  public WorkerPackageBase {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		WorkerPackage() {}
		WorkerPackage(Udm::ObjectImpl *impl) : WorkerPackageBase(impl) {}
		WorkerPackage(const WorkerPackage &master) : WorkerPackageBase(master) {}

		static WorkerPackage Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static WorkerPackage Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		WorkerPackage CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<WorkerPackage> Instances() { return Udm::InstantiatedAttr<WorkerPackage>(impl); }
		template <class Pred> Udm::InstantiatedAttr<WorkerPackage, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<WorkerPackage, Pred>(impl); }
		WorkerPackage CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<WorkerPackage> Derived() { return Udm::DerivedAttr<WorkerPackage>(impl); }
		template <class Pred> Udm::DerivedAttr<WorkerPackage, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<WorkerPackage, Pred>(impl); }
		Udm::ArchetypeAttr<WorkerPackage> Archetype() const { return Udm::ArchetypeAttr<WorkerPackage>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::WorkerPackage> WorkerPackage_children() const { return Udm::ChildrenAttr< ::PICML::WorkerPackage>(impl, meta_WorkerPackage_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkerPackage, Pred> WorkerPackage_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkerPackage, Pred>(impl, meta_WorkerPackage_children); }
		Udm::ChildrenAttr< ::PICML::WorkerPackage> WorkerPackage_kind_children() const { return Udm::ChildrenAttr< ::PICML::WorkerPackage>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkerPackage, Pred> WorkerPackage_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkerPackage, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::WorkerPackageBase> WorkerPackageBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::WorkerPackageBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkerPackageBase, Pred> WorkerPackageBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkerPackageBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::WorkerFile> WorkerFile_parent() const { return Udm::ParentAttr< ::PICML::WorkerFile>(impl, meta_WorkerFile_parent); }
		Udm::ParentAttr< ::PICML::WorkerPackage> WorkerPackage_parent() const { return Udm::ParentAttr< ::PICML::WorkerPackage>(impl, meta_WorkerPackage_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_WorkerPackage(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_WorkerPackage_children;
		static ::Uml::CompositionParentRole meta_WorkerFile_parent;
		static ::Uml::CompositionParentRole meta_WorkerPackage_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_WorkerFile_parent {};
		class PR_WorkerPackage_parent {};
		typedef boost::mpl::pair< ::PICML::WorkerFile, PR_WorkerFile_parent > _PR_WorkerFile_parent__WorkerFile;
		typedef boost::mpl::pair< ::PICML::WorkerPackage, PR_WorkerPackage_parent > _PR_WorkerPackage_parent__WorkerPackage;
		typedef boost::mpl::vector< _PR_WorkerFile_parent__WorkerFile, _PR_WorkerPackage_parent__WorkerPackage> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::WorkerFile, ::PICML::WorkerPackage> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_WorkerPackage_children {};
		typedef boost::mpl::pair< ::PICML::WorkerPackage, CR_WorkerPackage_children > _CR_WorkerPackage_children__WorkerPackage;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_WorkerPackage_children__WorkerPackage> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Worker, ::PICML::WorkerPackage> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Variable :  public MgaObject {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		Variable() {}
		Variable(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Variable(const Variable &master) : MgaObject(master) {}

		static Variable Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Variable Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Variable CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Variable> Instances() { return Udm::InstantiatedAttr<Variable>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Variable, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Variable, Pred>(impl); }
		Variable CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Variable> Derived() { return Udm::DerivedAttr<Variable>(impl); }
		template <class Pred> Udm::DerivedAttr<Variable, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Variable, Pred>(impl); }
		Udm::ArchetypeAttr<Variable> Archetype() const { return Udm::ArchetypeAttr<Variable>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr InitialValue() const { return Udm::StringAttr(impl, meta_InitialValue); }
		Udm::PointerAttr< ::PICML::PredefinedType> ref() const { return Udm::PointerAttr< ::PICML::PredefinedType>(impl, meta_ref); }
		Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const { return Udm::ParentAttr< ::PICML::BehaviorModel>(impl, meta_BehaviorModel_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Variable(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_InitialValue;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_BehaviorModel_parent {};
		typedef boost::mpl::pair< ::PICML::BehaviorModel, PR_BehaviorModel_parent > _PR_BehaviorModel_parent__BehaviorModel;
		typedef boost::mpl::vector< _PR_BehaviorModel_parent__BehaviorModel> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::PredefinedType, AR_ref > _AR_ref__PredefinedType;
		typedef boost::mpl::vector< _AR_ref__PredefinedType> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export BehaviorModel :  virtual  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		BehaviorModel() {}
		BehaviorModel(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		BehaviorModel(const BehaviorModel &master) : MgaObject(master) {}

		static BehaviorModel Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static BehaviorModel Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		BehaviorModel CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<BehaviorModel> Instances() { return Udm::InstantiatedAttr<BehaviorModel>(impl); }
		template <class Pred> Udm::InstantiatedAttr<BehaviorModel, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<BehaviorModel, Pred>(impl); }
		BehaviorModel CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<BehaviorModel> Derived() { return Udm::DerivedAttr<BehaviorModel>(impl); }
		template <class Pred> Udm::DerivedAttr<BehaviorModel, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<BehaviorModel, Pred>(impl); }
		Udm::ArchetypeAttr<BehaviorModel> Archetype() const { return Udm::ArchetypeAttr<BehaviorModel>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::TerminalTransition> TerminalTransition_children() const { return Udm::ChildrenAttr< ::PICML::TerminalTransition>(impl, meta_TerminalTransition_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TerminalTransition, Pred> TerminalTransition_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TerminalTransition, Pred>(impl, meta_TerminalTransition_children); }
		Udm::ChildrenAttr< ::PICML::Variable> Variable_children() const { return Udm::ChildrenAttr< ::PICML::Variable>(impl, meta_Variable_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Variable, Pred> Variable_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Variable, Pred>(impl, meta_Variable_children); }
		Udm::ChildrenAttr< ::PICML::Terminal> Terminal_children() const { return Udm::ChildrenAttr< ::PICML::Terminal>(impl, meta_Terminal_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Terminal, Pred> Terminal_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Terminal, Pred>(impl, meta_Terminal_children); }
		Udm::ChildrenAttr< ::PICML::TerminalEffect> TerminalEffect_children() const { return Udm::ChildrenAttr< ::PICML::TerminalEffect>(impl, meta_TerminalEffect_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TerminalEffect, Pred> TerminalEffect_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TerminalEffect, Pred>(impl, meta_TerminalEffect_children); }
		Udm::ChildrenAttr< ::PICML::StateBase> StateBase_children() const { return Udm::ChildrenAttr< ::PICML::StateBase>(impl, meta_StateBase_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::StateBase, Pred> StateBase_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::StateBase, Pred>(impl, meta_StateBase_children); }
		Udm::ChildrenAttr< ::PICML::BranchTransition> BranchTransition_children() const { return Udm::ChildrenAttr< ::PICML::BranchTransition>(impl, meta_BranchTransition_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::BranchTransition, Pred> BranchTransition_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::BranchTransition, Pred>(impl, meta_BranchTransition_children); }
		Udm::ChildrenAttr< ::PICML::Transition> Transition_children() const { return Udm::ChildrenAttr< ::PICML::Transition>(impl, meta_Transition_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Transition, Pred> Transition_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Transition, Pred>(impl, meta_Transition_children); }
		Udm::ChildrenAttr< ::PICML::LoopTransition> LoopTransition_children() const { return Udm::ChildrenAttr< ::PICML::LoopTransition>(impl, meta_LoopTransition_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::LoopTransition, Pred> LoopTransition_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::LoopTransition, Pred>(impl, meta_LoopTransition_children); }
		Udm::ChildrenAttr< ::PICML::Finish> Finish_children() const { return Udm::ChildrenAttr< ::PICML::Finish>(impl, meta_Finish_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Finish, Pred> Finish_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Finish, Pred>(impl, meta_Finish_children); }
		Udm::ChildrenAttr< ::PICML::BehaviorInputAction> BehaviorInputAction_children() const { return Udm::ChildrenAttr< ::PICML::BehaviorInputAction>(impl, meta_BehaviorInputAction_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::BehaviorInputAction, Pred> BehaviorInputAction_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::BehaviorInputAction, Pred>(impl, meta_BehaviorInputAction_children); }
		Udm::ChildrenAttr< ::PICML::ActionBase> ActionBase_children() const { return Udm::ChildrenAttr< ::PICML::ActionBase>(impl, meta_ActionBase_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ActionBase, Pred> ActionBase_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ActionBase, Pred>(impl, meta_ActionBase_children); }
		Udm::ChildrenAttr< ::PICML::InputEffect> InputEffect_children() const { return Udm::ChildrenAttr< ::PICML::InputEffect>(impl, meta_InputEffect_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InputEffect, Pred> InputEffect_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InputEffect, Pred>(impl, meta_InputEffect_children); }
		Udm::ChildrenAttr< ::PICML::Effect> Effect_children() const { return Udm::ChildrenAttr< ::PICML::Effect>(impl, meta_Effect_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Effect, Pred> Effect_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Effect, Pred>(impl, meta_Effect_children); }
		Udm::ChildrenAttr< ::PICML::QueryInputAction> QueryInputAction_children() const { return Udm::ChildrenAttr< ::PICML::QueryInputAction>(impl, meta_QueryInputAction_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::QueryInputAction, Pred> QueryInputAction_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::QueryInputAction, Pred>(impl, meta_QueryInputAction_children); }
		Udm::ChildrenAttr< ::PICML::Variable> Variable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Variable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Variable, Pred> Variable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Variable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::BehaviorInputAction> BehaviorInputAction_kind_children() const { return Udm::ChildrenAttr< ::PICML::BehaviorInputAction>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::BehaviorInputAction, Pred> BehaviorInputAction_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::BehaviorInputAction, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Action> Action_kind_children() const { return Udm::ChildrenAttr< ::PICML::Action>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Action, Pred> Action_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Action, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::OutputAction> OutputAction_kind_children() const { return Udm::ChildrenAttr< ::PICML::OutputAction>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OutputAction, Pred> OutputAction_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OutputAction, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Finish> Finish_kind_children() const { return Udm::ChildrenAttr< ::PICML::Finish>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Finish, Pred> Finish_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Finish, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::QueryAction> QueryAction_kind_children() const { return Udm::ChildrenAttr< ::PICML::QueryAction>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::QueryAction, Pred> QueryAction_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::QueryAction, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::InputAction> InputAction_kind_children() const { return Udm::ChildrenAttr< ::PICML::InputAction>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InputAction, Pred> InputAction_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InputAction, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::QueryInputAction> QueryInputAction_kind_children() const { return Udm::ChildrenAttr< ::PICML::QueryInputAction>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::QueryInputAction, Pred> QueryInputAction_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::QueryInputAction, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MultiInputAction> MultiInputAction_kind_children() const { return Udm::ChildrenAttr< ::PICML::MultiInputAction>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MultiInputAction, Pred> MultiInputAction_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MultiInputAction, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ActionBase> ActionBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::ActionBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ActionBase, Pred> ActionBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ActionBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Transition> Transition_kind_children() const { return Udm::ChildrenAttr< ::PICML::Transition>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Transition, Pred> Transition_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Transition, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::BranchState> BranchState_kind_children() const { return Udm::ChildrenAttr< ::PICML::BranchState>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::BranchState, Pred> BranchState_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::BranchState, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::BranchTransition> BranchTransition_kind_children() const { return Udm::ChildrenAttr< ::PICML::BranchTransition>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::BranchTransition, Pred> BranchTransition_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::BranchTransition, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::LoopState> LoopState_kind_children() const { return Udm::ChildrenAttr< ::PICML::LoopState>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::LoopState, Pred> LoopState_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::LoopState, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ForState> ForState_kind_children() const { return Udm::ChildrenAttr< ::PICML::ForState>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ForState, Pred> ForState_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ForState, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::DoWhileState> DoWhileState_kind_children() const { return Udm::ChildrenAttr< ::PICML::DoWhileState>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::DoWhileState, Pred> DoWhileState_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::DoWhileState, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::WhileState> WhileState_kind_children() const { return Udm::ChildrenAttr< ::PICML::WhileState>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WhileState, Pred> WhileState_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WhileState, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::LoopTransition> LoopTransition_kind_children() const { return Udm::ChildrenAttr< ::PICML::LoopTransition>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::LoopTransition, Pred> LoopTransition_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::LoopTransition, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::State> State_kind_children() const { return Udm::ChildrenAttr< ::PICML::State>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::State, Pred> State_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::State, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::StateBase> StateBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::StateBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::StateBase, Pred> StateBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::StateBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Terminal> Terminal_kind_children() const { return Udm::ChildrenAttr< ::PICML::Terminal>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Terminal, Pred> Terminal_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Terminal, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::TerminalTransition> TerminalTransition_kind_children() const { return Udm::ChildrenAttr< ::PICML::TerminalTransition>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TerminalTransition, Pred> TerminalTransition_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TerminalTransition, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Effect> Effect_kind_children() const { return Udm::ChildrenAttr< ::PICML::Effect>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Effect, Pred> Effect_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Effect, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::InputEffect> InputEffect_kind_children() const { return Udm::ChildrenAttr< ::PICML::InputEffect>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InputEffect, Pred> InputEffect_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InputEffect, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::TerminalEffect> TerminalEffect_kind_children() const { return Udm::ChildrenAttr< ::PICML::TerminalEffect>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::TerminalEffect, Pred> TerminalEffect_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::TerminalEffect, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::EffectBase> EffectBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::EffectBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::EffectBase, Pred> EffectBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::EffectBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_TerminalTransition_children;
		static ::Uml::CompositionChildRole meta_Variable_children;
		static ::Uml::CompositionChildRole meta_Terminal_children;
		static ::Uml::CompositionChildRole meta_TerminalEffect_children;
		static ::Uml::CompositionChildRole meta_StateBase_children;
		static ::Uml::CompositionChildRole meta_BranchTransition_children;
		static ::Uml::CompositionChildRole meta_Transition_children;
		static ::Uml::CompositionChildRole meta_LoopTransition_children;
		static ::Uml::CompositionChildRole meta_Finish_children;
		static ::Uml::CompositionChildRole meta_BehaviorInputAction_children;
		static ::Uml::CompositionChildRole meta_ActionBase_children;
		static ::Uml::CompositionChildRole meta_InputEffect_children;
		static ::Uml::CompositionChildRole meta_Effect_children;
		static ::Uml::CompositionChildRole meta_QueryInputAction_children;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_TerminalTransition_children {};
		class CR_Variable_children {};
		class CR_Terminal_children {};
		class CR_TerminalEffect_children {};
		class CR_StateBase_children {};
		class CR_BranchTransition_children {};
		class CR_Transition_children {};
		class CR_LoopTransition_children {};
		class CR_Finish_children {};
		class CR_BehaviorInputAction_children {};
		class CR_ActionBase_children {};
		class CR_InputEffect_children {};
		class CR_Effect_children {};
		class CR_QueryInputAction_children {};
		typedef boost::mpl::pair< ::PICML::TerminalTransition, CR_TerminalTransition_children > _CR_TerminalTransition_children__TerminalTransition;
		typedef boost::mpl::pair< ::PICML::Variable, CR_Variable_children > _CR_Variable_children__Variable;
		typedef boost::mpl::pair< ::PICML::Terminal, CR_Terminal_children > _CR_Terminal_children__Terminal;
		typedef boost::mpl::pair< ::PICML::TerminalEffect, CR_TerminalEffect_children > _CR_TerminalEffect_children__TerminalEffect;
		typedef boost::mpl::pair< ::PICML::StateBase, CR_StateBase_children > _CR_StateBase_children__StateBase;
		typedef boost::mpl::pair< ::PICML::BranchTransition, CR_BranchTransition_children > _CR_BranchTransition_children__BranchTransition;
		typedef boost::mpl::pair< ::PICML::Transition, CR_Transition_children > _CR_Transition_children__Transition;
		typedef boost::mpl::pair< ::PICML::LoopTransition, CR_LoopTransition_children > _CR_LoopTransition_children__LoopTransition;
		typedef boost::mpl::pair< ::PICML::Finish, CR_Finish_children > _CR_Finish_children__Finish;
		typedef boost::mpl::pair< ::PICML::BehaviorInputAction, CR_BehaviorInputAction_children > _CR_BehaviorInputAction_children__BehaviorInputAction;
		typedef boost::mpl::pair< ::PICML::ActionBase, CR_ActionBase_children > _CR_ActionBase_children__ActionBase;
		typedef boost::mpl::pair< ::PICML::InputEffect, CR_InputEffect_children > _CR_InputEffect_children__InputEffect;
		typedef boost::mpl::pair< ::PICML::Effect, CR_Effect_children > _CR_Effect_children__Effect;
		typedef boost::mpl::pair< ::PICML::QueryInputAction, CR_QueryInputAction_children > _CR_QueryInputAction_children__QueryInputAction;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_TerminalTransition_children__TerminalTransition, _CR_Variable_children__Variable, _CR_Terminal_children__Terminal, _CR_TerminalEffect_children__TerminalEffect, _CR_StateBase_children__StateBase, _CR_BranchTransition_children__BranchTransition, _CR_Transition_children__Transition, _CR_LoopTransition_children__LoopTransition, _CR_Finish_children__Finish, _CR_BehaviorInputAction_children__BehaviorInputAction, _CR_ActionBase_children__ActionBase, _CR_InputEffect_children__InputEffect, _CR_Effect_children__Effect, _CR_QueryInputAction_children__QueryInputAction> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Variable, ::PICML::BehaviorInputAction, ::PICML::Action, ::PICML::OutputAction, ::PICML::Finish, ::PICML::QueryAction, ::PICML::InputAction, ::PICML::QueryInputAction, ::PICML::MultiInputAction, ::PICML::ActionBase, ::PICML::Transition, ::PICML::BranchState, ::PICML::BranchTransition, ::PICML::ForState, ::PICML::DoWhileState, ::PICML::WhileState, ::PICML::LoopState, ::PICML::LoopTransition, ::PICML::State, ::PICML::StateBase, ::PICML::Terminal, ::PICML::TerminalTransition, ::PICML::Effect, ::PICML::InputEffect, ::PICML::TerminalEffect> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export BehaviorInputAction :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		BehaviorInputAction() {}
		BehaviorInputAction(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		BehaviorInputAction(const BehaviorInputAction &master) : MgaObject(master) {}

		static BehaviorInputAction Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static BehaviorInputAction Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		BehaviorInputAction CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<BehaviorInputAction> Instances() { return Udm::InstantiatedAttr<BehaviorInputAction>(impl); }
		template <class Pred> Udm::InstantiatedAttr<BehaviorInputAction, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<BehaviorInputAction, Pred>(impl); }
		BehaviorInputAction CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<BehaviorInputAction> Derived() { return Udm::DerivedAttr<BehaviorInputAction>(impl); }
		template <class Pred> Udm::DerivedAttr<BehaviorInputAction, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<BehaviorInputAction, Pred>(impl); }
		Udm::ArchetypeAttr<BehaviorInputAction> Archetype() const { return Udm::ArchetypeAttr<BehaviorInputAction>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::Finish, ::PICML::StateBase> srcFinish() const { return Udm::AClassPointerAttr< ::PICML::Finish, ::PICML::StateBase>(impl, meta_srcFinish, meta_srcFinish_rev); }
		Udm::AClassPointerAttr< ::PICML::InputEffect, ::PICML::StateBase> dstInputEffect() const { return Udm::AClassPointerAttr< ::PICML::InputEffect, ::PICML::StateBase>(impl, meta_dstInputEffect, meta_dstInputEffect_rev); }
		Udm::ChildrenAttr< ::PICML::Property> Property_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, meta_Property_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); }
		Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const { return Udm::ParentAttr< ::PICML::BehaviorModel>(impl, meta_BehaviorModel_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcFinish;
		static ::Uml::AssociationRole meta_srcFinish_rev;
		static ::Uml::AssociationRole meta_dstInputEffect;
		static ::Uml::AssociationRole meta_dstInputEffect_rev;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_BehaviorModel_parent {};
		typedef boost::mpl::pair< ::PICML::BehaviorModel, PR_BehaviorModel_parent > _PR_BehaviorModel_parent__BehaviorModel;
		typedef boost::mpl::vector< _PR_BehaviorModel_parent__BehaviorModel> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Property_children {};
		typedef boost::mpl::pair< ::PICML::Property, CR_Property_children > _CR_Property_children__Property;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Property_children__Property> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcFinish {};
		class AR_dstInputEffect {};
		typedef boost::mpl::pair< ::PICML::StateBase, boost::mpl::pair< ::PICML::Finish, AR_srcFinish > > _AR_srcFinish__Finish__StateBase;
		typedef boost::mpl::pair< ::PICML::StateBase, boost::mpl::pair< ::PICML::InputEffect, AR_dstInputEffect > > _AR_dstInputEffect__InputEffect__StateBase;
		typedef boost::mpl::vector< _AR_srcFinish__Finish__StateBase, _AR_dstInputEffect__InputEffect__StateBase> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Finish :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		Finish() {}
		Finish(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Finish(const Finish &master) : MgaObject(master) {}

		static Finish Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Finish Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Finish CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Finish> Instances() { return Udm::InstantiatedAttr<Finish>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Finish, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Finish, Pred>(impl); }
		Finish CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Finish> Derived() { return Udm::DerivedAttr<Finish>(impl); }
		template <class Pred> Udm::DerivedAttr<Finish, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Finish, Pred>(impl); }
		Udm::ArchetypeAttr<Finish> Archetype() const { return Udm::ArchetypeAttr<Finish>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const { return Udm::ParentAttr< ::PICML::BehaviorModel>(impl, meta_BehaviorModel_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::BehaviorInputAction> dstFinish_end() const { return Udm::AssocEndAttr< ::PICML::BehaviorInputAction>(impl, meta_dstFinish_end_); }
		Udm::AssocEndAttr< ::PICML::StateBase> srcFinish_end() const { return Udm::AssocEndAttr< ::PICML::StateBase>(impl, meta_srcFinish_end_); }
		void Accept(Visitor &v) { v.Visit_Finish(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;
		static ::Uml::AssociationRole meta_dstFinish_end_;
		static ::Uml::AssociationRole meta_srcFinish_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_BehaviorModel_parent {};
		typedef boost::mpl::pair< ::PICML::BehaviorModel, PR_BehaviorModel_parent > _PR_BehaviorModel_parent__BehaviorModel;
		typedef boost::mpl::vector< _PR_BehaviorModel_parent__BehaviorModel> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstFinish {};
		class ACE_srcFinish {};
		typedef boost::mpl::pair< ::PICML::BehaviorInputAction, ACE_dstFinish > _ACE_dstFinish__BehaviorInputAction;
		typedef boost::mpl::pair< ::PICML::StateBase, ACE_srcFinish > _ACE_srcFinish__StateBase;
		typedef boost::mpl::vector< _ACE_dstFinish__BehaviorInputAction, _ACE_srcFinish__StateBase> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export InputAction :  public BehaviorInputAction {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		InputAction() {}
		InputAction(Udm::ObjectImpl *impl) : BehaviorInputAction(impl) {}
		InputAction(const InputAction &master) : BehaviorInputAction(master) {}

		static InputAction Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static InputAction Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		InputAction CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<InputAction> Instances() { return Udm::InstantiatedAttr<InputAction>(impl); }
		template <class Pred> Udm::InstantiatedAttr<InputAction, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<InputAction, Pred>(impl); }
		InputAction CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<InputAction> Derived() { return Udm::DerivedAttr<InputAction>(impl); }
		template <class Pred> Udm::DerivedAttr<InputAction, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<InputAction, Pred>(impl); }
		Udm::ArchetypeAttr<InputAction> Archetype() const { return Udm::ArchetypeAttr<InputAction>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::Input, ::PICML::SingleInputBase> srcInput() const { return Udm::AClassPointerAttr< ::PICML::Input, ::PICML::SingleInputBase>(impl, meta_srcInput, meta_srcInput_rev); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_InputAction(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcInput;
		static ::Uml::AssociationRole meta_srcInput_rev;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcInput {};
		typedef boost::mpl::pair< ::PICML::SingleInputBase, boost::mpl::pair< ::PICML::Input, AR_srcInput > > _AR_srcInput__Input__SingleInputBase;
		typedef boost::mpl::vector< _AR_srcInput__Input__SingleInputBase> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export QueryInputAction :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		QueryInputAction() {}
		QueryInputAction(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		QueryInputAction(const QueryInputAction &master) : MgaObject(master) {}

		static QueryInputAction Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static QueryInputAction Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		QueryInputAction CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<QueryInputAction> Instances() { return Udm::InstantiatedAttr<QueryInputAction>(impl); }
		template <class Pred> Udm::InstantiatedAttr<QueryInputAction, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<QueryInputAction, Pred>(impl); }
		QueryInputAction CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<QueryInputAction> Derived() { return Udm::DerivedAttr<QueryInputAction>(impl); }
		template <class Pred> Udm::DerivedAttr<QueryInputAction, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<QueryInputAction, Pred>(impl); }
		Udm::ArchetypeAttr<QueryInputAction> Archetype() const { return Udm::ArchetypeAttr<QueryInputAction>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::QueryInput, ::PICML::QueryInputBase> srcQueryInput() const { return Udm::AClassPointerAttr< ::PICML::QueryInput, ::PICML::QueryInputBase>(impl, meta_srcQueryInput, meta_srcQueryInput_rev); }
		Udm::ChildrenAttr< ::PICML::Property> Property_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, meta_Property_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); }
		Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const { return Udm::ParentAttr< ::PICML::BehaviorModel>(impl, meta_BehaviorModel_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_QueryInputAction(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcQueryInput;
		static ::Uml::AssociationRole meta_srcQueryInput_rev;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_BehaviorModel_parent {};
		typedef boost::mpl::pair< ::PICML::BehaviorModel, PR_BehaviorModel_parent > _PR_BehaviorModel_parent__BehaviorModel;
		typedef boost::mpl::vector< _PR_BehaviorModel_parent__BehaviorModel> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Property_children {};
		typedef boost::mpl::pair< ::PICML::Property, CR_Property_children > _CR_Property_children__Property;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Property_children__Property> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcQueryInput {};
		typedef boost::mpl::pair< ::PICML::QueryInputBase, boost::mpl::pair< ::PICML::QueryInput, AR_srcQueryInput > > _AR_srcQueryInput__QueryInput__QueryInputBase;
		typedef boost::mpl::vector< _AR_srcQueryInput__QueryInput__QueryInputBase> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export MultiInputAction :  public BehaviorInputAction {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		MultiInputAction() {}
		MultiInputAction(Udm::ObjectImpl *impl) : BehaviorInputAction(impl) {}
		MultiInputAction(const MultiInputAction &master) : BehaviorInputAction(master) {}

		static MultiInputAction Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static MultiInputAction Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		MultiInputAction CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<MultiInputAction> Instances() { return Udm::InstantiatedAttr<MultiInputAction>(impl); }
		template <class Pred> Udm::InstantiatedAttr<MultiInputAction, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<MultiInputAction, Pred>(impl); }
		MultiInputAction CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<MultiInputAction> Derived() { return Udm::DerivedAttr<MultiInputAction>(impl); }
		template <class Pred> Udm::DerivedAttr<MultiInputAction, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<MultiInputAction, Pred>(impl); }
		Udm::ArchetypeAttr<MultiInputAction> Archetype() const { return Udm::ArchetypeAttr<MultiInputAction>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::MultiInput, ::PICML::MultiInputBase> srcMultiInput() const { return Udm::AClassPointerAttr< ::PICML::MultiInput, ::PICML::MultiInputBase>(impl, meta_srcMultiInput, meta_srcMultiInput_rev); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_MultiInputAction(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcMultiInput;
		static ::Uml::AssociationRole meta_srcMultiInput_rev;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcMultiInput {};
		typedef boost::mpl::pair< ::PICML::MultiInputBase, boost::mpl::pair< ::PICML::MultiInput, AR_srcMultiInput > > _AR_srcMultiInput__MultiInput__MultiInputBase;
		typedef boost::mpl::vector< _AR_srcMultiInput__MultiInput__MultiInputBase> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ActionBase :  public MgaObject {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		ActionBase() {}
		ActionBase(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		ActionBase(const ActionBase &master) : MgaObject(master) {}

		static ActionBase Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ActionBase Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ActionBase CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ActionBase> Instances() { return Udm::InstantiatedAttr<ActionBase>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ActionBase, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ActionBase, Pred>(impl); }
		ActionBase CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ActionBase> Derived() { return Udm::DerivedAttr<ActionBase>(impl); }
		template <class Pred> Udm::DerivedAttr<ActionBase, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ActionBase, Pred>(impl); }
		Udm::ArchetypeAttr<ActionBase> Archetype() const { return Udm::ArchetypeAttr<ActionBase>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::BranchTransition, ::PICML::BranchState> srcBranchTransition() const { return Udm::AClassPointerAttr< ::PICML::BranchTransition, ::PICML::BranchState>(impl, meta_srcBranchTransition, meta_srcBranchTransition_rev); }
		Udm::AClassPointerAttr< ::PICML::Effect, ::PICML::StateBase> dstEffect() const { return Udm::AClassPointerAttr< ::PICML::Effect, ::PICML::StateBase>(impl, meta_dstEffect, meta_dstEffect_rev); }
		Udm::AClassPointerAttr< ::PICML::LoopTransition, ::PICML::LoopState> srcLoopTransition() const { return Udm::AClassPointerAttr< ::PICML::LoopTransition, ::PICML::LoopState>(impl, meta_srcLoopTransition, meta_srcLoopTransition_rev); }
		Udm::AClassPointerAttr< ::PICML::Transition, ::PICML::State> srcTransition() const { return Udm::AClassPointerAttr< ::PICML::Transition, ::PICML::State>(impl, meta_srcTransition, meta_srcTransition_rev); }
		Udm::ChildrenAttr< ::PICML::Property> Property_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, meta_Property_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); }
		Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const { return Udm::ChildrenAttr< ::PICML::Property>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const { return Udm::ParentAttr< ::PICML::BehaviorModel>(impl, meta_BehaviorModel_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcBranchTransition;
		static ::Uml::AssociationRole meta_srcBranchTransition_rev;
		static ::Uml::AssociationRole meta_dstEffect;
		static ::Uml::AssociationRole meta_dstEffect_rev;
		static ::Uml::AssociationRole meta_srcLoopTransition;
		static ::Uml::AssociationRole meta_srcLoopTransition_rev;
		static ::Uml::AssociationRole meta_srcTransition;
		static ::Uml::AssociationRole meta_srcTransition_rev;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_BehaviorModel_parent {};
		typedef boost::mpl::pair< ::PICML::BehaviorModel, PR_BehaviorModel_parent > _PR_BehaviorModel_parent__BehaviorModel;
		typedef boost::mpl::vector< _PR_BehaviorModel_parent__BehaviorModel> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Property_children {};
		typedef boost::mpl::pair< ::PICML::Property, CR_Property_children > _CR_Property_children__Property;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_Property_children__Property> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcBranchTransition {};
		class AR_dstEffect {};
		class AR_srcLoopTransition {};
		class AR_srcTransition {};
		typedef boost::mpl::pair< ::PICML::BranchState, boost::mpl::pair< ::PICML::BranchTransition, AR_srcBranchTransition > > _AR_srcBranchTransition__BranchTransition__BranchState;
		typedef boost::mpl::pair< ::PICML::StateBase, boost::mpl::pair< ::PICML::Effect, AR_dstEffect > > _AR_dstEffect__Effect__StateBase;
		typedef boost::mpl::pair< ::PICML::LoopState, boost::mpl::pair< ::PICML::LoopTransition, AR_srcLoopTransition > > _AR_srcLoopTransition__LoopTransition__LoopState;
		typedef boost::mpl::pair< ::PICML::State, boost::mpl::pair< ::PICML::Transition, AR_srcTransition > > _AR_srcTransition__Transition__State;
		typedef boost::mpl::vector< _AR_srcBranchTransition__BranchTransition__BranchState, _AR_dstEffect__Effect__StateBase, _AR_srcLoopTransition__LoopTransition__LoopState, _AR_srcTransition__Transition__State> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Action :  public ActionBase {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Action() {}
		Action(Udm::ObjectImpl *impl) : ActionBase(impl) {}
		Action(const Action &master) : ActionBase(master) {}

		static Action Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Action Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Action CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Action> Instances() { return Udm::InstantiatedAttr<Action>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Action, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Action, Pred>(impl); }
		Action CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Action> Derived() { return Udm::DerivedAttr<Action>(impl); }
		template <class Pred> Udm::DerivedAttr<Action, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Action, Pred>(impl); }
		Udm::ArchetypeAttr<Action> Archetype() const { return Udm::ArchetypeAttr<Action>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::BooleanAttr LogAction() const { return Udm::BooleanAttr(impl, meta_LogAction); }
		Udm::IntegerAttr Duration() const { return Udm::IntegerAttr(impl, meta_Duration); }
		Udm::ParentAttr< ::PICML::Worker> Worker_parent() const { return Udm::ParentAttr< ::PICML::Worker>(impl, meta_Worker_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Action(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_LogAction;
		static ::Uml::Attribute meta_Duration;
		static ::Uml::CompositionParentRole meta_Worker_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_Worker_parent {};
		typedef boost::mpl::pair< ::PICML::Worker, PR_Worker_parent > _PR_Worker_parent__Worker;
		typedef boost::mpl::vector< _PR_Worker_parent__Worker> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::Worker, ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export OutputAction :  public ActionBase {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		OutputAction() {}
		OutputAction(Udm::ObjectImpl *impl) : ActionBase(impl) {}
		OutputAction(const OutputAction &master) : ActionBase(master) {}

		static OutputAction Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static OutputAction Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		OutputAction CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<OutputAction> Instances() { return Udm::InstantiatedAttr<OutputAction>(impl); }
		template <class Pred> Udm::InstantiatedAttr<OutputAction, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<OutputAction, Pred>(impl); }
		OutputAction CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<OutputAction> Derived() { return Udm::DerivedAttr<OutputAction>(impl); }
		template <class Pred> Udm::DerivedAttr<OutputAction, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<OutputAction, Pred>(impl); }
		Udm::ArchetypeAttr<OutputAction> Archetype() const { return Udm::ArchetypeAttr<OutputAction>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_OutputAction(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export QueryAction :  public ActionBase {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		QueryAction() {}
		QueryAction(Udm::ObjectImpl *impl) : ActionBase(impl) {}
		QueryAction(const QueryAction &master) : ActionBase(master) {}

		static QueryAction Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static QueryAction Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		QueryAction CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<QueryAction> Instances() { return Udm::InstantiatedAttr<QueryAction>(impl); }
		template <class Pred> Udm::InstantiatedAttr<QueryAction, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<QueryAction, Pred>(impl); }
		QueryAction CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<QueryAction> Derived() { return Udm::DerivedAttr<QueryAction>(impl); }
		template <class Pred> Udm::DerivedAttr<QueryAction, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<QueryAction, Pred>(impl); }
		Udm::ArchetypeAttr<QueryAction> Archetype() const { return Udm::ArchetypeAttr<QueryAction>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_QueryAction(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Property> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Input :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		Input() {}
		Input(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Input(const Input &master) : MgaObject(master) {}

		static Input Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Input Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Input CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Input> Instances() { return Udm::InstantiatedAttr<Input>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Input, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Input, Pred>(impl); }
		Input CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Input> Derived() { return Udm::DerivedAttr<Input>(impl); }
		template <class Pred> Udm::DerivedAttr<Input, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Input, Pred>(impl); }
		Udm::ArchetypeAttr<Input> Archetype() const { return Udm::ArchetypeAttr<Input>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::TopLevelBehavior> TopLevelBehavior_parent() const { return Udm::ParentAttr< ::PICML::TopLevelBehavior>(impl, meta_TopLevelBehavior_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::InputAction> dstInput_end() const { return Udm::AssocEndAttr< ::PICML::InputAction>(impl, meta_dstInput_end_); }
		Udm::AssocEndAttr< ::PICML::SingleInputBase> srcInput_end() const { return Udm::AssocEndAttr< ::PICML::SingleInputBase>(impl, meta_srcInput_end_); }
		void Accept(Visitor &v) { v.Visit_Input(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_TopLevelBehavior_parent;
		static ::Uml::AssociationRole meta_dstInput_end_;
		static ::Uml::AssociationRole meta_srcInput_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_TopLevelBehavior_parent {};
		typedef boost::mpl::pair< ::PICML::TopLevelBehavior, PR_TopLevelBehavior_parent > _PR_TopLevelBehavior_parent__TopLevelBehavior;
		typedef boost::mpl::vector< _PR_TopLevelBehavior_parent__TopLevelBehavior> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::TopLevelBehavior> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstInput {};
		class ACE_srcInput {};
		typedef boost::mpl::pair< ::PICML::InputAction, ACE_dstInput > _ACE_dstInput__InputAction;
		typedef boost::mpl::pair< ::PICML::SingleInputBase, ACE_srcInput > _ACE_srcInput__SingleInputBase;
		typedef boost::mpl::vector< _ACE_dstInput__InputAction, _ACE_srcInput__SingleInputBase> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export SingleInputBase :  virtual  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		SingleInputBase() {}
		SingleInputBase(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		SingleInputBase(const SingleInputBase &master) : MgaObject(master) {}

		static SingleInputBase Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static SingleInputBase Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		SingleInputBase CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<SingleInputBase> Instances() { return Udm::InstantiatedAttr<SingleInputBase>(impl); }
		template <class Pred> Udm::InstantiatedAttr<SingleInputBase, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<SingleInputBase, Pred>(impl); }
		SingleInputBase CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<SingleInputBase> Derived() { return Udm::DerivedAttr<SingleInputBase>(impl); }
		template <class Pred> Udm::DerivedAttr<SingleInputBase, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<SingleInputBase, Pred>(impl); }
		Udm::ArchetypeAttr<SingleInputBase> Archetype() const { return Udm::ArchetypeAttr<SingleInputBase>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::Input, ::PICML::InputAction> dstInput() const { return Udm::AClassPointerAttr< ::PICML::Input, ::PICML::InputAction>(impl, meta_dstInput, meta_dstInput_rev); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstInput;
		static ::Uml::AssociationRole meta_dstInput_rev;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstInput {};
		typedef boost::mpl::pair< ::PICML::InputAction, boost::mpl::pair< ::PICML::Input, AR_dstInput > > _AR_dstInput__Input__InputAction;
		typedef boost::mpl::vector< _AR_dstInput__Input__InputAction> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export PeriodicEvent :  public SingleInputBase {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		PeriodicEvent() {}
		PeriodicEvent(Udm::ObjectImpl *impl) : SingleInputBase(impl), MgaObject(impl) {}
		PeriodicEvent(const PeriodicEvent &master) : SingleInputBase(master), MgaObject(master) {}

		static PeriodicEvent Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static PeriodicEvent Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		PeriodicEvent CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<PeriodicEvent> Instances() { return Udm::InstantiatedAttr<PeriodicEvent>(impl); }
		template <class Pred> Udm::InstantiatedAttr<PeriodicEvent, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<PeriodicEvent, Pred>(impl); }
		PeriodicEvent CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<PeriodicEvent> Derived() { return Udm::DerivedAttr<PeriodicEvent>(impl); }
		template <class Pred> Udm::DerivedAttr<PeriodicEvent, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<PeriodicEvent, Pred>(impl); }
		Udm::ArchetypeAttr<PeriodicEvent> Archetype() const { return Udm::ArchetypeAttr<PeriodicEvent>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr Distribution() const { return Udm::StringAttr(impl, meta_Distribution); }
		Udm::StringAttr Hertz() const { return Udm::StringAttr(impl, meta_Hertz); }
		Udm::ParentAttr< ::PICML::TopLevelBehavior> TopLevelBehavior_parent() const { return Udm::ParentAttr< ::PICML::TopLevelBehavior>(impl, meta_TopLevelBehavior_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_PeriodicEvent(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Distribution;
		static ::Uml::Attribute meta_Hertz;
		static ::Uml::CompositionParentRole meta_TopLevelBehavior_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_TopLevelBehavior_parent {};
		typedef boost::mpl::pair< ::PICML::TopLevelBehavior, PR_TopLevelBehavior_parent > _PR_TopLevelBehavior_parent__TopLevelBehavior;
		typedef boost::mpl::vector< _PR_TopLevelBehavior_parent__TopLevelBehavior> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::TopLevelBehavior> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ApplicationTask :  public SingleInputBase {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		ApplicationTask() {}
		ApplicationTask(Udm::ObjectImpl *impl) : SingleInputBase(impl), MgaObject(impl) {}
		ApplicationTask(const ApplicationTask &master) : SingleInputBase(master), MgaObject(master) {}

		static ApplicationTask Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ApplicationTask Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ApplicationTask CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ApplicationTask> Instances() { return Udm::InstantiatedAttr<ApplicationTask>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ApplicationTask, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ApplicationTask, Pred>(impl); }
		ApplicationTask CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ApplicationTask> Derived() { return Udm::DerivedAttr<ApplicationTask>(impl); }
		template <class Pred> Udm::DerivedAttr<ApplicationTask, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ApplicationTask, Pred>(impl); }
		Udm::ArchetypeAttr<ApplicationTask> Archetype() const { return Udm::ArchetypeAttr<ApplicationTask>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::TopLevelBehavior> TopLevelBehavior_parent() const { return Udm::ParentAttr< ::PICML::TopLevelBehavior>(impl, meta_TopLevelBehavior_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ApplicationTask(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_TopLevelBehavior_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_TopLevelBehavior_parent {};
		typedef boost::mpl::pair< ::PICML::TopLevelBehavior, PR_TopLevelBehavior_parent > _PR_TopLevelBehavior_parent__TopLevelBehavior;
		typedef boost::mpl::vector< _PR_TopLevelBehavior_parent__TopLevelBehavior> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::TopLevelBehavior> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export MultiInputBase :  virtual  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		MultiInputBase() {}
		MultiInputBase(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		MultiInputBase(const MultiInputBase &master) : MgaObject(master) {}

		static MultiInputBase Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static MultiInputBase Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		MultiInputBase CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<MultiInputBase> Instances() { return Udm::InstantiatedAttr<MultiInputBase>(impl); }
		template <class Pred> Udm::InstantiatedAttr<MultiInputBase, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<MultiInputBase, Pred>(impl); }
		MultiInputBase CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<MultiInputBase> Derived() { return Udm::DerivedAttr<MultiInputBase>(impl); }
		template <class Pred> Udm::DerivedAttr<MultiInputBase, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<MultiInputBase, Pred>(impl); }
		Udm::ArchetypeAttr<MultiInputBase> Archetype() const { return Udm::ArchetypeAttr<MultiInputBase>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::MultiInput, ::PICML::MultiInputAction> dstMultiInput() const { return Udm::AClassAssocAttr< ::PICML::MultiInput, ::PICML::MultiInputAction>(impl, meta_dstMultiInput, meta_dstMultiInput_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::MultiInput, ::PICML::MultiInputAction, Pred> dstMultiInput_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::MultiInput, ::PICML::MultiInputAction, Pred>(impl, meta_dstMultiInput, meta_dstMultiInput_rev); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstMultiInput;
		static ::Uml::AssociationRole meta_dstMultiInput_rev;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstMultiInput {};
		typedef boost::mpl::pair< ::PICML::MultiInputAction, boost::mpl::pair< ::PICML::MultiInput, AR_dstMultiInput > > _AR_dstMultiInput__MultiInput__MultiInputAction;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstMultiInput__MultiInput__MultiInputAction> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ProvidedRequestPort :  public InvokePortBase,  public Port,  public MultiInputBase {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		ProvidedRequestPort() {}
		ProvidedRequestPort(Udm::ObjectImpl *impl) : InvokePortBase(impl),Port(impl),MultiInputBase(impl), MgaObject(impl) {}
		ProvidedRequestPort(const ProvidedRequestPort &master) : InvokePortBase(master),Port(master),MultiInputBase(master), MgaObject(master) {}

		static ProvidedRequestPort Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ProvidedRequestPort Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ProvidedRequestPort CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ProvidedRequestPort> Instances() { return Udm::InstantiatedAttr<ProvidedRequestPort>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ProvidedRequestPort, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ProvidedRequestPort, Pred>(impl); }
		ProvidedRequestPort CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ProvidedRequestPort> Derived() { return Udm::DerivedAttr<ProvidedRequestPort>(impl); }
		template <class Pred> Udm::DerivedAttr<ProvidedRequestPort, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ProvidedRequestPort, Pred>(impl); }
		Udm::ArchetypeAttr<ProvidedRequestPort> Archetype() const { return Udm::ArchetypeAttr<ProvidedRequestPort>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::PointerAttr< ::PICML::Provideable> ref() const { return Udm::PointerAttr< ::PICML::Provideable>(impl, meta_ref); }
		Udm::AClassAssocAttr< ::PICML::FacetDelegate, ::PICML::ProvidedRequestPort> dstFacetDelegate() const { return Udm::AClassAssocAttr< ::PICML::FacetDelegate, ::PICML::ProvidedRequestPort>(impl, meta_dstFacetDelegate, meta_dstFacetDelegate_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::FacetDelegate, ::PICML::ProvidedRequestPort, Pred> dstFacetDelegate_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::FacetDelegate, ::PICML::ProvidedRequestPort, Pred>(impl, meta_dstFacetDelegate, meta_dstFacetDelegate_rev); }
		Udm::AClassAssocAttr< ::PICML::FacetDelegate, ::PICML::ProvidedRequestPort> srcFacetDelegate() const { return Udm::AClassAssocAttr< ::PICML::FacetDelegate, ::PICML::ProvidedRequestPort>(impl, meta_srcFacetDelegate, meta_srcFacetDelegate_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::FacetDelegate, ::PICML::ProvidedRequestPort, Pred> srcFacetDelegate_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::FacetDelegate, ::PICML::ProvidedRequestPort, Pred>(impl, meta_srcFacetDelegate, meta_srcFacetDelegate_rev); }
		Udm::AClassAssocAttr< ::PICML::SupportsDelegate, ::PICML::Supports> srcSupportsDelegate() const { return Udm::AClassAssocAttr< ::PICML::SupportsDelegate, ::PICML::Supports>(impl, meta_srcSupportsDelegate, meta_srcSupportsDelegate_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::SupportsDelegate, ::PICML::Supports, Pred> srcSupportsDelegate_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::SupportsDelegate, ::PICML::Supports, Pred>(impl, meta_srcSupportsDelegate, meta_srcSupportsDelegate_rev); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ProvidedRequestPort(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_dstFacetDelegate;
		static ::Uml::AssociationRole meta_dstFacetDelegate_rev;
		static ::Uml::AssociationRole meta_srcFacetDelegate;
		static ::Uml::AssociationRole meta_srcFacetDelegate_rev;
		static ::Uml::AssociationRole meta_srcSupportsDelegate;
		static ::Uml::AssociationRole meta_srcSupportsDelegate_rev;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly, ::PICML::ConnectedComponent, ::PICML::Path, ::PICML::Component> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::Provideable, AR_ref > _AR_ref__Provideable;
		typedef boost::mpl::vector< _AR_ref__Provideable> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstFacetDelegate {};
		class AR_srcFacetDelegate {};
		class AR_srcSupportsDelegate {};
		typedef boost::mpl::pair< ::PICML::ProvidedRequestPort, boost::mpl::pair< ::PICML::FacetDelegate, AR_dstFacetDelegate > > _AR_dstFacetDelegate__FacetDelegate__ProvidedRequestPort;
		typedef boost::mpl::pair< ::PICML::ProvidedRequestPort, boost::mpl::pair< ::PICML::FacetDelegate, AR_srcFacetDelegate > > _AR_srcFacetDelegate__FacetDelegate__ProvidedRequestPort;
		typedef boost::mpl::pair< ::PICML::Supports, boost::mpl::pair< ::PICML::SupportsDelegate, AR_srcSupportsDelegate > > _AR_srcSupportsDelegate__SupportsDelegate__Supports;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstFacetDelegate__FacetDelegate__ProvidedRequestPort, _AR_srcFacetDelegate__FacetDelegate__ProvidedRequestPort, _AR_srcSupportsDelegate__SupportsDelegate__Supports> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Environment :  public MultiInputBase {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		Environment() {}
		Environment(Udm::ObjectImpl *impl) : MultiInputBase(impl), MgaObject(impl) {}
		Environment(const Environment &master) : MultiInputBase(master), MgaObject(master) {}

		static Environment Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Environment Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Environment CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Environment> Instances() { return Udm::InstantiatedAttr<Environment>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Environment, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Environment, Pred>(impl); }
		Environment CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Environment> Derived() { return Udm::DerivedAttr<Environment>(impl); }
		template <class Pred> Udm::DerivedAttr<Environment, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Environment, Pred>(impl); }
		Udm::ArchetypeAttr<Environment> Archetype() const { return Udm::ArchetypeAttr<Environment>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::TopLevelBehavior> TopLevelBehavior_parent() const { return Udm::ParentAttr< ::PICML::TopLevelBehavior>(impl, meta_TopLevelBehavior_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Environment(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_TopLevelBehavior_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_TopLevelBehavior_parent {};
		typedef boost::mpl::pair< ::PICML::TopLevelBehavior, PR_TopLevelBehavior_parent > _PR_TopLevelBehavior_parent__TopLevelBehavior;
		typedef boost::mpl::vector< _PR_TopLevelBehavior_parent__TopLevelBehavior> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::TopLevelBehavior> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export MultiOutputBase :  virtual  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		MultiOutputBase() {}
		MultiOutputBase(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		MultiOutputBase(const MultiOutputBase &master) : MgaObject(master) {}

		static MultiOutputBase Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static MultiOutputBase Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		MultiOutputBase CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<MultiOutputBase> Instances() { return Udm::InstantiatedAttr<MultiOutputBase>(impl); }
		template <class Pred> Udm::InstantiatedAttr<MultiOutputBase, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<MultiOutputBase, Pred>(impl); }
		MultiOutputBase CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<MultiOutputBase> Derived() { return Udm::DerivedAttr<MultiOutputBase>(impl); }
		template <class Pred> Udm::DerivedAttr<MultiOutputBase, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<MultiOutputBase, Pred>(impl); }
		Udm::ArchetypeAttr<MultiOutputBase> Archetype() const { return Udm::ArchetypeAttr<MultiOutputBase>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export RequiredRequestPort :  public Port,  public MultiOutputBase {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		RequiredRequestPort() {}
		RequiredRequestPort(Udm::ObjectImpl *impl) : Port(impl),MultiOutputBase(impl), MgaObject(impl) {}
		RequiredRequestPort(const RequiredRequestPort &master) : Port(master),MultiOutputBase(master), MgaObject(master) {}

		static RequiredRequestPort Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static RequiredRequestPort Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		RequiredRequestPort CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<RequiredRequestPort> Instances() { return Udm::InstantiatedAttr<RequiredRequestPort>(impl); }
		template <class Pred> Udm::InstantiatedAttr<RequiredRequestPort, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<RequiredRequestPort, Pred>(impl); }
		RequiredRequestPort CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<RequiredRequestPort> Derived() { return Udm::DerivedAttr<RequiredRequestPort>(impl); }
		template <class Pred> Udm::DerivedAttr<RequiredRequestPort, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<RequiredRequestPort, Pred>(impl); }
		Udm::ArchetypeAttr<RequiredRequestPort> Archetype() const { return Udm::ArchetypeAttr<RequiredRequestPort>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::BooleanAttr multiple_connections() const { return Udm::BooleanAttr(impl, meta_multiple_connections); }
		Udm::AClassAssocAttr< ::PICML::invoke, ::PICML::InvokePortBase> dstinvoke() const { return Udm::AClassAssocAttr< ::PICML::invoke, ::PICML::InvokePortBase>(impl, meta_dstinvoke, meta_dstinvoke_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::invoke, ::PICML::InvokePortBase, Pred> dstinvoke_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::invoke, ::PICML::InvokePortBase, Pred>(impl, meta_dstinvoke, meta_dstinvoke_rev); }
		Udm::PointerAttr< ::PICML::Provideable> ref() const { return Udm::PointerAttr< ::PICML::Provideable>(impl, meta_ref); }
		Udm::AClassAssocAttr< ::PICML::ReceptacleDelegate, ::PICML::RequiredRequestPort> dstReceptacleDelegate() const { return Udm::AClassAssocAttr< ::PICML::ReceptacleDelegate, ::PICML::RequiredRequestPort>(impl, meta_dstReceptacleDelegate, meta_dstReceptacleDelegate_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ReceptacleDelegate, ::PICML::RequiredRequestPort, Pred> dstReceptacleDelegate_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ReceptacleDelegate, ::PICML::RequiredRequestPort, Pred>(impl, meta_dstReceptacleDelegate, meta_dstReceptacleDelegate_rev); }
		Udm::AClassAssocAttr< ::PICML::ReceptacleDelegate, ::PICML::RequiredRequestPort> srcReceptacleDelegate() const { return Udm::AClassAssocAttr< ::PICML::ReceptacleDelegate, ::PICML::RequiredRequestPort>(impl, meta_srcReceptacleDelegate, meta_srcReceptacleDelegate_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::ReceptacleDelegate, ::PICML::RequiredRequestPort, Pred> srcReceptacleDelegate_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::ReceptacleDelegate, ::PICML::RequiredRequestPort, Pred>(impl, meta_srcReceptacleDelegate, meta_srcReceptacleDelegate_rev); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_RequiredRequestPort(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_multiple_connections;
		static ::Uml::AssociationRole meta_dstinvoke;
		static ::Uml::AssociationRole meta_dstinvoke_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_dstReceptacleDelegate;
		static ::Uml::AssociationRole meta_dstReceptacleDelegate_rev;
		static ::Uml::AssociationRole meta_srcReceptacleDelegate;
		static ::Uml::AssociationRole meta_srcReceptacleDelegate_rev;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly, ::PICML::ConnectedComponent, ::PICML::Path, ::PICML::Component> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::Provideable, AR_ref > _AR_ref__Provideable;
		typedef boost::mpl::vector< _AR_ref__Provideable> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstinvoke {};
		class AR_dstReceptacleDelegate {};
		class AR_srcReceptacleDelegate {};
		typedef boost::mpl::pair< ::PICML::InvokePortBase, boost::mpl::pair< ::PICML::invoke, AR_dstinvoke > > _AR_dstinvoke__invoke__InvokePortBase;
		typedef boost::mpl::pair< ::PICML::RequiredRequestPort, boost::mpl::pair< ::PICML::ReceptacleDelegate, AR_dstReceptacleDelegate > > _AR_dstReceptacleDelegate__ReceptacleDelegate__RequiredRequestPort;
		typedef boost::mpl::pair< ::PICML::RequiredRequestPort, boost::mpl::pair< ::PICML::ReceptacleDelegate, AR_srcReceptacleDelegate > > _AR_srcReceptacleDelegate__ReceptacleDelegate__RequiredRequestPort;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstinvoke__invoke__InvokePortBase, _AR_dstReceptacleDelegate__ReceptacleDelegate__RequiredRequestPort, _AR_srcReceptacleDelegate__ReceptacleDelegate__RequiredRequestPort> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export SingleOutputBase :  virtual  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		SingleOutputBase() {}
		SingleOutputBase(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		SingleOutputBase(const SingleOutputBase &master) : MgaObject(master) {}

		static SingleOutputBase Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static SingleOutputBase Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		SingleOutputBase CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<SingleOutputBase> Instances() { return Udm::InstantiatedAttr<SingleOutputBase>(impl); }
		template <class Pred> Udm::InstantiatedAttr<SingleOutputBase, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<SingleOutputBase, Pred>(impl); }
		SingleOutputBase CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<SingleOutputBase> Derived() { return Udm::DerivedAttr<SingleOutputBase>(impl); }
		template <class Pred> Udm::DerivedAttr<SingleOutputBase, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<SingleOutputBase, Pred>(impl); }
		Udm::ArchetypeAttr<SingleOutputBase> Archetype() const { return Udm::ArchetypeAttr<SingleOutputBase>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export OutEventPort :  public Port,  public SingleOutputBase {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		OutEventPort() {}
		OutEventPort(Udm::ObjectImpl *impl) : Port(impl),SingleOutputBase(impl), MgaObject(impl) {}
		OutEventPort(const OutEventPort &master) : Port(master),SingleOutputBase(master), MgaObject(master) {}

		static OutEventPort Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static OutEventPort Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		OutEventPort CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<OutEventPort> Instances() { return Udm::InstantiatedAttr<OutEventPort>(impl); }
		template <class Pred> Udm::InstantiatedAttr<OutEventPort, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<OutEventPort, Pred>(impl); }
		OutEventPort CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<OutEventPort> Derived() { return Udm::DerivedAttr<OutEventPort>(impl); }
		template <class Pred> Udm::DerivedAttr<OutEventPort, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<OutEventPort, Pred>(impl); }
		Udm::ArchetypeAttr<OutEventPort> Archetype() const { return Udm::ArchetypeAttr<OutEventPort>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr out_event_port_type() const { return Udm::StringAttr(impl, meta_out_event_port_type); }
		Udm::BooleanAttr single_destination() const { return Udm::BooleanAttr(impl, meta_single_destination); }
		Udm::AClassAssocAttr< ::PICML::publish, ::PICML::PublishConnector> dstpublish() const { return Udm::AClassAssocAttr< ::PICML::publish, ::PICML::PublishConnector>(impl, meta_dstpublish, meta_dstpublish_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::publish, ::PICML::PublishConnector, Pred> dstpublish_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::publish, ::PICML::PublishConnector, Pred>(impl, meta_dstpublish, meta_dstpublish_rev); }
		Udm::AClassPointerAttr< ::PICML::emit, ::PICML::InEventPort> dstemit() const { return Udm::AClassPointerAttr< ::PICML::emit, ::PICML::InEventPort>(impl, meta_dstemit, meta_dstemit_rev); }
		Udm::PointerAttr< ::PICML::Event> ref() const { return Udm::PointerAttr< ::PICML::Event>(impl, meta_ref); }
		Udm::AClassAssocAttr< ::PICML::EventSourceDelegate, ::PICML::OutEventPort> dstEventSourceDelegate() const { return Udm::AClassAssocAttr< ::PICML::EventSourceDelegate, ::PICML::OutEventPort>(impl, meta_dstEventSourceDelegate, meta_dstEventSourceDelegate_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::EventSourceDelegate, ::PICML::OutEventPort, Pred> dstEventSourceDelegate_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::EventSourceDelegate, ::PICML::OutEventPort, Pred>(impl, meta_dstEventSourceDelegate, meta_dstEventSourceDelegate_rev); }
		Udm::AClassAssocAttr< ::PICML::EventSourceDelegate, ::PICML::OutEventPort> srcEventSourceDelegate() const { return Udm::AClassAssocAttr< ::PICML::EventSourceDelegate, ::PICML::OutEventPort>(impl, meta_srcEventSourceDelegate, meta_srcEventSourceDelegate_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::EventSourceDelegate, ::PICML::OutEventPort, Pred> srcEventSourceDelegate_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::EventSourceDelegate, ::PICML::OutEventPort, Pred>(impl, meta_srcEventSourceDelegate, meta_srcEventSourceDelegate_rev); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_OutEventPort(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_out_event_port_type;
		static ::Uml::Attribute meta_single_destination;
		static ::Uml::AssociationRole meta_dstpublish;
		static ::Uml::AssociationRole meta_dstpublish_rev;
		static ::Uml::AssociationRole meta_dstemit;
		static ::Uml::AssociationRole meta_dstemit_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_dstEventSourceDelegate;
		static ::Uml::AssociationRole meta_dstEventSourceDelegate_rev;
		static ::Uml::AssociationRole meta_srcEventSourceDelegate;
		static ::Uml::AssociationRole meta_srcEventSourceDelegate_rev;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly, ::PICML::ConnectedComponent, ::PICML::Path, ::PICML::Component> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::Event, AR_ref > _AR_ref__Event;
		typedef boost::mpl::vector< _AR_ref__Event> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstpublish {};
		class AR_dstemit {};
		class AR_dstEventSourceDelegate {};
		class AR_srcEventSourceDelegate {};
		typedef boost::mpl::pair< ::PICML::PublishConnector, boost::mpl::pair< ::PICML::publish, AR_dstpublish > > _AR_dstpublish__publish__PublishConnector;
		typedef boost::mpl::pair< ::PICML::InEventPort, boost::mpl::pair< ::PICML::emit, AR_dstemit > > _AR_dstemit__emit__InEventPort;
		typedef boost::mpl::pair< ::PICML::OutEventPort, boost::mpl::pair< ::PICML::EventSourceDelegate, AR_dstEventSourceDelegate > > _AR_dstEventSourceDelegate__EventSourceDelegate__OutEventPort;
		typedef boost::mpl::pair< ::PICML::OutEventPort, boost::mpl::pair< ::PICML::EventSourceDelegate, AR_srcEventSourceDelegate > > _AR_srcEventSourceDelegate__EventSourceDelegate__OutEventPort;
		typedef boost::mpl::vector< _AR_dstemit__emit__InEventPort> AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstpublish__publish__PublishConnector, _AR_dstEventSourceDelegate__EventSourceDelegate__OutEventPort, _AR_srcEventSourceDelegate__EventSourceDelegate__OutEventPort> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export MultiInput :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		MultiInput() {}
		MultiInput(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		MultiInput(const MultiInput &master) : MgaObject(master) {}

		static MultiInput Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static MultiInput Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		MultiInput CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<MultiInput> Instances() { return Udm::InstantiatedAttr<MultiInput>(impl); }
		template <class Pred> Udm::InstantiatedAttr<MultiInput, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<MultiInput, Pred>(impl); }
		MultiInput CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<MultiInput> Derived() { return Udm::DerivedAttr<MultiInput>(impl); }
		template <class Pred> Udm::DerivedAttr<MultiInput, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<MultiInput, Pred>(impl); }
		Udm::ArchetypeAttr<MultiInput> Archetype() const { return Udm::ArchetypeAttr<MultiInput>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::TopLevelBehavior> TopLevelBehavior_parent() const { return Udm::ParentAttr< ::PICML::TopLevelBehavior>(impl, meta_TopLevelBehavior_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::MultiInputAction> dstMultiInput_end() const { return Udm::AssocEndAttr< ::PICML::MultiInputAction>(impl, meta_dstMultiInput_end_); }
		Udm::AssocEndAttr< ::PICML::MultiInputBase> srcMultiInput_end() const { return Udm::AssocEndAttr< ::PICML::MultiInputBase>(impl, meta_srcMultiInput_end_); }
		void Accept(Visitor &v) { v.Visit_MultiInput(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_TopLevelBehavior_parent;
		static ::Uml::AssociationRole meta_dstMultiInput_end_;
		static ::Uml::AssociationRole meta_srcMultiInput_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_TopLevelBehavior_parent {};
		typedef boost::mpl::pair< ::PICML::TopLevelBehavior, PR_TopLevelBehavior_parent > _PR_TopLevelBehavior_parent__TopLevelBehavior;
		typedef boost::mpl::vector< _PR_TopLevelBehavior_parent__TopLevelBehavior> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::TopLevelBehavior> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstMultiInput {};
		class ACE_srcMultiInput {};
		typedef boost::mpl::pair< ::PICML::MultiInputAction, ACE_dstMultiInput > _ACE_dstMultiInput__MultiInputAction;
		typedef boost::mpl::pair< ::PICML::MultiInputBase, ACE_srcMultiInput > _ACE_srcMultiInput__MultiInputBase;
		typedef boost::mpl::vector< _ACE_dstMultiInput__MultiInputAction, _ACE_srcMultiInput__MultiInputBase> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export TopLevelBehavior :  public BehaviorModel {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		TopLevelBehavior() {}
		TopLevelBehavior(Udm::ObjectImpl *impl) : BehaviorModel(impl), MgaObject(impl) {}
		TopLevelBehavior(const TopLevelBehavior &master) : BehaviorModel(master), MgaObject(master) {}

		static TopLevelBehavior Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static TopLevelBehavior Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		TopLevelBehavior CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<TopLevelBehavior> Instances() { return Udm::InstantiatedAttr<TopLevelBehavior>(impl); }
		template <class Pred> Udm::InstantiatedAttr<TopLevelBehavior, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<TopLevelBehavior, Pred>(impl); }
		TopLevelBehavior CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<TopLevelBehavior> Derived() { return Udm::DerivedAttr<TopLevelBehavior>(impl); }
		template <class Pred> Udm::DerivedAttr<TopLevelBehavior, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<TopLevelBehavior, Pred>(impl); }
		Udm::ArchetypeAttr<TopLevelBehavior> Archetype() const { return Udm::ArchetypeAttr<TopLevelBehavior>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ChildrenAttr< ::PICML::Input> Input_children() const { return Udm::ChildrenAttr< ::PICML::Input>(impl, meta_Input_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Input, Pred> Input_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Input, Pred>(impl, meta_Input_children); }
		Udm::ChildrenAttr< ::PICML::MultiInput> MultiInput_children() const { return Udm::ChildrenAttr< ::PICML::MultiInput>(impl, meta_MultiInput_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MultiInput, Pred> MultiInput_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MultiInput, Pred>(impl, meta_MultiInput_children); }
		Udm::ChildrenAttr< ::PICML::QueryInput> QueryInput_children() const { return Udm::ChildrenAttr< ::PICML::QueryInput>(impl, meta_QueryInput_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::QueryInput, Pred> QueryInput_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::QueryInput, Pred>(impl, meta_QueryInput_children); }
		Udm::ChildrenAttr< ::PICML::PeriodicEvent> PeriodicEvent_children() const { return Udm::ChildrenAttr< ::PICML::PeriodicEvent>(impl, meta_PeriodicEvent_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PeriodicEvent, Pred> PeriodicEvent_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PeriodicEvent, Pred>(impl, meta_PeriodicEvent_children); }
		Udm::ChildrenAttr< ::PICML::ApplicationTask> ApplicationTask_children() const { return Udm::ChildrenAttr< ::PICML::ApplicationTask>(impl, meta_ApplicationTask_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ApplicationTask, Pred> ApplicationTask_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ApplicationTask, Pred>(impl, meta_ApplicationTask_children); }
		Udm::ChildAttr< ::PICML::Environment> Environment_child() const { return Udm::ChildAttr< ::PICML::Environment>(impl, meta_Environment_child); }
		Udm::ChildrenAttr< ::PICML::Environment> Environment_kind_children() const { return Udm::ChildrenAttr< ::PICML::Environment>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Environment, Pred> Environment_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Environment, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::PeriodicEvent> PeriodicEvent_kind_children() const { return Udm::ChildrenAttr< ::PICML::PeriodicEvent>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::PeriodicEvent, Pred> PeriodicEvent_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::PeriodicEvent, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ApplicationTask> ApplicationTask_kind_children() const { return Udm::ChildrenAttr< ::PICML::ApplicationTask>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ApplicationTask, Pred> ApplicationTask_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ApplicationTask, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Input> Input_kind_children() const { return Udm::ChildrenAttr< ::PICML::Input>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Input, Pred> Input_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Input, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::SingleInputBase> SingleInputBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::SingleInputBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::SingleInputBase, Pred> SingleInputBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::SingleInputBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MultiInputBase> MultiInputBase_kind_children() const { return Udm::ChildrenAttr< ::PICML::MultiInputBase>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MultiInputBase, Pred> MultiInputBase_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MultiInputBase, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MultiInput> MultiInput_kind_children() const { return Udm::ChildrenAttr< ::PICML::MultiInput>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MultiInput, Pred> MultiInput_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MultiInput, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::QueryInput> QueryInput_kind_children() const { return Udm::ChildrenAttr< ::PICML::QueryInput>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::QueryInput, Pred> QueryInput_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::QueryInput, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Input_children;
		static ::Uml::CompositionChildRole meta_MultiInput_children;
		static ::Uml::CompositionChildRole meta_QueryInput_children;
		static ::Uml::CompositionChildRole meta_PeriodicEvent_children;
		static ::Uml::CompositionChildRole meta_ApplicationTask_children;
		static ::Uml::CompositionChildRole meta_Environment_child;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_Input_children {};
		class CR_MultiInput_children {};
		class CR_QueryInput_children {};
		class CR_PeriodicEvent_children {};
		class CR_ApplicationTask_children {};
		class CR_Environment_child {};
		typedef boost::mpl::pair< ::PICML::Input, CR_Input_children > _CR_Input_children__Input;
		typedef boost::mpl::pair< ::PICML::MultiInput, CR_MultiInput_children > _CR_MultiInput_children__MultiInput;
		typedef boost::mpl::pair< ::PICML::QueryInput, CR_QueryInput_children > _CR_QueryInput_children__QueryInput;
		typedef boost::mpl::pair< ::PICML::PeriodicEvent, CR_PeriodicEvent_children > _CR_PeriodicEvent_children__PeriodicEvent;
		typedef boost::mpl::pair< ::PICML::ApplicationTask, CR_ApplicationTask_children > _CR_ApplicationTask_children__ApplicationTask;
		typedef boost::mpl::pair< ::PICML::Environment, CR_Environment_child > _CR_Environment_child__Environment;
		typedef boost::mpl::vector< _CR_Environment_child__Environment> ChildrenSingle;
		typedef boost::mpl::vector< _CR_Input_children__Input, _CR_MultiInput_children__MultiInput, _CR_QueryInput_children__QueryInput, _CR_PeriodicEvent_children__PeriodicEvent, _CR_ApplicationTask_children__ApplicationTask> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::Variable, ::PICML::BehaviorInputAction, ::PICML::Action, ::PICML::OutputAction, ::PICML::Finish, ::PICML::QueryAction, ::PICML::InputAction, ::PICML::QueryInputAction, ::PICML::MultiInputAction, ::PICML::ActionBase, ::PICML::Environment, ::PICML::PeriodicEvent, ::PICML::ApplicationTask, ::PICML::Input, ::PICML::MultiInput, ::PICML::QueryInput, ::PICML::Transition, ::PICML::BranchState, ::PICML::BranchTransition, ::PICML::ForState, ::PICML::DoWhileState, ::PICML::WhileState, ::PICML::LoopState, ::PICML::LoopTransition, ::PICML::State, ::PICML::StateBase, ::PICML::Terminal, ::PICML::TerminalTransition, ::PICML::Effect, ::PICML::InputEffect, ::PICML::TerminalEffect> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Component :  public Manageable,  public SupportsInterfaces,  public NamedType,  public TopLevelBehavior {
	public:
		typedef ::Udm::ModelMetaTag MetaKind;

		Component() {}
		Component(Udm::ObjectImpl *impl) : Manageable(impl),SupportsInterfaces(impl),NamedType(impl),TopLevelBehavior(impl), MgaObject(impl) {}
		Component(const Component &master) : Manageable(master),SupportsInterfaces(master),NamedType(master),TopLevelBehavior(master), MgaObject(master) {}

		static Component Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Component Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Component CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Component> Instances() { return Udm::InstantiatedAttr<Component>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Component, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Component, Pred>(impl); }
		Component CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Component> Derived() { return Udm::DerivedAttr<Component>(impl); }
		template <class Pred> Udm::DerivedAttr<Component, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Component, Pred>(impl); }
		Udm::ArchetypeAttr<Component> Archetype() const { return Udm::ArchetypeAttr<Component>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr UUID() const { return Udm::StringAttr(impl, meta_UUID); }
		Udm::StringAttr label() const { return Udm::StringAttr(impl, meta_label); }
		Udm::AssocAttr< ::PICML::CompRef> referedbyCompRef() const { return Udm::AssocAttr< ::PICML::CompRef>(impl, meta_referedbyCompRef); }
		template <class Pred> Udm::AssocAttr< ::PICML::CompRef, Pred> referedbyCompRef_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::CompRef, Pred>(impl, meta_referedbyCompRef); }
		Udm::AClassAssocAttr< ::PICML::AssemblyselectRequirement, ::PICML::Requirement> dstAssemblyselectRequirement() const { return Udm::AClassAssocAttr< ::PICML::AssemblyselectRequirement, ::PICML::Requirement>(impl, meta_dstAssemblyselectRequirement, meta_dstAssemblyselectRequirement_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::AssemblyselectRequirement, ::PICML::Requirement, Pred> dstAssemblyselectRequirement_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::AssemblyselectRequirement, ::PICML::Requirement, Pred>(impl, meta_dstAssemblyselectRequirement, meta_dstAssemblyselectRequirement_rev); }
		Udm::AClassAssocAttr< ::PICML::AssemblyConfigProperty, ::PICML::Property> dstAssemblyConfigProperty() const { return Udm::AClassAssocAttr< ::PICML::AssemblyConfigProperty, ::PICML::Property>(impl, meta_dstAssemblyConfigProperty, meta_dstAssemblyConfigProperty_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::AssemblyConfigProperty, ::PICML::Property, Pred> dstAssemblyConfigProperty_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::AssemblyConfigProperty, ::PICML::Property, Pred>(impl, meta_dstAssemblyConfigProperty, meta_dstAssemblyConfigProperty_rev); }
		Udm::AssocAttr< ::PICML::ComponentRef> referedbyComponentRef() const { return Udm::AssocAttr< ::PICML::ComponentRef>(impl, meta_referedbyComponentRef); }
		template <class Pred> Udm::AssocAttr< ::PICML::ComponentRef, Pred> referedbyComponentRef_sorted(const Pred &) const { return Udm::AssocAttr< ::PICML::ComponentRef, Pred>(impl, meta_referedbyComponentRef); }
		Udm::ChildrenAttr< ::PICML::ReadonlyAttribute> ReadonlyAttribute_children() const { return Udm::ChildrenAttr< ::PICML::ReadonlyAttribute>(impl, meta_ReadonlyAttribute_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred> ReadonlyAttribute_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred>(impl, meta_ReadonlyAttribute_children); }
		Udm::ChildrenAttr< ::PICML::Port> Port_children() const { return Udm::ChildrenAttr< ::PICML::Port>(impl, meta_Port_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Port, Pred> Port_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Port, Pred>(impl, meta_Port_children); }
		Udm::ChildrenAttr< ::PICML::WorkerType> WorkerType_children() const { return Udm::ChildrenAttr< ::PICML::WorkerType>(impl, meta_WorkerType_children); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkerType, Pred> WorkerType_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkerType, Pred>(impl, meta_WorkerType_children); }
		Udm::ChildrenAttr< ::PICML::GraphVertex> GraphVertex_kind_children() const { return Udm::ChildrenAttr< ::PICML::GraphVertex>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::GraphVertex, Pred> GraphVertex_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::GraphVertex, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::CommonPortAttrs> CommonPortAttrs_kind_children() const { return Udm::ChildrenAttr< ::PICML::CommonPortAttrs>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::CommonPortAttrs, Pred> CommonPortAttrs_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::CommonPortAttrs, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const { return Udm::ChildrenAttr< ::PICML::Taggable>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Port> Port_kind_children() const { return Udm::ChildrenAttr< ::PICML::Port>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Port, Pred> Port_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Port, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ProvidedRequestPort> ProvidedRequestPort_kind_children() const { return Udm::ChildrenAttr< ::PICML::ProvidedRequestPort>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred> ProvidedRequestPort_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::InEventPort> InEventPort_kind_children() const { return Udm::ChildrenAttr< ::PICML::InEventPort>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::InEventPort, Pred> InEventPort_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::InEventPort, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::OutEventPort> OutEventPort_kind_children() const { return Udm::ChildrenAttr< ::PICML::OutEventPort>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::OutEventPort, Pred> OutEventPort_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::OutEventPort, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::RequiredRequestPort> RequiredRequestPort_kind_children() const { return Udm::ChildrenAttr< ::PICML::RequiredRequestPort>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred> RequiredRequestPort_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::Attribute> Attribute_kind_children() const { return Udm::ChildrenAttr< ::PICML::Attribute>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::Attribute, Pred> Attribute_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::Attribute, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::ReadonlyAttribute> ReadonlyAttribute_kind_children() const { return Udm::ChildrenAttr< ::PICML::ReadonlyAttribute>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred> ReadonlyAttribute_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::WorkerType> WorkerType_kind_children() const { return Udm::ChildrenAttr< ::PICML::WorkerType>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::WorkerType, Pred> WorkerType_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::WorkerType, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const { return Udm::ChildrenAttr< ::PICML::MgaObject>(impl, Udm::NULLCHILDROLE); }
		template <class Pred> Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, Udm::NULLCHILDROLE); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Component(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::Attribute meta_label;
		static ::Uml::AssociationRole meta_referedbyCompRef;
		static ::Uml::AssociationRole meta_dstAssemblyselectRequirement;
		static ::Uml::AssociationRole meta_dstAssemblyselectRequirement_rev;
		static ::Uml::AssociationRole meta_dstAssemblyConfigProperty;
		static ::Uml::AssociationRole meta_dstAssemblyConfigProperty_rev;
		static ::Uml::AssociationRole meta_referedbyComponentRef;
		static ::Uml::CompositionChildRole meta_ReadonlyAttribute_children;
		static ::Uml::CompositionChildRole meta_Port_children;
		static ::Uml::CompositionChildRole meta_WorkerType_children;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly, ::PICML::Package, ::PICML::File> ParentKinds;

		// types and typelist for children by returned type and role relations;
		class CR_ReadonlyAttribute_children {};
		class CR_Port_children {};
		class CR_WorkerType_children {};
		typedef boost::mpl::pair< ::PICML::ReadonlyAttribute, CR_ReadonlyAttribute_children > _CR_ReadonlyAttribute_children__ReadonlyAttribute;
		typedef boost::mpl::pair< ::PICML::Port, CR_Port_children > _CR_Port_children__Port;
		typedef boost::mpl::pair< ::PICML::WorkerType, CR_WorkerType_children > _CR_WorkerType_children__WorkerType;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< _CR_ReadonlyAttribute_children__ReadonlyAttribute, _CR_Port_children__Port, _CR_WorkerType_children__WorkerType> ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< ::PICML::ProvidedRequestPort, ::PICML::InEventPort, ::PICML::OutEventPort, ::PICML::RequiredRequestPort, ::PICML::Port, ::PICML::Supports, ::PICML::Attribute, ::PICML::ReadonlyAttribute, ::PICML::WorkerType, ::PICML::Variable, ::PICML::BehaviorInputAction, ::PICML::Action, ::PICML::OutputAction, ::PICML::Finish, ::PICML::QueryAction, ::PICML::InputAction, ::PICML::QueryInputAction, ::PICML::MultiInputAction, ::PICML::ActionBase, ::PICML::Environment, ::PICML::PeriodicEvent, ::PICML::ApplicationTask, ::PICML::Input, ::PICML::MultiInput, ::PICML::QueryInput, ::PICML::Transition, ::PICML::BranchState, ::PICML::BranchTransition, ::PICML::ForState, ::PICML::DoWhileState, ::PICML::WhileState, ::PICML::LoopState, ::PICML::LoopTransition, ::PICML::State, ::PICML::StateBase, ::PICML::Terminal, ::PICML::TerminalTransition, ::PICML::Effect, ::PICML::InputEffect, ::PICML::TerminalEffect> ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_referedbyCompRef {};
		class AR_referedbyComponentRef {};
		typedef boost::mpl::pair< ::PICML::CompRef, AR_referedbyCompRef > _AR_referedbyCompRef__CompRef;
		typedef boost::mpl::pair< ::PICML::ComponentRef, AR_referedbyComponentRef > _AR_referedbyComponentRef__ComponentRef;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< _AR_referedbyCompRef__CompRef, _AR_referedbyComponentRef__ComponentRef> AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstAssemblyselectRequirement {};
		class AR_dstAssemblyConfigProperty {};
		typedef boost::mpl::pair< ::PICML::Requirement, boost::mpl::pair< ::PICML::AssemblyselectRequirement, AR_dstAssemblyselectRequirement > > _AR_dstAssemblyselectRequirement__AssemblyselectRequirement__Requirement;
		typedef boost::mpl::pair< ::PICML::Property, boost::mpl::pair< ::PICML::AssemblyConfigProperty, AR_dstAssemblyConfigProperty > > _AR_dstAssemblyConfigProperty__AssemblyConfigProperty__Property;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstAssemblyselectRequirement__AssemblyselectRequirement__Requirement, _AR_dstAssemblyConfigProperty__AssemblyConfigProperty__Property> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export QueryInput :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		QueryInput() {}
		QueryInput(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		QueryInput(const QueryInput &master) : MgaObject(master) {}

		static QueryInput Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static QueryInput Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		QueryInput CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<QueryInput> Instances() { return Udm::InstantiatedAttr<QueryInput>(impl); }
		template <class Pred> Udm::InstantiatedAttr<QueryInput, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<QueryInput, Pred>(impl); }
		QueryInput CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<QueryInput> Derived() { return Udm::DerivedAttr<QueryInput>(impl); }
		template <class Pred> Udm::DerivedAttr<QueryInput, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<QueryInput, Pred>(impl); }
		Udm::ArchetypeAttr<QueryInput> Archetype() const { return Udm::ArchetypeAttr<QueryInput>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::TopLevelBehavior> TopLevelBehavior_parent() const { return Udm::ParentAttr< ::PICML::TopLevelBehavior>(impl, meta_TopLevelBehavior_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::QueryInputAction> dstQueryInput_end() const { return Udm::AssocEndAttr< ::PICML::QueryInputAction>(impl, meta_dstQueryInput_end_); }
		Udm::AssocEndAttr< ::PICML::QueryInputBase> srcQueryInput_end() const { return Udm::AssocEndAttr< ::PICML::QueryInputBase>(impl, meta_srcQueryInput_end_); }
		void Accept(Visitor &v) { v.Visit_QueryInput(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_TopLevelBehavior_parent;
		static ::Uml::AssociationRole meta_dstQueryInput_end_;
		static ::Uml::AssociationRole meta_srcQueryInput_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_TopLevelBehavior_parent {};
		typedef boost::mpl::pair< ::PICML::TopLevelBehavior, PR_TopLevelBehavior_parent > _PR_TopLevelBehavior_parent__TopLevelBehavior;
		typedef boost::mpl::vector< _PR_TopLevelBehavior_parent__TopLevelBehavior> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::TopLevelBehavior> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstQueryInput {};
		class ACE_srcQueryInput {};
		typedef boost::mpl::pair< ::PICML::QueryInputAction, ACE_dstQueryInput > _ACE_dstQueryInput__QueryInputAction;
		typedef boost::mpl::pair< ::PICML::QueryInputBase, ACE_srcQueryInput > _ACE_srcQueryInput__QueryInputBase;
		typedef boost::mpl::vector< _ACE_dstQueryInput__QueryInputAction, _ACE_srcQueryInput__QueryInputBase> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export QueryInputBase :  virtual  public MgaObject {
	public:
		typedef ::Udm::FCOMetaTag MetaKind;

		QueryInputBase() {}
		QueryInputBase(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		QueryInputBase(const QueryInputBase &master) : MgaObject(master) {}

		static QueryInputBase Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static QueryInputBase Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		QueryInputBase CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<QueryInputBase> Instances() { return Udm::InstantiatedAttr<QueryInputBase>(impl); }
		template <class Pred> Udm::InstantiatedAttr<QueryInputBase, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<QueryInputBase, Pred>(impl); }
		QueryInputBase CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<QueryInputBase> Derived() { return Udm::DerivedAttr<QueryInputBase>(impl); }
		template <class Pred> Udm::DerivedAttr<QueryInputBase, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<QueryInputBase, Pred>(impl); }
		Udm::ArchetypeAttr<QueryInputBase> Archetype() const { return Udm::ArchetypeAttr<QueryInputBase>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::QueryInput, ::PICML::QueryInputAction> dstQueryInput() const { return Udm::AClassPointerAttr< ::PICML::QueryInput, ::PICML::QueryInputAction>(impl, meta_dstQueryInput, meta_dstQueryInput_rev); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstQueryInput;
		static ::Uml::AssociationRole meta_dstQueryInput_rev;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstQueryInput {};
		typedef boost::mpl::pair< ::PICML::QueryInputAction, boost::mpl::pair< ::PICML::QueryInput, AR_dstQueryInput > > _AR_dstQueryInput__QueryInput__QueryInputAction;
		typedef boost::mpl::vector< _AR_dstQueryInput__QueryInput__QueryInputAction> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export InEventPort :  public Port,  public SingleInputBase,  public QueryInputBase {
	public:
		typedef ::Udm::ReferenceMetaTag MetaKind;

		InEventPort() {}
		InEventPort(Udm::ObjectImpl *impl) : Port(impl),SingleInputBase(impl),QueryInputBase(impl), MgaObject(impl) {}
		InEventPort(const InEventPort &master) : Port(master),SingleInputBase(master),QueryInputBase(master), MgaObject(master) {}

		static InEventPort Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static InEventPort Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		InEventPort CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<InEventPort> Instances() { return Udm::InstantiatedAttr<InEventPort>(impl); }
		template <class Pred> Udm::InstantiatedAttr<InEventPort, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<InEventPort, Pred>(impl); }
		InEventPort CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<InEventPort> Derived() { return Udm::DerivedAttr<InEventPort>(impl); }
		template <class Pred> Udm::DerivedAttr<InEventPort, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<InEventPort, Pred>(impl); }
		Udm::ArchetypeAttr<InEventPort> Archetype() const { return Udm::ArchetypeAttr<InEventPort>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::deliverTo, ::PICML::PublishConnector> srcdeliverTo() const { return Udm::AClassAssocAttr< ::PICML::deliverTo, ::PICML::PublishConnector>(impl, meta_srcdeliverTo, meta_srcdeliverTo_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::deliverTo, ::PICML::PublishConnector, Pred> srcdeliverTo_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::deliverTo, ::PICML::PublishConnector, Pred>(impl, meta_srcdeliverTo, meta_srcdeliverTo_rev); }
		Udm::PointerAttr< ::PICML::Event> ref() const { return Udm::PointerAttr< ::PICML::Event>(impl, meta_ref); }
		Udm::AClassAssocAttr< ::PICML::EventSinkDelegate, ::PICML::InEventPort> dstEventSinkDelegate() const { return Udm::AClassAssocAttr< ::PICML::EventSinkDelegate, ::PICML::InEventPort>(impl, meta_dstEventSinkDelegate, meta_dstEventSinkDelegate_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::EventSinkDelegate, ::PICML::InEventPort, Pred> dstEventSinkDelegate_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::EventSinkDelegate, ::PICML::InEventPort, Pred>(impl, meta_dstEventSinkDelegate, meta_dstEventSinkDelegate_rev); }
		Udm::AClassAssocAttr< ::PICML::EventSinkDelegate, ::PICML::InEventPort> srcEventSinkDelegate() const { return Udm::AClassAssocAttr< ::PICML::EventSinkDelegate, ::PICML::InEventPort>(impl, meta_srcEventSinkDelegate, meta_srcEventSinkDelegate_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::EventSinkDelegate, ::PICML::InEventPort, Pred> srcEventSinkDelegate_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::EventSinkDelegate, ::PICML::InEventPort, Pred>(impl, meta_srcEventSinkDelegate, meta_srcEventSinkDelegate_rev); }
		Udm::AClassAssocAttr< ::PICML::emit, ::PICML::OutEventPort> srcemit() const { return Udm::AClassAssocAttr< ::PICML::emit, ::PICML::OutEventPort>(impl, meta_srcemit, meta_srcemit_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::emit, ::PICML::OutEventPort, Pred> srcemit_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::emit, ::PICML::OutEventPort, Pred>(impl, meta_srcemit, meta_srcemit_rev); }
		Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const { return Udm::ParentAttr< ::PICML::ComponentAssembly>(impl, meta_ComponentAssembly_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_InEventPort(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcdeliverTo;
		static ::Uml::AssociationRole meta_srcdeliverTo_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_dstEventSinkDelegate;
		static ::Uml::AssociationRole meta_dstEventSinkDelegate_rev;
		static ::Uml::AssociationRole meta_srcEventSinkDelegate;
		static ::Uml::AssociationRole meta_srcEventSinkDelegate_rev;
		static ::Uml::AssociationRole meta_srcemit;
		static ::Uml::AssociationRole meta_srcemit_rev;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_ComponentAssembly_parent {};
		typedef boost::mpl::pair< ::PICML::ComponentAssembly, PR_ComponentAssembly_parent > _PR_ComponentAssembly_parent__ComponentAssembly;
		typedef boost::mpl::vector< _PR_ComponentAssembly_parent__ComponentAssembly> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::ComponentAssembly, ::PICML::ConnectedComponent, ::PICML::Path, ::PICML::Component> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		class AR_ref {};
		typedef boost::mpl::pair< ::PICML::Event, AR_ref > _AR_ref__Event;
		typedef boost::mpl::vector< _AR_ref__Event> AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcdeliverTo {};
		class AR_dstEventSinkDelegate {};
		class AR_srcEventSinkDelegate {};
		class AR_srcemit {};
		typedef boost::mpl::pair< ::PICML::PublishConnector, boost::mpl::pair< ::PICML::deliverTo, AR_srcdeliverTo > > _AR_srcdeliverTo__deliverTo__PublishConnector;
		typedef boost::mpl::pair< ::PICML::InEventPort, boost::mpl::pair< ::PICML::EventSinkDelegate, AR_dstEventSinkDelegate > > _AR_dstEventSinkDelegate__EventSinkDelegate__InEventPort;
		typedef boost::mpl::pair< ::PICML::InEventPort, boost::mpl::pair< ::PICML::EventSinkDelegate, AR_srcEventSinkDelegate > > _AR_srcEventSinkDelegate__EventSinkDelegate__InEventPort;
		typedef boost::mpl::pair< ::PICML::OutEventPort, boost::mpl::pair< ::PICML::emit, AR_srcemit > > _AR_srcemit__emit__OutEventPort;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcdeliverTo__deliverTo__PublishConnector, _AR_dstEventSinkDelegate__EventSinkDelegate__InEventPort, _AR_srcEventSinkDelegate__EventSinkDelegate__InEventPort, _AR_srcemit__emit__OutEventPort> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Transition :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		Transition() {}
		Transition(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Transition(const Transition &master) : MgaObject(master) {}

		static Transition Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Transition Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Transition CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Transition> Instances() { return Udm::InstantiatedAttr<Transition>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Transition, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Transition, Pred>(impl); }
		Transition CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Transition> Derived() { return Udm::DerivedAttr<Transition>(impl); }
		template <class Pred> Udm::DerivedAttr<Transition, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Transition, Pred>(impl); }
		Udm::ArchetypeAttr<Transition> Archetype() const { return Udm::ArchetypeAttr<Transition>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const { return Udm::ParentAttr< ::PICML::BehaviorModel>(impl, meta_BehaviorModel_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ActionBase> dstTransition_end() const { return Udm::AssocEndAttr< ::PICML::ActionBase>(impl, meta_dstTransition_end_); }
		Udm::AssocEndAttr< ::PICML::State> srcTransition_end() const { return Udm::AssocEndAttr< ::PICML::State>(impl, meta_srcTransition_end_); }
		void Accept(Visitor &v) { v.Visit_Transition(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;
		static ::Uml::AssociationRole meta_dstTransition_end_;
		static ::Uml::AssociationRole meta_srcTransition_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_BehaviorModel_parent {};
		typedef boost::mpl::pair< ::PICML::BehaviorModel, PR_BehaviorModel_parent > _PR_BehaviorModel_parent__BehaviorModel;
		typedef boost::mpl::vector< _PR_BehaviorModel_parent__BehaviorModel> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstTransition {};
		class ACE_srcTransition {};
		typedef boost::mpl::pair< ::PICML::ActionBase, ACE_dstTransition > _ACE_dstTransition__ActionBase;
		typedef boost::mpl::pair< ::PICML::State, ACE_srcTransition > _ACE_srcTransition__State;
		typedef boost::mpl::vector< _ACE_dstTransition__ActionBase, _ACE_srcTransition__State> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export BranchTransition :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		BranchTransition() {}
		BranchTransition(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		BranchTransition(const BranchTransition &master) : MgaObject(master) {}

		static BranchTransition Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static BranchTransition Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		BranchTransition CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<BranchTransition> Instances() { return Udm::InstantiatedAttr<BranchTransition>(impl); }
		template <class Pred> Udm::InstantiatedAttr<BranchTransition, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<BranchTransition, Pred>(impl); }
		BranchTransition CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<BranchTransition> Derived() { return Udm::DerivedAttr<BranchTransition>(impl); }
		template <class Pred> Udm::DerivedAttr<BranchTransition, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<BranchTransition, Pred>(impl); }
		Udm::ArchetypeAttr<BranchTransition> Archetype() const { return Udm::ArchetypeAttr<BranchTransition>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr Condition() const { return Udm::StringAttr(impl, meta_Condition); }
		Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const { return Udm::ParentAttr< ::PICML::BehaviorModel>(impl, meta_BehaviorModel_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ActionBase> dstBranchTransition_end() const { return Udm::AssocEndAttr< ::PICML::ActionBase>(impl, meta_dstBranchTransition_end_); }
		Udm::AssocEndAttr< ::PICML::BranchState> srcBranchTransition_end() const { return Udm::AssocEndAttr< ::PICML::BranchState>(impl, meta_srcBranchTransition_end_); }
		void Accept(Visitor &v) { v.Visit_BranchTransition(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Condition;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;
		static ::Uml::AssociationRole meta_dstBranchTransition_end_;
		static ::Uml::AssociationRole meta_srcBranchTransition_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_BehaviorModel_parent {};
		typedef boost::mpl::pair< ::PICML::BehaviorModel, PR_BehaviorModel_parent > _PR_BehaviorModel_parent__BehaviorModel;
		typedef boost::mpl::vector< _PR_BehaviorModel_parent__BehaviorModel> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstBranchTransition {};
		class ACE_srcBranchTransition {};
		typedef boost::mpl::pair< ::PICML::ActionBase, ACE_dstBranchTransition > _ACE_dstBranchTransition__ActionBase;
		typedef boost::mpl::pair< ::PICML::BranchState, ACE_srcBranchTransition > _ACE_srcBranchTransition__BranchState;
		typedef boost::mpl::vector< _ACE_dstBranchTransition__ActionBase, _ACE_srcBranchTransition__BranchState> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export LoopTransition :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		LoopTransition() {}
		LoopTransition(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		LoopTransition(const LoopTransition &master) : MgaObject(master) {}

		static LoopTransition Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static LoopTransition Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		LoopTransition CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<LoopTransition> Instances() { return Udm::InstantiatedAttr<LoopTransition>(impl); }
		template <class Pred> Udm::InstantiatedAttr<LoopTransition, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<LoopTransition, Pred>(impl); }
		LoopTransition CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<LoopTransition> Derived() { return Udm::DerivedAttr<LoopTransition>(impl); }
		template <class Pred> Udm::DerivedAttr<LoopTransition, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<LoopTransition, Pred>(impl); }
		Udm::ArchetypeAttr<LoopTransition> Archetype() const { return Udm::ArchetypeAttr<LoopTransition>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const { return Udm::ParentAttr< ::PICML::BehaviorModel>(impl, meta_BehaviorModel_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ActionBase> dstLoopTransition_end() const { return Udm::AssocEndAttr< ::PICML::ActionBase>(impl, meta_dstLoopTransition_end_); }
		Udm::AssocEndAttr< ::PICML::LoopState> srcLoopTransition_end() const { return Udm::AssocEndAttr< ::PICML::LoopState>(impl, meta_srcLoopTransition_end_); }
		void Accept(Visitor &v) { v.Visit_LoopTransition(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;
		static ::Uml::AssociationRole meta_dstLoopTransition_end_;
		static ::Uml::AssociationRole meta_srcLoopTransition_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_BehaviorModel_parent {};
		typedef boost::mpl::pair< ::PICML::BehaviorModel, PR_BehaviorModel_parent > _PR_BehaviorModel_parent__BehaviorModel;
		typedef boost::mpl::vector< _PR_BehaviorModel_parent__BehaviorModel> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstLoopTransition {};
		class ACE_srcLoopTransition {};
		typedef boost::mpl::pair< ::PICML::ActionBase, ACE_dstLoopTransition > _ACE_dstLoopTransition__ActionBase;
		typedef boost::mpl::pair< ::PICML::LoopState, ACE_srcLoopTransition > _ACE_srcLoopTransition__LoopState;
		typedef boost::mpl::vector< _ACE_dstLoopTransition__ActionBase, _ACE_srcLoopTransition__LoopState> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export StateBase :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		StateBase() {}
		StateBase(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		StateBase(const StateBase &master) : MgaObject(master) {}

		static StateBase Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static StateBase Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		StateBase CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<StateBase> Instances() { return Udm::InstantiatedAttr<StateBase>(impl); }
		template <class Pred> Udm::InstantiatedAttr<StateBase, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<StateBase, Pred>(impl); }
		StateBase CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<StateBase> Derived() { return Udm::DerivedAttr<StateBase>(impl); }
		template <class Pred> Udm::DerivedAttr<StateBase, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<StateBase, Pred>(impl); }
		Udm::ArchetypeAttr<StateBase> Archetype() const { return Udm::ArchetypeAttr<StateBase>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::Finish, ::PICML::BehaviorInputAction> dstFinish() const { return Udm::AClassAssocAttr< ::PICML::Finish, ::PICML::BehaviorInputAction>(impl, meta_dstFinish, meta_dstFinish_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::Finish, ::PICML::BehaviorInputAction, Pred> dstFinish_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::Finish, ::PICML::BehaviorInputAction, Pred>(impl, meta_dstFinish, meta_dstFinish_rev); }
		Udm::AClassAssocAttr< ::PICML::InputEffect, ::PICML::BehaviorInputAction> srcInputEffect() const { return Udm::AClassAssocAttr< ::PICML::InputEffect, ::PICML::BehaviorInputAction>(impl, meta_srcInputEffect, meta_srcInputEffect_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::InputEffect, ::PICML::BehaviorInputAction, Pred> srcInputEffect_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::InputEffect, ::PICML::BehaviorInputAction, Pred>(impl, meta_srcInputEffect, meta_srcInputEffect_rev); }
		Udm::AClassAssocAttr< ::PICML::Effect, ::PICML::ActionBase> srcEffect() const { return Udm::AClassAssocAttr< ::PICML::Effect, ::PICML::ActionBase>(impl, meta_srcEffect, meta_srcEffect_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::Effect, ::PICML::ActionBase, Pred> srcEffect_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::Effect, ::PICML::ActionBase, Pred>(impl, meta_srcEffect, meta_srcEffect_rev); }
		Udm::AClassPointerAttr< ::PICML::TerminalEffect, ::PICML::Terminal> srcTerminalEffect() const { return Udm::AClassPointerAttr< ::PICML::TerminalEffect, ::PICML::Terminal>(impl, meta_srcTerminalEffect, meta_srcTerminalEffect_rev); }
		Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const { return Udm::ParentAttr< ::PICML::BehaviorModel>(impl, meta_BehaviorModel_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstFinish;
		static ::Uml::AssociationRole meta_dstFinish_rev;
		static ::Uml::AssociationRole meta_srcInputEffect;
		static ::Uml::AssociationRole meta_srcInputEffect_rev;
		static ::Uml::AssociationRole meta_srcEffect;
		static ::Uml::AssociationRole meta_srcEffect_rev;
		static ::Uml::AssociationRole meta_srcTerminalEffect;
		static ::Uml::AssociationRole meta_srcTerminalEffect_rev;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_BehaviorModel_parent {};
		typedef boost::mpl::pair< ::PICML::BehaviorModel, PR_BehaviorModel_parent > _PR_BehaviorModel_parent__BehaviorModel;
		typedef boost::mpl::vector< _PR_BehaviorModel_parent__BehaviorModel> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstFinish {};
		class AR_srcInputEffect {};
		class AR_srcEffect {};
		class AR_srcTerminalEffect {};
		typedef boost::mpl::pair< ::PICML::BehaviorInputAction, boost::mpl::pair< ::PICML::Finish, AR_dstFinish > > _AR_dstFinish__Finish__BehaviorInputAction;
		typedef boost::mpl::pair< ::PICML::BehaviorInputAction, boost::mpl::pair< ::PICML::InputEffect, AR_srcInputEffect > > _AR_srcInputEffect__InputEffect__BehaviorInputAction;
		typedef boost::mpl::pair< ::PICML::ActionBase, boost::mpl::pair< ::PICML::Effect, AR_srcEffect > > _AR_srcEffect__Effect__ActionBase;
		typedef boost::mpl::pair< ::PICML::Terminal, boost::mpl::pair< ::PICML::TerminalEffect, AR_srcTerminalEffect > > _AR_srcTerminalEffect__TerminalEffect__Terminal;
		typedef boost::mpl::vector< _AR_srcTerminalEffect__TerminalEffect__Terminal> AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstFinish__Finish__BehaviorInputAction, _AR_srcInputEffect__InputEffect__BehaviorInputAction, _AR_srcEffect__Effect__ActionBase> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export BranchState :  public StateBase {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		BranchState() {}
		BranchState(Udm::ObjectImpl *impl) : StateBase(impl) {}
		BranchState(const BranchState &master) : StateBase(master) {}

		static BranchState Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static BranchState Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		BranchState CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<BranchState> Instances() { return Udm::InstantiatedAttr<BranchState>(impl); }
		template <class Pred> Udm::InstantiatedAttr<BranchState, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<BranchState, Pred>(impl); }
		BranchState CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<BranchState> Derived() { return Udm::DerivedAttr<BranchState>(impl); }
		template <class Pred> Udm::DerivedAttr<BranchState, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<BranchState, Pred>(impl); }
		Udm::ArchetypeAttr<BranchState> Archetype() const { return Udm::ArchetypeAttr<BranchState>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::BranchTransition, ::PICML::ActionBase> dstBranchTransition() const { return Udm::AClassAssocAttr< ::PICML::BranchTransition, ::PICML::ActionBase>(impl, meta_dstBranchTransition, meta_dstBranchTransition_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::BranchTransition, ::PICML::ActionBase, Pred> dstBranchTransition_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::BranchTransition, ::PICML::ActionBase, Pred>(impl, meta_dstBranchTransition, meta_dstBranchTransition_rev); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_BranchState(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstBranchTransition;
		static ::Uml::AssociationRole meta_dstBranchTransition_rev;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstBranchTransition {};
		typedef boost::mpl::pair< ::PICML::ActionBase, boost::mpl::pair< ::PICML::BranchTransition, AR_dstBranchTransition > > _AR_dstBranchTransition__BranchTransition__ActionBase;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_dstBranchTransition__BranchTransition__ActionBase> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export LoopState :  public StateBase {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		LoopState() {}
		LoopState(Udm::ObjectImpl *impl) : StateBase(impl) {}
		LoopState(const LoopState &master) : StateBase(master) {}

		static LoopState Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static LoopState Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		LoopState CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<LoopState> Instances() { return Udm::InstantiatedAttr<LoopState>(impl); }
		template <class Pred> Udm::InstantiatedAttr<LoopState, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<LoopState, Pred>(impl); }
		LoopState CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<LoopState> Derived() { return Udm::DerivedAttr<LoopState>(impl); }
		template <class Pred> Udm::DerivedAttr<LoopState, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<LoopState, Pred>(impl); }
		Udm::ArchetypeAttr<LoopState> Archetype() const { return Udm::ArchetypeAttr<LoopState>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr LoopingCondition() const { return Udm::StringAttr(impl, meta_LoopingCondition); }
		Udm::AClassPointerAttr< ::PICML::LoopTransition, ::PICML::ActionBase> dstLoopTransition() const { return Udm::AClassPointerAttr< ::PICML::LoopTransition, ::PICML::ActionBase>(impl, meta_dstLoopTransition, meta_dstLoopTransition_rev); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_LoopingCondition;
		static ::Uml::AssociationRole meta_dstLoopTransition;
		static ::Uml::AssociationRole meta_dstLoopTransition_rev;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstLoopTransition {};
		typedef boost::mpl::pair< ::PICML::ActionBase, boost::mpl::pair< ::PICML::LoopTransition, AR_dstLoopTransition > > _AR_dstLoopTransition__LoopTransition__ActionBase;
		typedef boost::mpl::vector< _AR_dstLoopTransition__LoopTransition__ActionBase> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export ForState :  public LoopState {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		ForState() {}
		ForState(Udm::ObjectImpl *impl) : LoopState(impl) {}
		ForState(const ForState &master) : LoopState(master) {}

		static ForState Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static ForState Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		ForState CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<ForState> Instances() { return Udm::InstantiatedAttr<ForState>(impl); }
		template <class Pred> Udm::InstantiatedAttr<ForState, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<ForState, Pred>(impl); }
		ForState CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<ForState> Derived() { return Udm::DerivedAttr<ForState>(impl); }
		template <class Pred> Udm::DerivedAttr<ForState, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<ForState, Pred>(impl); }
		Udm::ArchetypeAttr<ForState> Archetype() const { return Udm::ArchetypeAttr<ForState>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr IncrementExpr() const { return Udm::StringAttr(impl, meta_IncrementExpr); }
		Udm::StringAttr InitialCondition() const { return Udm::StringAttr(impl, meta_InitialCondition); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_ForState(*this); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_IncrementExpr;
		static ::Uml::Attribute meta_InitialCondition;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export DoWhileState :  public LoopState {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		DoWhileState() {}
		DoWhileState(Udm::ObjectImpl *impl) : LoopState(impl) {}
		DoWhileState(const DoWhileState &master) : LoopState(master) {}

		static DoWhileState Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static DoWhileState Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		DoWhileState CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<DoWhileState> Instances() { return Udm::InstantiatedAttr<DoWhileState>(impl); }
		template <class Pred> Udm::InstantiatedAttr<DoWhileState, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<DoWhileState, Pred>(impl); }
		DoWhileState CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<DoWhileState> Derived() { return Udm::DerivedAttr<DoWhileState>(impl); }
		template <class Pred> Udm::DerivedAttr<DoWhileState, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<DoWhileState, Pred>(impl); }
		Udm::ArchetypeAttr<DoWhileState> Archetype() const { return Udm::ArchetypeAttr<DoWhileState>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_DoWhileState(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export WhileState :  public LoopState {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		WhileState() {}
		WhileState(Udm::ObjectImpl *impl) : LoopState(impl) {}
		WhileState(const WhileState &master) : LoopState(master) {}

		static WhileState Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static WhileState Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		WhileState CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<WhileState> Instances() { return Udm::InstantiatedAttr<WhileState>(impl); }
		template <class Pred> Udm::InstantiatedAttr<WhileState, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<WhileState, Pred>(impl); }
		WhileState CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<WhileState> Derived() { return Udm::DerivedAttr<WhileState>(impl); }
		template <class Pred> Udm::DerivedAttr<WhileState, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<WhileState, Pred>(impl); }
		Udm::ArchetypeAttr<WhileState> Archetype() const { return Udm::ArchetypeAttr<WhileState>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_WhileState(*this); }

		static ::Uml::Class meta;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export State :  public StateBase {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		State() {}
		State(Udm::ObjectImpl *impl) : StateBase(impl) {}
		State(const State &master) : StateBase(master) {}

		static State Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static State Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		State CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<State> Instances() { return Udm::InstantiatedAttr<State>(impl); }
		template <class Pred> Udm::InstantiatedAttr<State, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<State, Pred>(impl); }
		State CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<State> Derived() { return Udm::DerivedAttr<State>(impl); }
		template <class Pred> Udm::DerivedAttr<State, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<State, Pred>(impl); }
		Udm::ArchetypeAttr<State> Archetype() const { return Udm::ArchetypeAttr<State>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassPointerAttr< ::PICML::Transition, ::PICML::ActionBase> dstTransition() const { return Udm::AClassPointerAttr< ::PICML::Transition, ::PICML::ActionBase>(impl, meta_dstTransition, meta_dstTransition_rev); }
		Udm::AClassPointerAttr< ::PICML::TerminalTransition, ::PICML::Terminal> dstTerminalTransition() const { return Udm::AClassPointerAttr< ::PICML::TerminalTransition, ::PICML::Terminal>(impl, meta_dstTerminalTransition, meta_dstTerminalTransition_rev); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_State(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstTransition;
		static ::Uml::AssociationRole meta_dstTransition_rev;
		static ::Uml::AssociationRole meta_dstTerminalTransition;
		static ::Uml::AssociationRole meta_dstTerminalTransition_rev;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_dstTransition {};
		class AR_dstTerminalTransition {};
		typedef boost::mpl::pair< ::PICML::ActionBase, boost::mpl::pair< ::PICML::Transition, AR_dstTransition > > _AR_dstTransition__Transition__ActionBase;
		typedef boost::mpl::pair< ::PICML::Terminal, boost::mpl::pair< ::PICML::TerminalTransition, AR_dstTerminalTransition > > _AR_dstTerminalTransition__TerminalTransition__Terminal;
		typedef boost::mpl::vector< _AR_dstTransition__Transition__ActionBase, _AR_dstTerminalTransition__TerminalTransition__Terminal> AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Terminal :  public MgaObject {
	public:
		typedef ::Udm::AtomMetaTag MetaKind;

		Terminal() {}
		Terminal(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		Terminal(const Terminal &master) : MgaObject(master) {}

		static Terminal Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Terminal Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Terminal CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Terminal> Instances() { return Udm::InstantiatedAttr<Terminal>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Terminal, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Terminal, Pred>(impl); }
		Terminal CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Terminal> Derived() { return Udm::DerivedAttr<Terminal>(impl); }
		template <class Pred> Udm::DerivedAttr<Terminal, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Terminal, Pred>(impl); }
		Udm::ArchetypeAttr<Terminal> Archetype() const { return Udm::ArchetypeAttr<Terminal>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::AClassAssocAttr< ::PICML::TerminalTransition, ::PICML::State> srcTerminalTransition() const { return Udm::AClassAssocAttr< ::PICML::TerminalTransition, ::PICML::State>(impl, meta_srcTerminalTransition, meta_srcTerminalTransition_rev); }
		template <class Pred> Udm::AClassAssocAttr< ::PICML::TerminalTransition, ::PICML::State, Pred> srcTerminalTransition_sorted(const Pred &) const { return Udm::AClassAssocAttr< ::PICML::TerminalTransition, ::PICML::State, Pred>(impl, meta_srcTerminalTransition, meta_srcTerminalTransition_rev); }
		Udm::AClassPointerAttr< ::PICML::TerminalEffect, ::PICML::StateBase> dstTerminalEffect() const { return Udm::AClassPointerAttr< ::PICML::TerminalEffect, ::PICML::StateBase>(impl, meta_dstTerminalEffect, meta_dstTerminalEffect_rev); }
		Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const { return Udm::ParentAttr< ::PICML::BehaviorModel>(impl, meta_BehaviorModel_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		void Accept(Visitor &v) { v.Visit_Terminal(*this); }

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcTerminalTransition;
		static ::Uml::AssociationRole meta_srcTerminalTransition_rev;
		static ::Uml::AssociationRole meta_dstTerminalEffect;
		static ::Uml::AssociationRole meta_dstTerminalEffect_rev;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;

		// types and typelist for parent by returned type and role relations;
		class PR_BehaviorModel_parent {};
		typedef boost::mpl::pair< ::PICML::BehaviorModel, PR_BehaviorModel_parent > _PR_BehaviorModel_parent__BehaviorModel;
		typedef boost::mpl::vector< _PR_BehaviorModel_parent__BehaviorModel> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		class AR_srcTerminalTransition {};
		class AR_dstTerminalEffect {};
		typedef boost::mpl::pair< ::PICML::State, boost::mpl::pair< ::PICML::TerminalTransition, AR_srcTerminalTransition > > _AR_srcTerminalTransition__TerminalTransition__State;
		typedef boost::mpl::pair< ::PICML::StateBase, boost::mpl::pair< ::PICML::TerminalEffect, AR_dstTerminalEffect > > _AR_dstTerminalEffect__TerminalEffect__StateBase;
		typedef boost::mpl::vector< _AR_dstTerminalEffect__TerminalEffect__StateBase> AssociationsWAClassSingle;
		typedef boost::mpl::vector< _AR_srcTerminalTransition__TerminalTransition__State> AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export TerminalTransition :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		TerminalTransition() {}
		TerminalTransition(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		TerminalTransition(const TerminalTransition &master) : MgaObject(master) {}

		static TerminalTransition Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static TerminalTransition Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		TerminalTransition CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<TerminalTransition> Instances() { return Udm::InstantiatedAttr<TerminalTransition>(impl); }
		template <class Pred> Udm::InstantiatedAttr<TerminalTransition, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<TerminalTransition, Pred>(impl); }
		TerminalTransition CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<TerminalTransition> Derived() { return Udm::DerivedAttr<TerminalTransition>(impl); }
		template <class Pred> Udm::DerivedAttr<TerminalTransition, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<TerminalTransition, Pred>(impl); }
		Udm::ArchetypeAttr<TerminalTransition> Archetype() const { return Udm::ArchetypeAttr<TerminalTransition>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const { return Udm::ParentAttr< ::PICML::BehaviorModel>(impl, meta_BehaviorModel_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::State> srcTerminalTransition_end() const { return Udm::AssocEndAttr< ::PICML::State>(impl, meta_srcTerminalTransition_end_); }
		Udm::AssocEndAttr< ::PICML::Terminal> dstTerminalTransition_end() const { return Udm::AssocEndAttr< ::PICML::Terminal>(impl, meta_dstTerminalTransition_end_); }
		void Accept(Visitor &v) { v.Visit_TerminalTransition(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;
		static ::Uml::AssociationRole meta_srcTerminalTransition_end_;
		static ::Uml::AssociationRole meta_dstTerminalTransition_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_BehaviorModel_parent {};
		typedef boost::mpl::pair< ::PICML::BehaviorModel, PR_BehaviorModel_parent > _PR_BehaviorModel_parent__BehaviorModel;
		typedef boost::mpl::vector< _PR_BehaviorModel_parent__BehaviorModel> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcTerminalTransition {};
		class ACE_dstTerminalTransition {};
		typedef boost::mpl::pair< ::PICML::State, ACE_srcTerminalTransition > _ACE_srcTerminalTransition__State;
		typedef boost::mpl::pair< ::PICML::Terminal, ACE_dstTerminalTransition > _ACE_dstTerminalTransition__Terminal;
		typedef boost::mpl::vector< _ACE_srcTerminalTransition__State, _ACE_dstTerminalTransition__Terminal> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export EffectBase :  public MgaObject {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		EffectBase() {}
		EffectBase(Udm::ObjectImpl *impl) : MgaObject(impl) {}
		EffectBase(const EffectBase &master) : MgaObject(master) {}

		static EffectBase Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static EffectBase Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		EffectBase CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<EffectBase> Instances() { return Udm::InstantiatedAttr<EffectBase>(impl); }
		template <class Pred> Udm::InstantiatedAttr<EffectBase, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<EffectBase, Pred>(impl); }
		EffectBase CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<EffectBase> Derived() { return Udm::DerivedAttr<EffectBase>(impl); }
		template <class Pred> Udm::DerivedAttr<EffectBase, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<EffectBase, Pred>(impl); }
		Udm::ArchetypeAttr<EffectBase> Archetype() const { return Udm::ArchetypeAttr<EffectBase>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::StringAttr Postcondition() const { return Udm::StringAttr(impl, meta_Postcondition); }
		Udm::ParentAttr<Udm::Object> parent() const { return Udm::ParentAttr<Udm::Object>(impl, Udm::NULLPARENTROLE); }

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Postcondition;

		// types and typelist for parent by returned type and role relations;
		typedef boost::mpl::vector< > Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< > ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		typedef boost::mpl::vector< > AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export Effect :  public EffectBase {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		Effect() {}
		Effect(Udm::ObjectImpl *impl) : EffectBase(impl) {}
		Effect(const Effect &master) : EffectBase(master) {}

		static Effect Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static Effect Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		Effect CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<Effect> Instances() { return Udm::InstantiatedAttr<Effect>(impl); }
		template <class Pred> Udm::InstantiatedAttr<Effect, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<Effect, Pred>(impl); }
		Effect CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<Effect> Derived() { return Udm::DerivedAttr<Effect>(impl); }
		template <class Pred> Udm::DerivedAttr<Effect, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<Effect, Pred>(impl); }
		Udm::ArchetypeAttr<Effect> Archetype() const { return Udm::ArchetypeAttr<Effect>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const { return Udm::ParentAttr< ::PICML::BehaviorModel>(impl, meta_BehaviorModel_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::ActionBase> srcEffect_end() const { return Udm::AssocEndAttr< ::PICML::ActionBase>(impl, meta_srcEffect_end_); }
		Udm::AssocEndAttr< ::PICML::StateBase> dstEffect_end() const { return Udm::AssocEndAttr< ::PICML::StateBase>(impl, meta_dstEffect_end_); }
		void Accept(Visitor &v) { v.Visit_Effect(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;
		static ::Uml::AssociationRole meta_srcEffect_end_;
		static ::Uml::AssociationRole meta_dstEffect_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_BehaviorModel_parent {};
		typedef boost::mpl::pair< ::PICML::BehaviorModel, PR_BehaviorModel_parent > _PR_BehaviorModel_parent__BehaviorModel;
		typedef boost::mpl::vector< _PR_BehaviorModel_parent__BehaviorModel> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcEffect {};
		class ACE_dstEffect {};
		typedef boost::mpl::pair< ::PICML::ActionBase, ACE_srcEffect > _ACE_srcEffect__ActionBase;
		typedef boost::mpl::pair< ::PICML::StateBase, ACE_dstEffect > _ACE_dstEffect__StateBase;
		typedef boost::mpl::vector< _ACE_srcEffect__ActionBase, _ACE_dstEffect__StateBase> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export InputEffect :  public EffectBase {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		InputEffect() {}
		InputEffect(Udm::ObjectImpl *impl) : EffectBase(impl) {}
		InputEffect(const InputEffect &master) : EffectBase(master) {}

		static InputEffect Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static InputEffect Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		InputEffect CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<InputEffect> Instances() { return Udm::InstantiatedAttr<InputEffect>(impl); }
		template <class Pred> Udm::InstantiatedAttr<InputEffect, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<InputEffect, Pred>(impl); }
		InputEffect CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<InputEffect> Derived() { return Udm::DerivedAttr<InputEffect>(impl); }
		template <class Pred> Udm::DerivedAttr<InputEffect, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<InputEffect, Pred>(impl); }
		Udm::ArchetypeAttr<InputEffect> Archetype() const { return Udm::ArchetypeAttr<InputEffect>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const { return Udm::ParentAttr< ::PICML::BehaviorModel>(impl, meta_BehaviorModel_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::BehaviorInputAction> srcInputEffect_end() const { return Udm::AssocEndAttr< ::PICML::BehaviorInputAction>(impl, meta_srcInputEffect_end_); }
		Udm::AssocEndAttr< ::PICML::StateBase> dstInputEffect_end() const { return Udm::AssocEndAttr< ::PICML::StateBase>(impl, meta_dstInputEffect_end_); }
		void Accept(Visitor &v) { v.Visit_InputEffect(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;
		static ::Uml::AssociationRole meta_srcInputEffect_end_;
		static ::Uml::AssociationRole meta_dstInputEffect_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_BehaviorModel_parent {};
		typedef boost::mpl::pair< ::PICML::BehaviorModel, PR_BehaviorModel_parent > _PR_BehaviorModel_parent__BehaviorModel;
		typedef boost::mpl::vector< _PR_BehaviorModel_parent__BehaviorModel> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_srcInputEffect {};
		class ACE_dstInputEffect {};
		typedef boost::mpl::pair< ::PICML::BehaviorInputAction, ACE_srcInputEffect > _ACE_srcInputEffect__BehaviorInputAction;
		typedef boost::mpl::pair< ::PICML::StateBase, ACE_dstInputEffect > _ACE_dstInputEffect__StateBase;
		typedef boost::mpl::vector< _ACE_srcInputEffect__BehaviorInputAction, _ACE_dstInputEffect__StateBase> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

	class PICML_Export TerminalEffect :  public EffectBase {
	public:
		typedef ::Udm::ConnectionMetaTag MetaKind;

		TerminalEffect() {}
		TerminalEffect(Udm::ObjectImpl *impl) : EffectBase(impl) {}
		TerminalEffect(const TerminalEffect &master) : EffectBase(master) {}

		static TerminalEffect Cast(const Udm::Object &a) { return __Cast(a, meta); }
		static TerminalEffect Create(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role); }
		TerminalEffect CreateInstance(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::InstantiatedAttr<TerminalEffect> Instances() { return Udm::InstantiatedAttr<TerminalEffect>(impl); }
		template <class Pred> Udm::InstantiatedAttr<TerminalEffect, Pred> Instances_sorted(const Pred &) { return Udm::InstantiatedAttr<TerminalEffect, Pred>(impl); }
		TerminalEffect CreateDerived(const Udm::Object &parent, const ::Uml::CompositionChildRole &role = Udm::NULLCHILDROLE) { return __Create(meta, parent, role, impl); }
		Udm::DerivedAttr<TerminalEffect> Derived() { return Udm::DerivedAttr<TerminalEffect>(impl); }
		template <class Pred> Udm::DerivedAttr<TerminalEffect, Pred> Derived_sorted(const Pred &) { return Udm::DerivedAttr<TerminalEffect, Pred>(impl); }
		Udm::ArchetypeAttr<TerminalEffect> Archetype() const { return Udm::ArchetypeAttr<TerminalEffect>(impl); }
		template <typename T> const ::Uml::AssociationRole& _type2ARole() const;
		template <typename T> const pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> _type2ACARole() const;
		template <typename T> const ::Uml::CompositionParentRole& _type2CPRole() const;
		template <typename T> const ::Uml::CompositionChildRole& _type2CCRole() const;
		template <class PeerType, class RoleType> Udm::PointerAttr<PeerType> peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, AssociationsSingle> >(); return Udm::PointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::AssocAttr<PeersType> peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::AssocAttr<PeersType, Pred> peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, AssociationsMulti> >(); return Udm::AssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassPointerAttr<ConnectorType, PeerType> connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, AssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassAssocAttr<ConnectorsType, PeerType> connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred> connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, AssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class PeerType, class RoleType> Udm::CrossPointerAttr<PeerType> cross_peer() const { boost::function_requires< Udm::WithRoleInTListConcept<PeerType, RoleType, CrossAssociationsSingle> >(); return Udm::CrossPointerAttr<PeerType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType> Udm::CrossAssocAttr<PeersType> cross_peers() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType>(impl, _type2ARole<RoleType>()); }
		template <class PeersType, class RoleType, class Pred> Udm::CrossAssocAttr<PeersType, Pred> cross_peers_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept<PeersType, RoleType, CrossAssociationsMulti> >(); return Udm::CrossAssocAttr<PeersType, Pred>(impl, _type2ARole<RoleType>()); }
		template <class ConnectorType, class PeerType, class RoleType> Udm::AClassCrossPointerAttr<ConnectorType, PeerType> cross_connector() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorType, RoleType, CrossAssociationsWAClassSingle> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossPointerAttr<ConnectorType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType> cross_connectors() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ConnectorsType, class PeerType, class RoleType, class Pred> Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred> cross_connectors_sorted() const { boost::function_requires< Udm::WithAClassAndRoleInTListConcept<PeerType, ConnectorsType, RoleType, CrossAssociationsWAClassMulti> >(); pair<const ::Uml::AssociationRole*, const ::Uml::AssociationRole*> roles_mp = _type2ACARole<RoleType>(); return Udm::AClassCrossAssocAttr<ConnectorsType, PeerType, Pred>(impl, *roles_mp.first, *roles_mp.second); }
		template <class ChildType, class RoleType> Udm::ChildAttr<ChildType> child() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildType, RoleType, ChildrenSingle> >(); return Udm::ChildAttr<ChildType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType> Udm::ChildrenAttr<ChildrenType> children() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType, class RoleType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_sorted() const { boost::function_requires< Udm::WithRoleInTListConcept_B<ChildrenType, RoleType, ChildrenMulti> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, _type2CCRole<RoleType>()); }
		template <class ChildrenType> Udm::ChildrenAttr<ChildrenType> children_kind() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType>(impl, Udm::NULLCHILDROLE); }
		template <class ChildrenType, class Pred> Udm::ChildrenAttr<ChildrenType, Pred> children_kind_sorted() const { boost::function_requires< Udm::InTListConcept<ChildrenType, ChildrenKinds> >(); return Udm::ChildrenAttr<ChildrenType, Pred>(impl, Udm::NULLCHILDROLE); }
		template <class ParentType, class RoleType> Udm::ParentAttr<ParentType> parent() const { boost::function_requires< Udm::WithRoleInTListConcept<ParentType, RoleType, Parents> >(); return Udm::ParentAttr<ParentType>(impl, _type2CPRole<RoleType>()); }
		template <class ParentType> Udm::ParentAttr<ParentType> parent_kind() const { boost::function_requires< Udm::InTListConcept<ParentType, ParentKinds> >(); return Udm::ParentAttr<ParentType>(impl, Udm::NULLPARENTROLE); }
		template <class EndType, class RoleType> Udm::AssocEndAttr<EndType> end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, AClassEnds> >(); return Udm::AssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		template <class EndType, class RoleType> Udm::CrossAssocEndAttr<EndType> cross_end() const { boost::function_requires< Udm::WithRoleInTListConcept<EndType, RoleType, CrossAClassEnds> >(); return Udm::CrossAssocEndAttr<EndType>(impl, _type2ARole<RoleType>()); }
		Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const { return Udm::ParentAttr< ::PICML::BehaviorModel>(impl, meta_BehaviorModel_parent); }
		Udm::ParentAttr< ::PICML::MgaObject> parent() const { return Udm::ParentAttr< ::PICML::MgaObject>(impl, Udm::NULLPARENTROLE); }
		Udm::AssocEndAttr< ::PICML::StateBase> dstTerminalEffect_end() const { return Udm::AssocEndAttr< ::PICML::StateBase>(impl, meta_dstTerminalEffect_end_); }
		Udm::AssocEndAttr< ::PICML::Terminal> srcTerminalEffect_end() const { return Udm::AssocEndAttr< ::PICML::Terminal>(impl, meta_srcTerminalEffect_end_); }
		void Accept(Visitor &v) { v.Visit_TerminalEffect(*this); }

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;
		static ::Uml::AssociationRole meta_dstTerminalEffect_end_;
		static ::Uml::AssociationRole meta_srcTerminalEffect_end_;

		// types and typelist for parent by returned type and role relations;
		class PR_BehaviorModel_parent {};
		typedef boost::mpl::pair< ::PICML::BehaviorModel, PR_BehaviorModel_parent > _PR_BehaviorModel_parent__BehaviorModel;
		typedef boost::mpl::vector< _PR_BehaviorModel_parent__BehaviorModel> Parents;

		// typelist for parent by returned type relations;
		typedef boost::mpl::vector< ::PICML::BehaviorModel> ParentKinds;

		// types and typelist for children by returned type and role relations;
		typedef boost::mpl::vector< > ChildrenSingle;
		typedef boost::mpl::vector< > ChildrenMulti;

		// typelist for children by returned type relations;
		typedef boost::mpl::vector< > ChildrenKinds;

		// types and typelist for associations by returned type and role relations;
		typedef boost::mpl::vector< > AssociationsSingle;
		typedef boost::mpl::vector< > AssociationsMulti;

		// types and typelist for associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > AssociationsWAClassSingle;
		typedef boost::mpl::vector< > AssociationsWAClassMulti;

		// types and typelist for cross associations by returned type and role relations;
		typedef boost::mpl::vector< > CrossAssociationsSingle;
		typedef boost::mpl::vector< > CrossAssociationsMulti;

		// types and typelist for cross associations by returned type, association class and role relations;
		typedef boost::mpl::vector< > CrossAssociationsWAClassSingle;
		typedef boost::mpl::vector< > CrossAssociationsWAClassMulti;

		// types and typelist for association class ends by returned type and role relations;
		class ACE_dstTerminalEffect {};
		class ACE_srcTerminalEffect {};
		typedef boost::mpl::pair< ::PICML::StateBase, ACE_dstTerminalEffect > _ACE_dstTerminalEffect__StateBase;
		typedef boost::mpl::pair< ::PICML::Terminal, ACE_srcTerminalEffect > _ACE_srcTerminalEffect__Terminal;
		typedef boost::mpl::vector< _ACE_dstTerminalEffect__StateBase, _ACE_srcTerminalEffect__Terminal> AClassEnds;

		// types and typelist for cross association class by returned type and role relations;
		typedef boost::mpl::vector< > CrossAClassEnds;

	};

}

#endif // MOBIES_PICML_H
