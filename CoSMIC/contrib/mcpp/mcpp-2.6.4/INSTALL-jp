  ここでは、MCPP のソースをコンパイルして実行プログラムを生成する方法を
説明します。詳細はさらに mcpp-porting.html を見てください。

1、実行プログラムの種類

  MCPP の実行プログラムは build する方法に応じて何種類かあります。Build
する方法には次の２つの次元があります。

    1. stand-alone-build vs subroutine-build
    2. compiler-independent-build vs compiler-specific-build

stand-alone-build: １つのコマンドとして単体で動くプリプロセッサです。処
    理系のコンパイラ・ドライバから呼び出されるものもあります。
subroutine-build: 他のメインプログラムの中からサブルーチンとして（必要な
    ら繰り返し）呼び出されるものです。

compiler-independent-build: 処理系からは独立して動くプリプロセッサです。
    実行時オプションなどの仕様は処理系のいかんによらず一定です。プリプロ
    セスだけすることができますが、処理系の一部として動作することはできま
    せん。
    これを V.2.6, V.2.6.1 では stand-alone-build と呼んでいました。V.2.6.
    2 で subroutine-build ができたのに伴って、呼称を変更しました。
compiler-specific-build: 特定の処理系のプリプロセッサを（もし可能なら）
    代替するためのものです。その処理系に専用の仕様を持ち、その処理系の専
    用のディレクトリにインストールされます。

  Subroutine-build についてはここでは説明は略します。mcpp-porting.html 3.
12 を見てください。以下はすべて stand-alone-build についての説明です。

2、configure と make

  MCPP をコンパイルするには、UNIX 系のシステムおよび CygWIN, MinGW では
configure スクリプトを使うことができます。configure と make は任意のディ
レクトリで実行できます。以下の説明では mcpp-2.6.4 ディレクトリのある
path を ${mcpp-dir} と表記します。

2、1、compiler-independent-build

    ${mcpp-dir}/configure; make; make install

とすると、compiler-independent 版の実行プログラムが生成されてインストー
ルされます。一部のドキュメントもインストールされます。

    ${mcpp-dir}/configure --prefix=/usr; make; make install

等とした場合は、prefix で指定されたディレクトリの中の bin ディレクトリに
インストールされます。これを指定しないと /usr/local を指定したのと同じこ
とになります。
  make install には通常は root 権限が必要なので、

    sudo make install

とします。あるいは su してから configure; make; make install とします。
なお、FreeBSD では make ではなく gmake を使ってください。
  実行プログラムを strip するには、make install のかわりに

    make install-strip

とします。

    make uninstall

とすると、mcpp の実行プログラムは削除されます。

  make (un)install では DESTDIR=DIR というオプションを指定すると、DIR 以
下のディレクトリにインストールされます。例えば、

    make DESTDIR=/tmp/mcpp install

とすると、/tmp/mcpp/usr/local/bin/ に mcpp がインストールされます（存在
しないディレクトリは作成される。configure で --prefix=DIR オプションを指
定していると '/usr/local' の部分が 'DIR' に置き換わる）。バイナリ・パッ
ケージを作るにはこの方法を使います。

  GCC 4.1 以降には -fstack-protector (-fstack-protector-all) というオプ
ションがありますが、configure または make で CFLAGS+=-fstack-protector
というオプションを指定することでこれを有効にすることができます。これは
GCC-specific-build でも同様です。

  なお、MCPP V.2.6.2 までの make には install-data, uninstall-data とい
うターゲットがありましたが、V.2.6.3 から廃止しました。ソースからインスト
ールする場合は、ドキュメントと検証セットをわざわざ別ディレクトリにコピー
する必要はないと思われるからです。しかし、compiler-independent-build で
は make install で最小限のドキュメントがインストールされるようにしました。
これはバイナリ・パッケージを作るつごうに合わせたものです。

  Linux や CygWIN ではシステムの標準ヘッダに欠陥があるので、compiler-
independent-build の mcpp ではその対策が必要です。この問題については
mcpp-manual.html 3.9.9 を見てください。

2、2、compiler-specific-build

    ${mcpp-dir}/configure --enable-replace-cpp; make; make install

とすると、compiler-specific 版の実行プログラムが生成されて、その処理系の
専用のディレクトリにインストールされます。
  make install-strip, make uninstall は compiler-independent-build と同
じです。configure の --prefix オプションも同じですが、これは実行プログラ
ムのインストールディレクトリには関係しません。また、make での DESTDIR オ
プションも、実行プログラムのインストールには関係しません。

  ただし、GCC 以外の処理系では先に移植作業を行い、configure でさらにいく
つかのオプションを指定しないと、適切なコンパイルとインストールがされませ
ん。

2、2、1、処理系が GCC の場合

2、2、1、1、make install
  --enable-replace-cpp オプションで configure した場合、make install で
はコンパイラの置かれるディレクトリ（/usr/libexec, /usr/lib/gcc-lib/i686-
pc-linux-gnu/VERSION 等）に実行プログラムがインストールされます。これは
gcc の呼び出す cpp0 (cc1) が置かれているディレクトリです。make install
は GCC / cpp0 (cc1) を保存した上で、gcc, g++ から mcpp が呼び出されるよ
うに適切な設定をします。この設定は GCC が V.2.* であるか V.3.*, 4.* であ
るかによって違っています（mcpp-manual.html 3.9.5, 3.9.7 を参照のこと）。

2、2、1、2、make check
  MCPP の検証セットには GCC の testsuite に対応した edition があります。
GCC / testsuite がインストールされている場合は、make check によってこの
testsuite 版検証セットで mcpp の Standard モードのテストをすることができ
ます。Testsuite 版検証セットは GCC / testsuite の一部として使うようにな
っているので、あらかじめ GCC / testsuite がインストールされ実行できる状
態になっていることが必要です。GCC / testsuite は通常は GCC のソースの一
部となっています（別のパッケージとなっている場合もある）。
  また、configure する時に GCC / testsuite の置かれているディレクトリを
指定しておく必要があります。そのためには次のようにします。

    ${mcpp-dir}/configure --with-gcc-testsuite-dir=DIR  \
            --enable-replace-cpp

この 'DIR' は GCC のソースが置かれているディレクトリを ${gcc-source} と
すると、

    ${gcc-source}/gcc/testsuite

となるはずです。
  こうして configure しておいて、make; make install した後で

    make check

とすると、検証セットの testsuite 版が GCC / testsuite の中にコピーされ、
GCC が V.2.* であるかそれとも V.3.*, 4.* であるかに応じて必要な設定がさ
れ、そして testsuite が実行されます。通常のソフトウェアでは make install
の前に make check しますが、MCPP の場合は順序が逆になります。gcc から
mcpp が呼び出されるようにしておかないと testsuite が mcpp に適用できない
からです。また、このため --enable-replace-cpp オプションも必要です。
  Testsuite 版検証セットは MCPP だけでなく、GCC V.2.95 以降の cpp0 (cc1)
にも適用することができます（cpp-test.html 3.2.3 参照）。

2、2、1、3、make uninstall
  make uninstall とすると、MCPP の実行プログラムは削除されます。gcc,
cpp0 (cc1) の設定は初期状態に戻ります。make install で生成された
mcpp_g*.h というファイルも削除されます。何かのつごうで make install した
後で configure を再実行する場合は、その前に make uninstall しなければな
りません。Configure が調査すべきなのは GCC であり MCPP ではないからです。
  GCC / testsuite の中に検証セットがインストールされていれば、それも
make uninstall で削除されます。GCC に検証セットを適用するには、手動で検
証セットをコピーしてください。
  GCC-specific-build の configure で生成された何本かの Makefile は MCPP
を uninstall するときに必要なので、そのまま残しておいてください。make
distclean する場合は、その前に make uninstall を実行してください。手動で
uninstall するのは少し手間がかかるからです。

2、2、2、処理系が GCC でない場合

  処理系が GCC でない場合は configure でいくつかのオプションを指定しなけ
ればなりません。また、その処理系のプリプロセッサと置換できるように、ソー
スコードを書き足す「移植」作業が必要です。作者自身は Linux, FreeBSD,
CygWIN 等で GCC を使っているので移植がすんでおり、configure で情報を収集
することもできるのですが、UNIX 系システムの他の処理系については知らない
ので、移植はおろが configure で何をどう調べれば良いのかもわからないから
です。
  UNIX 系システムの GCC 以外の処理系では、次のような手順でコンパイルを進
めてください。

2、2、2、1、オプションを指定して configure
  まず、いくつかのオプションを指定して configure してみます。例えば次の
ようにします。

    ${mcpp-dir}/configure --enable-replace-cpp --bindir=DIR \
            --with-cxx-include-dir=CXXDIR   \
            --enable-SYSTEM-STD-macro=_MACRO=val

  --bindir で指定するのは、コンパイラドライバから呼び出されるプリプロセ
ッサが置かれるディレクトリです。さらに C++ 固有のインクルードディレクト
リを --with-cxx-include-dir で、また処理系固有の事前定義マクロを
--enable-SYSTEM-STD-macro その他のオプションで指定します。

    ${mcpp-dir}/configure --help

とするとオプションが表示されます。
  そして make; make install して、さらにコンパイラドライバから mcpp が呼
び出されるように細工をします。その方法については、GCC での設定方法を参考
にしてください。

2、2、2、2、「移植」作業
  処理系のプリプロセッサを MCPP に置き換えて使うためには、ソースコードを
書き足す「移植」作業が必要です。処理系固有の実行時オプションや #pragma
等の実装です。中でもしばしば使われる実行時オプションで MCPP と異なるもの
があれば、最低限、その実装が必要です。そのためには、configed.H でそのコ
ンパイラを表すマクロを定義した上で、system.c にコードを書き加えます
（mcpp-porting.html のことに 4.2 を参照）。

2、2、2、3、オプションを追加して configure しなおす
  ソースの移植ができたら、--with-compiler-name=COMPILER というオプション
を追加して configure し直します。COMPILER は configed.H で定義したそのコ
ンパイラを表すマクロです。
  make; make install ができたら、さらに make clean; make とすると、MCPP
を使って MCPP のリコンパイルが行われます。これが通れば、最低限の移植はで
きています。

2、2、3、configure の制約

  compiler-specific-build の MCPP のコンパイルではターゲット処理系（MCPP
をプリプロセッサとして使う予定の処理系）の仕様を詳しく知る必要があります。
同時に、コンパイルする処理系についても別の側面の仕様を知る必要があります。
MCPP のソースはこの両者の処理系が違っていてもかまわないように、両者の設
定を分けてヘッダファイル (configed.H) を書いてあります。しかし、
configure ではこの両者を同時に調べることができません。そのため、ターゲッ
トとする処理系とコンパイルする処理系は同じであるという前提で調査をします。
  もしこの両者の処理系が違う場合は、configed.H の Part 2 を編集すること
が必要です。
  MCPP の configure は同様にクロスコンパイルにも対応していません。また、
クロスコンパイルでは実行できないテストもいくつか含まれています。クロスコ
ンパイルではその場合はデフォルト値をセットしますが、うまくゆかないかもし
れません。どちらにしても作者自身はクロスコンパイラを使った経験がないので、
よくわかりません。

3、Windows 上の処理系での make

  Windows 上の処理系は CygWIN, MinGW 以外は configure の対象にならないの
で、ソースを修正して make することが必要です。すでに移植ずみの処理系につ
いては差分ファイルを用意してあるので、これを使ってパッチをあてることがで
きます。差分ファイルを使う場合の手順を以下に説明します。
  また、configure の対象になる処理系でも、ヘッダファイルや makefile を直
接、編集することできめのこまかい制御をすることができます。

3、1、パッチをあてる
  noconfig というディレクトリに各種処理系用の差分ファイルと makefile が
用意されています。MCPP のソースはデフォルトでは FreeBSD / GCC 3.4 用の設
定になっています。差分ファイルはこれを別の処理系用に修正するものです。
Makefile は各処理系に付属する make を使うように書かれています。
  src ディレクトリに入って次のようにします。以下の作業はすべて src ディ
レクトリで行います。

    patch -c < ..\noconfig\which-compiler.dif
    copy ..\noconfig\which-compiler.mak Makefile

  patch は UNIX 系システムのコマンドですが、Windows にも移植されているの
で、それを使います。もちろん、差分ファイルを見て、エディタで修正してもか
まいません。

3、2、必要ならさらに noconfig.H, Makefile を修正する
  差分ファイルでは各種ディレクトリの設定が筆者の環境を元にしているので、
自分の環境に合わせて修正します。
  使う処理系が差分ファイルのものとはバージョンが違っている場合は、ヘッダ
ファイル noconfig.H にさらに修正を加えます（noconfig.H そのものおよび
mcpp-porting.html 3.1 を参照）。通常使う multi-byte character が日本語で
はない場合も同様に、nocongig.H の MBCHAR というマクロの定義を書き換えま
す。
  また、実行プログラムをインストールするディレクトリを Makefile の
BINDIR という変数に書きます。Visual C 用の Makefile では次の行の # を削
除して、install ターゲットを有効にしてください。

    #install :

3、3、compiler-independent-build
  これで  make して make install すると、compiler-independent 版の実行プ
ログラムが生成されてインストールされます（Visual C++ では make ではなく
nmake を使う）。

3、4、compiler-specific-build
  compiler-specific 版を生成するためには、まず Makefile の BINDIR をその
処理系の実行プログラムの置かれているディレクトリに書き換えます。そして、
noconfig.H の次の行の 'INDEPENDENT' をそのコンパイラを表すマクロに書き換
えて、'make' し 'make install' します。

    #define COMPILER    INDEPENDENT

'COMPILER' は make のオプションで上書きすることもできるので、noconfig.H
は必ずしも書き換える必要はありません。例えば、Visual C では 'nmake
COMPILER=MSC' として 'nmake COMPILER=MSC install' します。Borland C では
'make -DCOMPILER=BORLANDC' として 'make -DCOMPILER=BORLANDC install' し
ます。

  もし、ターゲット処理系とコンパイルする処理系とが違っている場合は、
noconfig.H / Part 1 をターゲット処理系の仕様に合わせ、Part 2 をコンパイ
ルする処理系の仕様に合わせます。Makefile はコンパイルする処理系用のもの
を使い、インストールするディレクトリをターゲット処理系用に変更します。

  しかし、Windows の処理系の多くはプリプロセッサがコンパイラ本体と一体に
なっているので、MCPP をインストールしてもプリプロセッサを置換することが
できません。そうした処理系で MCPP を使うためには、そのように makefile を
書く必要があります。noconfig ディレクトリの各 makefile には、MCPP を使っ
て MCPP をリコンパイルする設定が書いてあるので、それを参考にしてください。
  Visual C++ ではそうした makefile を使って、IDE で「メイクファイルプロ
ジェクト」を作成すると、IDE のソースレベルデバッグ等の機能がすべて使えま
す（mcpp-manual.html 2.10 参照）。

3、5、テスト
  Windows では MinGW / GCC-specific-build および CygWIN 以外では include
directory は設定されないので、INCLUDE という環境変数で設定します（必要な
ら CPLUS_INCLUDE も）。
  Windows では GCC / testsuite は使えないので、test-t, test-c, test-l デ
ィレクトリにあるテスト用サンプルを直接、プリプロセスして確かめます。tool
/cpp_test.c を使うと、一部のテストだけですが、自動的に実行できます（cpp-
test.html 3.2.2 参照）。
  compiler-specific-build では、MCPP 自身をプリプロセッサとして使って、
MCPP の "pre-preprocess" という機能を使って MCPP をリコンパイルしてみる
と、その処理系でとりあえず使えるようになったかどうかを確かめることができ
ます（mcpp-porting.html 3.7 参照）。

4、移植のための情報をお寄せください

  MCPP をまだ移植されてない処理系に移植するためには、多くの情報が必要で
す。みなさんの情報をお待ちしています。
  GCC 以外の処理系について configure のオプションで指定する値がおわかり
のかたは教えてください。configure.ac に取り込んでゆきたいと思います。

5、「検証セット」とは

  MCPP には「検証セット」というものが付属しています。これは C/C++ プリプ
ロセッサについて 265 項目にわたる徹底的なテストと評価をするものです。
MCPP だけでなく任意のプリプロセッサに適用することができます。その使い方
については、cpp-test.html 3.1, 3.2 を参照してください。

2007/05
                                         松井　潔 <kmatsui@t3.rim.or.jp>

