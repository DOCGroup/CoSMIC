// $Id$

#include "Workspace_Generator.h"
#include "Dependency_Graph.h"
#include "Export_File_Generator.h"
#include "UDM_Utility_T.h"
#include "Uml.h"

#include <sstream>
#include <fstream>
#include <algorithm>

static const char * WORKSPACE_SUFFIX = "_CUTS";
static const char * PROJECT_SUFFIX = ".mpc";

static const char * STUB_SUFFIX = "_stub";
static const char * SVNT_SUFFIX = "_svnt";
static const char * EXEC_SUFFIX = "_exec";

static const char * CLIENT_SUFFIX = "C";
static const char * SERVER_SUFFIX = "S";

//
// CUTS_Workspace_Generator
//
CUTS_Workspace_Generator::CUTS_Workspace_Generator (
  const std::string & outdir,
  const CUTS_Dependency_Graph & graph)
: outdir_ (outdir),
  graph_ (graph),
  node_ (0)
{

}

//
// ~CUTS_Workspace_Generator
//
CUTS_Workspace_Generator::~CUTS_Workspace_Generator (void)
{

}

//
// Visit_RootFolder
//
void CUTS_Workspace_Generator::Visit_RootFolder (
  const PICML::RootFolder & root)
{
  std::string name = root.name ();

  // Create the workspace filename.
  std::ostringstream workspace;
  workspace
    << this->outdir_ << "\\" << name
    << WORKSPACE_SUFFIX << ".mwc" << std::ends;

  // Open the file for writing.
  this->workspace_.open (workspace.str ().c_str ());

  if (this->workspace_.is_open ())
  {
    this->workspace_
      << "// This workspace file was generated by" << std::endl
      << "// $Id$"
      << std::endl
      << std::endl
      << "workspace (" << name << WORKSPACE_SUFFIX << ") {" << std::endl

      // Specify where to locate base projects for this workspace.
      << "  // -- Initialize the includes for the project." << std::endl
      << "  cmdline += -include $CUTS_ROOT/etc/config" << std::endl
      << std::endl
      << "  // -- Explicitly specify which components(s) to build"
      << std::endl;

    // We now are ready to visit all the component implementations
    // in the project and generate its corresponding MPC file.
    typedef std::vector <PICML::ComponentImplementations> Folder_Set;
    Folder_Set folders = root.ComponentImplementations_children ();

    std::for_each (folders.begin (),
                   folders.end (),
                   UDM_Accept_Functor <CUTS_Workspace_Generator,
                                       Folder_Set::value_type> (*this));

    // We have generated all the component MPC files, e.g., svnt and exec
    // project. Now we need to generate all the base project that are
    // used by these components. This includes the server/client projects
    // that are created from IDL files.
    this->workspace_
      << std::endl
      << "  // -- Explicitly specify which IDLs to compile"
      << std::endl;

    CUTS_Dependency_Graph::Dependency_Graph::const_iterator iter;

    for (iter = this->graph_.graph ().begin ();
         iter != this->graph_.graph ().end ();
         iter ++)
    {
      CUTS_Dependency_Node * node = iter->second;

      if ((this->node_->flags_ & CUTS_Dependency_Node::DNF_STUB))
      {
        // Construct the name of the project. We use _Base as the
        // name decorator in hopes of not overwriting an existing
        // file.
        std::ostringstream pathname;
        pathname
          << this->outdir_ << "\\" << node->name ()
          << "_stub" << PROJECT_SUFFIX << std::ends;

        this->project_.open (pathname.str ().c_str ());

        if (this->project_.is_open ())
        {
          // Add the project to the workspace.
          this->workspace_
            << "  " << node->name ()
            << "_stub" << PROJECT_SUFFIX << std::endl;

          this->project_
            << "// This project file was generated by" << std::endl
            << "// $Id$"
            << std::endl << std::endl;

          // Generate the client and server project.
          this->generate_stub_project (node);
          this->project_.close ();
        }

        // We need to clear the project flags just in case it went
        // bad somewhere along the way.
        if (!this->project_.good ())
          this->project_.clear ();
      }
    }

    this->workspace_ << "}" << std::endl;
    this->workspace_.close ();
  }
}

//
// Visit_ComponentImplementations
//
void CUTS_Workspace_Generator::Visit_ComponentImplementations (
  const PICML::ComponentImplementations & folder)
{
  typedef std::vector <PICML::ComponentImplementationContainer> Container_Set;
  Container_Set containers = folder.ComponentImplementationContainer_children ();

  std::for_each (containers.begin (),
                 containers.end (),
                 UDM_Accept_Functor <CUTS_Workspace_Generator,
                                     Container_Set::value_type> (*this));
}

//
// Visit_ComponentImplementationContainer
//
void CUTS_Workspace_Generator::Visit_ComponentImplementationContainer (
  const PICML::ComponentImplementationContainer & container)
{
  typedef std::vector <PICML::MonolithicImplementation> Monolithic_Set;
  Monolithic_Set monolithics = container.MonolithicImplementation_kind_children ();

  // We can add a project file to this workspace if we know that
  // we have at least one monolithic implemenation in the container.
  if (monolithics.size () == 0)
    return;

  this->project_name_ = container.name ();

  // Create the MPC project filename and open it for writing.
  std::string project = this->project_name_;
  project.append (".mpc");

  std::ostringstream filename;
  filename << this->outdir_ << "\\" << project << std::ends;

  this->project_.open (filename.str ().c_str ());

  if (this->project_.is_open ())
  {
    // We can add the project to the workspace since we have
    // successfully opened it.
    this->workspace_ << "  " << project << std::endl;

    this->project_
      << "// This project file was generate by" << std::endl
      << "// $Id$"
      << std::endl
      << std::endl;

    // Visit all the monolithic implemenations.
    std::for_each (monolithics.begin (),
                   monolithics.end (),
                   UDM_Accept_Functor <CUTS_Workspace_Generator,
                                       Monolithic_Set::value_type> (*this));

    this->project_.close ();
  }

  // We need to reset the project just in case it went bad
  // along the way.
  if (!this->project_.good ())
    this->project_.clear ();
}

//
// Visit_MonolithicImplementation
//
void CUTS_Workspace_Generator::Visit_MonolithicImplementation (
  const PICML::MonolithicImplementation & monolithic)
{
  // Get the connection to the component interface we are
  // actually implementing.
  PICML::Implements implements = monolithic.dstImplements ();

  if (implements == Udm::null)
    return;

  this->node_ = 0;
  implements.Accept (*this);

  if (this->node_ != 0)
    this->generate_component_project ();
}

//
// Visit_Implements
//
void CUTS_Workspace_Generator::Visit_Implements (
  const PICML::Implements & implements)
{
  PICML::ComponentRef ref = implements.dstImplements_end ();
  ref.Accept (*this);
}

//
// Visit_ComponentRef
//
void CUTS_Workspace_Generator::Visit_ComponentRef (
  const PICML::ComponentRef & ref)
{
  if (ref == Udm::null)
    return;

  PICML::Component component = ref.ref ();
  component.Accept (*this);
}

//
// Visit_Component
//
void CUTS_Workspace_Generator::Visit_Component (const PICML::Component & component)
{
  // We need to locate the parent file for this interface. This will
  // help us know what dependencies we have for this implementation.
  PICML::MgaObject parent = component.parent ();

  while ((std::string)parent.type ().name () !=
         (std::string)PICML::File::meta.name ())
  {
    parent = PICML::MgaObject::Cast (parent.parent ());
  }

  this->graph_.find_node (parent.name (), this->node_);
}

//
// generate_project
//
void CUTS_Workspace_Generator::generate_component_project (void)
{
  this->generate_svnt_project ();
  this->generate_exec_project ();
}

//
// generate_server_project
//
void CUTS_Workspace_Generator::generate_stub_project (
  const CUTS_Dependency_Node * node)
{
  // Generate the export file for the project.
  std::string export = node->basename ();
  export.append ("_stub");

  CUTS_Export_File_Generator efg (export);
  efg.generate (this->outdir_);

  // Generate the project.
  this->project_
    << "project (" << node->basename () << STUB_SUFFIX << ") : "
    << "cuts_coworker_stub {" << std::endl
    << "  sharedname = "
    << node->basename () << STUB_SUFFIX << std::endl
    << std::endl

    // Generate the dynamic flags.
    << "  dynamicflags = " << efg.build_flag () << std::endl
    << std::endl

    // Generate the IDL flag definitions.
    << "  idlflags += -Wb,export_macro="
    << efg.export_macro () << " \\" << std::endl
    << "              -Wb,export_include="
    << efg.export_file () << std::endl;

  if (!this->node_->references_.empty ())
  {
    // Generate the dependencies for this project. This will be
    // all the client projects of the references for this node.
    this->project_
      << std::endl << "  after +=";

    CUTS_Reference_Set::const_iterator iter;

    for (iter  = node->references_.begin ();
         iter != node->references_.end ();
         iter ++)
    {
      this->project_
        << " \\" << std::endl
        << "    " << (*iter)->basename () << STUB_SUFFIX;
    }

    // Generate the import libraries for this project. This will be
    // all client project of the references for this node. The will
    // also be the same as those specified in the "after" tag.
    this->project_
      << std::endl
      << std::endl << "  libs +=";

    for (iter  = node->references_.begin ();
         iter != node->references_.end ();
         iter ++)
    {
      this->project_
        << " \\" << std::endl
        << "    " << (*iter)->basename () << STUB_SUFFIX;
    }

    this->project_ << std::endl;
  }

  this->project_
    << std::endl
    // Generate the IDL files for this project.
    << "  IDL_Files {" << std::endl
    << "    " << node->basename () << ".idl" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the source files for this project.
    << "  Source_Files {" << std::endl
    << "    " << node->basename () << SERVER_SUFFIX << ".cpp" << std::endl
    << "    " << node->basename () << CLIENT_SUFFIX << ".cpp" << std::endl
    << "  }" << std::endl
    << std::endl
    // Generate the header files for this project.
    << "  Header_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << "}" << std::endl
    << std::endl;
}

//
// generate_svnt_project
//
void CUTS_Workspace_Generator::generate_svnt_project (void)
{
  // Generate the export file for the project.
  std::string export = this->project_name_;
  export.append ("_svnt");

  CUTS_Export_File_Generator efg (export);
  efg.generate (this->outdir_);

  // Generate the project, keeping in mind the export file.
  this->project_
    << "project (" << this->project_name_ << SVNT_SUFFIX
    << ") : cuts_coworker_svnt {" << std::endl
    << "  sharedname = " << this->project_name_ << SVNT_SUFFIX << std::endl
    << std::endl
    << "  dynamicflags = " << efg.build_flag () << std::endl
    << std::endl

    // Generate the IDL flag definitions.
    << "  idlflags += -Wb,export_macro=" << efg.export_macro () << " \\" << std::endl
    << "              -Wb,export_include=" << efg.export_file () << std::endl
    << std::endl;

  // Generate the dependencies.
  this->project_
    << "  after += " << this->node_->basename () << STUB_SUFFIX;

  CUTS_Reference_Set::const_iterator iter;

  for (iter  = this->node_->references_.begin ();
       iter != this->node_->references_.end ();
       iter ++)
  {
    this->project_
      << " \\" << std::endl
      << "    " << (*iter)->basename () << STUB_SUFFIX;
  }

  // Generate the import libraries.
  this->project_
    << std::endl << std::endl
    << "  libs += " << this->node_->basename () << STUB_SUFFIX;

  for (iter  = this->node_->references_.begin ();
       iter != this->node_->references_.end ();
       iter ++)
  {
    this->project_
      << " \\" << std::endl
      << "    " << (*iter)->basename () << STUB_SUFFIX;
  }

  this->project_
    // Generate the CIDL files
    << std::endl << std::endl
    << "  CIDL_Files {" << std::endl
    << "    " << this->project_name_ << ".cidl" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the IDL files
    << "  IDL_Files {" << std::endl
    << "    " << this->project_name_ << "E.idl" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the source files
    << "  Source_Files {" << std::endl
    << "    " << this->project_name_ << "EC.cpp" << std::endl
    << "    " << this->project_name_ << SVNT_SUFFIX << ".cpp" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the header files
    << "  Header_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << "}" << std::endl
    << std::endl;
}

//
// generate_exec_project
//
void CUTS_Workspace_Generator::generate_exec_project (void)
{
  // Generate the export file for the project.
  std::string export = this->project_name_;
  export.append ("_exec");

  CUTS_Export_File_Generator efg (export);
  efg.generate (this->outdir_);

  // Generate the executor project.
  this->project_
    << "project (" << this->project_name_ << EXEC_SUFFIX
    << ") : cuts_coworker_exec {"
    << std::endl
    << "  sharedname = " << this->project_name_ << EXEC_SUFFIX << std::endl
    << std::endl
    << "  dynamicflags = " << efg.build_flag () << std::endl
    << std::endl
    << "  after += " << this->project_name_ << SVNT_SUFFIX << std::endl
    << std::endl

    // Generate the import libraries for the project.
    << "  libs  += "
    << this->project_name_ << SVNT_SUFFIX << " "
    << this->node_->basename () << STUB_SUFFIX;

  CUTS_Reference_Set::const_iterator iter;

  for (iter  = this->node_->references_.begin ();
       iter != this->node_->references_.end ();
       iter ++)
  {
    this->project_
      << " \\" << std::endl
      << "    " << (*iter)->basename () << STUB_SUFFIX;
  }

  // Generate the additional import libraries needed for the executor
  // to compile successfully.
  for (String_Set::const_iterator iter = this->node_->libs_.begin ();
        iter != this->node_->libs_.end ();
        iter ++)
  {
    this->project_
      << " \\" << std::endl
      << "    " << *iter;
  }

  // Generate the library paths needed for the executor
  // to compile successfully.
  if (!this->node_->libpaths_.empty ())
  {
    this->project_
      << std::endl << std::endl
      << "  libpaths += ";

    for (String_Set::const_iterator iter = this->node_->libpaths_.begin ();
          iter != this->node_->libpaths_.end ();
          iter ++)
    {
      this->project_
        << " \\" << std::endl
        << "    " << *iter;
    }
  }

  this->project_
    << std::endl << std::endl

    // Generate the source files.
    << "  Source_Files {" << std::endl
    << "    " << this->project_name_ << "_exec_i.cpp" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the header files.
    << "  Header_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << std::endl
    << "  Inline_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << std::endl
    << "  IDL_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << "}" << std::endl
    << std::endl;
}
