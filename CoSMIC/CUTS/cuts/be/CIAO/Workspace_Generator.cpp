// $Id$

#include "Workspace_Generator.h"
#include "CoWorkEr_Cache.h"
#include "Dependency_Graph.h"
#include "Export_File_Generator.h"
#include "UDM_Utility_T.h"
#include "Uml.h"

#include <sstream>
#include <fstream>
#include <algorithm>

static const char * WORKSPACE_SUFFIX = "_CUTS";
static const char * PROJECT_SUFFIX = ".mpc";

static const char * STUB_SUFFIX = "_stub";
static const char * SVNT_SUFFIX = "_svnt";
static const char * EXEC_SUFFIX = "_exec";

static const char * CLIENT_SUFFIX = "C";
static const char * SERVER_SUFFIX = "S";

//
// CUTS_Workspace_Generator
//
CUTS_Workspace_Generator::CUTS_Workspace_Generator (
  const std::string & outdir,
  CUTS_Dependency_Graph & impls,
  CUTS_Dependency_Graph & stubs)
: outdir_ (outdir),
  impls_ (impls),
  stubs_ (stubs)
{

}

//
// ~CUTS_Workspace_Generator
//
CUTS_Workspace_Generator::~CUTS_Workspace_Generator (void)
{

}

//
// Visit_RootFolder
//
void CUTS_Workspace_Generator::Visit_RootFolder (
  const PICML::RootFolder & root)
{
  std::string name = root.name ();

  // Create the workspace filename.
  std::ostringstream pathname;
  pathname
    << this->outdir_ << "\\" << name
    << WORKSPACE_SUFFIX << ".mwc" << std::ends;

  std::ofstream workspace;
  workspace.open (pathname.str ().c_str (),
                  std::ios_base::out | std::ios_base::trunc);

  if (!workspace.is_open ())
    return;

  workspace
    << "// This workspace file was generated by" << std::endl
    << "// $Id$"
    << std::endl
    << std::endl
    << "workspace (" << name << WORKSPACE_SUFFIX << ") {" << std::endl

    // Specify where to locate base projects for this workspace.
    << "  // -- Initialize the includes for the project." << std::endl
    << "  cmdline += -include $CUTS_ROOT/etc/config" << std::endl
    << std::endl
    << "  // -- Explicitly specify which components(s) to build"
    << std::endl;

  // Visit all the implemenations.
  CUTS_Dependency_Graph::Dependency_Graph::const_iterator iter;

  for (iter  = this->impls_.graph ().begin ();
       iter != this->impls_.graph ().end ();
       iter ++)
  {
    this->generate_component_project (workspace,
                                      iter->second);
  }

  // Now we can generate all the stub projects.
  workspace
    << std::endl
    << "  // -- Explicitly specify which IDLs to compile"
    << std::endl;

  for (iter  = this->stubs_.graph ().begin ();
       iter != this->stubs_.graph ().end ();
       iter ++)
  {
    // Generate the stub project for this node iff we have
    // not visited this stub is need by any of the impls.
    CUTS_Dependency_Node * node = iter->second;

    if ((node->flags_ & CUTS_Dependency_Node::DNF_STUB) == 0)
      continue;

    this->generate_stub_project (workspace, node);

    // Generate the stub projects for all this nodes refernces.
    CUTS_Reference_Set::const_iterator ref_iter;

    for (ref_iter  = node->references_.begin ();
         ref_iter != node->references_.end ();
         ref_iter ++)
    {
      this->generate_stub_project (workspace, (*ref_iter));
    }
  }

  // Close off the workspace and close the file.
  workspace << "}" << std::endl;
  workspace.close ();
}

//
// generate_project
//
void
CUTS_Workspace_Generator::
generate_component_project (std::ostream & workspace,
                            CUTS_Dependency_Node * impl_node)
{
  // Create the MPC project filename and open it for writing.
  std::string project_name = impl_node->name ();
  project_name.append (".mpc");

  std::ostringstream filename;
  filename << this->outdir_ << "\\" << project_name << std::ends;

  // Open file and truncate any of the existing text.
  std::ofstream project;
  project.open (filename.str ().c_str (),
                std::ios_base::out | std::ios_base::trunc);

  if (!project.is_open ())
    return;

  // Write the preamble for the project file.
  project
    << "// This project file was generate by" << std::endl
    << "// $Id$"
    << std::endl
    << std::endl;

  this->generate_svnt_project (project, impl_node);
  this->generate_exec_project (project, impl_node);
  project.close ();

  // Add project to workspace if everything went well.
  if (project.good ())
    workspace << "  " << project_name << std::endl;
}

//
// generate_stub_project
//
void
CUTS_Workspace_Generator::
generate_stub_project (std::ofstream & workspace,
                       CUTS_Dependency_Node * node)
{
  // We only generate the stub for a node if it has its
  // stub bit enabled. We also disable the bit after we visit
  // a stub node so we don't generate the project more than
  // one time.
  if ((node->flags_ & CUTS_Dependency_Node::DNF_VISITED))
    return;

  node->flags_ |= CUTS_Dependency_Node::DNF_VISITED;

  // Construct the name of the project. We use _Base as the
  // name decorator in hopes of not overwriting an existing
  // file.
  std::string project_name = node->name ();
  project_name.append ("_stub");

  std::string project_file = project_name;
  project_file.append (PROJECT_SUFFIX);

  std::ostringstream pathname;
  pathname
    << this->outdir_ << "\\" << project_file << std::ends;

  std::ofstream project;
  project.open (pathname.str ().c_str ());

  if (!project.is_open ())
    return;

  // Write the preamble for the project file. We need to add
  // a more detailed one in the near future.
  project
    << "// This project file was generated by" << std::endl
    << "// $Id$"
    << std::endl
    << std::endl;

  // Generate the export file for the project.
  std::string name = node->basename ();
  name.append (STUB_SUFFIX);

  CUTS_Export_File_Generator efg (name);
  efg.generate (this->outdir_);

  // Generate the project.
  project
    << "project (" << node->basename () << STUB_SUFFIX << ") : "
    << "cuts_coworker_stub {" << std::endl
    << "  sharedname = "
    << node->basename () << STUB_SUFFIX << std::endl
    << std::endl

    // Generate the dynamic flags.
    << "  dynamicflags = " << efg.build_flag () << std::endl
    << std::endl

    // Generate the IDL flag definitions.
    << "  idlflags += -Wb,export_macro="
    << efg.export_macro () << " \\" << std::endl
    << "              -Wb,export_include="
    << efg.export_file () << std::endl;

  if (!node->references_.empty ())
  {
    // Generate the dependencies for this project. This will be
    // all the client projects of the references for this node.
    project
      << std::endl << "  after +=";

    CUTS_Reference_Set::const_iterator iter;

    for (iter  = node->references_.begin ();
         iter != node->references_.end ();
         iter ++)
    {
      project
        << " \\" << std::endl
        << "    " << (*iter)->basename () << STUB_SUFFIX;
    }

    // Generate the import libraries for this project. This will be
    // all client project of the references for this node. The will
    // also be the same as those specified in the "after" tag.
    project
      << std::endl
      << std::endl << "  libs +=";

    for (iter  = node->references_.begin ();
         iter != node->references_.end ();
         iter ++)
    {
      project
        << " \\" << std::endl
        << "    " << (*iter)->basename () << STUB_SUFFIX;
    }

    project << std::endl;
  }

  project
    << std::endl
    // Generate the IDL files for this project.
    << "  IDL_Files {" << std::endl
    << "    " << node->basename () << ".idl" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the source files for this project.
    << "  Source_Files {" << std::endl
    << "    " << node->basename () << SERVER_SUFFIX << ".cpp" << std::endl
    << "    " << node->basename () << CLIENT_SUFFIX << ".cpp" << std::endl
    << "  }" << std::endl
    << std::endl
    // Generate the header files for this project.
    << "  Header_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << "}" << std::endl
    << std::endl;

  // Close the project and add it to the workspace.
  project.close ();

  if (project.good ())
    workspace << "  " << project_file << std::endl;
}

//
// generate_svnt_project
//
void
CUTS_Workspace_Generator::
generate_svnt_project (std::ofstream & project,
                       CUTS_Dependency_Node * impl_node)
{
  // Generate the export file for the project.
  std::string project_name = impl_node->basename ();
  project_name.append (SVNT_SUFFIX);

  CUTS_Export_File_Generator efg (project_name);
  efg.generate (this->outdir_);

  // Generate the project, keeping in mind the export file.
  project
    << "project (" << project_name << ") : cuts_coworker_svnt {" << std::endl
    << "  sharedname = " << project_name << std::endl
    << std::endl
    << "  dynamicflags = " << efg.build_flag () << std::endl
    << std::endl

    // Generate the IDL flag definitions.
    << "  idlflags += -Wb,export_macro=" << efg.export_macro ()
    << " \\" << std::endl
    << "              -Wb,export_include=" << efg.export_file ()
    << std::endl
    << std::endl;

  // Generate the STUB dependencies for this node.
  if (!impl_node->references_.empty ())
  {
    project << "  after +=";

    this->generate_stub_listing (project, impl_node);
    impl_node->flags_ &= ~CUTS_Dependency_Node::DNF_VISITED;
    this->stubs_.reset_visit_flag ();

    project << std::endl << std::endl;
  }

  // Generate the STUB import libraries for this node.
  if (!impl_node->references_.empty ())
  {
    project << "  libs +=";

    this->generate_stub_listing (project, impl_node);
    impl_node->flags_ &= ~CUTS_Dependency_Node::DNF_VISITED;
    this->stubs_.reset_visit_flag ();

    project << std::endl << std::endl;
  }

  project
    // Generate the CIDL files
    << "  CIDL_Files {" << std::endl
    << "    " << impl_node->basename () << ".cidl" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the IDL files
    << "  IDL_Files {" << std::endl
    << "    " << impl_node->basename () << "E.idl" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the source files
    << "  Source_Files {" << std::endl
    << "    " << impl_node->basename () << "EC.cpp" << std::endl
    << "    " << project_name << ".cpp" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the header files
    << "  Header_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << "}" << std::endl
    << std::endl;
}

//
// generate_exec_project
//
void
CUTS_Workspace_Generator::
generate_exec_project (std::ofstream & project,
                       CUTS_Dependency_Node * impl_node)
{
  // Generate the export file for the project.
  std::string project_name = impl_node->basename ();
  project_name.append (EXEC_SUFFIX);

  std::string svnt_project = impl_node->basename ();
  svnt_project.append (SVNT_SUFFIX);

  CUTS_Export_File_Generator efg (project_name);
  efg.generate (this->outdir_);

  // Generate the executor project.
  project
    << "project (" << project_name << ") : cuts_coworker_exec {"
    << std::endl
    << "  sharedname = " << project_name << std::endl
    << std::endl
    << "  dynamicflags = " << efg.build_flag () << std::endl
    << std::endl
    << "  after += " << svnt_project << std::endl
    << std::endl

    // Generate the import libraries for the project.
    << "  libs  += " << svnt_project;

  // Generate the STUB import libraries for this node.
  this->generate_stub_listing (project, impl_node);
  impl_node->flags_ &= ~CUTS_Dependency_Node::DNF_VISITED;
  this->stubs_.reset_visit_flag ();

  // Generate the remaining MPC stuff for this project.
  project
    << std::endl
    << std::endl
    << "  // implementation specific settings" << std::endl;
  this->generate_mpc_i (project, impl_node);

  project
    << std::endl
    << std::endl

    // Generate the source files.
    << "  Source_Files {" << std::endl
    << "    " << impl_node->basename () << "_exec_i.cpp" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the header files.
    << "  Header_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << std::endl
    << "  Inline_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << std::endl
    << "  IDL_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << "}" << std::endl
    << std::endl;
}

//
// generate_stub_listing
//
void
CUTS_Workspace_Generator::
generate_stub_listing (std::ofstream & project,
                       CUTS_Dependency_Node * node)
{
  if ((node->flags_ & CUTS_Dependency_Node::DNF_VISITED))
    return;

  // Generate the STUB import libraries for this node.
  node->flags_ |= CUTS_Dependency_Node::DNF_VISITED;
  CUTS_Reference_Set::const_iterator ref_iter;

  for (ref_iter  = node->references_.begin ();
       ref_iter != node->references_.end ();
       ref_iter ++)
  {
    project
      << " \\" << std::endl
      << "    " << (*ref_iter)->basename () << STUB_SUFFIX;

    this->generate_stub_listing (project, *ref_iter);
  }
}

void
CUTS_Workspace_Generator::
generate_mpc_values (std::ofstream & project,
                     const std::string & heading,
                     const CUTS_String_Set & listing)
{
  if (listing.empty ())
    return;

  project << "  " << heading << " +=";

  for (CUTS_String_Set::const_iterator iter = listing.begin ();
       iter != listing.end ();
       iter ++)
  {
    project
      << " \\" << std::endl
      << "    " << iter->c_str ();
  }
}

//
// genereate_mpc_i
//
void CUTS_Workspace_Generator::
generate_mpc_i (std::ofstream & project,
                CUTS_Dependency_Node * node)
{
  this->generate_mpc_values (project, "includes", node->includes_);
  this->generate_mpc_values (project, "libpaths", node->libpaths_);
  this->generate_mpc_values (project, "libs", node->libs_);
}
