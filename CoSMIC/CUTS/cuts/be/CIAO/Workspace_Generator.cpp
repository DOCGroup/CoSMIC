// $Id: Workspace_Generator.cpp,v 1.1.2.3 2006/06/07 04:08:01 hillj Exp $

#include "Workspace_Generator.h"
#include "Dependency_Graph.h"

#include <sstream>
#include <fstream>
#include <algorithm>

static const char * WORKSPACE_SUFFIX = "_CUTS.mwc";
static const char * PROJECT_SUFFIX = "_CoWorkEr.mpc";

static const char * STUB_SUFFIX = "_stub";
static const char * SVNT_SUFFIX = "_svnt";
static const char * EXEC_SUFFIX = "_exec";

#define GENERATE_COWORKER_NAME(out, node, suffix) \
  outfile << node->basename (); \
  if ((node->flags_ & CUTS_Dependency_Node::DNF_EXEC)) \
  { \
    out << "_CoWorkEr"; \
  } \
  outfile << suffix

//
// CUTS_Workspace_Generator
//
CUTS_Workspace_Generator::CUTS_Workspace_Generator (
  const std::string & outdir,
  const CUTS_Dependency_Graph & graph)
: outdir_ (outdir),
  graph_ (graph)
{

}

//
// ~CUTS_Workspace_Generator
//
CUTS_Workspace_Generator::~CUTS_Workspace_Generator (void)
{

}

//
// Visit_RootFolder
//
void CUTS_Workspace_Generator::Visit_RootFolder (
  const PICML::RootFolder & folder)
{
  // Create the workspace filename.
  std::ostringstream workspace;
  workspace
    << this->outdir_ << "/" << folder.name ()
    << WORKSPACE_SUFFIX << std::ends;

  // Open the file for writing.
  ofstream wfile;
  wfile.open (workspace.str ().c_str ());

  if (wfile.is_open ())
  {
    this->generate_workspace (wfile, folder.name ());
    wfile.close ();
  }
}

//
// generate_workspace
//
void CUTS_Workspace_Generator::generate_workspace (std::ofstream & outfile,
                                                   const std::string & name)
{
  outfile
    << "// This workspace file was generated by" << std::endl
    << "// $Id: Workspace_Generator.cpp,v 1.1.2.3 2006/06/07 04:08:01 hillj Exp $"
    << std::endl
    << std::endl
    << "workspace (" << name << "_CUTS) {" << std::endl
    << "  // -- Initialize the includes for the project." << std::endl
    << "  cmdline += -include $CUTS_ROOT/etc/config" << std::endl
    << std::endl
    << "  // -- Explicitly specify which project(s) to build" << std::endl;

  CUTS_Dependency_Graph::Dependency_Graph::const_iterator iter;

  for (iter = this->graph_.graph ().begin ();
       iter != this->graph_.graph ().end ();
       iter ++)
  {
    if ((iter->second->flags_ & (CUTS_Dependency_Node::DNF_STUB |
                                 CUTS_Dependency_Node::DNF_SVNT |
                                 CUTS_Dependency_Node::DNF_EXEC |
                                 CUTS_Dependency_Node::DNF_COWORKER)))
    {
      // Open the project file for writing.
      std::ostringstream project;
      project
        << this->outdir_ << "/"
        << iter->first << PROJECT_SUFFIX << std::ends;

      std::ofstream project_file;
      project_file.open (project.str ().c_str ());

      if (project_file.is_open ())
      {
        // Generate the project file.
        this->generate_project (project_file,
                                iter->second);
        project_file.close ();

        // Write the project file.
        outfile << "  " << iter->first << PROJECT_SUFFIX << std::endl;
      }
    }
  }

  // Close the workspace file definition.
  outfile << "}" << std::endl;
}

//
// generate_project
//
void CUTS_Workspace_Generator::generate_project (
  std::ofstream & outfile,
  const CUTS_Dependency_Node * node)
{
  outfile
    << "// This project file was generate by" << std::endl
    << "// $Id: Workspace_Generator.cpp,v 1.1.2.3 2006/06/07 04:08:01 hillj Exp $" << std::endl
    << std::endl;

  this->generate_stub_project (outfile, node);
  this->generate_svnt_project (outfile, node);
  this->generate_exec_project (outfile, node);
}

//
// generate_stub_project
//
void CUTS_Workspace_Generator::generate_stub_project (
  std::ofstream & outfile,
  const CUTS_Dependency_Node * node)
{
  if ((node->flags_ & CUTS_Dependency_Node::DNF_STUB) == 0)
  {
    return;
  }

  outfile << "project (";

  GENERATE_COWORKER_NAME (outfile, node, STUB_SUFFIX);

  outfile
    << ") : cuts_coworker_stub {"
    << std::endl
    << "  sharedname = ";

  GENERATE_COWORKER_NAME (outfile, node, STUB_SUFFIX) << std::endl;

  if (!node->references_.empty ())
  {
    // Generate the dependencies for this project.
    outfile << std::endl << "  after +=";
    CUTS_Reference_Set::const_iterator iter;

    for (iter  = node->references_.begin ();
          iter != node->references_.end ();
          iter ++)
    {
      outfile << " \\" << std::endl << "    ";
      GENERATE_COWORKER_NAME (outfile, (*iter), STUB_SUFFIX);
    }

    outfile << std::endl;

    // Generate the import libraries for this project.
    outfile << std::endl << "  libs +=";
    for (iter  = node->references_.begin ();
          iter != node->references_.end ();
          iter ++)
    {
      outfile << " \\" << std::endl << "    ";
      GENERATE_COWORKER_NAME (outfile, (*iter), STUB_SUFFIX);
    }

    outfile << std::endl;
  }

  outfile
    << std::endl
    // Generate the IDL files for this project.
    << "  IDL_Files {" << std::endl
    << "    " << node->basename () << ".idl" << std::endl
    << "  }" << std::endl
    << std::endl
    // Generate the source files for this project.
    << "  Source_Files {" << std::endl
    << "    " << node->basename () << "C.cpp" << std::endl
    << "  }" << std::endl
    << std::endl
    // Generate the header files for this project.
    << "  Header_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << "}" << std::endl
    << std::endl;
}

//
// generate_svnt_project
//
void CUTS_Workspace_Generator::generate_svnt_project (
  std::ofstream & outfile,
  const CUTS_Dependency_Node * node)
{
  if ((node->flags_ & CUTS_Dependency_Node::DNF_SVNT) == 0)
  {
    return;
  }

  outfile << "project (";

  GENERATE_COWORKER_NAME (outfile, node, SVNT_SUFFIX);

  outfile
    << ") : cuts_coworker_svnt {"
    << std::endl
    << "  sharedname = ";
  GENERATE_COWORKER_NAME (outfile, node, SVNT_SUFFIX) << std::endl;

  // Generate the dependencies.
  outfile << std::endl << "  after += ";
  GENERATE_COWORKER_NAME (outfile, node, STUB_SUFFIX);

  if (!node->references_.empty ())
  {
    CUTS_Reference_Set::const_iterator iter;

    for (iter  = node->references_.begin ();
          iter != node->references_.end ();
          iter ++)
    {
      outfile << " \\" << std::endl << "    ";
      GENERATE_COWORKER_NAME (outfile, (*iter), SVNT_SUFFIX);
    }
  }

  // Generate the import libraries.
  outfile << std::endl << std::endl << "  libs  += ";
  GENERATE_COWORKER_NAME (outfile, node, STUB_SUFFIX);

  if (!node->references_.empty ())
  {
    CUTS_Reference_Set::const_iterator iter;

    for (iter  = node->references_.begin ();
          iter != node->references_.end ();
          iter ++)
    {
      outfile << " \\" << std::endl << "    ";
      GENERATE_COWORKER_NAME (outfile, (*iter), STUB_SUFFIX) << " ";
      GENERATE_COWORKER_NAME (outfile, (*iter), SVNT_SUFFIX);
    }
  }

  outfile
    << std::endl << std::endl

    // Generate the CIDL files
    << "  CIDL_Files {" << std::endl;

  if ((node->flags_ & CUTS_Dependency_Node::DNF_EXEC))
  {
    outfile << "    " << node->basename () << ".cidl" << std::endl;
  }

  outfile
    << "  }" << std::endl
    << std::endl

    // Generate the IDL files
    << "  IDL_Files {" << std::endl;

  if ((node->flags_ & CUTS_Dependency_Node::DNF_EXEC))
  {
    outfile << "    " << node->basename () << "E.idl" << std::endl;
  }

  outfile
    << "  }" << std::endl
    << std::endl

    // Generate the source files
    << "  Source_Files {" << std::endl
    << "    " << node->basename () << "S.cpp" << std::endl;

  if ((node->flags_ & CUTS_Dependency_Node::DNF_EXEC))
  {
    outfile
      << "    " << node->basename () << "EC.cpp" << std::endl
      << "    " << node->basename () << "_svnt.cpp" << std::endl;
  }

  outfile
    << "  }" << std::endl
    << std::endl

    // Generate the header files
    << "  Header_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << "}" << std::endl
    << std::endl;
}

//
// generate_exec_project
//
void CUTS_Workspace_Generator::generate_exec_project (
  std::ofstream & outfile,
  const CUTS_Dependency_Node * node)
{
  if ((node->flags_ & CUTS_Dependency_Node::DNF_EXEC) == 0)
  {
    return;
  }

  outfile << "project (";
  GENERATE_COWORKER_NAME (outfile, node, EXEC_SUFFIX);

  outfile
    << ") : cuts_coworker_exec {"
    << std::endl
    << "  sharedname = ";

  GENERATE_COWORKER_NAME (outfile, node, EXEC_SUFFIX) << std::endl;


  // Generate the dependencies.
  outfile << std::endl << "  after += ";
  GENERATE_COWORKER_NAME (outfile, node, SVNT_SUFFIX);


  CUTS_Reference_Set::const_iterator iter;

  for (iter  = node->references_.begin ();
        iter != node->references_.end ();
        iter ++)
  {
    outfile << " \\" << std::endl << "    ";
    GENERATE_COWORKER_NAME (outfile, (*iter), SVNT_SUFFIX);
  }

  // Generate the import libraries for the project.
  outfile << std::endl << std::endl << "  libs  += ";
  GENERATE_COWORKER_NAME (outfile, node, STUB_SUFFIX) << " ";
  GENERATE_COWORKER_NAME (outfile, node, SVNT_SUFFIX);

  for (iter  = node->references_.begin ();
        iter != node->references_.end ();
        iter ++)
  {
    outfile << " \\" << std::endl << "    ";
    GENERATE_COWORKER_NAME (outfile, (*iter), STUB_SUFFIX) << " ";
    GENERATE_COWORKER_NAME (outfile, (*iter), SVNT_SUFFIX);
  }

  // Generate the additional import libraries needed for the executor
  // to compile successfully.
  for (String_Set::const_iterator iter = node->libs_.begin ();
        iter != node->libs_.end ();
        iter ++)
  {
    outfile
      << " \\" << std::endl
      << "    " << *iter;
  }

  // Generate the library paths needed for the executor
  // to compile successfully.
  if (!node->libpaths_.empty ())
  {
    outfile
      << std::endl << std::endl
      << "  libpaths += ";

    for (String_Set::const_iterator iter = node->libpaths_.begin ();
          iter != node->libpaths_.end ();
          iter ++)
    {
      outfile
        << " \\" << std::endl
        << "    " << *iter;
    }
  }

  outfile
    << std::endl << std::endl

    // Generate the source files.
    << "  Source_Files {" << std::endl
    << "    " << node->basename () << "_CoWorkEr.cpp" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the header files.
    << "  Header_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << std::endl
    << "  IDL_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << "}" << std::endl
    << std::endl;
}
