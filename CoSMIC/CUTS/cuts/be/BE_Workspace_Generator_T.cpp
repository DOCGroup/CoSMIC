// $Id$

#include "BE_Options.h"
#include "BE_Preprocessor.h"

#include "boost/bind.hpp"

#include <algorithm>
#include <sstream>
#include <fstream>

//
// CUTS_BE_Workspace_Generator_T
//
template <typename PROJ_STRATEGY>
CUTS_BE_Workspace_Generator_T <PROJ_STRATEGY>::
CUTS_BE_Workspace_Generator_T (void)
{

}

//
// ~CUTS_BE_Workspace_Generator_T
//
template <typename PROJ_STRATEGY>
CUTS_BE_Workspace_Generator_T <PROJ_STRATEGY>::
~CUTS_BE_Workspace_Generator_T (void)
{

}

//
// generate
//
template <typename PROJ_STRATEGY>
bool CUTS_BE_Workspace_Generator_T <PROJ_STRATEGY>::
generate (void)
{
  std::string workspace_name =
    CUTS_BE_OPTIONS ()->project_name_ + "_CUTS";

  // Construct the name of the workspace file.
  std::ostringstream ostr;
  ostr
    << CUTS_BE_OPTIONS ()->output_directory_
    << "/" << workspace_name << ".mwc";

  // Open the workspace file for writing.
  std::ofstream outfile;
  outfile.open (ostr.str ().c_str ());

  if (!outfile.is_open ())
    return false;

  // Write the prologue for the workspace file.
  outfile
    << "// -*- MWC -*-" << std::endl
    << std::endl
    << "//==================================================================="
    << std::endl
    << "// Makefile, Project, and Workspace Creator File" << std::endl
    << "//" << std::endl
    << "// This file was generated by" << std::endl
    << "// $Id$" << std::endl
    << "//==================================================================="
    << std::endl
    << std::endl
    << "workspace (" << workspace_name << ") {" << std::endl
    << "  // -- initialize the includes for the project." << std::endl
    << "  cmdline += -include $CUTS_ROOT/etc/config" << std::endl
    << std::endl
    << "  // -- implementation projects" << std::endl;

  // We are writing all the implementation projects.
  std::for_each (
    CUTS_BE_PREPROCESSOR ()->impls ().graph ().begin (),
    CUTS_BE_PREPROCESSOR ()->impls ().graph ().end (),
    boost::bind (&CUTS_BE_Workspace_Generator_T::generate_impl_project,
                 this,
                 boost::ref (outfile),
                 boost::bind (&CUTS_BE_Impl_Graph::Node_Map::value_type::second,
                              _1)));

  outfile
    << std::endl
    << "  // -- stub projects" << std::endl;

  // We are writing all the stub projects.
  std::for_each (
    this->required_stubs_.begin (),
    this->required_stubs_.end (),
    boost::bind (&CUTS_BE_Workspace_Generator_T::generate_stub_project,
                 this,
                 boost::ref (outfile),
                 _1));

  // Close the output file and return its status.
  outfile
    << "}" << std::endl;

  outfile.close ();
  return outfile.good ();
}

//
// write_impl_project
//
template <typename PROJ_STRATEGY>
void CUTS_BE_Workspace_Generator_T <PROJ_STRATEGY>::
generate_impl_project (std::ofstream & outfile,
                       const CUTS_BE_Impl_Node * node)
{
  // Generate the implementation project. We need to make sure that we
  // recognize if the impl is a proxy or executor. It would be easier
  // if we recognize it ourselves at this level and tell the generator
  // which type of project to generate (i.e., exec or proxy).
  if (node->impl_flags_[CUTS_BE_Impl_Node::IMPL_PROXY])
  {
    if (this->proj_generator_.generate_proxy (*node))
    {
      outfile
        << "  " << node->name_
        << CUTS_BE_OPTIONS ()->proxy_suffix_ << ".mpc" << std::endl;
    }
  }
  else
  {
    if (this->proj_generator_.generate_exec (*node))
    {
      outfile
        << "  " << node->name_
        << CUTS_BE_OPTIONS ()->exec_suffix_ << ".mpc" << std::endl;
    }
  }

  // Now, we need to add all the stubs for this implementation to the
  // collection of <required_stubs_>. We will iterate over this collection
  // once we have finished all the implementation projects.
  std::for_each (node->references_.begin (),
                 node->references_.end (),
                 boost::bind (&IDL_Node_Set::insert,
                              boost::ref (this->required_stubs_),
                              _1));
}

//
// write_stub_project
//
template <typename PROJ_STRATEGY>
void CUTS_BE_Workspace_Generator_T <PROJ_STRATEGY>::
generate_stub_project (std::ofstream & outfile,
                       const CUTS_BE_IDL_Node * node)
{
  // Locate the node in the <visited_nodes_> before we continue
  // process. The main idea is to only process nodes that we
  // haven't seen yet.
  IDL_Node_Set::const_iterator iter = this->visited_nodes_.find (node);

  if (iter == this->visited_nodes_.end ())
  {
    // Insert the node into the collection.
    this->visited_nodes_.insert (node);

    // Generate the project for the stub.
    if (this->proj_generator_.generate_stub (*node))
      outfile << "  " << node->name_ << "_stub.mpc" << std::endl;

    std::for_each (
      node->references_.begin (),
      node->references_.end (),
      boost::bind (&CUTS_BE_Workspace_Generator_T::generate_stub_project,
                   this,
                   boost::ref (outfile),
                   _1));
  }
}
