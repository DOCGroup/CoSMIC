// $Id$

#include "BE_Workspace_Generator.h"
#include "BE_IDL_Node.h"
#include "BE_IDL_Graph.h"
#include "BE_Options.h"
#include "BE_Project_Generator.h"
#include "CoWorkEr_Cache.h"
#include "boost/bind.hpp"
#include <algorithm>
#include <sstream>

const std::string WORKSPACE_SUFFIX ("_CUTS");

//
// CUTS_BE_Workspace_Generator
//
CUTS_BE_Workspace_Generator::
CUTS_BE_Workspace_Generator (CUTS_BE_Project_Generator * project)
: project_ (project),
  coworker_ (false)
{

}

//
// ~CUTS_BE_Workspace_Generator
//
CUTS_BE_Workspace_Generator::~CUTS_BE_Workspace_Generator (void)
{

}

//
// Visit_RootFolder
//
void CUTS_BE_Workspace_Generator::
Visit_RootFolder (const PICML::RootFolder & root)
{
  // Construct the filename for the workspace and open it for
  // writing.
  std::ostringstream filename;
  filename
    << CUTS_BE_Options::instance ()->output_directory_
    << "\\" << root.name () << "_CUTS.mwc";

  this->workspace_.open (filename.str ().c_str ());

  if (this->workspace_.is_open ())
  {
    this->workspace_
      << "// This workspace file was generated by" << std::endl
      << "// $Id$"
      << std::endl
      << std::endl
      << "workspace (" << root.name () << WORKSPACE_SUFFIX << ") {" << std::endl

      // Specify where to locate base projects for this workspace.
      << "  // -- Initialize the includes for the project." << std::endl
      << "  cmdline += -include $CUTS_ROOT/etc/config" << std::endl
      << std::endl
      << "  // -- Explicitly specify which components(s) to build"
      << std::endl;

    // Create an IDL dependency graph for the entire project.
    PICML::RootFolder (root).Accept (*CUTS_BE_IDL_Graph::instance ());

    // Visit the component implemenation folders.
    typedef std::vector <PICML::ComponentImplementations> Folder_Set;
    Folder_Set folders = root.ComponentImplementations_children ();

    std::for_each (folders.begin (),
                   folders.end (),
                   boost::bind (&Folder_Set::value_type::Accept,
                                _1,
                                boost::ref (*this)));

    this->workspace_
      << std::endl
      << "  // -- stub projects" << std::endl;

    typedef
    void (CUTS_BE_Workspace_Generator::*BE_WRITE_METHOD)
         (CUTS_BE_IDL_Node *);

    std::for_each (
      CUTS_BE_IDL_Graph::instance ()->graph ().begin (),
      CUTS_BE_IDL_Graph::instance ()->graph ().end (),
      boost::bind (static_cast <BE_WRITE_METHOD> (
                   &CUTS_BE_Workspace_Generator::write_project),
                   this,
                   boost::bind (&CUTS_BE_IDL_Graph::Node_Map::value_type::second,
                                _1)));

    this->workspace_ << "}" << std::endl;
    this->workspace_.close ();
  }

  // Reset the <workspace_> flags if necessary.
  if (!this->workspace_.good ())
    this->workspace_.clear ();
}

//
// Visit_ComponentImplementations
//
void CUTS_BE_Workspace_Generator::
Visit_ComponentImplementations (const PICML::ComponentImplementations & folder)
{
  // Visit all the component implementation containers.
  typedef std::vector <PICML::ComponentImplementationContainer> Container_Set;
  Container_Set containers = folder.ComponentImplementationContainer_children ();

  std::for_each (containers.begin (),
                 containers.end (),
                 boost::bind (&Container_Set::value_type::Accept,
                              _1,
                              boost::ref (*this)));
}

//
// Visit_ComponentImplementationContainer
//
void CUTS_BE_Workspace_Generator::
Visit_ComponentImplementationContainer (
const PICML::ComponentImplementationContainer & container)
{
  typedef std::vector <PICML::MonolithicImplementation> Impl_Set;
  Impl_Set monos = container.MonolithicImplementation_kind_children ();

  // Make sure we have the flag in the "off" state.
  this->coworker_ = false;

  for (Impl_Set::iterator iter = monos.begin ();
       iter != monos.end ();
       iter ++)
  {
    // Since we only care about CoWorkEr components, we should
    // verify that this is a CoWorkEr implementation before
    // continuing. Eventually we would want to abstract this
    // out so that we can do non-CoWorkEr components as well.
    iter->Accept (*this);
    if (!this->coworker_)
      continue;

    // Turn off the flag since we have made it this far.
    this->coworker_ = false;

    // Construct the MPC filename.
    std::string project = container.name ();
    project.append (".mpc");

    // Write the project to the workspace.
    std::ostringstream pathname;
    pathname << CUTS_BE_OPTIONS ()->output_directory_ << "\\" << project;
    this->workspace_ << "  " << project << std::endl;

    // Pass control to the project generator, if applicable.
    if (this->project_.get () != 0)
    {
      PICML::ComponentImplementationContainer (container).
      Accept (*this->project_.get ());
    }
  }
}

//
// Visit_MonolithicImplementation
//
void CUTS_BE_Workspace_Generator::
Visit_MonolithicImplementation (const PICML::MonolithicImplementation & mono)
{
  // Get the <Implements> connection from the model.
  PICML::Implements implements = mono.dstImplements ();
  if (implements == Udm::null)
    return;

  // Get the <ComponentRef> that we are attached to so that we
  // can visit the component.
  PICML::ComponentRef ref = implements.dstImplements_end ();
  PICML::Component component = ref.ref ();
  if (component == Udm::null)
    return;

  component.Accept (*this);
}

//
// Visit_Component
//
void CUTS_BE_Workspace_Generator::
Visit_Component (const PICML::Component & component)
{
  this->coworker_ =
    CUTS_CoWorkEr_Cache::instance ()->is_coworker (component);
}

//
// write_project
//
void CUTS_BE_Workspace_Generator::
write_project (CUTS_BE_IDL_Node * node)
{
  if ((node->flags_ & CUTS_BE_IDL_Node::IDL_VISITED) != 0)
    return;

  node->flags_ |= CUTS_BE_IDL_Node::IDL_VISITED;

  if ((node->flags_ & CUTS_BE_IDL_Node::IDL_STUB) == 0)
    return;

  if (this->project_.get () != 0)
  {
    // Write the stub project and add it to the listing of
    // project files if we are successful.
    if (this->project_->write_project (node))
      this->workspace_ << "  " << node->name_ << "_stub.mpc" << std::endl;
  }

  std::for_each (node->references_.begin (),
                 node->references_.end (),
                 boost::bind (&CUTS_BE_Workspace_Generator::write_project_i,
                              this,
                              _1));
}

//
// write_project_i
//
void CUTS_BE_Workspace_Generator::
write_project_i (CUTS_BE_IDL_Node * node)
{
  if (this->project_->write_project (node))
    this->workspace_ << "  " << node->name_ << "_stub.mpc" << std::endl;
}
