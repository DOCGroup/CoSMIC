#ifndef MOBIES_PICML_H
#define MOBIES_PICML_H

// header file PICML.h generated from diagram PICML
// generated with Udm version 3.33 on Thu May 29 20:35:24 2014

#include <UdmBase.h>

#if !defined(UDM_VERSION_MAJOR) || !defined(UDM_VERSION_MINOR)
#    error "Udm headers too old, they do not define UDM_VERSION"
#elif UDM_VERSION_MAJOR < 3
#    error "Udm headers too old, minimum version required 3.33"
#elif UDM_VERSION_MAJOR == 3 && UDM_VERSION_MINOR < 33
#    error "Udm headers too old, minimum version required 3.33"
#endif

#include <Uml.h>


#ifdef min
#undef min
#endif

#ifdef max
#undef max
#endif

#include "PICML_export.h"

namespace PICML {

	extern ::Uml::Diagram meta;
	class PICML_Export ComponentImplementationArtifact;
	class PICML_Export ComponentServantArtifact;
	class PICML_Export MonolithicImplementationBase;
	class PICML_Export ImplementationContainer;
	class PICML_Export Implemenation;
	class PICML_Export MonolithExecParameter;
	class PICML_Export MonolithDeployRequirement;
	class PICML_Export MonolithprimaryArtifact;
	class PICML_Export InfoProperty;
	class PICML_Export ConfigProperty;
	class PICML_Export ComponentFactoryImplementationContainer;
	class PICML_Export ComponentFactoryInstance;
	class PICML_Export ComponentFactoryImplementations;
	class PICML_Export ServiceConsumer;
	class PICML_Export ServiceLevels;
	class PICML_Export MultipleServiceRequests;
	class PICML_Export ServiceProvider;
	class PICML_Export RTRequirements;
	class PICML_Export ECRole;
	class PICML_Export ECBehavior;
	class PICML_Export ECRequirements;
	class PICML_Export PathReference;
	class PICML_Export PathProperty;
	class PICML_Export Paths;
	class PICML_Export DisplayNode;
	class PICML_Export Edge;
	class PICML_Export EdgeProperty;
	class PICML_Export SrcEdge;
	class PICML_Export GraphVertex;
	class PICML_Export DstEdge;
	class PICML_Export PathDiagrams;
	class PICML_Export Path;
	class PICML_Export ConnectedComponent;
	class PICML_Export BenchmarkCharacteristics;
	class PICML_Export PeriodicBenchmarks;
	class PICML_Export FixedIterationBenchmarks;
	class PICML_Export TriggerBenchmarks;
	class PICML_Export BenchmarkType;
	class PICML_Export WorkLoadOperationConnection;
	class PICML_Export ComponentOperation;
	class PICML_Export CompRef;
	class PICML_Export WorkloadCharacteristics;
	class PICML_Export Task;
	class PICML_Export TaskSet;
	class PICML_Export TimerEventSinkConn;
	class PICML_Export EventRef;
	class PICML_Export OperationRef;
	class PICML_Export MetricsBase;
	class PICML_Export BenchmarkAnalysis;
	class PICML_Export ComponentAnalyses;
	class PICML_Export Throughput;
	class PICML_Export Latency;
	class PICML_Export TimerConnection;
	class PICML_Export TimeProbe;
	class PICML_Export Jitter;
	class PICML_Export Maximum;
	class PICML_Export Minimum;
	class PICML_Export Average;
	class PICML_Export DataAnalysisBase;
	class PICML_Export MetricConnection;
	class PICML_Export Resource;
	class PICML_Export SharedResource;
	class PICML_Export NodeReference;
	class PICML_Export Node;
	class PICML_Export Interconnect;
	class PICML_Export Bridge;
	class PICML_Export CollocationGroupProperty;
	class PICML_Export PropertyMapping;
	class PICML_Export ComponentInstanceRef;
	class PICML_Export CollocationGroupMember;
	class PICML_Export Deploys;
	class PICML_Export ComponentFactoryRef;
	class PICML_Export CollocationGroup;
	class PICML_Export DeploymentPlans;
	class PICML_Export DeploymentPlan;
	class PICML_Export InstanceMapping;
	class PICML_Export PackageConfiguration;
	class PICML_Export PackageConfSpecializedConfig;
	class PICML_Export PackageConfSelectRequirement;
	class PICML_Export PackageConfConfigProperty;
	class PICML_Export PackageConfigurationContainer;
	class PICML_Export PackageConfigurations;
	class PICML_Export PackageConfReference;
	class PICML_Export PackageConfigurationReference;
	class PICML_Export PackageConfBasePackage;
	class PICML_Export ArtifactDependency;
	class PICML_Export ImplementationArtifact;
	class PICML_Export ArtifactInfoProperty;
	class PICML_Export ArtifactExecParameter;
	class PICML_Export ArtifactContainer;
	class PICML_Export ArtifactDeployRequirement;
	class PICML_Export ArtifactDependsOn;
	class PICML_Export ImplementationArtifactReference;
	class PICML_Export ImplementationArtifacts;
	class PICML_Export package;
	class PICML_Export TopLevelPackage;
	class PICML_Export TopLevelPackages;
	class PICML_Export TopLevelPackageContainer;
	class PICML_Export ComponentPackageReference;
	class PICML_Export ComponentPackage;
	class PICML_Export PackageConfigProperty;
	class PICML_Export PackageContainer;
	class PICML_Export PackageInfoProperty;
	class PICML_Export Implementation;
	class PICML_Export PackageInterface;
	class PICML_Export ComponentPackages;
	class PICML_Export ComplexProperty;
	class PICML_Export SimpleProperty;
	class PICML_Export Property;
	class PICML_Export DataValueBase;
	class PICML_Export SimpleType;
	class PICML_Export ComplexType;
	class PICML_Export DataValue;
	class PICML_Export ComplexTypeReference;
	class PICML_Export DataValueContainer;
	class PICML_Export DataType;
	class PICML_Export ImplementationRequirement;
	class PICML_Export RequirementBase;
	class PICML_Export Capability;
	class PICML_Export RequirementSatisfier;
	class PICML_Export SatisfierProperty;
	class PICML_Export ImplementationDependency;
	class PICML_Export Requirement;
	class PICML_Export InterconnectConnection;
	class PICML_Export Targets;
	class PICML_Export Domain;
	class PICML_Export BridgeConnection;
	class PICML_Export Shares;
	class PICML_Export Taggable;
	class PICML_Export Prefixable;
	class PICML_Export ParameterType;
	class PICML_Export ReturnType;
	class PICML_Export OutParameter;
	class PICML_Export InoutParameter;
	class PICML_Export InParameter;
	class PICML_Export HasExceptions;
	class PICML_Export OnewayOperation;
	class PICML_Export TwowayOperation;
	class PICML_Export FactoryOperation;
	class PICML_Export OperationBase;
	class PICML_Export LookupOperation;
	class PICML_Export ExceptionRef;
	class PICML_Export AttributeMember;
	class PICML_Export MakeMemberPrivate;
	class PICML_Export PrivateFlag;
	class PICML_Export GetException;
	class PICML_Export ObjectByValue;
	class PICML_Export SetException;
	class PICML_Export Attribute;
	class PICML_Export ReadonlyAttribute;
	class PICML_Export Supports;
	class PICML_Export SupportsInterfaces;
	class PICML_Export HasOperations;
	class PICML_Export Inheritable;
	class PICML_Export ValueObject;
	class PICML_Export Event;
	class PICML_Export Inherits;
	class PICML_Export Object;
	class PICML_Export Key;
	class PICML_Export KeyMember;
	class PICML_Export ArrayMember;
	class PICML_Export NoInheritable;
	class PICML_Export Member;
	class PICML_Export Boxed;
	class PICML_Export Alias;
	class PICML_Export Collection;
	class PICML_Export NamedType;
	class PICML_Export Discriminator;
	class PICML_Export MemberType;
	class PICML_Export LabelConnection;
	class PICML_Export Label;
	class PICML_Export SwitchedAggregate;
	class PICML_Export Aggregate;
	class PICML_Export EnumValue;
	class PICML_Export Enum;
	class PICML_Export Char;
	class PICML_Export StringType;
	class PICML_Export WideString;
	class PICML_Export WideChar;
	class PICML_Export CharType;
	class PICML_Export UnsignedShortInteger;
	class PICML_Export UnsignedLongLongInteger;
	class PICML_Export UnsignedLongInteger;
	class PICML_Export LongLongInteger;
	class PICML_Export UnsignedIntegerType;
	class PICML_Export SignedIntegerType;
	class PICML_Export IntegerType;
	class PICML_Export LongDoubleNumber;
	class PICML_Export FloatingPointType;
	class PICML_Export DoubleNumber;
	class PICML_Export TypeKind;
	class PICML_Export TypeEncoding;
	class PICML_Export GenericValue;
	class PICML_Export GenericValueObject;
	class PICML_Export GenericObject;
	class PICML_Export String;
	class PICML_Export FloatNumber;
	class PICML_Export LongInteger;
	class PICML_Export ShortInteger;
	class PICML_Export Boolean;
	class PICML_Export Byte;
	class PICML_Export PredefinedType;
	class PICML_Export PredefinedTypes;
	class PICML_Export TemplateParameterReference;
	class PICML_Export TemplatePackageAlias;
	class PICML_Export TemplateParameterValueType;
	class PICML_Export ExceptionType;
	class PICML_Export NativeValue;
	class PICML_Export TypeParameter;
	class PICML_Export TemplateParameter;
	class PICML_Export TemplatePackageInstance;
	class PICML_Export TemplateParameterValue;
	class PICML_Export PackageType;
	class PICML_Export CollectionParameter;
	class PICML_Export NameParameter;
	class PICML_Export Constant;
	class PICML_Export ConstantType;
	class PICML_Export InterfaceDefinitions;
	class PICML_Export FileRef;
	class PICML_Export Exception;
	class PICML_Export File;
	class PICML_Export Package;
	class PICML_Export Workspaces;
	class PICML_Export ExecutorProject;
	class PICML_Export ServantProject;
	class PICML_Export MPC;
	class PICML_Export ComponentLib;
	class PICML_Export StubProject;
	class PICML_Export ExtResourceConn;
	class PICML_Export ExternalResources;
	class PICML_Export Project;
	class PICML_Export ComponentBuild;
	class PICML_Export ExternalPort;
	class PICML_Export ComponentAssemblyReference;
	class PICML_Export ComponentAssembly;
	class PICML_Export ExtendedDelegate;
	class PICML_Export ExtendedPortDelegate;
	class PICML_Export ExtendedPortInstanceBase;
	class PICML_Export MirrorPortInstanceBase;
	class PICML_Export MirrorPortDelegate;
	class PICML_Export MirrorDelegate;
	class PICML_Export AssemblyConfigPropertyEnd;
	class PICML_Export ConnectorToFacet;
	class PICML_Export ConnectorToReceptacle;
	class PICML_Export ExternalPortEnd;
	class PICML_Export ProvidedRequestPortEnd;
	class PICML_Export ProvidedRequestPortDelegate;
	class PICML_Export RequiredRequestPortDelegate;
	class PICML_Export OutEventPortDelegate;
	class PICML_Export InEventPortDelegate;
	class PICML_Export RequiredRequestPortEnd;
	class PICML_Export ExtendPortEnd;
	class PICML_Export OutEventPortEnd;
	class PICML_Export InEventPortEnd;
	class PICML_Export Consume;
	class PICML_Export Publish;
	class PICML_Export AttributeMappingDelegate;
	class PICML_Export AttributeMappingValue;
	class PICML_Export AttributeMapping;
	class PICML_Export AttributeDelegate;
	class PICML_Export AttributeValue;
	class PICML_Export ExternalDelegate;
	class PICML_Export EventSinkDelegate;
	class PICML_Export EventSourceDelegate;
	class PICML_Export FacetDelegate;
	class PICML_Export ReceptacleDelegate;
	class PICML_Export SendsTo;
	class PICML_Export AssemblyConfigProperty;
	class PICML_Export AssemblyselectRequirement;
	class PICML_Export Invoke;
	class PICML_Export PortInstance;
	class PICML_Export SupportsInstance;
	class PICML_Export RequiredRequestPortInstance;
	class PICML_Export InEventPortInstance;
	class PICML_Export ProvidedRequestPortInstance;
	class PICML_Export OutEventPortInstance;
	class PICML_Export MirrorPortInstance;
	class PICML_Export ExtendedPortInstance;
	class PICML_Export AttributeInstance;
	class PICML_Export ComponentInstanceType;
	class PICML_Export ComponentInstance;
	class PICML_Export CriticalPath;
	class PICML_Export ComponentImplementationContainer;
	class PICML_Export MonolithicImplementation;
	class PICML_Export ComponentImplementation;
	class PICML_Export ComponentImplementationReference;
	class PICML_Export ComponentImplementations;
	class PICML_Export Implements;
	class PICML_Export ImplementationDependsOn;
	class PICML_Export ImplementationCapability;
	class PICML_Export CommonPortAttrs;
	class PICML_Export ComponentConfigProperty;
	class PICML_Export ComponentInfoProperty;
	class PICML_Export ComponentContainer;
	class PICML_Export ComponentProperty;
	class PICML_Export ComponentPropertyDescription;
	class PICML_Export ComponentTypes;
	class PICML_Export LookupKeyType;
	class PICML_Export LookupKey;
	class PICML_Export ExtendedPortBase;
	class PICML_Export MirrorPort;
	class PICML_Export ComponentInherits;
	class PICML_Export EventType;
	class PICML_Export PortType;
	class PICML_Export ExtendedPort;
	class PICML_Export EventPort;
	class PICML_Export ObjectPort;
	class PICML_Export Provideable;
	class PICML_Export ManagesComponent;
	class PICML_Export ComponentFactory;
	class PICML_Export Manageable;
	class PICML_Export ComponentRef;
	class PICML_Export Port;
	class PICML_Export InEventPort;
	class PICML_Export RequiredRequestPort;
	class PICML_Export ProvidedRequestPort;
	class PICML_Export OutEventPort;
	class PICML_Export Component;
	class PICML_Export ConnectorType;
	class PICML_Export ConnectorImplements;
	class PICML_Export ConnectorImplementationContainer;
	class PICML_Export ConnectorImplementation;
	class PICML_Export ConnectorImplementations;
	class PICML_Export ConnectorImplementationType;
	class PICML_Export ConnectorInstance;
	class PICML_Export ConnectorInherits;
	class PICML_Export ConnectorObject;
	class PICML_Export EffectBase;
	class PICML_Export TerminalEffect;
	class PICML_Export InputEffect;
	class PICML_Export Effect;
	class PICML_Export TerminalTransition;
	class PICML_Export Terminal;
	class PICML_Export LoopTransition;
	class PICML_Export WhileState;
	class PICML_Export DoWhileState;
	class PICML_Export ForState;
	class PICML_Export LoopState;
	class PICML_Export StateBase;
	class PICML_Export BranchTransition;
	class PICML_Export BranchState;
	class PICML_Export State;
	class PICML_Export Transition;
	class PICML_Export QueryInputBase;
	class PICML_Export QueryInput;
	class PICML_Export TopLevelBehavior;
	class PICML_Export MultiInput;
	class PICML_Export SingleOutputBase;
	class PICML_Export MultiOutputBase;
	class PICML_Export MultiInputBase;
	class PICML_Export SingleInputBase;
	class PICML_Export Input;
	class PICML_Export WorkerType;
	class PICML_Export ApplicationTask;
	class PICML_Export PeriodicEvent;
	class PICML_Export Environment;
	class PICML_Export TargetRequiredRequestPort;
	class PICML_Export CallAction;
	class PICML_Export RequestAction;
	class PICML_Export ActionType;
	class PICML_Export InputAction;
	class PICML_Export MultiInputAction;
	class PICML_Export QueryInputAction;
	class PICML_Export QueryAction;
	class PICML_Export ActionBase;
	class PICML_Export Finish;
	class PICML_Export OutputAction;
	class PICML_Export Action;
	class PICML_Export BehaviorInputAction;
	class PICML_Export BehaviorModel;
	class PICML_Export Variable;
	class PICML_Export Operation;
	class PICML_Export WorkerPackageBase;
	class PICML_Export WorkerPackage;
	class PICML_Export WorkerFile;
	class PICML_Export Worker;
	class PICML_Export WorkerLibraries;
	class PICML_Export WorkerLibrary;
	class PICML_Export RootFolder;
	class PICML_Export MgaObject;

	class PICML_Export Visitor : public ::Udm::BaseVisitor {
	public:
		virtual ~Visitor();

		virtual void Visit_ComponentImplementationArtifact(const ComponentImplementationArtifact &);
		virtual void Visit_ComponentServantArtifact(const ComponentServantArtifact &);
		virtual void Visit_MonolithExecParameter(const MonolithExecParameter &);
		virtual void Visit_MonolithDeployRequirement(const MonolithDeployRequirement &);
		virtual void Visit_MonolithprimaryArtifact(const MonolithprimaryArtifact &);
		virtual void Visit_InfoProperty(const InfoProperty &);
		virtual void Visit_ConfigProperty(const ConfigProperty &);
		virtual void Visit_ComponentFactoryImplementationContainer(const ComponentFactoryImplementationContainer &);
		virtual void Visit_ComponentFactoryInstance(const ComponentFactoryInstance &);
		virtual void Visit_ComponentFactoryImplementations(const ComponentFactoryImplementations &);
		virtual void Visit_ServiceConsumer(const ServiceConsumer &);
		virtual void Visit_ServiceLevels(const ServiceLevels &);
		virtual void Visit_MultipleServiceRequests(const MultipleServiceRequests &);
		virtual void Visit_ServiceProvider(const ServiceProvider &);
		virtual void Visit_RTRequirements(const RTRequirements &);
		virtual void Visit_ECRole(const ECRole &);
		virtual void Visit_ECBehavior(const ECBehavior &);
		virtual void Visit_ECRequirements(const ECRequirements &);
		virtual void Visit_PathReference(const PathReference &);
		virtual void Visit_PathProperty(const PathProperty &);
		virtual void Visit_Paths(const Paths &);
		virtual void Visit_DisplayNode(const DisplayNode &);
		virtual void Visit_Edge(const Edge &);
		virtual void Visit_EdgeProperty(const EdgeProperty &);
		virtual void Visit_SrcEdge(const SrcEdge &);
		virtual void Visit_DstEdge(const DstEdge &);
		virtual void Visit_PathDiagrams(const PathDiagrams &);
		virtual void Visit_Path(const Path &);
		virtual void Visit_ConnectedComponent(const ConnectedComponent &);
		virtual void Visit_BenchmarkCharacteristics(const BenchmarkCharacteristics &);
		virtual void Visit_PeriodicBenchmarks(const PeriodicBenchmarks &);
		virtual void Visit_FixedIterationBenchmarks(const FixedIterationBenchmarks &);
		virtual void Visit_TriggerBenchmarks(const TriggerBenchmarks &);
		virtual void Visit_WorkLoadOperationConnection(const WorkLoadOperationConnection &);
		virtual void Visit_ComponentOperation(const ComponentOperation &);
		virtual void Visit_CompRef(const CompRef &);
		virtual void Visit_WorkloadCharacteristics(const WorkloadCharacteristics &);
		virtual void Visit_Task(const Task &);
		virtual void Visit_TaskSet(const TaskSet &);
		virtual void Visit_TimerEventSinkConn(const TimerEventSinkConn &);
		virtual void Visit_EventRef(const EventRef &);
		virtual void Visit_OperationRef(const OperationRef &);
		virtual void Visit_BenchmarkAnalysis(const BenchmarkAnalysis &);
		virtual void Visit_ComponentAnalyses(const ComponentAnalyses &);
		virtual void Visit_Throughput(const Throughput &);
		virtual void Visit_Latency(const Latency &);
		virtual void Visit_TimerConnection(const TimerConnection &);
		virtual void Visit_TimeProbe(const TimeProbe &);
		virtual void Visit_Jitter(const Jitter &);
		virtual void Visit_Maximum(const Maximum &);
		virtual void Visit_Minimum(const Minimum &);
		virtual void Visit_Average(const Average &);
		virtual void Visit_MetricConnection(const MetricConnection &);
		virtual void Visit_Resource(const Resource &);
		virtual void Visit_SharedResource(const SharedResource &);
		virtual void Visit_NodeReference(const NodeReference &);
		virtual void Visit_Node(const Node &);
		virtual void Visit_Interconnect(const Interconnect &);
		virtual void Visit_Bridge(const Bridge &);
		virtual void Visit_CollocationGroupProperty(const CollocationGroupProperty &);
		virtual void Visit_PropertyMapping(const PropertyMapping &);
		virtual void Visit_ComponentInstanceRef(const ComponentInstanceRef &);
		virtual void Visit_Deploys(const Deploys &);
		virtual void Visit_ComponentFactoryRef(const ComponentFactoryRef &);
		virtual void Visit_CollocationGroup(const CollocationGroup &);
		virtual void Visit_DeploymentPlans(const DeploymentPlans &);
		virtual void Visit_DeploymentPlan(const DeploymentPlan &);
		virtual void Visit_InstanceMapping(const InstanceMapping &);
		virtual void Visit_PackageConfiguration(const PackageConfiguration &);
		virtual void Visit_PackageConfSpecializedConfig(const PackageConfSpecializedConfig &);
		virtual void Visit_PackageConfSelectRequirement(const PackageConfSelectRequirement &);
		virtual void Visit_PackageConfConfigProperty(const PackageConfConfigProperty &);
		virtual void Visit_PackageConfigurationContainer(const PackageConfigurationContainer &);
		virtual void Visit_PackageConfigurations(const PackageConfigurations &);
		virtual void Visit_PackageConfReference(const PackageConfReference &);
		virtual void Visit_PackageConfigurationReference(const PackageConfigurationReference &);
		virtual void Visit_PackageConfBasePackage(const PackageConfBasePackage &);
		virtual void Visit_ArtifactDependency(const ArtifactDependency &);
		virtual void Visit_ImplementationArtifact(const ImplementationArtifact &);
		virtual void Visit_ArtifactInfoProperty(const ArtifactInfoProperty &);
		virtual void Visit_ArtifactExecParameter(const ArtifactExecParameter &);
		virtual void Visit_ArtifactContainer(const ArtifactContainer &);
		virtual void Visit_ArtifactDeployRequirement(const ArtifactDeployRequirement &);
		virtual void Visit_ArtifactDependsOn(const ArtifactDependsOn &);
		virtual void Visit_ImplementationArtifactReference(const ImplementationArtifactReference &);
		virtual void Visit_ImplementationArtifacts(const ImplementationArtifacts &);
		virtual void Visit_package(const package &);
		virtual void Visit_TopLevelPackage(const TopLevelPackage &);
		virtual void Visit_TopLevelPackages(const TopLevelPackages &);
		virtual void Visit_TopLevelPackageContainer(const TopLevelPackageContainer &);
		virtual void Visit_ComponentPackageReference(const ComponentPackageReference &);
		virtual void Visit_ComponentPackage(const ComponentPackage &);
		virtual void Visit_PackageConfigProperty(const PackageConfigProperty &);
		virtual void Visit_PackageContainer(const PackageContainer &);
		virtual void Visit_PackageInfoProperty(const PackageInfoProperty &);
		virtual void Visit_Implementation(const Implementation &);
		virtual void Visit_PackageInterface(const PackageInterface &);
		virtual void Visit_ComponentPackages(const ComponentPackages &);
		virtual void Visit_ComplexProperty(const ComplexProperty &);
		virtual void Visit_SimpleProperty(const SimpleProperty &);
		virtual void Visit_DataValue(const DataValue &);
		virtual void Visit_ComplexTypeReference(const ComplexTypeReference &);
		virtual void Visit_DataValueContainer(const DataValueContainer &);
		virtual void Visit_DataType(const DataType &);
		virtual void Visit_ImplementationRequirement(const ImplementationRequirement &);
		virtual void Visit_Capability(const Capability &);
		virtual void Visit_SatisfierProperty(const SatisfierProperty &);
		virtual void Visit_ImplementationDependency(const ImplementationDependency &);
		virtual void Visit_Requirement(const Requirement &);
		virtual void Visit_InterconnectConnection(const InterconnectConnection &);
		virtual void Visit_Targets(const Targets &);
		virtual void Visit_Domain(const Domain &);
		virtual void Visit_BridgeConnection(const BridgeConnection &);
		virtual void Visit_Shares(const Shares &);
		virtual void Visit_ReturnType(const ReturnType &);
		virtual void Visit_OutParameter(const OutParameter &);
		virtual void Visit_InoutParameter(const InoutParameter &);
		virtual void Visit_InParameter(const InParameter &);
		virtual void Visit_OnewayOperation(const OnewayOperation &);
		virtual void Visit_TwowayOperation(const TwowayOperation &);
		virtual void Visit_FactoryOperation(const FactoryOperation &);
		virtual void Visit_LookupOperation(const LookupOperation &);
		virtual void Visit_ExceptionRef(const ExceptionRef &);
		virtual void Visit_AttributeMember(const AttributeMember &);
		virtual void Visit_MakeMemberPrivate(const MakeMemberPrivate &);
		virtual void Visit_PrivateFlag(const PrivateFlag &);
		virtual void Visit_GetException(const GetException &);
		virtual void Visit_SetException(const SetException &);
		virtual void Visit_Attribute(const Attribute &);
		virtual void Visit_ReadonlyAttribute(const ReadonlyAttribute &);
		virtual void Visit_Supports(const Supports &);
		virtual void Visit_ValueObject(const ValueObject &);
		virtual void Visit_Event(const Event &);
		virtual void Visit_Inherits(const Inherits &);
		virtual void Visit_Object(const Object &);
		virtual void Visit_Key(const Key &);
		virtual void Visit_KeyMember(const KeyMember &);
		virtual void Visit_ArrayMember(const ArrayMember &);
		virtual void Visit_Member(const Member &);
		virtual void Visit_Boxed(const Boxed &);
		virtual void Visit_Alias(const Alias &);
		virtual void Visit_Collection(const Collection &);
		virtual void Visit_Discriminator(const Discriminator &);
		virtual void Visit_LabelConnection(const LabelConnection &);
		virtual void Visit_Label(const Label &);
		virtual void Visit_SwitchedAggregate(const SwitchedAggregate &);
		virtual void Visit_Aggregate(const Aggregate &);
		virtual void Visit_EnumValue(const EnumValue &);
		virtual void Visit_Enum(const Enum &);
		virtual void Visit_Char(const Char &);
		virtual void Visit_WideString(const WideString &);
		virtual void Visit_WideChar(const WideChar &);
		virtual void Visit_UnsignedShortInteger(const UnsignedShortInteger &);
		virtual void Visit_UnsignedLongLongInteger(const UnsignedLongLongInteger &);
		virtual void Visit_UnsignedLongInteger(const UnsignedLongInteger &);
		virtual void Visit_LongLongInteger(const LongLongInteger &);
		virtual void Visit_LongDoubleNumber(const LongDoubleNumber &);
		virtual void Visit_DoubleNumber(const DoubleNumber &);
		virtual void Visit_TypeKind(const TypeKind &);
		virtual void Visit_TypeEncoding(const TypeEncoding &);
		virtual void Visit_GenericValue(const GenericValue &);
		virtual void Visit_GenericValueObject(const GenericValueObject &);
		virtual void Visit_GenericObject(const GenericObject &);
		virtual void Visit_String(const String &);
		virtual void Visit_FloatNumber(const FloatNumber &);
		virtual void Visit_LongInteger(const LongInteger &);
		virtual void Visit_ShortInteger(const ShortInteger &);
		virtual void Visit_Boolean(const Boolean &);
		virtual void Visit_Byte(const Byte &);
		virtual void Visit_PredefinedTypes(const PredefinedTypes &);
		virtual void Visit_TemplateParameterReference(const TemplateParameterReference &);
		virtual void Visit_TemplatePackageAlias(const TemplatePackageAlias &);
		virtual void Visit_NativeValue(const NativeValue &);
		virtual void Visit_TypeParameter(const TypeParameter &);
		virtual void Visit_TemplatePackageInstance(const TemplatePackageInstance &);
		virtual void Visit_TemplateParameterValue(const TemplateParameterValue &);
		virtual void Visit_PackageType(const PackageType &);
		virtual void Visit_CollectionParameter(const CollectionParameter &);
		virtual void Visit_NameParameter(const NameParameter &);
		virtual void Visit_Constant(const Constant &);
		virtual void Visit_InterfaceDefinitions(const InterfaceDefinitions &);
		virtual void Visit_FileRef(const FileRef &);
		virtual void Visit_Exception(const Exception &);
		virtual void Visit_File(const File &);
		virtual void Visit_Package(const Package &);
		virtual void Visit_Workspaces(const Workspaces &);
		virtual void Visit_ExecutorProject(const ExecutorProject &);
		virtual void Visit_ServantProject(const ServantProject &);
		virtual void Visit_MPC(const MPC &);
		virtual void Visit_StubProject(const StubProject &);
		virtual void Visit_ExtResourceConn(const ExtResourceConn &);
		virtual void Visit_ExternalResources(const ExternalResources &);
		virtual void Visit_Project(const Project &);
		virtual void Visit_ComponentBuild(const ComponentBuild &);
		virtual void Visit_ExternalPort(const ExternalPort &);
		virtual void Visit_ComponentAssemblyReference(const ComponentAssemblyReference &);
		virtual void Visit_ComponentAssembly(const ComponentAssembly &);
		virtual void Visit_ExtendedDelegate(const ExtendedDelegate &);
		virtual void Visit_ExtendedPortDelegate(const ExtendedPortDelegate &);
		virtual void Visit_MirrorPortDelegate(const MirrorPortDelegate &);
		virtual void Visit_MirrorDelegate(const MirrorDelegate &);
		virtual void Visit_ConnectorToFacet(const ConnectorToFacet &);
		virtual void Visit_ConnectorToReceptacle(const ConnectorToReceptacle &);
		virtual void Visit_ProvidedRequestPortDelegate(const ProvidedRequestPortDelegate &);
		virtual void Visit_RequiredRequestPortDelegate(const RequiredRequestPortDelegate &);
		virtual void Visit_OutEventPortDelegate(const OutEventPortDelegate &);
		virtual void Visit_InEventPortDelegate(const InEventPortDelegate &);
		virtual void Visit_Consume(const Consume &);
		virtual void Visit_Publish(const Publish &);
		virtual void Visit_AttributeMappingDelegate(const AttributeMappingDelegate &);
		virtual void Visit_AttributeMappingValue(const AttributeMappingValue &);
		virtual void Visit_AttributeMapping(const AttributeMapping &);
		virtual void Visit_AttributeDelegate(const AttributeDelegate &);
		virtual void Visit_AttributeValue(const AttributeValue &);
		virtual void Visit_ExternalDelegate(const ExternalDelegate &);
		virtual void Visit_EventSinkDelegate(const EventSinkDelegate &);
		virtual void Visit_EventSourceDelegate(const EventSourceDelegate &);
		virtual void Visit_FacetDelegate(const FacetDelegate &);
		virtual void Visit_ReceptacleDelegate(const ReceptacleDelegate &);
		virtual void Visit_SendsTo(const SendsTo &);
		virtual void Visit_AssemblyConfigProperty(const AssemblyConfigProperty &);
		virtual void Visit_AssemblyselectRequirement(const AssemblyselectRequirement &);
		virtual void Visit_Invoke(const Invoke &);
		virtual void Visit_SupportsInstance(const SupportsInstance &);
		virtual void Visit_RequiredRequestPortInstance(const RequiredRequestPortInstance &);
		virtual void Visit_InEventPortInstance(const InEventPortInstance &);
		virtual void Visit_ProvidedRequestPortInstance(const ProvidedRequestPortInstance &);
		virtual void Visit_OutEventPortInstance(const OutEventPortInstance &);
		virtual void Visit_MirrorPortInstance(const MirrorPortInstance &);
		virtual void Visit_ExtendedPortInstance(const ExtendedPortInstance &);
		virtual void Visit_AttributeInstance(const AttributeInstance &);
		virtual void Visit_ComponentInstanceType(const ComponentInstanceType &);
		virtual void Visit_ComponentInstance(const ComponentInstance &);
		virtual void Visit_CriticalPath(const CriticalPath &);
		virtual void Visit_ComponentImplementationContainer(const ComponentImplementationContainer &);
		virtual void Visit_MonolithicImplementation(const MonolithicImplementation &);
		virtual void Visit_ComponentImplementationReference(const ComponentImplementationReference &);
		virtual void Visit_ComponentImplementations(const ComponentImplementations &);
		virtual void Visit_Implements(const Implements &);
		virtual void Visit_ImplementationDependsOn(const ImplementationDependsOn &);
		virtual void Visit_ImplementationCapability(const ImplementationCapability &);
		virtual void Visit_ComponentConfigProperty(const ComponentConfigProperty &);
		virtual void Visit_ComponentInfoProperty(const ComponentInfoProperty &);
		virtual void Visit_ComponentContainer(const ComponentContainer &);
		virtual void Visit_ComponentProperty(const ComponentProperty &);
		virtual void Visit_ComponentPropertyDescription(const ComponentPropertyDescription &);
		virtual void Visit_ComponentTypes(const ComponentTypes &);
		virtual void Visit_LookupKey(const LookupKey &);
		virtual void Visit_MirrorPort(const MirrorPort &);
		virtual void Visit_ComponentInherits(const ComponentInherits &);
		virtual void Visit_PortType(const PortType &);
		virtual void Visit_ExtendedPort(const ExtendedPort &);
		virtual void Visit_ManagesComponent(const ManagesComponent &);
		virtual void Visit_ComponentFactory(const ComponentFactory &);
		virtual void Visit_ComponentRef(const ComponentRef &);
		virtual void Visit_InEventPort(const InEventPort &);
		virtual void Visit_RequiredRequestPort(const RequiredRequestPort &);
		virtual void Visit_ProvidedRequestPort(const ProvidedRequestPort &);
		virtual void Visit_OutEventPort(const OutEventPort &);
		virtual void Visit_Component(const Component &);
		virtual void Visit_ConnectorType(const ConnectorType &);
		virtual void Visit_ConnectorImplements(const ConnectorImplements &);
		virtual void Visit_ConnectorImplementationContainer(const ConnectorImplementationContainer &);
		virtual void Visit_ConnectorImplementation(const ConnectorImplementation &);
		virtual void Visit_ConnectorImplementations(const ConnectorImplementations &);
		virtual void Visit_ConnectorImplementationType(const ConnectorImplementationType &);
		virtual void Visit_ConnectorInstance(const ConnectorInstance &);
		virtual void Visit_ConnectorInherits(const ConnectorInherits &);
		virtual void Visit_ConnectorObject(const ConnectorObject &);
		virtual void Visit_TerminalEffect(const TerminalEffect &);
		virtual void Visit_InputEffect(const InputEffect &);
		virtual void Visit_Effect(const Effect &);
		virtual void Visit_TerminalTransition(const TerminalTransition &);
		virtual void Visit_Terminal(const Terminal &);
		virtual void Visit_LoopTransition(const LoopTransition &);
		virtual void Visit_WhileState(const WhileState &);
		virtual void Visit_DoWhileState(const DoWhileState &);
		virtual void Visit_ForState(const ForState &);
		virtual void Visit_BranchTransition(const BranchTransition &);
		virtual void Visit_BranchState(const BranchState &);
		virtual void Visit_State(const State &);
		virtual void Visit_Transition(const Transition &);
		virtual void Visit_QueryInput(const QueryInput &);
		virtual void Visit_MultiInput(const MultiInput &);
		virtual void Visit_Input(const Input &);
		virtual void Visit_WorkerType(const WorkerType &);
		virtual void Visit_ApplicationTask(const ApplicationTask &);
		virtual void Visit_PeriodicEvent(const PeriodicEvent &);
		virtual void Visit_Environment(const Environment &);
		virtual void Visit_TargetRequiredRequestPort(const TargetRequiredRequestPort &);
		virtual void Visit_CallAction(const CallAction &);
		virtual void Visit_RequestAction(const RequestAction &);
		virtual void Visit_ActionType(const ActionType &);
		virtual void Visit_InputAction(const InputAction &);
		virtual void Visit_MultiInputAction(const MultiInputAction &);
		virtual void Visit_QueryInputAction(const QueryInputAction &);
		virtual void Visit_QueryAction(const QueryAction &);
		virtual void Visit_Finish(const Finish &);
		virtual void Visit_OutputAction(const OutputAction &);
		virtual void Visit_Action(const Action &);
		virtual void Visit_Variable(const Variable &);
		virtual void Visit_Operation(const Operation &);
		virtual void Visit_WorkerPackage(const WorkerPackage &);
		virtual void Visit_WorkerFile(const WorkerFile &);
		virtual void Visit_Worker(const Worker &);
		virtual void Visit_WorkerLibraries(const WorkerLibraries &);
		virtual void Visit_WorkerLibrary(const WorkerLibrary &);
		virtual void Visit_RootFolder(const RootFolder &);
		virtual void Visit_Object(const ::Udm::Object &);

	};

	PICML_Export void Initialize();
	PICML_Export void Initialize(const ::Uml::Diagram &dgr);

	extern PICML_Export  ::Udm::UdmDiagram diagram;

	class PICML_Export ComponentFactoryImplementations : public ::Udm::Object {
	public:
		ComponentFactoryImplementations();
		ComponentFactoryImplementations(::Udm::ObjectImpl *impl);
		ComponentFactoryImplementations(const ComponentFactoryImplementations &master);

#ifdef UDM_RVALUE
		ComponentFactoryImplementations(ComponentFactoryImplementations &&master);

		static ComponentFactoryImplementations Cast(::Udm::Object &&a);
		ComponentFactoryImplementations& operator=(ComponentFactoryImplementations &&a);

#endif
		static ComponentFactoryImplementations Cast(const ::Udm::Object &a);
		static ComponentFactoryImplementations Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentFactoryImplementations CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentFactoryImplementations> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentFactoryImplementations, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentFactoryImplementations, Pred>(impl); };
		ComponentFactoryImplementations CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentFactoryImplementations> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentFactoryImplementations, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentFactoryImplementations, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentFactoryImplementations> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementationContainer> ComponentFactoryImplementationContainer_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementationContainer, Pred> ComponentFactoryImplementationContainer_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementationContainer, Pred>(impl, meta_ComponentFactoryImplementationContainer_children); };
		::Udm::ChildrenAttr< ::PICML::ImplementationContainer> ImplementationContainer_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationContainer, Pred> ImplementationContainer_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationContainer, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementationContainer> ComponentFactoryImplementationContainer_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementationContainer, Pred> ComponentFactoryImplementationContainer_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementationContainer, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_ComponentFactoryImplementationContainer_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export PathDiagrams : public ::Udm::Object {
	public:
		PathDiagrams();
		PathDiagrams(::Udm::ObjectImpl *impl);
		PathDiagrams(const PathDiagrams &master);

#ifdef UDM_RVALUE
		PathDiagrams(PathDiagrams &&master);

		static PathDiagrams Cast(::Udm::Object &&a);
		PathDiagrams& operator=(PathDiagrams &&a);

#endif
		static PathDiagrams Cast(const ::Udm::Object &a);
		static PathDiagrams Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PathDiagrams CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PathDiagrams> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PathDiagrams, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PathDiagrams, Pred>(impl); };
		PathDiagrams CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PathDiagrams> Derived();
		template <class Pred> ::Udm::DerivedAttr< PathDiagrams, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PathDiagrams, Pred>(impl); };
		::Udm::ArchetypeAttr< PathDiagrams> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::Paths> Paths_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Paths, Pred> Paths_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Paths, Pred>(impl, meta_Paths_children); };
		::Udm::ChildrenAttr< ::PICML::Paths> Paths_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Paths, Pred> Paths_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Paths, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_Paths_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export ComponentAnalyses : public ::Udm::Object {
	public:
		ComponentAnalyses();
		ComponentAnalyses(::Udm::ObjectImpl *impl);
		ComponentAnalyses(const ComponentAnalyses &master);

#ifdef UDM_RVALUE
		ComponentAnalyses(ComponentAnalyses &&master);

		static ComponentAnalyses Cast(::Udm::Object &&a);
		ComponentAnalyses& operator=(ComponentAnalyses &&a);

#endif
		static ComponentAnalyses Cast(const ::Udm::Object &a);
		static ComponentAnalyses Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentAnalyses CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentAnalyses> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentAnalyses, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentAnalyses, Pred>(impl); };
		ComponentAnalyses CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentAnalyses> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentAnalyses, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentAnalyses, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentAnalyses> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::BenchmarkAnalysis, Pred> BenchmarkAnalysis_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::BenchmarkAnalysis, Pred>(impl, meta_BenchmarkAnalysis_children); };
		::Udm::ChildrenAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::BenchmarkAnalysis, Pred> BenchmarkAnalysis_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::BenchmarkAnalysis, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_BenchmarkAnalysis_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export DeploymentPlans : public ::Udm::Object {
	public:
		DeploymentPlans();
		DeploymentPlans(::Udm::ObjectImpl *impl);
		DeploymentPlans(const DeploymentPlans &master);

#ifdef UDM_RVALUE
		DeploymentPlans(DeploymentPlans &&master);

		static DeploymentPlans Cast(::Udm::Object &&a);
		DeploymentPlans& operator=(DeploymentPlans &&a);

#endif
		static DeploymentPlans Cast(const ::Udm::Object &a);
		static DeploymentPlans Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		DeploymentPlans CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< DeploymentPlans> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< DeploymentPlans, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< DeploymentPlans, Pred>(impl); };
		DeploymentPlans CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< DeploymentPlans> Derived();
		template <class Pred> ::Udm::DerivedAttr< DeploymentPlans, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< DeploymentPlans, Pred>(impl); };
		::Udm::ArchetypeAttr< DeploymentPlans> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::DeploymentPlan> DeploymentPlan_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DeploymentPlan, Pred> DeploymentPlan_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DeploymentPlan, Pred>(impl, meta_DeploymentPlan_children); };
		::Udm::ChildrenAttr< ::PICML::DeploymentPlan> DeploymentPlan_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DeploymentPlan, Pred> DeploymentPlan_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DeploymentPlan, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_DeploymentPlan_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export PackageConfigurations : public ::Udm::Object {
	public:
		PackageConfigurations();
		PackageConfigurations(::Udm::ObjectImpl *impl);
		PackageConfigurations(const PackageConfigurations &master);

#ifdef UDM_RVALUE
		PackageConfigurations(PackageConfigurations &&master);

		static PackageConfigurations Cast(::Udm::Object &&a);
		PackageConfigurations& operator=(PackageConfigurations &&a);

#endif
		static PackageConfigurations Cast(const ::Udm::Object &a);
		static PackageConfigurations Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PackageConfigurations CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PackageConfigurations> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PackageConfigurations, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PackageConfigurations, Pred>(impl); };
		PackageConfigurations CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PackageConfigurations> Derived();
		template <class Pred> ::Udm::DerivedAttr< PackageConfigurations, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PackageConfigurations, Pred>(impl); };
		::Udm::ArchetypeAttr< PackageConfigurations> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageConfigurationContainer, Pred> PackageConfigurationContainer_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageConfigurationContainer, Pred>(impl, meta_PackageConfigurationContainer_children); };
		::Udm::ChildrenAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageConfigurationContainer, Pred> PackageConfigurationContainer_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageConfigurationContainer, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_PackageConfigurationContainer_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export ImplementationArtifacts : public ::Udm::Object {
	public:
		ImplementationArtifacts();
		ImplementationArtifacts(::Udm::ObjectImpl *impl);
		ImplementationArtifacts(const ImplementationArtifacts &master);

#ifdef UDM_RVALUE
		ImplementationArtifacts(ImplementationArtifacts &&master);

		static ImplementationArtifacts Cast(::Udm::Object &&a);
		ImplementationArtifacts& operator=(ImplementationArtifacts &&a);

#endif
		static ImplementationArtifacts Cast(const ::Udm::Object &a);
		static ImplementationArtifacts Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ImplementationArtifacts CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ImplementationArtifacts> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ImplementationArtifacts, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ImplementationArtifacts, Pred>(impl); };
		ImplementationArtifacts CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ImplementationArtifacts> Derived();
		template <class Pred> ::Udm::DerivedAttr< ImplementationArtifacts, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ImplementationArtifacts, Pred>(impl); };
		::Udm::ArchetypeAttr< ImplementationArtifacts> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::ArtifactContainer> ArtifactContainer_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ArtifactContainer, Pred> ArtifactContainer_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ArtifactContainer, Pred>(impl, meta_ArtifactContainer_children); };
		::Udm::ChildrenAttr< ::PICML::ArtifactContainer> ArtifactContainer_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ArtifactContainer, Pred> ArtifactContainer_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ArtifactContainer, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_ArtifactContainer_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export TopLevelPackages : public ::Udm::Object {
	public:
		TopLevelPackages();
		TopLevelPackages(::Udm::ObjectImpl *impl);
		TopLevelPackages(const TopLevelPackages &master);

#ifdef UDM_RVALUE
		TopLevelPackages(TopLevelPackages &&master);

		static TopLevelPackages Cast(::Udm::Object &&a);
		TopLevelPackages& operator=(TopLevelPackages &&a);

#endif
		static TopLevelPackages Cast(const ::Udm::Object &a);
		static TopLevelPackages Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TopLevelPackages CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TopLevelPackages> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TopLevelPackages, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TopLevelPackages, Pred>(impl); };
		TopLevelPackages CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TopLevelPackages> Derived();
		template <class Pred> ::Udm::DerivedAttr< TopLevelPackages, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TopLevelPackages, Pred>(impl); };
		::Udm::ArchetypeAttr< TopLevelPackages> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::TopLevelPackageContainer> TopLevelPackageContainer_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TopLevelPackageContainer, Pred> TopLevelPackageContainer_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TopLevelPackageContainer, Pred>(impl, meta_TopLevelPackageContainer_children); };
		::Udm::ChildrenAttr< ::PICML::TopLevelPackageContainer> TopLevelPackageContainer_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TopLevelPackageContainer, Pred> TopLevelPackageContainer_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TopLevelPackageContainer, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_TopLevelPackageContainer_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export ComponentPackages : public ::Udm::Object {
	public:
		ComponentPackages();
		ComponentPackages(::Udm::ObjectImpl *impl);
		ComponentPackages(const ComponentPackages &master);

#ifdef UDM_RVALUE
		ComponentPackages(ComponentPackages &&master);

		static ComponentPackages Cast(::Udm::Object &&a);
		ComponentPackages& operator=(ComponentPackages &&a);

#endif
		static ComponentPackages Cast(const ::Udm::Object &a);
		static ComponentPackages Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentPackages CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentPackages> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentPackages, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentPackages, Pred>(impl); };
		ComponentPackages CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentPackages> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentPackages, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentPackages, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentPackages> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::PackageContainer> PackageContainer_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageContainer, Pred> PackageContainer_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageContainer, Pred>(impl, meta_PackageContainer_children); };
		::Udm::ChildrenAttr< ::PICML::PackageContainer> PackageContainer_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageContainer, Pred> PackageContainer_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageContainer, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_PackageContainer_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export Targets : public ::Udm::Object {
	public:
		Targets();
		Targets(::Udm::ObjectImpl *impl);
		Targets(const Targets &master);

#ifdef UDM_RVALUE
		Targets(Targets &&master);

		static Targets Cast(::Udm::Object &&a);
		Targets& operator=(Targets &&a);

#endif
		static Targets Cast(const ::Udm::Object &a);
		static Targets Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Targets CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Targets> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Targets, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Targets, Pred>(impl); };
		Targets CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Targets> Derived();
		template <class Pred> ::Udm::DerivedAttr< Targets, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Targets, Pred>(impl); };
		::Udm::ArchetypeAttr< Targets> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::Domain> Domain_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Domain, Pred> Domain_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Domain, Pred>(impl, meta_Domain_children); };
		::Udm::ChildrenAttr< ::PICML::Domain> Domain_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Domain, Pred> Domain_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Domain, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_Domain_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export PredefinedTypes : public ::Udm::Object {
	public:
		PredefinedTypes();
		PredefinedTypes(::Udm::ObjectImpl *impl);
		PredefinedTypes(const PredefinedTypes &master);

#ifdef UDM_RVALUE
		PredefinedTypes(PredefinedTypes &&master);

		static PredefinedTypes Cast(::Udm::Object &&a);
		PredefinedTypes& operator=(PredefinedTypes &&a);

#endif
		static PredefinedTypes Cast(const ::Udm::Object &a);
		static PredefinedTypes Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PredefinedTypes CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PredefinedTypes> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PredefinedTypes, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PredefinedTypes, Pred>(impl); };
		PredefinedTypes CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PredefinedTypes> Derived();
		template <class Pred> ::Udm::DerivedAttr< PredefinedTypes, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PredefinedTypes, Pred>(impl); };
		::Udm::ArchetypeAttr< PredefinedTypes> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::PredefinedType> PredefinedType_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PredefinedType, Pred> PredefinedType_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PredefinedType, Pred>(impl, meta_PredefinedType_children); };
		::Udm::ChildrenAttr< ::PICML::SimpleType> SimpleType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SimpleType, Pred> SimpleType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SimpleType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MemberType> MemberType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MemberType, Pred> MemberType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MemberType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Char> Char_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Char, Pred> Char_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Char, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::StringType> StringType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::StringType, Pred> StringType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::StringType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::WideString> WideString_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WideString, Pred> WideString_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WideString, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::WideChar> WideChar_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WideChar, Pred> WideChar_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WideChar, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::CharType> CharType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CharType, Pred> CharType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CharType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::UnsignedShortInteger> UnsignedShortInteger_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::UnsignedShortInteger, Pred> UnsignedShortInteger_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::UnsignedShortInteger, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::UnsignedLongLongInteger> UnsignedLongLongInteger_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::UnsignedLongLongInteger, Pred> UnsignedLongLongInteger_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::UnsignedLongLongInteger, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::UnsignedLongInteger> UnsignedLongInteger_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::UnsignedLongInteger, Pred> UnsignedLongInteger_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::UnsignedLongInteger, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::LongLongInteger> LongLongInteger_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::LongLongInteger, Pred> LongLongInteger_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::LongLongInteger, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::UnsignedIntegerType> UnsignedIntegerType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::UnsignedIntegerType, Pred> UnsignedIntegerType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::UnsignedIntegerType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SignedIntegerType> SignedIntegerType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SignedIntegerType, Pred> SignedIntegerType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SignedIntegerType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::IntegerType> IntegerType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::IntegerType, Pred> IntegerType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::IntegerType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::LongDoubleNumber> LongDoubleNumber_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::LongDoubleNumber, Pred> LongDoubleNumber_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::LongDoubleNumber, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::FloatingPointType> FloatingPointType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::FloatingPointType, Pred> FloatingPointType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::FloatingPointType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::DoubleNumber> DoubleNumber_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DoubleNumber, Pred> DoubleNumber_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DoubleNumber, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TypeKind> TypeKind_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TypeKind, Pred> TypeKind_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TypeKind, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TypeEncoding> TypeEncoding_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TypeEncoding, Pred> TypeEncoding_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TypeEncoding, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::GenericValue> GenericValue_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::GenericValue, Pred> GenericValue_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::GenericValue, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::GenericValueObject> GenericValueObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::GenericValueObject, Pred> GenericValueObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::GenericValueObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::GenericObject> GenericObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::GenericObject, Pred> GenericObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::GenericObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::String> String_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::String, Pred> String_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::String, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::FloatNumber> FloatNumber_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::FloatNumber, Pred> FloatNumber_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::FloatNumber, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::LongInteger> LongInteger_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::LongInteger, Pred> LongInteger_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::LongInteger, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ShortInteger> ShortInteger_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ShortInteger, Pred> ShortInteger_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ShortInteger, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Boolean> Boolean_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Boolean, Pred> Boolean_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Boolean, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Byte> Byte_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Byte, Pred> Byte_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Byte, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PredefinedType> PredefinedType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PredefinedType, Pred> PredefinedType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PredefinedType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType> TemplateParameterValueType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType, Pred> TemplateParameterValueType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_PredefinedType_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export InterfaceDefinitions : public ::Udm::Object {
	public:
		InterfaceDefinitions();
		InterfaceDefinitions(::Udm::ObjectImpl *impl);
		InterfaceDefinitions(const InterfaceDefinitions &master);

#ifdef UDM_RVALUE
		InterfaceDefinitions(InterfaceDefinitions &&master);

		static InterfaceDefinitions Cast(::Udm::Object &&a);
		InterfaceDefinitions& operator=(InterfaceDefinitions &&a);

#endif
		static InterfaceDefinitions Cast(const ::Udm::Object &a);
		static InterfaceDefinitions Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		InterfaceDefinitions CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< InterfaceDefinitions> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< InterfaceDefinitions, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< InterfaceDefinitions, Pred>(impl); };
		InterfaceDefinitions CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< InterfaceDefinitions> Derived();
		template <class Pred> ::Udm::DerivedAttr< InterfaceDefinitions, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< InterfaceDefinitions, Pred>(impl); };
		::Udm::ArchetypeAttr< InterfaceDefinitions> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::File> File_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::File, Pred> File_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::File, Pred>(impl, meta_File_children); };
		::Udm::ChildrenAttr< ::PICML::Prefixable> Prefixable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Prefixable, Pred> Prefixable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Prefixable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::File> File_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::File, Pred> File_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::File, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_File_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export ComponentBuild : public ::Udm::Object {
	public:
		ComponentBuild();
		ComponentBuild(::Udm::ObjectImpl *impl);
		ComponentBuild(const ComponentBuild &master);

#ifdef UDM_RVALUE
		ComponentBuild(ComponentBuild &&master);

		static ComponentBuild Cast(::Udm::Object &&a);
		ComponentBuild& operator=(ComponentBuild &&a);

#endif
		static ComponentBuild Cast(const ::Udm::Object &a);
		static ComponentBuild Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentBuild CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentBuild> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentBuild, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentBuild, Pred>(impl); };
		ComponentBuild CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentBuild> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentBuild, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentBuild, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentBuild> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::MPC> MPC_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MPC, Pred> MPC_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MPC, Pred>(impl, meta_MPC_children); };
		::Udm::ChildrenAttr< ::PICML::MPC> MPC_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MPC, Pred> MPC_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MPC, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_MPC_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export ComponentImplementations : public ::Udm::Object {
	public:
		ComponentImplementations();
		ComponentImplementations(::Udm::ObjectImpl *impl);
		ComponentImplementations(const ComponentImplementations &master);

#ifdef UDM_RVALUE
		ComponentImplementations(ComponentImplementations &&master);

		static ComponentImplementations Cast(::Udm::Object &&a);
		ComponentImplementations& operator=(ComponentImplementations &&a);

#endif
		static ComponentImplementations Cast(const ::Udm::Object &a);
		static ComponentImplementations Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentImplementations CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentImplementations> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentImplementations, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentImplementations, Pred>(impl); };
		ComponentImplementations CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentImplementations> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentImplementations, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentImplementations, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentImplementations> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentImplementationContainer, Pred> ComponentImplementationContainer_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentImplementationContainer, Pred>(impl, meta_ComponentImplementationContainer_children); };
		::Udm::ChildrenAttr< ::PICML::ImplementationContainer> ImplementationContainer_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationContainer, Pred> ImplementationContainer_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationContainer, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentImplementationContainer, Pred> ComponentImplementationContainer_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentImplementationContainer, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_ComponentImplementationContainer_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export ComponentTypes : public ::Udm::Object {
	public:
		ComponentTypes();
		ComponentTypes(::Udm::ObjectImpl *impl);
		ComponentTypes(const ComponentTypes &master);

#ifdef UDM_RVALUE
		ComponentTypes(ComponentTypes &&master);

		static ComponentTypes Cast(::Udm::Object &&a);
		ComponentTypes& operator=(ComponentTypes &&a);

#endif
		static ComponentTypes Cast(const ::Udm::Object &a);
		static ComponentTypes Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentTypes CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentTypes> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentTypes, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentTypes, Pred>(impl); };
		ComponentTypes CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentTypes> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentTypes, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentTypes, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentTypes> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::ComponentContainer> ComponentContainer_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentContainer, Pred> ComponentContainer_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentContainer, Pred>(impl, meta_ComponentContainer_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentContainer> ComponentContainer_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentContainer, Pred> ComponentContainer_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentContainer, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_ComponentContainer_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export ConnectorImplementations : public ::Udm::Object {
	public:
		ConnectorImplementations();
		ConnectorImplementations(::Udm::ObjectImpl *impl);
		ConnectorImplementations(const ConnectorImplementations &master);

#ifdef UDM_RVALUE
		ConnectorImplementations(ConnectorImplementations &&master);

		static ConnectorImplementations Cast(::Udm::Object &&a);
		ConnectorImplementations& operator=(ConnectorImplementations &&a);

#endif
		static ConnectorImplementations Cast(const ::Udm::Object &a);
		static ConnectorImplementations Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ConnectorImplementations CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ConnectorImplementations> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ConnectorImplementations, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ConnectorImplementations, Pred>(impl); };
		ConnectorImplementations CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ConnectorImplementations> Derived();
		template <class Pred> ::Udm::DerivedAttr< ConnectorImplementations, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ConnectorImplementations, Pred>(impl); };
		::Udm::ArchetypeAttr< ConnectorImplementations> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::ConnectorImplementationContainer> ConnectorImplementationContainer_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorImplementationContainer, Pred> ConnectorImplementationContainer_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorImplementationContainer, Pred>(impl, meta_ConnectorImplementationContainer_children); };
		::Udm::ChildrenAttr< ::PICML::ImplementationContainer> ImplementationContainer_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationContainer, Pred> ImplementationContainer_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationContainer, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ConnectorImplementationContainer> ConnectorImplementationContainer_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorImplementationContainer, Pred> ConnectorImplementationContainer_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorImplementationContainer, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_ConnectorImplementationContainer_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export WorkerLibraries : public ::Udm::Object {
	public:
		WorkerLibraries();
		WorkerLibraries(::Udm::ObjectImpl *impl);
		WorkerLibraries(const WorkerLibraries &master);

#ifdef UDM_RVALUE
		WorkerLibraries(WorkerLibraries &&master);

		static WorkerLibraries Cast(::Udm::Object &&a);
		WorkerLibraries& operator=(WorkerLibraries &&a);

#endif
		static WorkerLibraries Cast(const ::Udm::Object &a);
		static WorkerLibraries Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		WorkerLibraries CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< WorkerLibraries> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< WorkerLibraries, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< WorkerLibraries, Pred>(impl); };
		WorkerLibraries CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< WorkerLibraries> Derived();
		template <class Pred> ::Udm::DerivedAttr< WorkerLibraries, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< WorkerLibraries, Pred>(impl); };
		::Udm::ArchetypeAttr< WorkerLibraries> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::WorkerLibrary> WorkerLibrary_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkerLibrary, Pred> WorkerLibrary_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkerLibrary, Pred>(impl, meta_WorkerLibrary_children); };
		::Udm::ChildrenAttr< ::PICML::WorkerLibrary> WorkerLibrary_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkerLibrary, Pred> WorkerLibrary_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkerLibrary, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_WorkerLibrary_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export RootFolder : public ::Udm::Object {
	public:
		RootFolder();
		RootFolder(::Udm::ObjectImpl *impl);
		RootFolder(const RootFolder &master);

#ifdef UDM_RVALUE
		RootFolder(RootFolder &&master);

		static RootFolder Cast(::Udm::Object &&a);
		RootFolder& operator=(RootFolder &&a);

#endif
		static RootFolder Cast(const ::Udm::Object &a);
		static RootFolder Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		RootFolder CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< RootFolder> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< RootFolder, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< RootFolder, Pred>(impl); };
		RootFolder CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< RootFolder> Derived();
		template <class Pred> ::Udm::DerivedAttr< RootFolder, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< RootFolder, Pred>(impl); };
		::Udm::ArchetypeAttr< RootFolder> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementations> ComponentFactoryImplementations_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementations, Pred> ComponentFactoryImplementations_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementations, Pred>(impl, meta_ComponentFactoryImplementations_children); };
		::Udm::ChildrenAttr< ::PICML::PathDiagrams> PathDiagrams_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PathDiagrams, Pred> PathDiagrams_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PathDiagrams, Pred>(impl, meta_PathDiagrams_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentAnalyses> ComponentAnalyses_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentAnalyses, Pred> ComponentAnalyses_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentAnalyses, Pred>(impl, meta_ComponentAnalyses_children); };
		::Udm::ChildrenAttr< ::PICML::DeploymentPlans> DeploymentPlans_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DeploymentPlans, Pred> DeploymentPlans_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DeploymentPlans, Pred>(impl, meta_DeploymentPlans_children); };
		::Udm::ChildrenAttr< ::PICML::PackageConfigurations> PackageConfigurations_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageConfigurations, Pred> PackageConfigurations_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageConfigurations, Pred>(impl, meta_PackageConfigurations_children); };
		::Udm::ChildrenAttr< ::PICML::ImplementationArtifacts> ImplementationArtifacts_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationArtifacts, Pred> ImplementationArtifacts_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationArtifacts, Pred>(impl, meta_ImplementationArtifacts_children); };
		::Udm::ChildrenAttr< ::PICML::TopLevelPackages> TopLevelPackages_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TopLevelPackages, Pred> TopLevelPackages_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TopLevelPackages, Pred>(impl, meta_TopLevelPackages_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentPackages> ComponentPackages_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentPackages, Pred> ComponentPackages_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentPackages, Pred>(impl, meta_ComponentPackages_children); };
		::Udm::ChildrenAttr< ::PICML::Targets> Targets_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Targets, Pred> Targets_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Targets, Pred>(impl, meta_Targets_children); };
		::Udm::ChildrenAttr< ::PICML::PredefinedTypes> PredefinedTypes_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PredefinedTypes, Pred> PredefinedTypes_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PredefinedTypes, Pred>(impl, meta_PredefinedTypes_children); };
		::Udm::ChildrenAttr< ::PICML::InterfaceDefinitions> InterfaceDefinitions_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InterfaceDefinitions, Pred> InterfaceDefinitions_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InterfaceDefinitions, Pred>(impl, meta_InterfaceDefinitions_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentBuild> ComponentBuild_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentBuild, Pred> ComponentBuild_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentBuild, Pred>(impl, meta_ComponentBuild_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentImplementations> ComponentImplementations_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentImplementations, Pred> ComponentImplementations_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentImplementations, Pred>(impl, meta_ComponentImplementations_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentTypes> ComponentTypes_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentTypes, Pred> ComponentTypes_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentTypes, Pred>(impl, meta_ComponentTypes_children); };
		::Udm::ChildrenAttr< ::PICML::ConnectorImplementations> ConnectorImplementations_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorImplementations, Pred> ConnectorImplementations_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorImplementations, Pred>(impl, meta_ConnectorImplementations_children); };
		::Udm::ChildrenAttr< ::PICML::WorkerLibraries> WorkerLibraries_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkerLibraries, Pred> WorkerLibraries_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkerLibraries, Pred>(impl, meta_WorkerLibraries_children); };
		::Udm::ChildrenAttr< ::PICML::RootFolder> RootFolder_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RootFolder, Pred> RootFolder_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RootFolder, Pred>(impl, meta_RootFolder_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementations> ComponentFactoryImplementations_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementations, Pred> ComponentFactoryImplementations_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentFactoryImplementations, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PathDiagrams> PathDiagrams_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PathDiagrams, Pred> PathDiagrams_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PathDiagrams, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentAnalyses> ComponentAnalyses_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentAnalyses, Pred> ComponentAnalyses_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentAnalyses, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::DeploymentPlans> DeploymentPlans_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DeploymentPlans, Pred> DeploymentPlans_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DeploymentPlans, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PackageConfigurations> PackageConfigurations_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageConfigurations, Pred> PackageConfigurations_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageConfigurations, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ImplementationArtifacts> ImplementationArtifacts_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationArtifacts, Pred> ImplementationArtifacts_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationArtifacts, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TopLevelPackages> TopLevelPackages_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TopLevelPackages, Pred> TopLevelPackages_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TopLevelPackages, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentPackages> ComponentPackages_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentPackages, Pred> ComponentPackages_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentPackages, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Targets> Targets_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Targets, Pred> Targets_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Targets, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PredefinedTypes> PredefinedTypes_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PredefinedTypes, Pred> PredefinedTypes_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PredefinedTypes, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::InterfaceDefinitions> InterfaceDefinitions_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InterfaceDefinitions, Pred> InterfaceDefinitions_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InterfaceDefinitions, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentBuild> ComponentBuild_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentBuild, Pred> ComponentBuild_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentBuild, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentImplementations> ComponentImplementations_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentImplementations, Pred> ComponentImplementations_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentImplementations, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentTypes> ComponentTypes_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentTypes, Pred> ComponentTypes_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentTypes, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ConnectorImplementations> ConnectorImplementations_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorImplementations, Pred> ConnectorImplementations_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorImplementations, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::WorkerLibraries> WorkerLibraries_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkerLibraries, Pred> WorkerLibraries_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkerLibraries, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RootFolder> RootFolder_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RootFolder, Pred> RootFolder_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RootFolder, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RootFolder> RootFolder_parent() const;
		::Udm::ParentAttr< ::PICML::RootFolder> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::CompositionChildRole meta_ComponentFactoryImplementations_children;
		static ::Uml::CompositionChildRole meta_PathDiagrams_children;
		static ::Uml::CompositionChildRole meta_ComponentAnalyses_children;
		static ::Uml::CompositionChildRole meta_DeploymentPlans_children;
		static ::Uml::CompositionChildRole meta_PackageConfigurations_children;
		static ::Uml::CompositionChildRole meta_ImplementationArtifacts_children;
		static ::Uml::CompositionChildRole meta_TopLevelPackages_children;
		static ::Uml::CompositionChildRole meta_ComponentPackages_children;
		static ::Uml::CompositionChildRole meta_Targets_children;
		static ::Uml::CompositionChildRole meta_PredefinedTypes_children;
		static ::Uml::CompositionChildRole meta_InterfaceDefinitions_children;
		static ::Uml::CompositionChildRole meta_ComponentBuild_children;
		static ::Uml::CompositionChildRole meta_ComponentImplementations_children;
		static ::Uml::CompositionChildRole meta_ComponentTypes_children;
		static ::Uml::CompositionChildRole meta_ConnectorImplementations_children;
		static ::Uml::CompositionChildRole meta_WorkerLibraries_children;
		static ::Uml::CompositionChildRole meta_RootFolder_children;
		static ::Uml::CompositionParentRole meta_RootFolder_parent;

	};

	class PICML_Export MgaObject : public ::Udm::Object {
	public:
		MgaObject();
		MgaObject(::Udm::ObjectImpl *impl);
		MgaObject(const MgaObject &master);

#ifdef UDM_RVALUE
		MgaObject(MgaObject &&master);

		static MgaObject Cast(::Udm::Object &&a);
		MgaObject& operator=(MgaObject &&a);

#endif
		static MgaObject Cast(const ::Udm::Object &a);
		static MgaObject Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MgaObject CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MgaObject> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MgaObject, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MgaObject, Pred>(impl); };
		MgaObject CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MgaObject> Derived();
		template <class Pred> ::Udm::DerivedAttr< MgaObject, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MgaObject, Pred>(impl); };
		::Udm::ArchetypeAttr< MgaObject> Archetype() const;
		::Udm::StringAttr name() const;
		::Udm::StringAttr position() const;
		::Udm::ParentAttr< ::Udm::Object> parent() const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_name;
		static ::Uml::Attribute meta_position;

	};

	class PICML_Export ImplementationContainer :  public MgaObject {
	public:
		ImplementationContainer();
		ImplementationContainer(::Udm::ObjectImpl *impl);
		ImplementationContainer(const ImplementationContainer &master);

#ifdef UDM_RVALUE
		ImplementationContainer(ImplementationContainer &&master);

		static ImplementationContainer Cast(::Udm::Object &&a);
		ImplementationContainer& operator=(ImplementationContainer &&a);

#endif
		static ImplementationContainer Cast(const ::Udm::Object &a);
		static ImplementationContainer Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ImplementationContainer CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ImplementationContainer> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ImplementationContainer, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ImplementationContainer, Pred>(impl); };
		ImplementationContainer CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ImplementationContainer> Derived();
		template <class Pred> ::Udm::DerivedAttr< ImplementationContainer, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ImplementationContainer, Pred>(impl); };
		::Udm::ArchetypeAttr< ImplementationContainer> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::Property> Property_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); };
		::Udm::ChildrenAttr< ::PICML::ImplementationRequirement> ImplementationRequirement_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationRequirement, Pred> ImplementationRequirement_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationRequirement, Pred>(impl, meta_ImplementationRequirement_children); };
		::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred> ImplementationArtifactReference_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred>(impl, meta_ImplementationArtifactReference_children); };
		::Udm::ChildrenAttr< ::PICML::MonolithExecParameter> MonolithExecParameter_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MonolithExecParameter, Pred> MonolithExecParameter_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MonolithExecParameter, Pred>(impl, meta_MonolithExecParameter_children); };
		::Udm::ChildrenAttr< ::PICML::MonolithDeployRequirement> MonolithDeployRequirement_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MonolithDeployRequirement, Pred> MonolithDeployRequirement_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MonolithDeployRequirement, Pred>(impl, meta_MonolithDeployRequirement_children); };
		::Udm::ChildrenAttr< ::PICML::MonolithprimaryArtifact> MonolithprimaryArtifact_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MonolithprimaryArtifact, Pred> MonolithprimaryArtifact_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MonolithprimaryArtifact, Pred>(impl, meta_MonolithprimaryArtifact_children); };
		::Udm::ChildrenAttr< ::PICML::ConfigProperty> ConfigProperty_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConfigProperty, Pred> ConfigProperty_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConfigProperty, Pred>(impl, meta_ConfigProperty_children); };
		::Udm::ChildrenAttr< ::PICML::InfoProperty> InfoProperty_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InfoProperty, Pred> InfoProperty_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InfoProperty, Pred>(impl, meta_InfoProperty_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact> ComponentImplementationArtifact_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred> ComponentImplementationArtifact_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentServantArtifact> ComponentServantArtifact_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred> ComponentServantArtifact_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MonolithExecParameter> MonolithExecParameter_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MonolithExecParameter, Pred> MonolithExecParameter_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MonolithExecParameter, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MonolithDeployRequirement> MonolithDeployRequirement_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MonolithDeployRequirement, Pred> MonolithDeployRequirement_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MonolithDeployRequirement, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MonolithprimaryArtifact> MonolithprimaryArtifact_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MonolithprimaryArtifact, Pred> MonolithprimaryArtifact_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MonolithprimaryArtifact, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::InfoProperty> InfoProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InfoProperty, Pred> InfoProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InfoProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ConfigProperty> ConfigProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConfigProperty, Pred> ConfigProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConfigProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred> ImplementationArtifactReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComplexProperty> ComplexProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred> ComplexProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SimpleProperty> SimpleProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred> SimpleProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ImplementationRequirement> ImplementationRequirement_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationRequirement, Pred> ImplementationRequirement_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationRequirement, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequirementBase> RequirementBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequirementBase, Pred> RequirementBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequirementBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::Udm::Object> parent() const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_ImplementationRequirement_children;
		static ::Uml::CompositionChildRole meta_ImplementationArtifactReference_children;
		static ::Uml::CompositionChildRole meta_MonolithExecParameter_children;
		static ::Uml::CompositionChildRole meta_MonolithDeployRequirement_children;
		static ::Uml::CompositionChildRole meta_MonolithprimaryArtifact_children;
		static ::Uml::CompositionChildRole meta_ConfigProperty_children;
		static ::Uml::CompositionChildRole meta_InfoProperty_children;

	};

	class PICML_Export Implemenation :  public MgaObject {
	public:
		Implemenation();
		Implemenation(::Udm::ObjectImpl *impl);
		Implemenation(const Implemenation &master);

#ifdef UDM_RVALUE
		Implemenation(Implemenation &&master);

		static Implemenation Cast(::Udm::Object &&a);
		Implemenation& operator=(Implemenation &&a);

#endif
		static Implemenation Cast(const ::Udm::Object &a);
		static Implemenation Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Implemenation CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Implemenation> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Implemenation, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Implemenation, Pred>(impl); };
		Implemenation CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Implemenation> Derived();
		template <class Pred> ::Udm::DerivedAttr< Implemenation, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Implemenation, Pred>(impl); };
		::Udm::ArchetypeAttr< Implemenation> Archetype() const;
		::Udm::StringAttr label() const;
		::Udm::StringAttr UUID() const;
		::Udm::AClassAssocAttr< InfoProperty, Property> dstInfoProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< InfoProperty, Property, Pred> dstInfoProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< InfoProperty, Property, Pred>(impl, meta_dstInfoProperty, meta_dstInfoProperty_rev); };
		::Udm::AClassAssocAttr< ConfigProperty, Property> dstConfigProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< ConfigProperty, Property, Pred> dstConfigProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ConfigProperty, Property, Pred>(impl, meta_dstConfigProperty, meta_dstConfigProperty_rev); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_label;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::AssociationRole meta_dstInfoProperty;
		static ::Uml::AssociationRole meta_dstInfoProperty_rev;
		static ::Uml::AssociationRole meta_dstConfigProperty;
		static ::Uml::AssociationRole meta_dstConfigProperty_rev;

	};

	class PICML_Export MonolithicImplementationBase :  virtual  public Implemenation {
	public:
		MonolithicImplementationBase();
		MonolithicImplementationBase(::Udm::ObjectImpl *impl);
		MonolithicImplementationBase(const MonolithicImplementationBase &master);

#ifdef UDM_RVALUE
		MonolithicImplementationBase(MonolithicImplementationBase &&master);

		static MonolithicImplementationBase Cast(::Udm::Object &&a);
		MonolithicImplementationBase& operator=(MonolithicImplementationBase &&a);

#endif
		static MonolithicImplementationBase Cast(const ::Udm::Object &a);
		static MonolithicImplementationBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MonolithicImplementationBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MonolithicImplementationBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MonolithicImplementationBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MonolithicImplementationBase, Pred>(impl); };
		MonolithicImplementationBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MonolithicImplementationBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< MonolithicImplementationBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MonolithicImplementationBase, Pred>(impl); };
		::Udm::ArchetypeAttr< MonolithicImplementationBase> Archetype() const;
		::Udm::AClassAssocAttr< MonolithprimaryArtifact, ImplementationArtifactReference> dstMonolithprimaryArtifact() const;
		template <class Pred> ::Udm::AClassAssocAttr< MonolithprimaryArtifact, ImplementationArtifactReference, Pred> dstMonolithprimaryArtifact_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< MonolithprimaryArtifact, ImplementationArtifactReference, Pred>(impl, meta_dstMonolithprimaryArtifact, meta_dstMonolithprimaryArtifact_rev); };
		::Udm::AClassAssocAttr< MonolithExecParameter, Property> dstMonolithExecParameter() const;
		template <class Pred> ::Udm::AClassAssocAttr< MonolithExecParameter, Property, Pred> dstMonolithExecParameter_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< MonolithExecParameter, Property, Pred>(impl, meta_dstMonolithExecParameter, meta_dstMonolithExecParameter_rev); };
		::Udm::AClassAssocAttr< MonolithDeployRequirement, ImplementationRequirement> dstMonolithDeployRequirement() const;
		template <class Pred> ::Udm::AClassAssocAttr< MonolithDeployRequirement, ImplementationRequirement, Pred> dstMonolithDeployRequirement_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< MonolithDeployRequirement, ImplementationRequirement, Pred>(impl, meta_dstMonolithDeployRequirement, meta_dstMonolithDeployRequirement_rev); };
		::Udm::ParentAttr< ::PICML::ImplementationContainer> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstMonolithprimaryArtifact;
		static ::Uml::AssociationRole meta_dstMonolithprimaryArtifact_rev;
		static ::Uml::AssociationRole meta_dstMonolithExecParameter;
		static ::Uml::AssociationRole meta_dstMonolithExecParameter_rev;
		static ::Uml::AssociationRole meta_dstMonolithDeployRequirement;
		static ::Uml::AssociationRole meta_dstMonolithDeployRequirement_rev;

	};

	class PICML_Export MonolithExecParameter :  public MgaObject {
	public:
		MonolithExecParameter();
		MonolithExecParameter(::Udm::ObjectImpl *impl);
		MonolithExecParameter(const MonolithExecParameter &master);

#ifdef UDM_RVALUE
		MonolithExecParameter(MonolithExecParameter &&master);

		static MonolithExecParameter Cast(::Udm::Object &&a);
		MonolithExecParameter& operator=(MonolithExecParameter &&a);

#endif
		static MonolithExecParameter Cast(const ::Udm::Object &a);
		static MonolithExecParameter Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MonolithExecParameter CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MonolithExecParameter> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MonolithExecParameter, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MonolithExecParameter, Pred>(impl); };
		MonolithExecParameter CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MonolithExecParameter> Derived();
		template <class Pred> ::Udm::DerivedAttr< MonolithExecParameter, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MonolithExecParameter, Pred>(impl); };
		::Udm::ArchetypeAttr< MonolithExecParameter> Archetype() const;
		::Udm::ParentAttr< ::PICML::ImplementationContainer> ImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ImplementationContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::MonolithicImplementationBase> srcMonolithExecParameter_end() const;
		::Udm::AssocEndAttr< ::PICML::Property> dstMonolithExecParameter_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcMonolithExecParameter_end_;
		static ::Uml::AssociationRole meta_dstMonolithExecParameter_end_;

	};

	class PICML_Export MonolithDeployRequirement :  public MgaObject {
	public:
		MonolithDeployRequirement();
		MonolithDeployRequirement(::Udm::ObjectImpl *impl);
		MonolithDeployRequirement(const MonolithDeployRequirement &master);

#ifdef UDM_RVALUE
		MonolithDeployRequirement(MonolithDeployRequirement &&master);

		static MonolithDeployRequirement Cast(::Udm::Object &&a);
		MonolithDeployRequirement& operator=(MonolithDeployRequirement &&a);

#endif
		static MonolithDeployRequirement Cast(const ::Udm::Object &a);
		static MonolithDeployRequirement Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MonolithDeployRequirement CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MonolithDeployRequirement> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MonolithDeployRequirement, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MonolithDeployRequirement, Pred>(impl); };
		MonolithDeployRequirement CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MonolithDeployRequirement> Derived();
		template <class Pred> ::Udm::DerivedAttr< MonolithDeployRequirement, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MonolithDeployRequirement, Pred>(impl); };
		::Udm::ArchetypeAttr< MonolithDeployRequirement> Archetype() const;
		::Udm::ParentAttr< ::PICML::ImplementationContainer> ImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ImplementationContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::MonolithicImplementationBase> srcMonolithDeployRequirement_end() const;
		::Udm::AssocEndAttr< ::PICML::ImplementationRequirement> dstMonolithDeployRequirement_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcMonolithDeployRequirement_end_;
		static ::Uml::AssociationRole meta_dstMonolithDeployRequirement_end_;

	};

	class PICML_Export MonolithprimaryArtifact :  public MgaObject {
	public:
		MonolithprimaryArtifact();
		MonolithprimaryArtifact(::Udm::ObjectImpl *impl);
		MonolithprimaryArtifact(const MonolithprimaryArtifact &master);

#ifdef UDM_RVALUE
		MonolithprimaryArtifact(MonolithprimaryArtifact &&master);

		static MonolithprimaryArtifact Cast(::Udm::Object &&a);
		MonolithprimaryArtifact& operator=(MonolithprimaryArtifact &&a);

#endif
		static MonolithprimaryArtifact Cast(const ::Udm::Object &a);
		static MonolithprimaryArtifact Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MonolithprimaryArtifact CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MonolithprimaryArtifact> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MonolithprimaryArtifact, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MonolithprimaryArtifact, Pred>(impl); };
		MonolithprimaryArtifact CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MonolithprimaryArtifact> Derived();
		template <class Pred> ::Udm::DerivedAttr< MonolithprimaryArtifact, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MonolithprimaryArtifact, Pred>(impl); };
		::Udm::ArchetypeAttr< MonolithprimaryArtifact> Archetype() const;
		::Udm::ParentAttr< ::PICML::ImplementationContainer> ImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ImplementationContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::MonolithicImplementationBase> srcMonolithprimaryArtifact_end() const;
		::Udm::AssocEndAttr< ::PICML::ImplementationArtifactReference> dstMonolithprimaryArtifact_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcMonolithprimaryArtifact_end_;
		static ::Uml::AssociationRole meta_dstMonolithprimaryArtifact_end_;

	};

	class PICML_Export InfoProperty :  public MgaObject {
	public:
		InfoProperty();
		InfoProperty(::Udm::ObjectImpl *impl);
		InfoProperty(const InfoProperty &master);

#ifdef UDM_RVALUE
		InfoProperty(InfoProperty &&master);

		static InfoProperty Cast(::Udm::Object &&a);
		InfoProperty& operator=(InfoProperty &&a);

#endif
		static InfoProperty Cast(const ::Udm::Object &a);
		static InfoProperty Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		InfoProperty CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< InfoProperty> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< InfoProperty, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< InfoProperty, Pred>(impl); };
		InfoProperty CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< InfoProperty> Derived();
		template <class Pred> ::Udm::DerivedAttr< InfoProperty, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< InfoProperty, Pred>(impl); };
		::Udm::ArchetypeAttr< InfoProperty> Archetype() const;
		::Udm::ParentAttr< ::PICML::ImplementationContainer> ImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ImplementationContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::Implemenation> srcInfoProperty_end() const;
		::Udm::AssocEndAttr< ::PICML::Property> dstInfoProperty_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcInfoProperty_end_;
		static ::Uml::AssociationRole meta_dstInfoProperty_end_;

	};

	class PICML_Export ConfigProperty :  public MgaObject {
	public:
		ConfigProperty();
		ConfigProperty(::Udm::ObjectImpl *impl);
		ConfigProperty(const ConfigProperty &master);

#ifdef UDM_RVALUE
		ConfigProperty(ConfigProperty &&master);

		static ConfigProperty Cast(::Udm::Object &&a);
		ConfigProperty& operator=(ConfigProperty &&a);

#endif
		static ConfigProperty Cast(const ::Udm::Object &a);
		static ConfigProperty Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ConfigProperty CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ConfigProperty> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ConfigProperty, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ConfigProperty, Pred>(impl); };
		ConfigProperty CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ConfigProperty> Derived();
		template <class Pred> ::Udm::DerivedAttr< ConfigProperty, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ConfigProperty, Pred>(impl); };
		::Udm::ArchetypeAttr< ConfigProperty> Archetype() const;
		::Udm::ParentAttr< ::PICML::ImplementationContainer> ImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ImplementationContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::Implemenation> srcConfigProperty_end() const;
		::Udm::AssocEndAttr< ::PICML::Property> dstConfigProperty_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcConfigProperty_end_;
		static ::Uml::AssociationRole meta_dstConfigProperty_end_;

	};

	class PICML_Export ComponentFactoryImplementationContainer :  public ImplementationContainer {
	public:
		ComponentFactoryImplementationContainer();
		ComponentFactoryImplementationContainer(::Udm::ObjectImpl *impl);
		ComponentFactoryImplementationContainer(const ComponentFactoryImplementationContainer &master);

#ifdef UDM_RVALUE
		ComponentFactoryImplementationContainer(ComponentFactoryImplementationContainer &&master);

		static ComponentFactoryImplementationContainer Cast(::Udm::Object &&a);
		ComponentFactoryImplementationContainer& operator=(ComponentFactoryImplementationContainer &&a);

#endif
		static ComponentFactoryImplementationContainer Cast(const ::Udm::Object &a);
		static ComponentFactoryImplementationContainer Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentFactoryImplementationContainer CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentFactoryImplementationContainer> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentFactoryImplementationContainer, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentFactoryImplementationContainer, Pred>(impl); };
		ComponentFactoryImplementationContainer CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentFactoryImplementationContainer> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentFactoryImplementationContainer, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentFactoryImplementationContainer, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentFactoryImplementationContainer> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::ComponentFactoryInstance> ComponentFactoryInstance_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentFactoryInstance, Pred> ComponentFactoryInstance_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentFactoryInstance, Pred>(impl, meta_ComponentFactoryInstance_children); };
		::Udm::ChildrenAttr< ::PICML::MonolithicImplementationBase> MonolithicImplementationBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MonolithicImplementationBase, Pred> MonolithicImplementationBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MonolithicImplementationBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Implemenation> Implemenation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Implemenation, Pred> Implemenation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Implemenation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentFactoryInstance> ComponentFactoryInstance_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentFactoryInstance, Pred> ComponentFactoryInstance_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentFactoryInstance, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::ComponentFactoryImplementations> ComponentFactoryImplementations_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentFactoryImplementations> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_ComponentFactoryInstance_children;
		static ::Uml::CompositionParentRole meta_ComponentFactoryImplementations_parent;

	};

	class PICML_Export ComponentFactoryInstance :  public MonolithicImplementationBase {
	public:
		ComponentFactoryInstance();
		ComponentFactoryInstance(::Udm::ObjectImpl *impl);
		ComponentFactoryInstance(const ComponentFactoryInstance &master);

#ifdef UDM_RVALUE
		ComponentFactoryInstance(ComponentFactoryInstance &&master);

		static ComponentFactoryInstance Cast(::Udm::Object &&a);
		ComponentFactoryInstance& operator=(ComponentFactoryInstance &&a);

#endif
		static ComponentFactoryInstance Cast(const ::Udm::Object &a);
		static ComponentFactoryInstance Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentFactoryInstance CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentFactoryInstance> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentFactoryInstance, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentFactoryInstance, Pred>(impl); };
		ComponentFactoryInstance CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentFactoryInstance> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentFactoryInstance, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentFactoryInstance, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentFactoryInstance> Archetype() const;
		::Udm::PointerAttr< ComponentFactory> ref() const;
		::Udm::AssocAttr< ComponentFactoryRef> referedbyComponentFactoryRef() const;
		template <class Pred> ::Udm::AssocAttr< ComponentFactoryRef, Pred> referedbyComponentFactoryRef_sorted(const Pred &) const { return ::Udm::AssocAttr< ComponentFactoryRef, Pred>(impl, meta_referedbyComponentFactoryRef); };
		::Udm::ParentAttr< ::PICML::ComponentFactoryImplementationContainer> ComponentFactoryImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentFactoryImplementationContainer> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_referedbyComponentFactoryRef;
		static ::Uml::CompositionParentRole meta_ComponentFactoryImplementationContainer_parent;

	};

	class PICML_Export ServiceConsumer :  public MgaObject {
	public:
		ServiceConsumer();
		ServiceConsumer(::Udm::ObjectImpl *impl);
		ServiceConsumer(const ServiceConsumer &master);

#ifdef UDM_RVALUE
		ServiceConsumer(ServiceConsumer &&master);

		static ServiceConsumer Cast(::Udm::Object &&a);
		ServiceConsumer& operator=(ServiceConsumer &&a);

#endif
		static ServiceConsumer Cast(const ::Udm::Object &a);
		static ServiceConsumer Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ServiceConsumer CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ServiceConsumer> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ServiceConsumer, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ServiceConsumer, Pred>(impl); };
		ServiceConsumer CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ServiceConsumer> Derived();
		template <class Pred> ::Udm::DerivedAttr< ServiceConsumer, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ServiceConsumer, Pred>(impl); };
		::Udm::ArchetypeAttr< ServiceConsumer> Archetype() const;
		::Udm::BooleanAttr prioritize_service_invocations() const;
		::Udm::ParentAttr< ::PICML::RTRequirements> RTRequirements_parent() const;
		::Udm::ParentAttr< ::PICML::RTRequirements> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_prioritize_service_invocations;
		static ::Uml::CompositionParentRole meta_RTRequirements_parent;

	};

	class PICML_Export ServiceLevels :  public MgaObject {
	public:
		ServiceLevels();
		ServiceLevels(::Udm::ObjectImpl *impl);
		ServiceLevels(const ServiceLevels &master);

#ifdef UDM_RVALUE
		ServiceLevels(ServiceLevels &&master);

		static ServiceLevels Cast(::Udm::Object &&a);
		ServiceLevels& operator=(ServiceLevels &&a);

#endif
		static ServiceLevels Cast(const ::Udm::Object &a);
		static ServiceLevels Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ServiceLevels CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ServiceLevels> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ServiceLevels, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ServiceLevels, Pred>(impl); };
		ServiceLevels CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ServiceLevels> Derived();
		template <class Pred> ::Udm::DerivedAttr< ServiceLevels, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ServiceLevels, Pred>(impl); };
		::Udm::ArchetypeAttr< ServiceLevels> Archetype() const;
		::Udm::BooleanAttr varying_service_levels() const;
		::Udm::ParentAttr< ::PICML::ServiceProvider> ServiceProvider_parent() const;
		::Udm::ParentAttr< ::PICML::ServiceProvider> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_varying_service_levels;
		static ::Uml::CompositionParentRole meta_ServiceProvider_parent;

	};

	class PICML_Export MultipleServiceRequests :  public MgaObject {
	public:
		MultipleServiceRequests();
		MultipleServiceRequests(::Udm::ObjectImpl *impl);
		MultipleServiceRequests(const MultipleServiceRequests &master);

#ifdef UDM_RVALUE
		MultipleServiceRequests(MultipleServiceRequests &&master);

		static MultipleServiceRequests Cast(::Udm::Object &&a);
		MultipleServiceRequests& operator=(MultipleServiceRequests &&a);

#endif
		static MultipleServiceRequests Cast(const ::Udm::Object &a);
		static MultipleServiceRequests Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MultipleServiceRequests CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MultipleServiceRequests> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MultipleServiceRequests, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MultipleServiceRequests, Pred>(impl); };
		MultipleServiceRequests CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MultipleServiceRequests> Derived();
		template <class Pred> ::Udm::DerivedAttr< MultipleServiceRequests, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MultipleServiceRequests, Pred>(impl); };
		::Udm::ArchetypeAttr< MultipleServiceRequests> Archetype() const;
		::Udm::IntegerAttr minimum_simultaneous_service_level() const;
		::Udm::BooleanAttr simultaneous_service_execution() const;
		::Udm::BooleanAttr buffer_service_requests() const;
		::Udm::IntegerAttr maximum_simultaneous_service_level() const;
		::Udm::ParentAttr< ::PICML::ServiceProvider> ServiceProvider_parent() const;
		::Udm::ParentAttr< ::PICML::ServiceProvider> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_minimum_simultaneous_service_level;
		static ::Uml::Attribute meta_simultaneous_service_execution;
		static ::Uml::Attribute meta_buffer_service_requests;
		static ::Uml::Attribute meta_maximum_simultaneous_service_level;
		static ::Uml::CompositionParentRole meta_ServiceProvider_parent;

	};

	class PICML_Export ServiceProvider :  public MgaObject {
	public:
		ServiceProvider();
		ServiceProvider(::Udm::ObjectImpl *impl);
		ServiceProvider(const ServiceProvider &master);

#ifdef UDM_RVALUE
		ServiceProvider(ServiceProvider &&master);

		static ServiceProvider Cast(::Udm::Object &&a);
		ServiceProvider& operator=(ServiceProvider &&a);

#endif
		static ServiceProvider Cast(const ::Udm::Object &a);
		static ServiceProvider Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ServiceProvider CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ServiceProvider> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ServiceProvider, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ServiceProvider, Pred>(impl); };
		ServiceProvider CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ServiceProvider> Derived();
		template <class Pred> ::Udm::DerivedAttr< ServiceProvider, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ServiceProvider, Pred>(impl); };
		::Udm::ArchetypeAttr< ServiceProvider> Archetype() const;
		::Udm::BooleanAttr fixed_prioirty_service_execution() const;
		::Udm::ChildAttr< ::PICML::ServiceLevels> ServiceLevels_child() const;
		::Udm::ChildAttr< ::PICML::MultipleServiceRequests> MultipleServiceRequests_child() const;
		::Udm::ChildrenAttr< ::PICML::ServiceLevels> ServiceLevels_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ServiceLevels, Pred> ServiceLevels_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ServiceLevels, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MultipleServiceRequests> MultipleServiceRequests_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MultipleServiceRequests, Pred> MultipleServiceRequests_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MultipleServiceRequests, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RTRequirements> RTRequirements_parent() const;
		::Udm::ParentAttr< ::PICML::RTRequirements> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_fixed_prioirty_service_execution;
		static ::Uml::CompositionChildRole meta_ServiceLevels_child;
		static ::Uml::CompositionChildRole meta_MultipleServiceRequests_child;
		static ::Uml::CompositionParentRole meta_RTRequirements_parent;

	};

	class PICML_Export ECRole :  public MgaObject {
	public:
		ECRole();
		ECRole(::Udm::ObjectImpl *impl);
		ECRole(const ECRole &master);

#ifdef UDM_RVALUE
		ECRole(ECRole &&master);

		static ECRole Cast(::Udm::Object &&a);
		ECRole& operator=(ECRole &&a);

#endif
		static ECRole Cast(const ::Udm::Object &a);
		static ECRole Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ECRole CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ECRole> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ECRole, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ECRole, Pred>(impl); };
		ECRole CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ECRole> Derived();
		template <class Pred> ::Udm::DerivedAttr< ECRole, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ECRole, Pred>(impl); };
		::Udm::ArchetypeAttr< ECRole> Archetype() const;
		::Udm::StringAttr ECFilterType() const;
		::Udm::StringAttr rolekind() const;
		::Udm::ParentAttr< ::PICML::ECRequirements> ECRequirements_parent() const;
		::Udm::ParentAttr< ::PICML::ECRequirements> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_ECFilterType;
		static ::Uml::Attribute meta_rolekind;
		static ::Uml::CompositionParentRole meta_ECRequirements_parent;

	};

	class PICML_Export ECBehavior :  public MgaObject {
	public:
		ECBehavior();
		ECBehavior(::Udm::ObjectImpl *impl);
		ECBehavior(const ECBehavior &master);

#ifdef UDM_RVALUE
		ECBehavior(ECBehavior &&master);

		static ECBehavior Cast(::Udm::Object &&a);
		ECBehavior& operator=(ECBehavior &&a);

#endif
		static ECBehavior Cast(const ::Udm::Object &a);
		static ECBehavior Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ECBehavior CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ECBehavior> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ECBehavior, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ECBehavior, Pred>(impl); };
		ECBehavior CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ECBehavior> Derived();
		template <class Pred> ::Udm::DerivedAttr< ECBehavior, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ECBehavior, Pred>(impl); };
		::Udm::ArchetypeAttr< ECBehavior> Archetype() const;
		::Udm::BooleanAttr SupplierBasedFiltering() const;
		::Udm::BooleanAttr ConsumerBasedFiltering() const;
		::Udm::BooleanAttr DisconnectDanglingConnections() const;
		::Udm::BooleanAttr MultithreadedConsumer() const;
		::Udm::IntegerAttr DispatchingMultithreadingLevel() const;
		::Udm::BooleanAttr MultithreadedSupplier() const;
		::Udm::ParentAttr< ::PICML::ECRequirements> ECRequirements_parent() const;
		::Udm::ParentAttr< ::PICML::ECRequirements> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_SupplierBasedFiltering;
		static ::Uml::Attribute meta_ConsumerBasedFiltering;
		static ::Uml::Attribute meta_DisconnectDanglingConnections;
		static ::Uml::Attribute meta_MultithreadedConsumer;
		static ::Uml::Attribute meta_DispatchingMultithreadingLevel;
		static ::Uml::Attribute meta_MultithreadedSupplier;
		static ::Uml::CompositionParentRole meta_ECRequirements_parent;

	};

	class PICML_Export PathReference :  public MgaObject {
	public:
		PathReference();
		PathReference(::Udm::ObjectImpl *impl);
		PathReference(const PathReference &master);

#ifdef UDM_RVALUE
		PathReference(PathReference &&master);

		static PathReference Cast(::Udm::Object &&a);
		PathReference& operator=(PathReference &&a);

#endif
		static PathReference Cast(const ::Udm::Object &a);
		static PathReference Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PathReference CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PathReference> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PathReference, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PathReference, Pred>(impl); };
		PathReference CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PathReference> Derived();
		template <class Pred> ::Udm::DerivedAttr< PathReference, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PathReference, Pred>(impl); };
		::Udm::ArchetypeAttr< PathReference> Archetype() const;
		::Udm::PointerAttr< Path> ref() const;
		::Udm::AClassPointerAttr< CriticalPath, ComponentAssembly> srcCriticalPath() const;
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_srcCriticalPath;
		static ::Uml::AssociationRole meta_srcCriticalPath_rev;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;

	};

	class PICML_Export PathProperty :  public MgaObject {
	public:
		PathProperty();
		PathProperty(::Udm::ObjectImpl *impl);
		PathProperty(const PathProperty &master);

#ifdef UDM_RVALUE
		PathProperty(PathProperty &&master);

		static PathProperty Cast(::Udm::Object &&a);
		PathProperty& operator=(PathProperty &&a);

#endif
		static PathProperty Cast(const ::Udm::Object &a);
		static PathProperty Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PathProperty CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PathProperty> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PathProperty, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PathProperty, Pred>(impl); };
		PathProperty CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PathProperty> Derived();
		template <class Pred> ::Udm::DerivedAttr< PathProperty, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PathProperty, Pred>(impl); };
		::Udm::ArchetypeAttr< PathProperty> Archetype() const;
		::Udm::ParentAttr< ::PICML::Paths> Paths_parent() const;
		::Udm::ParentAttr< ::PICML::Paths> parent() const;
		::Udm::AssocEndAttr< ::PICML::Path> srcPathProperty_end() const;
		::Udm::AssocEndAttr< ::PICML::Property> dstPathProperty_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Paths_parent;
		static ::Uml::AssociationRole meta_srcPathProperty_end_;
		static ::Uml::AssociationRole meta_dstPathProperty_end_;

	};

	class PICML_Export Paths :  public MgaObject {
	public:
		Paths();
		Paths(::Udm::ObjectImpl *impl);
		Paths(const Paths &master);

#ifdef UDM_RVALUE
		Paths(Paths &&master);

		static Paths Cast(::Udm::Object &&a);
		Paths& operator=(Paths &&a);

#endif
		static Paths Cast(const ::Udm::Object &a);
		static Paths Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Paths CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Paths> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Paths, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Paths, Pred>(impl); };
		Paths CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Paths> Derived();
		template <class Pred> ::Udm::DerivedAttr< Paths, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Paths, Pred>(impl); };
		::Udm::ArchetypeAttr< Paths> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::Property> Property_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); };
		::Udm::ChildrenAttr< ::PICML::PathProperty> PathProperty_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PathProperty, Pred> PathProperty_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PathProperty, Pred>(impl, meta_PathProperty_children); };
		::Udm::ChildrenAttr< ::PICML::Path> Path_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Path, Pred> Path_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Path, Pred>(impl, meta_Path_children); };
		::Udm::ChildrenAttr< ::PICML::PathProperty> PathProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PathProperty, Pred> PathProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PathProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Path> Path_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Path, Pred> Path_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Path, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComplexProperty> ComplexProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred> ComplexProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SimpleProperty> SimpleProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred> SimpleProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::PathDiagrams> PathDiagrams_parent() const;
		::Udm::ParentAttr< ::PICML::PathDiagrams> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_PathProperty_children;
		static ::Uml::CompositionChildRole meta_Path_children;
		static ::Uml::CompositionParentRole meta_PathDiagrams_parent;

	};

	class PICML_Export Edge :  public MgaObject {
	public:
		Edge();
		Edge(::Udm::ObjectImpl *impl);
		Edge(const Edge &master);

#ifdef UDM_RVALUE
		Edge(Edge &&master);

		static Edge Cast(::Udm::Object &&a);
		Edge& operator=(Edge &&a);

#endif
		static Edge Cast(const ::Udm::Object &a);
		static Edge Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Edge CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Edge> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Edge, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Edge, Pred>(impl); };
		Edge CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Edge> Derived();
		template <class Pred> ::Udm::DerivedAttr< Edge, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Edge, Pred>(impl); };
		::Udm::ArchetypeAttr< Edge> Archetype() const;
		::Udm::AClassPointerAttr< SrcEdge, GraphVertex> dstSrcEdge() const;
		::Udm::AClassPointerAttr< DstEdge, GraphVertex> srcDstEdge() const;
		::Udm::AClassAssocAttr< EdgeProperty, Property> srcPropertyConnector() const;
		template <class Pred> ::Udm::AClassAssocAttr< EdgeProperty, Property, Pred> srcPropertyConnector_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< EdgeProperty, Property, Pred>(impl, meta_srcPropertyConnector, meta_srcPropertyConnector_rev); };
		::Udm::ParentAttr< ::PICML::Path> Path_parent() const;
		::Udm::ParentAttr< ::PICML::Path> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstSrcEdge;
		static ::Uml::AssociationRole meta_dstSrcEdge_rev;
		static ::Uml::AssociationRole meta_srcDstEdge;
		static ::Uml::AssociationRole meta_srcDstEdge_rev;
		static ::Uml::AssociationRole meta_srcPropertyConnector;
		static ::Uml::AssociationRole meta_srcPropertyConnector_rev;
		static ::Uml::CompositionParentRole meta_Path_parent;

	};

	class PICML_Export EdgeProperty :  public MgaObject {
	public:
		EdgeProperty();
		EdgeProperty(::Udm::ObjectImpl *impl);
		EdgeProperty(const EdgeProperty &master);

#ifdef UDM_RVALUE
		EdgeProperty(EdgeProperty &&master);

		static EdgeProperty Cast(::Udm::Object &&a);
		EdgeProperty& operator=(EdgeProperty &&a);

#endif
		static EdgeProperty Cast(const ::Udm::Object &a);
		static EdgeProperty Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		EdgeProperty CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< EdgeProperty> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< EdgeProperty, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< EdgeProperty, Pred>(impl); };
		EdgeProperty CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< EdgeProperty> Derived();
		template <class Pred> ::Udm::DerivedAttr< EdgeProperty, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< EdgeProperty, Pred>(impl); };
		::Udm::ArchetypeAttr< EdgeProperty> Archetype() const;
		::Udm::ParentAttr< ::PICML::Path> Path_parent() const;
		::Udm::ParentAttr< ::PICML::Path> parent() const;
		::Udm::AssocEndAttr< ::PICML::Property> srcPropertyConnector_end() const;
		::Udm::AssocEndAttr< ::PICML::Edge> dstPropertyConnector_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Path_parent;
		static ::Uml::AssociationRole meta_srcPropertyConnector_end_;
		static ::Uml::AssociationRole meta_dstPropertyConnector_end_;

	};

	class PICML_Export SrcEdge :  public MgaObject {
	public:
		SrcEdge();
		SrcEdge(::Udm::ObjectImpl *impl);
		SrcEdge(const SrcEdge &master);

#ifdef UDM_RVALUE
		SrcEdge(SrcEdge &&master);

		static SrcEdge Cast(::Udm::Object &&a);
		SrcEdge& operator=(SrcEdge &&a);

#endif
		static SrcEdge Cast(const ::Udm::Object &a);
		static SrcEdge Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		SrcEdge CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< SrcEdge> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< SrcEdge, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< SrcEdge, Pred>(impl); };
		SrcEdge CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< SrcEdge> Derived();
		template <class Pred> ::Udm::DerivedAttr< SrcEdge, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< SrcEdge, Pred>(impl); };
		::Udm::ArchetypeAttr< SrcEdge> Archetype() const;
		::Udm::ParentAttr< ::PICML::Path> Path_parent() const;
		::Udm::ParentAttr< ::PICML::Path> parent() const;
		::Udm::AssocEndAttr< ::PICML::Edge> srcSrcEdge_end() const;
		::Udm::AssocEndAttr< ::PICML::GraphVertex> dstSrcEdge_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Path_parent;
		static ::Uml::AssociationRole meta_srcSrcEdge_end_;
		static ::Uml::AssociationRole meta_dstSrcEdge_end_;

	};

	class PICML_Export GraphVertex :  virtual  public MgaObject {
	public:
		GraphVertex();
		GraphVertex(::Udm::ObjectImpl *impl);
		GraphVertex(const GraphVertex &master);

#ifdef UDM_RVALUE
		GraphVertex(GraphVertex &&master);

		static GraphVertex Cast(::Udm::Object &&a);
		GraphVertex& operator=(GraphVertex &&a);

#endif
		static GraphVertex Cast(const ::Udm::Object &a);
		static GraphVertex Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		GraphVertex CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< GraphVertex> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< GraphVertex, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< GraphVertex, Pred>(impl); };
		GraphVertex CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< GraphVertex> Derived();
		template <class Pred> ::Udm::DerivedAttr< GraphVertex, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< GraphVertex, Pred>(impl); };
		::Udm::ArchetypeAttr< GraphVertex> Archetype() const;
		::Udm::AClassPointerAttr< SrcEdge, Edge> srcSrcEdge() const;
		::Udm::AClassPointerAttr< DstEdge, Edge> dstDstEdge() const;
		::Udm::ParentAttr< ::PICML::Path> Path_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcSrcEdge;
		static ::Uml::AssociationRole meta_srcSrcEdge_rev;
		static ::Uml::AssociationRole meta_dstDstEdge;
		static ::Uml::AssociationRole meta_dstDstEdge_rev;
		static ::Uml::CompositionParentRole meta_Path_parent;

	};

	class PICML_Export DisplayNode :  public GraphVertex {
	public:
		DisplayNode();
		DisplayNode(::Udm::ObjectImpl *impl);
		DisplayNode(const DisplayNode &master);

#ifdef UDM_RVALUE
		DisplayNode(DisplayNode &&master);

		static DisplayNode Cast(::Udm::Object &&a);
		DisplayNode& operator=(DisplayNode &&a);

#endif
		static DisplayNode Cast(const ::Udm::Object &a);
		static DisplayNode Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		DisplayNode CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< DisplayNode> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< DisplayNode, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< DisplayNode, Pred>(impl); };
		DisplayNode CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< DisplayNode> Derived();
		template <class Pred> ::Udm::DerivedAttr< DisplayNode, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< DisplayNode, Pred>(impl); };
		::Udm::ArchetypeAttr< DisplayNode> Archetype() const;
		::Udm::ParentAttr< ::PICML::Path> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export DstEdge :  public MgaObject {
	public:
		DstEdge();
		DstEdge(::Udm::ObjectImpl *impl);
		DstEdge(const DstEdge &master);

#ifdef UDM_RVALUE
		DstEdge(DstEdge &&master);

		static DstEdge Cast(::Udm::Object &&a);
		DstEdge& operator=(DstEdge &&a);

#endif
		static DstEdge Cast(const ::Udm::Object &a);
		static DstEdge Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		DstEdge CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< DstEdge> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< DstEdge, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< DstEdge, Pred>(impl); };
		DstEdge CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< DstEdge> Derived();
		template <class Pred> ::Udm::DerivedAttr< DstEdge, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< DstEdge, Pred>(impl); };
		::Udm::ArchetypeAttr< DstEdge> Archetype() const;
		::Udm::ParentAttr< ::PICML::Path> Path_parent() const;
		::Udm::ParentAttr< ::PICML::ConnectedComponent> ConnectedComponent_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		::Udm::AssocEndAttr< ::PICML::GraphVertex> srcDstEdge_end() const;
		::Udm::AssocEndAttr< ::PICML::Edge> dstDstEdge_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Path_parent;
		static ::Uml::CompositionParentRole meta_ConnectedComponent_parent;
		static ::Uml::AssociationRole meta_srcDstEdge_end_;
		static ::Uml::AssociationRole meta_dstDstEdge_end_;

	};

	class PICML_Export Path :  public MgaObject {
	public:
		Path();
		Path(::Udm::ObjectImpl *impl);
		Path(const Path &master);

#ifdef UDM_RVALUE
		Path(Path &&master);

		static Path Cast(::Udm::Object &&a);
		Path& operator=(Path &&a);

#endif
		static Path Cast(const ::Udm::Object &a);
		static Path Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Path CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Path> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Path, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Path, Pred>(impl); };
		Path CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Path> Derived();
		template <class Pred> ::Udm::DerivedAttr< Path, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Path, Pred>(impl); };
		::Udm::ArchetypeAttr< Path> Archetype() const;
		::Udm::AssocAttr< PathReference> referedbyPathReference() const;
		template <class Pred> ::Udm::AssocAttr< PathReference, Pred> referedbyPathReference_sorted(const Pred &) const { return ::Udm::AssocAttr< PathReference, Pred>(impl, meta_referedbyPathReference); };
		::Udm::AClassAssocAttr< PathProperty, Property> dstPathProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< PathProperty, Property, Pred> dstPathProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< PathProperty, Property, Pred>(impl, meta_dstPathProperty, meta_dstPathProperty_rev); };
		::Udm::ChildrenAttr< ::PICML::Property> Property_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); };
		::Udm::ChildrenAttr< ::PICML::GraphVertex> GraphVertex_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::GraphVertex, Pred> GraphVertex_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::GraphVertex, Pred>(impl, meta_GraphVertex_children); };
		::Udm::ChildrenAttr< ::PICML::Edge> Edge_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Edge, Pred> Edge_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Edge, Pred>(impl, meta_Edge_children); };
		::Udm::ChildrenAttr< ::PICML::EdgeProperty> EdgeProperty_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::EdgeProperty, Pred> EdgeProperty_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::EdgeProperty, Pred>(impl, meta_EdgeProperty_children); };
		::Udm::ChildrenAttr< ::PICML::SrcEdge> SrcEdge_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SrcEdge, Pred> SrcEdge_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SrcEdge, Pred>(impl, meta_SrcEdge_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, meta_ComponentRef_children); };
		::Udm::ChildrenAttr< ::PICML::DstEdge> DstEdge_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DstEdge, Pred> DstEdge_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DstEdge, Pred>(impl, meta_DstEdge_children); };
		::Udm::ChildrenAttr< ::PICML::DisplayNode> DisplayNode_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DisplayNode, Pred> DisplayNode_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DisplayNode, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Edge> Edge_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Edge, Pred> Edge_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Edge, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::EdgeProperty> EdgeProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::EdgeProperty, Pred> EdgeProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::EdgeProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SrcEdge> SrcEdge_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SrcEdge, Pred> SrcEdge_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SrcEdge, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::GraphVertex> GraphVertex_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::GraphVertex, Pred> GraphVertex_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::GraphVertex, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::DstEdge> DstEdge_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DstEdge, Pred> DstEdge_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DstEdge, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ConnectedComponent> ConnectedComponent_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectedComponent, Pred> ConnectedComponent_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectedComponent, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComplexProperty> ComplexProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred> ComplexProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SimpleProperty> SimpleProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred> SimpleProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::EventPort> EventPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::EventPort, Pred> EventPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::EventPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ObjectPort> ObjectPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ObjectPort, Pred> ObjectPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ObjectPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Manageable> Manageable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Manageable, Pred> Manageable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Manageable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Port> Port_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Port, Pred> Port_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Port, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::InEventPort> InEventPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InEventPort, Pred> InEventPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InEventPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequiredRequestPort> RequiredRequestPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred> RequiredRequestPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ProvidedRequestPort> ProvidedRequestPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred> ProvidedRequestPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::OutEventPort> OutEventPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OutEventPort, Pred> OutEventPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OutEventPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::Paths> Paths_parent() const;
		::Udm::ParentAttr< ::PICML::Paths> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyPathReference;
		static ::Uml::AssociationRole meta_dstPathProperty;
		static ::Uml::AssociationRole meta_dstPathProperty_rev;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_GraphVertex_children;
		static ::Uml::CompositionChildRole meta_Edge_children;
		static ::Uml::CompositionChildRole meta_EdgeProperty_children;
		static ::Uml::CompositionChildRole meta_SrcEdge_children;
		static ::Uml::CompositionChildRole meta_ComponentRef_children;
		static ::Uml::CompositionChildRole meta_DstEdge_children;
		static ::Uml::CompositionParentRole meta_Paths_parent;

	};

	class PICML_Export ConnectedComponent :  public GraphVertex {
	public:
		ConnectedComponent();
		ConnectedComponent(::Udm::ObjectImpl *impl);
		ConnectedComponent(const ConnectedComponent &master);

#ifdef UDM_RVALUE
		ConnectedComponent(ConnectedComponent &&master);

		static ConnectedComponent Cast(::Udm::Object &&a);
		ConnectedComponent& operator=(ConnectedComponent &&a);

#endif
		static ConnectedComponent Cast(const ::Udm::Object &a);
		static ConnectedComponent Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ConnectedComponent CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ConnectedComponent> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ConnectedComponent, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ConnectedComponent, Pred>(impl); };
		ConnectedComponent CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ConnectedComponent> Derived();
		template <class Pred> ::Udm::DerivedAttr< ConnectedComponent, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ConnectedComponent, Pred>(impl); };
		::Udm::ArchetypeAttr< ConnectedComponent> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::Port> Port_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Port, Pred> Port_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Port, Pred>(impl, meta_Port_children); };
		::Udm::ChildrenAttr< ::PICML::DstEdge> DstEdge_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DstEdge, Pred> DstEdge_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DstEdge, Pred>(impl, meta_DstEdge_children); };
		::Udm::ChildrenAttr< ::PICML::GraphVertex> GraphVertex_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::GraphVertex, Pred> GraphVertex_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::GraphVertex, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::DstEdge> DstEdge_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DstEdge, Pred> DstEdge_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DstEdge, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::CommonPortAttrs> CommonPortAttrs_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CommonPortAttrs, Pred> CommonPortAttrs_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CommonPortAttrs, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::EventPort> EventPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::EventPort, Pred> EventPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::EventPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ObjectPort> ObjectPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ObjectPort, Pred> ObjectPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ObjectPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Port> Port_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Port, Pred> Port_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Port, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::InEventPort> InEventPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InEventPort, Pred> InEventPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InEventPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequiredRequestPort> RequiredRequestPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred> RequiredRequestPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ProvidedRequestPort> ProvidedRequestPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred> ProvidedRequestPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::OutEventPort> OutEventPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OutEventPort, Pred> OutEventPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OutEventPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::Path> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Port_children;
		static ::Uml::CompositionChildRole meta_DstEdge_children;

	};

	class PICML_Export BenchmarkCharacteristics :  public MgaObject {
	public:
		BenchmarkCharacteristics();
		BenchmarkCharacteristics(::Udm::ObjectImpl *impl);
		BenchmarkCharacteristics(const BenchmarkCharacteristics &master);

#ifdef UDM_RVALUE
		BenchmarkCharacteristics(BenchmarkCharacteristics &&master);

		static BenchmarkCharacteristics Cast(::Udm::Object &&a);
		BenchmarkCharacteristics& operator=(BenchmarkCharacteristics &&a);

#endif
		static BenchmarkCharacteristics Cast(const ::Udm::Object &a);
		static BenchmarkCharacteristics Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		BenchmarkCharacteristics CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< BenchmarkCharacteristics> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< BenchmarkCharacteristics, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< BenchmarkCharacteristics, Pred>(impl); };
		BenchmarkCharacteristics CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< BenchmarkCharacteristics> Derived();
		template <class Pred> ::Udm::DerivedAttr< BenchmarkCharacteristics, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< BenchmarkCharacteristics, Pred>(impl); };
		::Udm::ArchetypeAttr< BenchmarkCharacteristics> Archetype() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		::Udm::AssocEndAttr< ::PICML::BenchmarkType> srcBenchmarkCharacteristics_end() const;
		::Udm::AssocEndAttr< ::PICML::MetricsBase> dstBenchmarkCharacteristics_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;
		static ::Uml::AssociationRole meta_srcBenchmarkCharacteristics_end_;
		static ::Uml::AssociationRole meta_dstBenchmarkCharacteristics_end_;

	};

	class PICML_Export BenchmarkType :  public MgaObject {
	public:
		BenchmarkType();
		BenchmarkType(::Udm::ObjectImpl *impl);
		BenchmarkType(const BenchmarkType &master);

#ifdef UDM_RVALUE
		BenchmarkType(BenchmarkType &&master);

		static BenchmarkType Cast(::Udm::Object &&a);
		BenchmarkType& operator=(BenchmarkType &&a);

#endif
		static BenchmarkType Cast(const ::Udm::Object &a);
		static BenchmarkType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		BenchmarkType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< BenchmarkType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< BenchmarkType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< BenchmarkType, Pred>(impl); };
		BenchmarkType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< BenchmarkType> Derived();
		template <class Pred> ::Udm::DerivedAttr< BenchmarkType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< BenchmarkType, Pred>(impl); };
		::Udm::ArchetypeAttr< BenchmarkType> Archetype() const;
		::Udm::AClassPointerAttr< BenchmarkCharacteristics, MetricsBase> dstBenchmarkCharacteristics() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstBenchmarkCharacteristics;
		static ::Uml::AssociationRole meta_dstBenchmarkCharacteristics_rev;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

	};

	class PICML_Export PeriodicBenchmarks :  public BenchmarkType {
	public:
		PeriodicBenchmarks();
		PeriodicBenchmarks(::Udm::ObjectImpl *impl);
		PeriodicBenchmarks(const PeriodicBenchmarks &master);

#ifdef UDM_RVALUE
		PeriodicBenchmarks(PeriodicBenchmarks &&master);

		static PeriodicBenchmarks Cast(::Udm::Object &&a);
		PeriodicBenchmarks& operator=(PeriodicBenchmarks &&a);

#endif
		static PeriodicBenchmarks Cast(const ::Udm::Object &a);
		static PeriodicBenchmarks Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PeriodicBenchmarks CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PeriodicBenchmarks> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PeriodicBenchmarks, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PeriodicBenchmarks, Pred>(impl); };
		PeriodicBenchmarks CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PeriodicBenchmarks> Derived();
		template <class Pred> ::Udm::DerivedAttr< PeriodicBenchmarks, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PeriodicBenchmarks, Pred>(impl); };
		::Udm::ArchetypeAttr< PeriodicBenchmarks> Archetype() const;
		::Udm::IntegerAttr timeperiod() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_timeperiod;

	};

	class PICML_Export FixedIterationBenchmarks :  public BenchmarkType {
	public:
		FixedIterationBenchmarks();
		FixedIterationBenchmarks(::Udm::ObjectImpl *impl);
		FixedIterationBenchmarks(const FixedIterationBenchmarks &master);

#ifdef UDM_RVALUE
		FixedIterationBenchmarks(FixedIterationBenchmarks &&master);

		static FixedIterationBenchmarks Cast(::Udm::Object &&a);
		FixedIterationBenchmarks& operator=(FixedIterationBenchmarks &&a);

#endif
		static FixedIterationBenchmarks Cast(const ::Udm::Object &a);
		static FixedIterationBenchmarks Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		FixedIterationBenchmarks CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< FixedIterationBenchmarks> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< FixedIterationBenchmarks, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< FixedIterationBenchmarks, Pred>(impl); };
		FixedIterationBenchmarks CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< FixedIterationBenchmarks> Derived();
		template <class Pred> ::Udm::DerivedAttr< FixedIterationBenchmarks, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< FixedIterationBenchmarks, Pred>(impl); };
		::Udm::ArchetypeAttr< FixedIterationBenchmarks> Archetype() const;
		::Udm::IntegerAttr benchmarkIterations() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_benchmarkIterations;

	};

	class PICML_Export TriggerBenchmarks :  public BenchmarkType {
	public:
		TriggerBenchmarks();
		TriggerBenchmarks(::Udm::ObjectImpl *impl);
		TriggerBenchmarks(const TriggerBenchmarks &master);

#ifdef UDM_RVALUE
		TriggerBenchmarks(TriggerBenchmarks &&master);

		static TriggerBenchmarks Cast(::Udm::Object &&a);
		TriggerBenchmarks& operator=(TriggerBenchmarks &&a);

#endif
		static TriggerBenchmarks Cast(const ::Udm::Object &a);
		static TriggerBenchmarks Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TriggerBenchmarks CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TriggerBenchmarks> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TriggerBenchmarks, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TriggerBenchmarks, Pred>(impl); };
		TriggerBenchmarks CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TriggerBenchmarks> Derived();
		template <class Pred> ::Udm::DerivedAttr< TriggerBenchmarks, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TriggerBenchmarks, Pred>(impl); };
		::Udm::ArchetypeAttr< TriggerBenchmarks> Archetype() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export WorkLoadOperationConnection :  public MgaObject {
	public:
		WorkLoadOperationConnection();
		WorkLoadOperationConnection(::Udm::ObjectImpl *impl);
		WorkLoadOperationConnection(const WorkLoadOperationConnection &master);

#ifdef UDM_RVALUE
		WorkLoadOperationConnection(WorkLoadOperationConnection &&master);

		static WorkLoadOperationConnection Cast(::Udm::Object &&a);
		WorkLoadOperationConnection& operator=(WorkLoadOperationConnection &&a);

#endif
		static WorkLoadOperationConnection Cast(const ::Udm::Object &a);
		static WorkLoadOperationConnection Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		WorkLoadOperationConnection CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< WorkLoadOperationConnection> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< WorkLoadOperationConnection, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< WorkLoadOperationConnection, Pred>(impl); };
		WorkLoadOperationConnection CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< WorkLoadOperationConnection> Derived();
		template <class Pred> ::Udm::DerivedAttr< WorkLoadOperationConnection, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< WorkLoadOperationConnection, Pred>(impl); };
		::Udm::ArchetypeAttr< WorkLoadOperationConnection> Archetype() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		::Udm::AssocEndAttr< ::PICML::OperationRef> srcWorkLoadOperationConnection_end() const;
		::Udm::AssocEndAttr< ::PICML::Task> dstWorkLoadOperationConnection_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;
		static ::Uml::AssociationRole meta_srcWorkLoadOperationConnection_end_;
		static ::Uml::AssociationRole meta_dstWorkLoadOperationConnection_end_;

	};

	class PICML_Export ComponentOperation :  public MgaObject {
	public:
		ComponentOperation();
		ComponentOperation(::Udm::ObjectImpl *impl);
		ComponentOperation(const ComponentOperation &master);

#ifdef UDM_RVALUE
		ComponentOperation(ComponentOperation &&master);

		static ComponentOperation Cast(::Udm::Object &&a);
		ComponentOperation& operator=(ComponentOperation &&a);

#endif
		static ComponentOperation Cast(const ::Udm::Object &a);
		static ComponentOperation Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentOperation CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentOperation> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentOperation, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentOperation, Pred>(impl); };
		ComponentOperation CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentOperation> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentOperation, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentOperation, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentOperation> Archetype() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		::Udm::AssocEndAttr< ::PICML::OperationRef> srcComponentOperation_end() const;
		::Udm::AssocEndAttr< ::PICML::CompRef> dstComponentOperation_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;
		static ::Uml::AssociationRole meta_srcComponentOperation_end_;
		static ::Uml::AssociationRole meta_dstComponentOperation_end_;

	};

	class PICML_Export CompRef :  public MgaObject {
	public:
		CompRef();
		CompRef(::Udm::ObjectImpl *impl);
		CompRef(const CompRef &master);

#ifdef UDM_RVALUE
		CompRef(CompRef &&master);

		static CompRef Cast(::Udm::Object &&a);
		CompRef& operator=(CompRef &&a);

#endif
		static CompRef Cast(const ::Udm::Object &a);
		static CompRef Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		CompRef CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< CompRef> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< CompRef, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< CompRef, Pred>(impl); };
		CompRef CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< CompRef> Derived();
		template <class Pred> ::Udm::DerivedAttr< CompRef, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< CompRef, Pred>(impl); };
		::Udm::ArchetypeAttr< CompRef> Archetype() const;
		::Udm::PointerAttr< Component> ref() const;
		::Udm::AClassPointerAttr< ComponentOperation, OperationRef> srcComponentOperation() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_srcComponentOperation;
		static ::Uml::AssociationRole meta_srcComponentOperation_rev;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

	};

	class PICML_Export WorkloadCharacteristics :  public MgaObject {
	public:
		WorkloadCharacteristics();
		WorkloadCharacteristics(::Udm::ObjectImpl *impl);
		WorkloadCharacteristics(const WorkloadCharacteristics &master);

#ifdef UDM_RVALUE
		WorkloadCharacteristics(WorkloadCharacteristics &&master);

		static WorkloadCharacteristics Cast(::Udm::Object &&a);
		WorkloadCharacteristics& operator=(WorkloadCharacteristics &&a);

#endif
		static WorkloadCharacteristics Cast(const ::Udm::Object &a);
		static WorkloadCharacteristics Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		WorkloadCharacteristics CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< WorkloadCharacteristics> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< WorkloadCharacteristics, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< WorkloadCharacteristics, Pred>(impl); };
		WorkloadCharacteristics CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< WorkloadCharacteristics> Derived();
		template <class Pred> ::Udm::DerivedAttr< WorkloadCharacteristics, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< WorkloadCharacteristics, Pred>(impl); };
		::Udm::ArchetypeAttr< WorkloadCharacteristics> Archetype() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		::Udm::AssocEndAttr< ::PICML::MetricsBase> srcWorkloadCharacteristics_end() const;
		::Udm::AssocEndAttr< ::PICML::TaskSet> dstWorkloadCharacteristics_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;
		static ::Uml::AssociationRole meta_srcWorkloadCharacteristics_end_;
		static ::Uml::AssociationRole meta_dstWorkloadCharacteristics_end_;

	};

	class PICML_Export Task :  public MgaObject {
	public:
		Task();
		Task(::Udm::ObjectImpl *impl);
		Task(const Task &master);

#ifdef UDM_RVALUE
		Task(Task &&master);

		static Task Cast(::Udm::Object &&a);
		Task& operator=(Task &&a);

#endif
		static Task Cast(const ::Udm::Object &a);
		static Task Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Task CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Task> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Task, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Task, Pred>(impl); };
		Task CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Task> Derived();
		template <class Pred> ::Udm::DerivedAttr< Task, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Task, Pred>(impl); };
		::Udm::ArchetypeAttr< Task> Archetype() const;
		::Udm::AssocAttr< TaskSet> setTaskSet() const;
		template <class Pred> ::Udm::AssocAttr< TaskSet, Pred> setTaskSet_sorted(const Pred &) const { return ::Udm::AssocAttr< TaskSet, Pred>(impl, meta_setTaskSet); };
		::Udm::AClassPointerAttr< WorkLoadOperationConnection, OperationRef> srcWorkLoadOperationConnection() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_setTaskSet;
		static ::Uml::AssociationRole meta_srcWorkLoadOperationConnection;
		static ::Uml::AssociationRole meta_srcWorkLoadOperationConnection_rev;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

	};

	class PICML_Export TaskSet :  public MgaObject {
	public:
		TaskSet();
		TaskSet(::Udm::ObjectImpl *impl);
		TaskSet(const TaskSet &master);

#ifdef UDM_RVALUE
		TaskSet(TaskSet &&master);

		static TaskSet Cast(::Udm::Object &&a);
		TaskSet& operator=(TaskSet &&a);

#endif
		static TaskSet Cast(const ::Udm::Object &a);
		static TaskSet Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TaskSet CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TaskSet> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TaskSet, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TaskSet, Pred>(impl); };
		TaskSet CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TaskSet> Derived();
		template <class Pred> ::Udm::DerivedAttr< TaskSet, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TaskSet, Pred>(impl); };
		::Udm::ArchetypeAttr< TaskSet> Archetype() const;
		::Udm::IntegerAttr priority() const;
		::Udm::IntegerAttr rate() const;
		::Udm::AssocAttr< Task> members() const;
		template <class Pred> ::Udm::AssocAttr< Task, Pred> members_sorted(const Pred &) const { return ::Udm::AssocAttr< Task, Pred>(impl, meta_members); };
		::Udm::AClassPointerAttr< WorkloadCharacteristics, MetricsBase> srcWorkloadCharacteristics() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_priority;
		static ::Uml::Attribute meta_rate;
		static ::Uml::AssociationRole meta_members;
		static ::Uml::AssociationRole meta_srcWorkloadCharacteristics;
		static ::Uml::AssociationRole meta_srcWorkloadCharacteristics_rev;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

	};

	class PICML_Export TimerEventSinkConn :  public MgaObject {
	public:
		TimerEventSinkConn();
		TimerEventSinkConn(::Udm::ObjectImpl *impl);
		TimerEventSinkConn(const TimerEventSinkConn &master);

#ifdef UDM_RVALUE
		TimerEventSinkConn(TimerEventSinkConn &&master);

		static TimerEventSinkConn Cast(::Udm::Object &&a);
		TimerEventSinkConn& operator=(TimerEventSinkConn &&a);

#endif
		static TimerEventSinkConn Cast(const ::Udm::Object &a);
		static TimerEventSinkConn Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TimerEventSinkConn CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TimerEventSinkConn> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TimerEventSinkConn, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TimerEventSinkConn, Pred>(impl); };
		TimerEventSinkConn CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TimerEventSinkConn> Derived();
		template <class Pred> ::Udm::DerivedAttr< TimerEventSinkConn, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TimerEventSinkConn, Pred>(impl); };
		::Udm::ArchetypeAttr< TimerEventSinkConn> Archetype() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		::Udm::AssocEndAttr< ::PICML::EventRef> srcTimerEventSinkConn_end() const;
		::Udm::AssocEndAttr< ::PICML::TimeProbe> dstTimerEventSinkConn_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;
		static ::Uml::AssociationRole meta_srcTimerEventSinkConn_end_;
		static ::Uml::AssociationRole meta_dstTimerEventSinkConn_end_;

	};

	class PICML_Export EventRef :  public MgaObject {
	public:
		EventRef();
		EventRef(::Udm::ObjectImpl *impl);
		EventRef(const EventRef &master);

#ifdef UDM_RVALUE
		EventRef(EventRef &&master);

		static EventRef Cast(::Udm::Object &&a);
		EventRef& operator=(EventRef &&a);

#endif
		static EventRef Cast(const ::Udm::Object &a);
		static EventRef Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		EventRef CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< EventRef> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< EventRef, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< EventRef, Pred>(impl); };
		EventRef CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< EventRef> Derived();
		template <class Pred> ::Udm::DerivedAttr< EventRef, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< EventRef, Pred>(impl); };
		::Udm::ArchetypeAttr< EventRef> Archetype() const;
		::Udm::AClassAssocAttr< TimerEventSinkConn, TimeProbe> dstTimerEventSinkConn() const;
		template <class Pred> ::Udm::AClassAssocAttr< TimerEventSinkConn, TimeProbe, Pred> dstTimerEventSinkConn_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< TimerEventSinkConn, TimeProbe, Pred>(impl, meta_dstTimerEventSinkConn, meta_dstTimerEventSinkConn_rev); };
		::Udm::PointerAttr< Event> ref() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstTimerEventSinkConn;
		static ::Uml::AssociationRole meta_dstTimerEventSinkConn_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

	};

	class PICML_Export OperationRef :  public MgaObject {
	public:
		OperationRef();
		OperationRef(::Udm::ObjectImpl *impl);
		OperationRef(const OperationRef &master);

#ifdef UDM_RVALUE
		OperationRef(OperationRef &&master);

		static OperationRef Cast(::Udm::Object &&a);
		OperationRef& operator=(OperationRef &&a);

#endif
		static OperationRef Cast(const ::Udm::Object &a);
		static OperationRef Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		OperationRef CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< OperationRef> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< OperationRef, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< OperationRef, Pred>(impl); };
		OperationRef CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< OperationRef> Derived();
		template <class Pred> ::Udm::DerivedAttr< OperationRef, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< OperationRef, Pred>(impl); };
		::Udm::ArchetypeAttr< OperationRef> Archetype() const;
		::Udm::AClassPointerAttr< WorkLoadOperationConnection, Task> dstWorkLoadOperationConnection() const;
		::Udm::AClassPointerAttr< ComponentOperation, CompRef> dstComponentOperation() const;
		::Udm::AClassPointerAttr< TimerConnection, TimeProbe> dstTimerConnection() const;
		::Udm::AClassPointerAttr< MetricConnection, MetricsBase> dstMetricConnection() const;
		::Udm::PointerAttr< OperationBase> ref() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstWorkLoadOperationConnection;
		static ::Uml::AssociationRole meta_dstWorkLoadOperationConnection_rev;
		static ::Uml::AssociationRole meta_dstComponentOperation;
		static ::Uml::AssociationRole meta_dstComponentOperation_rev;
		static ::Uml::AssociationRole meta_dstTimerConnection;
		static ::Uml::AssociationRole meta_dstTimerConnection_rev;
		static ::Uml::AssociationRole meta_dstMetricConnection;
		static ::Uml::AssociationRole meta_dstMetricConnection_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

	};

	class PICML_Export MetricsBase :  public MgaObject {
	public:
		MetricsBase();
		MetricsBase(::Udm::ObjectImpl *impl);
		MetricsBase(const MetricsBase &master);

#ifdef UDM_RVALUE
		MetricsBase(MetricsBase &&master);

		static MetricsBase Cast(::Udm::Object &&a);
		MetricsBase& operator=(MetricsBase &&a);

#endif
		static MetricsBase Cast(const ::Udm::Object &a);
		static MetricsBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MetricsBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MetricsBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MetricsBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MetricsBase, Pred>(impl); };
		MetricsBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MetricsBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< MetricsBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MetricsBase, Pred>(impl); };
		::Udm::ArchetypeAttr< MetricsBase> Archetype() const;
		::Udm::StringAttr fileName() const;
		::Udm::IntegerAttr warmup() const;
		::Udm::IntegerAttr iterations() const;
		::Udm::IntegerAttr priority() const;
		::Udm::IntegerAttr rate() const;
		::Udm::StringAttr resolution() const;
		::Udm::AClassPointerAttr< BenchmarkCharacteristics, BenchmarkType> srcBenchmarkCharacteristics() const;
		::Udm::AClassPointerAttr< MetricConnection, OperationRef> srcMetricConnection() const;
		::Udm::AClassPointerAttr< WorkloadCharacteristics, TaskSet> dstWorkloadCharacteristics() const;
		::Udm::ChildrenAttr< ::PICML::DataAnalysisBase> DataAnalysisBase_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DataAnalysisBase, Pred> DataAnalysisBase_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DataAnalysisBase, Pred>(impl, meta_DataAnalysisBase_children); };
		::Udm::ChildrenAttr< ::PICML::Jitter> Jitter_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Jitter, Pred> Jitter_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Jitter, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Maximum> Maximum_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Maximum, Pred> Maximum_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Maximum, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Minimum> Minimum_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Minimum, Pred> Minimum_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Minimum, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Average> Average_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Average, Pred> Average_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Average, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::DataAnalysisBase> DataAnalysisBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DataAnalysisBase, Pred> DataAnalysisBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DataAnalysisBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_fileName;
		static ::Uml::Attribute meta_warmup;
		static ::Uml::Attribute meta_iterations;
		static ::Uml::Attribute meta_priority;
		static ::Uml::Attribute meta_rate;
		static ::Uml::Attribute meta_resolution;
		static ::Uml::AssociationRole meta_srcBenchmarkCharacteristics;
		static ::Uml::AssociationRole meta_srcBenchmarkCharacteristics_rev;
		static ::Uml::AssociationRole meta_srcMetricConnection;
		static ::Uml::AssociationRole meta_srcMetricConnection_rev;
		static ::Uml::AssociationRole meta_dstWorkloadCharacteristics;
		static ::Uml::AssociationRole meta_dstWorkloadCharacteristics_rev;
		static ::Uml::CompositionChildRole meta_DataAnalysisBase_children;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

	};

	class PICML_Export BenchmarkAnalysis :  public MgaObject {
	public:
		BenchmarkAnalysis();
		BenchmarkAnalysis(::Udm::ObjectImpl *impl);
		BenchmarkAnalysis(const BenchmarkAnalysis &master);

#ifdef UDM_RVALUE
		BenchmarkAnalysis(BenchmarkAnalysis &&master);

		static BenchmarkAnalysis Cast(::Udm::Object &&a);
		BenchmarkAnalysis& operator=(BenchmarkAnalysis &&a);

#endif
		static BenchmarkAnalysis Cast(const ::Udm::Object &a);
		static BenchmarkAnalysis Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		BenchmarkAnalysis CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< BenchmarkAnalysis> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< BenchmarkAnalysis, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< BenchmarkAnalysis, Pred>(impl); };
		BenchmarkAnalysis CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< BenchmarkAnalysis> Derived();
		template <class Pred> ::Udm::DerivedAttr< BenchmarkAnalysis, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< BenchmarkAnalysis, Pred>(impl); };
		::Udm::ArchetypeAttr< BenchmarkAnalysis> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::BenchmarkCharacteristics> BenchmarkCharacteristics_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::BenchmarkCharacteristics, Pred> BenchmarkCharacteristics_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::BenchmarkCharacteristics, Pred>(impl, meta_BenchmarkCharacteristics_children); };
		::Udm::ChildrenAttr< ::PICML::BenchmarkType> BenchmarkType_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::BenchmarkType, Pred> BenchmarkType_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::BenchmarkType, Pred>(impl, meta_BenchmarkType_children); };
		::Udm::ChildrenAttr< ::PICML::WorkLoadOperationConnection> WorkLoadOperationConnection_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkLoadOperationConnection, Pred> WorkLoadOperationConnection_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkLoadOperationConnection, Pred>(impl, meta_WorkLoadOperationConnection_children); };
		::Udm::ChildrenAttr< ::PICML::CompRef> CompRef_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CompRef, Pred> CompRef_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CompRef, Pred>(impl, meta_CompRef_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentOperation> ComponentOperation_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentOperation, Pred> ComponentOperation_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentOperation, Pred>(impl, meta_ComponentOperation_children); };
		::Udm::ChildrenAttr< ::PICML::WorkloadCharacteristics> WorkloadCharacteristics_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkloadCharacteristics, Pred> WorkloadCharacteristics_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkloadCharacteristics, Pred>(impl, meta_WorkloadCharacteristics_children); };
		::Udm::ChildrenAttr< ::PICML::Task> Task_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Task, Pred> Task_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Task, Pred>(impl, meta_Task_children); };
		::Udm::ChildrenAttr< ::PICML::TaskSet> TaskSet_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TaskSet, Pred> TaskSet_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TaskSet, Pred>(impl, meta_TaskSet_children); };
		::Udm::ChildrenAttr< ::PICML::TimerEventSinkConn> TimerEventSinkConn_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TimerEventSinkConn, Pred> TimerEventSinkConn_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TimerEventSinkConn, Pred>(impl, meta_TimerEventSinkConn_children); };
		::Udm::ChildrenAttr< ::PICML::Event> Event_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Event, Pred> Event_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Event, Pred>(impl, meta_Event_children); };
		::Udm::ChildrenAttr< ::PICML::EventRef> EventRef_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::EventRef, Pred> EventRef_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::EventRef, Pred>(impl, meta_EventRef_children); };
		::Udm::ChildrenAttr< ::PICML::OperationRef> OperationRef_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OperationRef, Pred> OperationRef_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OperationRef, Pred>(impl, meta_OperationRef_children); };
		::Udm::ChildrenAttr< ::PICML::TimeProbe> TimeProbe_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TimeProbe, Pred> TimeProbe_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TimeProbe, Pred>(impl, meta_TimeProbe_children); };
		::Udm::ChildrenAttr< ::PICML::MetricsBase> MetricsBase_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MetricsBase, Pred> MetricsBase_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MetricsBase, Pred>(impl, meta_MetricsBase_children); };
		::Udm::ChildrenAttr< ::PICML::DataAnalysisBase> DataAnalysisBase_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DataAnalysisBase, Pred> DataAnalysisBase_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DataAnalysisBase, Pred>(impl, meta_DataAnalysisBase_children); };
		::Udm::ChildrenAttr< ::PICML::MetricConnection> MetricConnection_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MetricConnection, Pred> MetricConnection_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MetricConnection, Pred>(impl, meta_MetricConnection_children); };
		::Udm::ChildrenAttr< ::PICML::TimerConnection> TimerConnection_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TimerConnection, Pred> TimerConnection_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TimerConnection, Pred>(impl, meta_TimerConnection_children); };
		::Udm::ChildrenAttr< ::PICML::OperationBase> OperationBase_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OperationBase, Pred> OperationBase_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OperationBase, Pred>(impl, meta_OperationBase_children); };
		::Udm::ChildrenAttr< ::PICML::BenchmarkCharacteristics> BenchmarkCharacteristics_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::BenchmarkCharacteristics, Pred> BenchmarkCharacteristics_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::BenchmarkCharacteristics, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PeriodicBenchmarks> PeriodicBenchmarks_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PeriodicBenchmarks, Pred> PeriodicBenchmarks_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PeriodicBenchmarks, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::FixedIterationBenchmarks> FixedIterationBenchmarks_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::FixedIterationBenchmarks, Pred> FixedIterationBenchmarks_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::FixedIterationBenchmarks, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TriggerBenchmarks> TriggerBenchmarks_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TriggerBenchmarks, Pred> TriggerBenchmarks_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TriggerBenchmarks, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::BenchmarkType> BenchmarkType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::BenchmarkType, Pred> BenchmarkType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::BenchmarkType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::WorkLoadOperationConnection> WorkLoadOperationConnection_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkLoadOperationConnection, Pred> WorkLoadOperationConnection_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkLoadOperationConnection, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentOperation> ComponentOperation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentOperation, Pred> ComponentOperation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentOperation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::CompRef> CompRef_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CompRef, Pred> CompRef_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CompRef, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::WorkloadCharacteristics> WorkloadCharacteristics_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkloadCharacteristics, Pred> WorkloadCharacteristics_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkloadCharacteristics, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Task> Task_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Task, Pred> Task_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Task, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TaskSet> TaskSet_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TaskSet, Pred> TaskSet_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TaskSet, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TimerEventSinkConn> TimerEventSinkConn_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TimerEventSinkConn, Pred> TimerEventSinkConn_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TimerEventSinkConn, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::EventRef> EventRef_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::EventRef, Pred> EventRef_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::EventRef, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::OperationRef> OperationRef_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OperationRef, Pred> OperationRef_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OperationRef, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MetricsBase> MetricsBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MetricsBase, Pred> MetricsBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MetricsBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Throughput> Throughput_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Throughput, Pred> Throughput_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Throughput, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Latency> Latency_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Latency, Pred> Latency_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Latency, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TimerConnection> TimerConnection_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TimerConnection, Pred> TimerConnection_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TimerConnection, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TimeProbe> TimeProbe_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TimeProbe, Pred> TimeProbe_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TimeProbe, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Jitter> Jitter_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Jitter, Pred> Jitter_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Jitter, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Maximum> Maximum_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Maximum, Pred> Maximum_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Maximum, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Minimum> Minimum_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Minimum, Pred> Minimum_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Minimum, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Average> Average_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Average, Pred> Average_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Average, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::DataAnalysisBase> DataAnalysisBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DataAnalysisBase, Pred> DataAnalysisBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DataAnalysisBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MetricConnection> MetricConnection_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MetricConnection, Pred> MetricConnection_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MetricConnection, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Prefixable> Prefixable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Prefixable, Pred> Prefixable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Prefixable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::HasExceptions> HasExceptions_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::HasExceptions, Pred> HasExceptions_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::HasExceptions, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::OnewayOperation> OnewayOperation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OnewayOperation, Pred> OnewayOperation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OnewayOperation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TwowayOperation> TwowayOperation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TwowayOperation, Pred> TwowayOperation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TwowayOperation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::FactoryOperation> FactoryOperation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred> FactoryOperation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::OperationBase> OperationBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OperationBase, Pred> OperationBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OperationBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::LookupOperation> LookupOperation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::LookupOperation, Pred> LookupOperation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::LookupOperation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ObjectByValue> ObjectByValue_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ObjectByValue, Pred> ObjectByValue_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ObjectByValue, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SupportsInterfaces> SupportsInterfaces_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SupportsInterfaces, Pred> SupportsInterfaces_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SupportsInterfaces, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::HasOperations> HasOperations_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::HasOperations, Pred> HasOperations_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::HasOperations, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Inheritable> Inheritable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Inheritable, Pred> Inheritable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Inheritable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Event> Event_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Event, Pred> Event_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Event, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::NamedType> NamedType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NamedType, Pred> NamedType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NamedType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MemberType> MemberType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MemberType, Pred> MemberType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MemberType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType> TemplateParameterValueType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType, Pred> TemplateParameterValueType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::EventType> EventType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::EventType, Pred> EventType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::EventType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::ComponentAnalyses> ComponentAnalyses_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAnalyses> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_BenchmarkCharacteristics_children;
		static ::Uml::CompositionChildRole meta_BenchmarkType_children;
		static ::Uml::CompositionChildRole meta_WorkLoadOperationConnection_children;
		static ::Uml::CompositionChildRole meta_CompRef_children;
		static ::Uml::CompositionChildRole meta_ComponentOperation_children;
		static ::Uml::CompositionChildRole meta_WorkloadCharacteristics_children;
		static ::Uml::CompositionChildRole meta_Task_children;
		static ::Uml::CompositionChildRole meta_TaskSet_children;
		static ::Uml::CompositionChildRole meta_TimerEventSinkConn_children;
		static ::Uml::CompositionChildRole meta_Event_children;
		static ::Uml::CompositionChildRole meta_EventRef_children;
		static ::Uml::CompositionChildRole meta_OperationRef_children;
		static ::Uml::CompositionChildRole meta_TimeProbe_children;
		static ::Uml::CompositionChildRole meta_MetricsBase_children;
		static ::Uml::CompositionChildRole meta_DataAnalysisBase_children;
		static ::Uml::CompositionChildRole meta_MetricConnection_children;
		static ::Uml::CompositionChildRole meta_TimerConnection_children;
		static ::Uml::CompositionChildRole meta_OperationBase_children;
		static ::Uml::CompositionParentRole meta_ComponentAnalyses_parent;

	};

	class PICML_Export Throughput :  public MetricsBase {
	public:
		Throughput();
		Throughput(::Udm::ObjectImpl *impl);
		Throughput(const Throughput &master);

#ifdef UDM_RVALUE
		Throughput(Throughput &&master);

		static Throughput Cast(::Udm::Object &&a);
		Throughput& operator=(Throughput &&a);

#endif
		static Throughput Cast(const ::Udm::Object &a);
		static Throughput Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Throughput CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Throughput> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Throughput, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Throughput, Pred>(impl); };
		Throughput CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Throughput> Derived();
		template <class Pred> ::Udm::DerivedAttr< Throughput, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Throughput, Pred>(impl); };
		::Udm::ArchetypeAttr< Throughput> Archetype() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export Latency :  public MetricsBase {
	public:
		Latency();
		Latency(::Udm::ObjectImpl *impl);
		Latency(const Latency &master);

#ifdef UDM_RVALUE
		Latency(Latency &&master);

		static Latency Cast(::Udm::Object &&a);
		Latency& operator=(Latency &&a);

#endif
		static Latency Cast(const ::Udm::Object &a);
		static Latency Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Latency CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Latency> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Latency, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Latency, Pred>(impl); };
		Latency CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Latency> Derived();
		template <class Pred> ::Udm::DerivedAttr< Latency, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Latency, Pred>(impl); };
		::Udm::ArchetypeAttr< Latency> Archetype() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export TimerConnection :  public MgaObject {
	public:
		TimerConnection();
		TimerConnection(::Udm::ObjectImpl *impl);
		TimerConnection(const TimerConnection &master);

#ifdef UDM_RVALUE
		TimerConnection(TimerConnection &&master);

		static TimerConnection Cast(::Udm::Object &&a);
		TimerConnection& operator=(TimerConnection &&a);

#endif
		static TimerConnection Cast(const ::Udm::Object &a);
		static TimerConnection Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TimerConnection CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TimerConnection> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TimerConnection, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TimerConnection, Pred>(impl); };
		TimerConnection CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TimerConnection> Derived();
		template <class Pred> ::Udm::DerivedAttr< TimerConnection, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TimerConnection, Pred>(impl); };
		::Udm::ArchetypeAttr< TimerConnection> Archetype() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		::Udm::AssocEndAttr< ::PICML::OperationRef> srcTimerConnection_end() const;
		::Udm::AssocEndAttr< ::PICML::TimeProbe> dstTimerConnection_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;
		static ::Uml::AssociationRole meta_srcTimerConnection_end_;
		static ::Uml::AssociationRole meta_dstTimerConnection_end_;

	};

	class PICML_Export TimeProbe :  public MgaObject {
	public:
		TimeProbe();
		TimeProbe(::Udm::ObjectImpl *impl);
		TimeProbe(const TimeProbe &master);

#ifdef UDM_RVALUE
		TimeProbe(TimeProbe &&master);

		static TimeProbe Cast(::Udm::Object &&a);
		TimeProbe& operator=(TimeProbe &&a);

#endif
		static TimeProbe Cast(const ::Udm::Object &a);
		static TimeProbe Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TimeProbe CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TimeProbe> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TimeProbe, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TimeProbe, Pred>(impl); };
		TimeProbe CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TimeProbe> Derived();
		template <class Pred> ::Udm::DerivedAttr< TimeProbe, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TimeProbe, Pred>(impl); };
		::Udm::ArchetypeAttr< TimeProbe> Archetype() const;
		::Udm::AClassPointerAttr< TimerEventSinkConn, EventRef> srcTimerEventSinkConn() const;
		::Udm::AClassPointerAttr< TimerConnection, OperationRef> srcTimerConnection() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcTimerEventSinkConn;
		static ::Uml::AssociationRole meta_srcTimerEventSinkConn_rev;
		static ::Uml::AssociationRole meta_srcTimerConnection;
		static ::Uml::AssociationRole meta_srcTimerConnection_rev;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

	};

	class PICML_Export DataAnalysisBase :  public MgaObject {
	public:
		DataAnalysisBase();
		DataAnalysisBase(::Udm::ObjectImpl *impl);
		DataAnalysisBase(const DataAnalysisBase &master);

#ifdef UDM_RVALUE
		DataAnalysisBase(DataAnalysisBase &&master);

		static DataAnalysisBase Cast(::Udm::Object &&a);
		DataAnalysisBase& operator=(DataAnalysisBase &&a);

#endif
		static DataAnalysisBase Cast(const ::Udm::Object &a);
		static DataAnalysisBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		DataAnalysisBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< DataAnalysisBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< DataAnalysisBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< DataAnalysisBase, Pred>(impl); };
		DataAnalysisBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< DataAnalysisBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< DataAnalysisBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< DataAnalysisBase, Pred>(impl); };
		::Udm::ArchetypeAttr< DataAnalysisBase> Archetype() const;
		::Udm::ParentAttr< ::PICML::MetricsBase> MetricsBase_parent() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_MetricsBase_parent;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

	};

	class PICML_Export Jitter :  public DataAnalysisBase {
	public:
		Jitter();
		Jitter(::Udm::ObjectImpl *impl);
		Jitter(const Jitter &master);

#ifdef UDM_RVALUE
		Jitter(Jitter &&master);

		static Jitter Cast(::Udm::Object &&a);
		Jitter& operator=(Jitter &&a);

#endif
		static Jitter Cast(const ::Udm::Object &a);
		static Jitter Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Jitter CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Jitter> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Jitter, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Jitter, Pred>(impl); };
		Jitter CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Jitter> Derived();
		template <class Pred> ::Udm::DerivedAttr< Jitter, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Jitter, Pred>(impl); };
		::Udm::ArchetypeAttr< Jitter> Archetype() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export Maximum :  public DataAnalysisBase {
	public:
		Maximum();
		Maximum(::Udm::ObjectImpl *impl);
		Maximum(const Maximum &master);

#ifdef UDM_RVALUE
		Maximum(Maximum &&master);

		static Maximum Cast(::Udm::Object &&a);
		Maximum& operator=(Maximum &&a);

#endif
		static Maximum Cast(const ::Udm::Object &a);
		static Maximum Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Maximum CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Maximum> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Maximum, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Maximum, Pred>(impl); };
		Maximum CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Maximum> Derived();
		template <class Pred> ::Udm::DerivedAttr< Maximum, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Maximum, Pred>(impl); };
		::Udm::ArchetypeAttr< Maximum> Archetype() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export Minimum :  public DataAnalysisBase {
	public:
		Minimum();
		Minimum(::Udm::ObjectImpl *impl);
		Minimum(const Minimum &master);

#ifdef UDM_RVALUE
		Minimum(Minimum &&master);

		static Minimum Cast(::Udm::Object &&a);
		Minimum& operator=(Minimum &&a);

#endif
		static Minimum Cast(const ::Udm::Object &a);
		static Minimum Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Minimum CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Minimum> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Minimum, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Minimum, Pred>(impl); };
		Minimum CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Minimum> Derived();
		template <class Pred> ::Udm::DerivedAttr< Minimum, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Minimum, Pred>(impl); };
		::Udm::ArchetypeAttr< Minimum> Archetype() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export Average :  public DataAnalysisBase {
	public:
		Average();
		Average(::Udm::ObjectImpl *impl);
		Average(const Average &master);

#ifdef UDM_RVALUE
		Average(Average &&master);

		static Average Cast(::Udm::Object &&a);
		Average& operator=(Average &&a);

#endif
		static Average Cast(const ::Udm::Object &a);
		static Average Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Average CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Average> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Average, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Average, Pred>(impl); };
		Average CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Average> Derived();
		template <class Pred> ::Udm::DerivedAttr< Average, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Average, Pred>(impl); };
		::Udm::ArchetypeAttr< Average> Archetype() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export MetricConnection :  public MgaObject {
	public:
		MetricConnection();
		MetricConnection(::Udm::ObjectImpl *impl);
		MetricConnection(const MetricConnection &master);

#ifdef UDM_RVALUE
		MetricConnection(MetricConnection &&master);

		static MetricConnection Cast(::Udm::Object &&a);
		MetricConnection& operator=(MetricConnection &&a);

#endif
		static MetricConnection Cast(const ::Udm::Object &a);
		static MetricConnection Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MetricConnection CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MetricConnection> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MetricConnection, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MetricConnection, Pred>(impl); };
		MetricConnection CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MetricConnection> Derived();
		template <class Pred> ::Udm::DerivedAttr< MetricConnection, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MetricConnection, Pred>(impl); };
		::Udm::ArchetypeAttr< MetricConnection> Archetype() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;
		::Udm::AssocEndAttr< ::PICML::OperationRef> srcMetricConnection_end() const;
		::Udm::AssocEndAttr< ::PICML::MetricsBase> dstMetricConnection_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;
		static ::Uml::AssociationRole meta_srcMetricConnection_end_;
		static ::Uml::AssociationRole meta_dstMetricConnection_end_;

	};

	class PICML_Export NodeReference :  public MgaObject {
	public:
		NodeReference();
		NodeReference(::Udm::ObjectImpl *impl);
		NodeReference(const NodeReference &master);

#ifdef UDM_RVALUE
		NodeReference(NodeReference &&master);

		static NodeReference Cast(::Udm::Object &&a);
		NodeReference& operator=(NodeReference &&a);

#endif
		static NodeReference Cast(const ::Udm::Object &a);
		static NodeReference Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		NodeReference CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< NodeReference> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< NodeReference, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< NodeReference, Pred>(impl); };
		NodeReference CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< NodeReference> Derived();
		template <class Pred> ::Udm::DerivedAttr< NodeReference, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< NodeReference, Pred>(impl); };
		::Udm::ArchetypeAttr< NodeReference> Archetype() const;
		::Udm::PointerAttr< Node> ref() const;
		::Udm::AClassAssocAttr< PropertyMapping, Property> dstPropertyMapping() const;
		template <class Pred> ::Udm::AClassAssocAttr< PropertyMapping, Property, Pred> dstPropertyMapping_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< PropertyMapping, Property, Pred>(impl, meta_dstPropertyMapping, meta_dstPropertyMapping_rev); };
		::Udm::AClassAssocAttr< InstanceMapping, CollocationGroup> srcInstanceMapping() const;
		template <class Pred> ::Udm::AClassAssocAttr< InstanceMapping, CollocationGroup, Pred> srcInstanceMapping_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< InstanceMapping, CollocationGroup, Pred>(impl, meta_srcInstanceMapping, meta_srcInstanceMapping_rev); };
		::Udm::ParentAttr< ::PICML::DeploymentPlan> DeploymentPlan_parent() const;
		::Udm::ParentAttr< ::PICML::DeploymentPlan> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_dstPropertyMapping;
		static ::Uml::AssociationRole meta_dstPropertyMapping_rev;
		static ::Uml::AssociationRole meta_srcInstanceMapping;
		static ::Uml::AssociationRole meta_srcInstanceMapping_rev;
		static ::Uml::CompositionParentRole meta_DeploymentPlan_parent;

	};

	class PICML_Export Node :  public MgaObject {
	public:
		Node();
		Node(::Udm::ObjectImpl *impl);
		Node(const Node &master);

#ifdef UDM_RVALUE
		Node(Node &&master);

		static Node Cast(::Udm::Object &&a);
		Node& operator=(Node &&a);

#endif
		static Node Cast(const ::Udm::Object &a);
		static Node Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Node CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Node> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Node, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Node, Pred>(impl); };
		Node CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Node> Derived();
		template <class Pred> ::Udm::DerivedAttr< Node, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Node, Pred>(impl); };
		::Udm::ArchetypeAttr< Node> Archetype() const;
		::Udm::StringAttr label() const;
		::Udm::StringAttr operatingSystem() const;
		::Udm::StringAttr architecture() const;
		::Udm::AssocAttr< NodeReference> referedbyNodeReference() const;
		template <class Pred> ::Udm::AssocAttr< NodeReference, Pred> referedbyNodeReference_sorted(const Pred &) const { return ::Udm::AssocAttr< NodeReference, Pred>(impl, meta_referedbyNodeReference); };
		::Udm::AClassAssocAttr< InterconnectConnection, Interconnect> dstInterconnectConnection() const;
		template <class Pred> ::Udm::AClassAssocAttr< InterconnectConnection, Interconnect, Pred> dstInterconnectConnection_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< InterconnectConnection, Interconnect, Pred>(impl, meta_dstInterconnectConnection, meta_dstInterconnectConnection_rev); };
		::Udm::AClassAssocAttr< Shares, SharedResource> dstShares() const;
		template <class Pred> ::Udm::AClassAssocAttr< Shares, SharedResource, Pred> dstShares_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< Shares, SharedResource, Pred>(impl, meta_dstShares, meta_dstShares_rev); };
		::Udm::ChildrenAttr< ::PICML::Resource> Resource_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Resource, Pred> Resource_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Resource, Pred>(impl, meta_Resource_children); };
		::Udm::ChildrenAttr< ::PICML::Resource> Resource_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Resource, Pred> Resource_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Resource, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequirementSatisfier> RequirementSatisfier_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred> RequirementSatisfier_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::Domain> Domain_parent() const;
		::Udm::ParentAttr< ::PICML::Domain> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_label;
		static ::Uml::Attribute meta_operatingSystem;
		static ::Uml::Attribute meta_architecture;
		static ::Uml::AssociationRole meta_referedbyNodeReference;
		static ::Uml::AssociationRole meta_dstInterconnectConnection;
		static ::Uml::AssociationRole meta_dstInterconnectConnection_rev;
		static ::Uml::AssociationRole meta_dstShares;
		static ::Uml::AssociationRole meta_dstShares_rev;
		static ::Uml::CompositionChildRole meta_Resource_children;
		static ::Uml::CompositionParentRole meta_Domain_parent;

	};

	class PICML_Export Interconnect :  public MgaObject {
	public:
		Interconnect();
		Interconnect(::Udm::ObjectImpl *impl);
		Interconnect(const Interconnect &master);

#ifdef UDM_RVALUE
		Interconnect(Interconnect &&master);

		static Interconnect Cast(::Udm::Object &&a);
		Interconnect& operator=(Interconnect &&a);

#endif
		static Interconnect Cast(const ::Udm::Object &a);
		static Interconnect Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Interconnect CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Interconnect> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Interconnect, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Interconnect, Pred>(impl); };
		Interconnect CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Interconnect> Derived();
		template <class Pred> ::Udm::DerivedAttr< Interconnect, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Interconnect, Pred>(impl); };
		::Udm::ArchetypeAttr< Interconnect> Archetype() const;
		::Udm::StringAttr label() const;
		::Udm::AClassAssocAttr< InterconnectConnection, Node> srcInterconnectConnection() const;
		template <class Pred> ::Udm::AClassAssocAttr< InterconnectConnection, Node, Pred> srcInterconnectConnection_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< InterconnectConnection, Node, Pred>(impl, meta_srcInterconnectConnection, meta_srcInterconnectConnection_rev); };
		::Udm::AClassAssocAttr< BridgeConnection, Bridge> dstBridgeConnection() const;
		template <class Pred> ::Udm::AClassAssocAttr< BridgeConnection, Bridge, Pred> dstBridgeConnection_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< BridgeConnection, Bridge, Pred>(impl, meta_dstBridgeConnection, meta_dstBridgeConnection_rev); };
		::Udm::ChildrenAttr< ::PICML::Resource> Resource_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Resource, Pred> Resource_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Resource, Pred>(impl, meta_Resource_children); };
		::Udm::ChildrenAttr< ::PICML::Resource> Resource_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Resource, Pred> Resource_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Resource, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequirementSatisfier> RequirementSatisfier_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred> RequirementSatisfier_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::Domain> Domain_parent() const;
		::Udm::ParentAttr< ::PICML::Domain> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_label;
		static ::Uml::AssociationRole meta_srcInterconnectConnection;
		static ::Uml::AssociationRole meta_srcInterconnectConnection_rev;
		static ::Uml::AssociationRole meta_dstBridgeConnection;
		static ::Uml::AssociationRole meta_dstBridgeConnection_rev;
		static ::Uml::CompositionChildRole meta_Resource_children;
		static ::Uml::CompositionParentRole meta_Domain_parent;

	};

	class PICML_Export Bridge :  public MgaObject {
	public:
		Bridge();
		Bridge(::Udm::ObjectImpl *impl);
		Bridge(const Bridge &master);

#ifdef UDM_RVALUE
		Bridge(Bridge &&master);

		static Bridge Cast(::Udm::Object &&a);
		Bridge& operator=(Bridge &&a);

#endif
		static Bridge Cast(const ::Udm::Object &a);
		static Bridge Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Bridge CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Bridge> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Bridge, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Bridge, Pred>(impl); };
		Bridge CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Bridge> Derived();
		template <class Pred> ::Udm::DerivedAttr< Bridge, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Bridge, Pred>(impl); };
		::Udm::ArchetypeAttr< Bridge> Archetype() const;
		::Udm::StringAttr label() const;
		::Udm::AClassAssocAttr< BridgeConnection, Interconnect> srcBridgeConnection() const;
		template <class Pred> ::Udm::AClassAssocAttr< BridgeConnection, Interconnect, Pred> srcBridgeConnection_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< BridgeConnection, Interconnect, Pred>(impl, meta_srcBridgeConnection, meta_srcBridgeConnection_rev); };
		::Udm::ChildrenAttr< ::PICML::Resource> Resource_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Resource, Pred> Resource_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Resource, Pred>(impl, meta_Resource_children); };
		::Udm::ChildrenAttr< ::PICML::Resource> Resource_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Resource, Pred> Resource_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Resource, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequirementSatisfier> RequirementSatisfier_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred> RequirementSatisfier_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::Domain> Domain_parent() const;
		::Udm::ParentAttr< ::PICML::Domain> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_label;
		static ::Uml::AssociationRole meta_srcBridgeConnection;
		static ::Uml::AssociationRole meta_srcBridgeConnection_rev;
		static ::Uml::CompositionChildRole meta_Resource_children;
		static ::Uml::CompositionParentRole meta_Domain_parent;

	};

	class PICML_Export CollocationGroupProperty :  public MgaObject {
	public:
		CollocationGroupProperty();
		CollocationGroupProperty(::Udm::ObjectImpl *impl);
		CollocationGroupProperty(const CollocationGroupProperty &master);

#ifdef UDM_RVALUE
		CollocationGroupProperty(CollocationGroupProperty &&master);

		static CollocationGroupProperty Cast(::Udm::Object &&a);
		CollocationGroupProperty& operator=(CollocationGroupProperty &&a);

#endif
		static CollocationGroupProperty Cast(const ::Udm::Object &a);
		static CollocationGroupProperty Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		CollocationGroupProperty CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< CollocationGroupProperty> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< CollocationGroupProperty, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< CollocationGroupProperty, Pred>(impl); };
		CollocationGroupProperty CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< CollocationGroupProperty> Derived();
		template <class Pred> ::Udm::DerivedAttr< CollocationGroupProperty, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< CollocationGroupProperty, Pred>(impl); };
		::Udm::ArchetypeAttr< CollocationGroupProperty> Archetype() const;
		::Udm::ParentAttr< ::PICML::DeploymentPlan> DeploymentPlan_parent() const;
		::Udm::ParentAttr< ::PICML::DeploymentPlan> parent() const;
		::Udm::AssocEndAttr< ::PICML::Property> srcCollocationGroupProperty_end() const;
		::Udm::AssocEndAttr< ::PICML::CollocationGroup> dstCollocationGroupProperty_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_DeploymentPlan_parent;
		static ::Uml::AssociationRole meta_srcCollocationGroupProperty_end_;
		static ::Uml::AssociationRole meta_dstCollocationGroupProperty_end_;

	};

	class PICML_Export PropertyMapping :  public MgaObject {
	public:
		PropertyMapping();
		PropertyMapping(::Udm::ObjectImpl *impl);
		PropertyMapping(const PropertyMapping &master);

#ifdef UDM_RVALUE
		PropertyMapping(PropertyMapping &&master);

		static PropertyMapping Cast(::Udm::Object &&a);
		PropertyMapping& operator=(PropertyMapping &&a);

#endif
		static PropertyMapping Cast(const ::Udm::Object &a);
		static PropertyMapping Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PropertyMapping CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PropertyMapping> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PropertyMapping, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PropertyMapping, Pred>(impl); };
		PropertyMapping CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PropertyMapping> Derived();
		template <class Pred> ::Udm::DerivedAttr< PropertyMapping, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PropertyMapping, Pred>(impl); };
		::Udm::ArchetypeAttr< PropertyMapping> Archetype() const;
		::Udm::ParentAttr< ::PICML::DeploymentPlan> DeploymentPlan_parent() const;
		::Udm::ParentAttr< ::PICML::DeploymentPlan> parent() const;
		::Udm::AssocEndAttr< ::PICML::NodeReference> srcPropertyMapping_end() const;
		::Udm::AssocEndAttr< ::PICML::Property> dstPropertyMapping_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_DeploymentPlan_parent;
		static ::Uml::AssociationRole meta_srcPropertyMapping_end_;
		static ::Uml::AssociationRole meta_dstPropertyMapping_end_;

	};

	class PICML_Export CollocationGroupMember :  public MgaObject {
	public:
		CollocationGroupMember();
		CollocationGroupMember(::Udm::ObjectImpl *impl);
		CollocationGroupMember(const CollocationGroupMember &master);

#ifdef UDM_RVALUE
		CollocationGroupMember(CollocationGroupMember &&master);

		static CollocationGroupMember Cast(::Udm::Object &&a);
		CollocationGroupMember& operator=(CollocationGroupMember &&a);

#endif
		static CollocationGroupMember Cast(const ::Udm::Object &a);
		static CollocationGroupMember Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		CollocationGroupMember CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< CollocationGroupMember> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< CollocationGroupMember, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< CollocationGroupMember, Pred>(impl); };
		CollocationGroupMember CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< CollocationGroupMember> Derived();
		template <class Pred> ::Udm::DerivedAttr< CollocationGroupMember, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< CollocationGroupMember, Pred>(impl); };
		::Udm::ArchetypeAttr< CollocationGroupMember> Archetype() const;
		::Udm::AssocAttr< CollocationGroup> setCollocationGroup() const;
		template <class Pred> ::Udm::AssocAttr< CollocationGroup, Pred> setCollocationGroup_sorted(const Pred &) const { return ::Udm::AssocAttr< CollocationGroup, Pred>(impl, meta_setCollocationGroup); };
		::Udm::ParentAttr< ::PICML::DeploymentPlan> DeploymentPlan_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_setCollocationGroup;
		static ::Uml::CompositionParentRole meta_DeploymentPlan_parent;

	};

	class PICML_Export ComponentInstanceRef :  public CollocationGroupMember {
	public:
		ComponentInstanceRef();
		ComponentInstanceRef(::Udm::ObjectImpl *impl);
		ComponentInstanceRef(const ComponentInstanceRef &master);

#ifdef UDM_RVALUE
		ComponentInstanceRef(ComponentInstanceRef &&master);

		static ComponentInstanceRef Cast(::Udm::Object &&a);
		ComponentInstanceRef& operator=(ComponentInstanceRef &&a);

#endif
		static ComponentInstanceRef Cast(const ::Udm::Object &a);
		static ComponentInstanceRef Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentInstanceRef CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentInstanceRef> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentInstanceRef, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentInstanceRef, Pred>(impl); };
		ComponentInstanceRef CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentInstanceRef> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentInstanceRef, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentInstanceRef, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentInstanceRef> Archetype() const;
		::Udm::PointerAttr< ComponentInstance> ref() const;
		::Udm::AClassPointerAttr< Deploys, ComponentFactoryRef> srcDeploys() const;
		::Udm::ParentAttr< ::PICML::DeploymentPlan> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_srcDeploys;
		static ::Uml::AssociationRole meta_srcDeploys_rev;

	};

	class PICML_Export Deploys :  public MgaObject {
	public:
		Deploys();
		Deploys(::Udm::ObjectImpl *impl);
		Deploys(const Deploys &master);

#ifdef UDM_RVALUE
		Deploys(Deploys &&master);

		static Deploys Cast(::Udm::Object &&a);
		Deploys& operator=(Deploys &&a);

#endif
		static Deploys Cast(const ::Udm::Object &a);
		static Deploys Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Deploys CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Deploys> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Deploys, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Deploys, Pred>(impl); };
		Deploys CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Deploys> Derived();
		template <class Pred> ::Udm::DerivedAttr< Deploys, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Deploys, Pred>(impl); };
		::Udm::ArchetypeAttr< Deploys> Archetype() const;
		::Udm::ParentAttr< ::PICML::DeploymentPlan> DeploymentPlan_parent() const;
		::Udm::ParentAttr< ::PICML::DeploymentPlan> parent() const;
		::Udm::AssocEndAttr< ::PICML::ComponentFactoryRef> srcDeploys_end() const;
		::Udm::AssocEndAttr< ::PICML::ComponentInstanceRef> dstDeploys_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_DeploymentPlan_parent;
		static ::Uml::AssociationRole meta_srcDeploys_end_;
		static ::Uml::AssociationRole meta_dstDeploys_end_;

	};

	class PICML_Export ComponentFactoryRef :  public CollocationGroupMember {
	public:
		ComponentFactoryRef();
		ComponentFactoryRef(::Udm::ObjectImpl *impl);
		ComponentFactoryRef(const ComponentFactoryRef &master);

#ifdef UDM_RVALUE
		ComponentFactoryRef(ComponentFactoryRef &&master);

		static ComponentFactoryRef Cast(::Udm::Object &&a);
		ComponentFactoryRef& operator=(ComponentFactoryRef &&a);

#endif
		static ComponentFactoryRef Cast(const ::Udm::Object &a);
		static ComponentFactoryRef Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentFactoryRef CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentFactoryRef> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentFactoryRef, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentFactoryRef, Pred>(impl); };
		ComponentFactoryRef CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentFactoryRef> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentFactoryRef, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentFactoryRef, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentFactoryRef> Archetype() const;
		::Udm::AClassAssocAttr< Deploys, ComponentInstanceRef> dstDeploys() const;
		template <class Pred> ::Udm::AClassAssocAttr< Deploys, ComponentInstanceRef, Pred> dstDeploys_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< Deploys, ComponentInstanceRef, Pred>(impl, meta_dstDeploys, meta_dstDeploys_rev); };
		::Udm::PointerAttr< ComponentFactoryInstance> ref() const;
		::Udm::ParentAttr< ::PICML::DeploymentPlan> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstDeploys;
		static ::Uml::AssociationRole meta_dstDeploys_rev;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export CollocationGroup :  public MgaObject {
	public:
		CollocationGroup();
		CollocationGroup(::Udm::ObjectImpl *impl);
		CollocationGroup(const CollocationGroup &master);

#ifdef UDM_RVALUE
		CollocationGroup(CollocationGroup &&master);

		static CollocationGroup Cast(::Udm::Object &&a);
		CollocationGroup& operator=(CollocationGroup &&a);

#endif
		static CollocationGroup Cast(const ::Udm::Object &a);
		static CollocationGroup Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		CollocationGroup CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< CollocationGroup> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< CollocationGroup, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< CollocationGroup, Pred>(impl); };
		CollocationGroup CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< CollocationGroup> Derived();
		template <class Pred> ::Udm::DerivedAttr< CollocationGroup, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< CollocationGroup, Pred>(impl); };
		::Udm::ArchetypeAttr< CollocationGroup> Archetype() const;
		::Udm::AssocAttr< CollocationGroupMember> members() const;
		template <class Pred> ::Udm::AssocAttr< CollocationGroupMember, Pred> members_sorted(const Pred &) const { return ::Udm::AssocAttr< CollocationGroupMember, Pred>(impl, meta_members); };
		::Udm::AClassPointerAttr< InstanceMapping, NodeReference> dstInstanceMapping() const;
		::Udm::AClassAssocAttr< CollocationGroupProperty, Property> srcCollocationGroupProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< CollocationGroupProperty, Property, Pred> srcCollocationGroupProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< CollocationGroupProperty, Property, Pred>(impl, meta_srcCollocationGroupProperty, meta_srcCollocationGroupProperty_rev); };
		::Udm::ParentAttr< ::PICML::DeploymentPlan> DeploymentPlan_parent() const;
		::Udm::ParentAttr< ::PICML::DeploymentPlan> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_members;
		static ::Uml::AssociationRole meta_dstInstanceMapping;
		static ::Uml::AssociationRole meta_dstInstanceMapping_rev;
		static ::Uml::AssociationRole meta_srcCollocationGroupProperty;
		static ::Uml::AssociationRole meta_srcCollocationGroupProperty_rev;
		static ::Uml::CompositionParentRole meta_DeploymentPlan_parent;

	};

	class PICML_Export DeploymentPlan :  public MgaObject {
	public:
		DeploymentPlan();
		DeploymentPlan(::Udm::ObjectImpl *impl);
		DeploymentPlan(const DeploymentPlan &master);

#ifdef UDM_RVALUE
		DeploymentPlan(DeploymentPlan &&master);

		static DeploymentPlan Cast(::Udm::Object &&a);
		DeploymentPlan& operator=(DeploymentPlan &&a);

#endif
		static DeploymentPlan Cast(const ::Udm::Object &a);
		static DeploymentPlan Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		DeploymentPlan CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< DeploymentPlan> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< DeploymentPlan, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< DeploymentPlan, Pred>(impl); };
		DeploymentPlan CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< DeploymentPlan> Derived();
		template <class Pred> ::Udm::DerivedAttr< DeploymentPlan, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< DeploymentPlan, Pred>(impl); };
		::Udm::ArchetypeAttr< DeploymentPlan> Archetype() const;
		::Udm::StringAttr label() const;
		::Udm::StringAttr UUID() const;
		::Udm::ChildrenAttr< ::PICML::CollocationGroupProperty> CollocationGroupProperty_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CollocationGroupProperty, Pred> CollocationGroupProperty_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CollocationGroupProperty, Pred>(impl, meta_CollocationGroupProperty_children); };
		::Udm::ChildrenAttr< ::PICML::InstanceMapping> InstanceMapping_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InstanceMapping, Pred> InstanceMapping_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InstanceMapping, Pred>(impl, meta_InstanceMapping_children); };
		::Udm::ChildrenAttr< ::PICML::NodeReference> NodeReference_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NodeReference, Pred> NodeReference_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NodeReference, Pred>(impl, meta_NodeReference_children); };
		::Udm::ChildrenAttr< ::PICML::CollocationGroup> CollocationGroup_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CollocationGroup, Pred> CollocationGroup_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CollocationGroup, Pred>(impl, meta_CollocationGroup_children); };
		::Udm::ChildrenAttr< ::PICML::PropertyMapping> PropertyMapping_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PropertyMapping, Pred> PropertyMapping_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PropertyMapping, Pred>(impl, meta_PropertyMapping_children); };
		::Udm::ChildrenAttr< ::PICML::Property> Property_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); };
		::Udm::ChildrenAttr< ::PICML::CollocationGroupMember> CollocationGroupMember_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred> CollocationGroupMember_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred>(impl, meta_CollocationGroupMember_children); };
		::Udm::ChildrenAttr< ::PICML::Deploys> Deploys_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Deploys, Pred> Deploys_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Deploys, Pred>(impl, meta_Deploys_children); };
		::Udm::ChildrenAttr< ::PICML::NodeReference> NodeReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NodeReference, Pred> NodeReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NodeReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::CollocationGroupProperty> CollocationGroupProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CollocationGroupProperty, Pred> CollocationGroupProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CollocationGroupProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PropertyMapping> PropertyMapping_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PropertyMapping, Pred> PropertyMapping_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PropertyMapping, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentInstanceRef> ComponentInstanceRef_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentInstanceRef, Pred> ComponentInstanceRef_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentInstanceRef, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::CollocationGroupMember> CollocationGroupMember_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred> CollocationGroupMember_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Deploys> Deploys_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Deploys, Pred> Deploys_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Deploys, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentFactoryRef> ComponentFactoryRef_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentFactoryRef, Pred> ComponentFactoryRef_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentFactoryRef, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::CollocationGroup> CollocationGroup_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CollocationGroup, Pred> CollocationGroup_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CollocationGroup, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::InstanceMapping> InstanceMapping_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InstanceMapping, Pred> InstanceMapping_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InstanceMapping, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComplexProperty> ComplexProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred> ComplexProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SimpleProperty> SimpleProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred> SimpleProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference> ComponentAssemblyReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference, Pred> ComponentAssemblyReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::DeploymentPlans> DeploymentPlans_parent() const;
		::Udm::ParentAttr< ::PICML::DeploymentPlans> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_label;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::CompositionChildRole meta_CollocationGroupProperty_children;
		static ::Uml::CompositionChildRole meta_InstanceMapping_children;
		static ::Uml::CompositionChildRole meta_NodeReference_children;
		static ::Uml::CompositionChildRole meta_CollocationGroup_children;
		static ::Uml::CompositionChildRole meta_PropertyMapping_children;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_CollocationGroupMember_children;
		static ::Uml::CompositionChildRole meta_Deploys_children;
		static ::Uml::CompositionParentRole meta_DeploymentPlans_parent;

	};

	class PICML_Export InstanceMapping :  public MgaObject {
	public:
		InstanceMapping();
		InstanceMapping(::Udm::ObjectImpl *impl);
		InstanceMapping(const InstanceMapping &master);

#ifdef UDM_RVALUE
		InstanceMapping(InstanceMapping &&master);

		static InstanceMapping Cast(::Udm::Object &&a);
		InstanceMapping& operator=(InstanceMapping &&a);

#endif
		static InstanceMapping Cast(const ::Udm::Object &a);
		static InstanceMapping Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		InstanceMapping CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< InstanceMapping> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< InstanceMapping, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< InstanceMapping, Pred>(impl); };
		InstanceMapping CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< InstanceMapping> Derived();
		template <class Pred> ::Udm::DerivedAttr< InstanceMapping, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< InstanceMapping, Pred>(impl); };
		::Udm::ArchetypeAttr< InstanceMapping> Archetype() const;
		::Udm::ParentAttr< ::PICML::DeploymentPlan> DeploymentPlan_parent() const;
		::Udm::ParentAttr< ::PICML::DeploymentPlan> parent() const;
		::Udm::AssocEndAttr< ::PICML::CollocationGroup> srcInstanceMapping_end() const;
		::Udm::AssocEndAttr< ::PICML::NodeReference> dstInstanceMapping_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_DeploymentPlan_parent;
		static ::Uml::AssociationRole meta_srcInstanceMapping_end_;
		static ::Uml::AssociationRole meta_dstInstanceMapping_end_;

	};

	class PICML_Export PackageConfiguration :  public MgaObject {
	public:
		PackageConfiguration();
		PackageConfiguration(::Udm::ObjectImpl *impl);
		PackageConfiguration(const PackageConfiguration &master);

#ifdef UDM_RVALUE
		PackageConfiguration(PackageConfiguration &&master);

		static PackageConfiguration Cast(::Udm::Object &&a);
		PackageConfiguration& operator=(PackageConfiguration &&a);

#endif
		static PackageConfiguration Cast(const ::Udm::Object &a);
		static PackageConfiguration Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PackageConfiguration CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PackageConfiguration> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PackageConfiguration, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PackageConfiguration, Pred>(impl); };
		PackageConfiguration CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PackageConfiguration> Derived();
		template <class Pred> ::Udm::DerivedAttr< PackageConfiguration, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PackageConfiguration, Pred>(impl); };
		::Udm::ArchetypeAttr< PackageConfiguration> Archetype() const;
		::Udm::StringAttr label() const;
		::Udm::StringAttr UUID() const;
		::Udm::AClassPointerAttr< PackageConfSpecializedConfig, PackageConfigurationReference> dstPackageConfSpecializedConfig() const;
		::Udm::AClassAssocAttr< PackageConfConfigProperty, Property> dstPackageConfConfigProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< PackageConfConfigProperty, Property, Pred> dstPackageConfConfigProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< PackageConfConfigProperty, Property, Pred>(impl, meta_dstPackageConfConfigProperty, meta_dstPackageConfConfigProperty_rev); };
		::Udm::AClassAssocAttr< PackageConfSelectRequirement, Requirement> dstPackageConfSelectRequirement() const;
		template <class Pred> ::Udm::AClassAssocAttr< PackageConfSelectRequirement, Requirement, Pred> dstPackageConfSelectRequirement_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< PackageConfSelectRequirement, Requirement, Pred>(impl, meta_dstPackageConfSelectRequirement, meta_dstPackageConfSelectRequirement_rev); };
		::Udm::AClassPointerAttr< PackageConfReference, ComponentPackageReference> dstPackageConfReference() const;
		::Udm::AClassPointerAttr< PackageConfBasePackage, ComponentPackage> dstPackageConfBasePackage() const;
		::Udm::AssocAttr< PackageConfigurationReference> referedbyPackageConfigurationReference() const;
		template <class Pred> ::Udm::AssocAttr< PackageConfigurationReference, Pred> referedbyPackageConfigurationReference_sorted(const Pred &) const { return ::Udm::AssocAttr< PackageConfigurationReference, Pred>(impl, meta_referedbyPackageConfigurationReference); };
		::Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::PackageConfigurationContainer> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_label;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::AssociationRole meta_dstPackageConfSpecializedConfig;
		static ::Uml::AssociationRole meta_dstPackageConfSpecializedConfig_rev;
		static ::Uml::AssociationRole meta_dstPackageConfConfigProperty;
		static ::Uml::AssociationRole meta_dstPackageConfConfigProperty_rev;
		static ::Uml::AssociationRole meta_dstPackageConfSelectRequirement;
		static ::Uml::AssociationRole meta_dstPackageConfSelectRequirement_rev;
		static ::Uml::AssociationRole meta_dstPackageConfReference;
		static ::Uml::AssociationRole meta_dstPackageConfReference_rev;
		static ::Uml::AssociationRole meta_dstPackageConfBasePackage;
		static ::Uml::AssociationRole meta_dstPackageConfBasePackage_rev;
		static ::Uml::AssociationRole meta_referedbyPackageConfigurationReference;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;

	};

	class PICML_Export PackageConfSpecializedConfig :  public MgaObject {
	public:
		PackageConfSpecializedConfig();
		PackageConfSpecializedConfig(::Udm::ObjectImpl *impl);
		PackageConfSpecializedConfig(const PackageConfSpecializedConfig &master);

#ifdef UDM_RVALUE
		PackageConfSpecializedConfig(PackageConfSpecializedConfig &&master);

		static PackageConfSpecializedConfig Cast(::Udm::Object &&a);
		PackageConfSpecializedConfig& operator=(PackageConfSpecializedConfig &&a);

#endif
		static PackageConfSpecializedConfig Cast(const ::Udm::Object &a);
		static PackageConfSpecializedConfig Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PackageConfSpecializedConfig CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PackageConfSpecializedConfig> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PackageConfSpecializedConfig, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PackageConfSpecializedConfig, Pred>(impl); };
		PackageConfSpecializedConfig CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PackageConfSpecializedConfig> Derived();
		template <class Pred> ::Udm::DerivedAttr< PackageConfSpecializedConfig, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PackageConfSpecializedConfig, Pred>(impl); };
		::Udm::ArchetypeAttr< PackageConfSpecializedConfig> Archetype() const;
		::Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::PackageConfigurationContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::PackageConfiguration> srcPackageConfSpecializedConfig_end() const;
		::Udm::AssocEndAttr< ::PICML::PackageConfigurationReference> dstPackageConfSpecializedConfig_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::AssociationRole meta_srcPackageConfSpecializedConfig_end_;
		static ::Uml::AssociationRole meta_dstPackageConfSpecializedConfig_end_;

	};

	class PICML_Export PackageConfSelectRequirement :  public MgaObject {
	public:
		PackageConfSelectRequirement();
		PackageConfSelectRequirement(::Udm::ObjectImpl *impl);
		PackageConfSelectRequirement(const PackageConfSelectRequirement &master);

#ifdef UDM_RVALUE
		PackageConfSelectRequirement(PackageConfSelectRequirement &&master);

		static PackageConfSelectRequirement Cast(::Udm::Object &&a);
		PackageConfSelectRequirement& operator=(PackageConfSelectRequirement &&a);

#endif
		static PackageConfSelectRequirement Cast(const ::Udm::Object &a);
		static PackageConfSelectRequirement Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PackageConfSelectRequirement CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PackageConfSelectRequirement> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PackageConfSelectRequirement, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PackageConfSelectRequirement, Pred>(impl); };
		PackageConfSelectRequirement CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PackageConfSelectRequirement> Derived();
		template <class Pred> ::Udm::DerivedAttr< PackageConfSelectRequirement, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PackageConfSelectRequirement, Pred>(impl); };
		::Udm::ArchetypeAttr< PackageConfSelectRequirement> Archetype() const;
		::Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::PackageConfigurationContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::PackageConfiguration> srcPackageConfSelectRequirement_end() const;
		::Udm::AssocEndAttr< ::PICML::Requirement> dstPackageConfSelectRequirement_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::AssociationRole meta_srcPackageConfSelectRequirement_end_;
		static ::Uml::AssociationRole meta_dstPackageConfSelectRequirement_end_;

	};

	class PICML_Export PackageConfConfigProperty :  public MgaObject {
	public:
		PackageConfConfigProperty();
		PackageConfConfigProperty(::Udm::ObjectImpl *impl);
		PackageConfConfigProperty(const PackageConfConfigProperty &master);

#ifdef UDM_RVALUE
		PackageConfConfigProperty(PackageConfConfigProperty &&master);

		static PackageConfConfigProperty Cast(::Udm::Object &&a);
		PackageConfConfigProperty& operator=(PackageConfConfigProperty &&a);

#endif
		static PackageConfConfigProperty Cast(const ::Udm::Object &a);
		static PackageConfConfigProperty Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PackageConfConfigProperty CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PackageConfConfigProperty> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PackageConfConfigProperty, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PackageConfConfigProperty, Pred>(impl); };
		PackageConfConfigProperty CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PackageConfConfigProperty> Derived();
		template <class Pred> ::Udm::DerivedAttr< PackageConfConfigProperty, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PackageConfConfigProperty, Pred>(impl); };
		::Udm::ArchetypeAttr< PackageConfConfigProperty> Archetype() const;
		::Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::PackageConfigurationContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::PackageConfiguration> srcPackageConfConfigProperty_end() const;
		::Udm::AssocEndAttr< ::PICML::Property> dstPackageConfConfigProperty_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::AssociationRole meta_srcPackageConfConfigProperty_end_;
		static ::Uml::AssociationRole meta_dstPackageConfConfigProperty_end_;

	};

	class PICML_Export PackageConfigurationContainer :  public MgaObject {
	public:
		PackageConfigurationContainer();
		PackageConfigurationContainer(::Udm::ObjectImpl *impl);
		PackageConfigurationContainer(const PackageConfigurationContainer &master);

#ifdef UDM_RVALUE
		PackageConfigurationContainer(PackageConfigurationContainer &&master);

		static PackageConfigurationContainer Cast(::Udm::Object &&a);
		PackageConfigurationContainer& operator=(PackageConfigurationContainer &&a);

#endif
		static PackageConfigurationContainer Cast(const ::Udm::Object &a);
		static PackageConfigurationContainer Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PackageConfigurationContainer CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PackageConfigurationContainer> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PackageConfigurationContainer, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PackageConfigurationContainer, Pred>(impl); };
		PackageConfigurationContainer CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PackageConfigurationContainer> Derived();
		template <class Pred> ::Udm::DerivedAttr< PackageConfigurationContainer, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PackageConfigurationContainer, Pred>(impl); };
		::Udm::ArchetypeAttr< PackageConfigurationContainer> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::Property> Property_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); };
		::Udm::ChildrenAttr< ::PICML::PackageConfiguration> PackageConfiguration_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageConfiguration, Pred> PackageConfiguration_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageConfiguration, Pred>(impl, meta_PackageConfiguration_children); };
		::Udm::ChildAttr< ::PICML::PackageConfSpecializedConfig> PackageConfSpecializedConfig_child() const;
		::Udm::ChildrenAttr< ::PICML::Requirement> Requirement_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Requirement, Pred> Requirement_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Requirement, Pred>(impl, meta_Requirement_children); };
		::Udm::ChildrenAttr< ::PICML::PackageConfSelectRequirement> PackageConfSelectRequirement_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageConfSelectRequirement, Pred> PackageConfSelectRequirement_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageConfSelectRequirement, Pred>(impl, meta_PackageConfSelectRequirement_children); };
		::Udm::ChildrenAttr< ::PICML::PackageConfConfigProperty> PackageConfConfigProperty_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageConfConfigProperty, Pred> PackageConfConfigProperty_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageConfConfigProperty, Pred>(impl, meta_PackageConfConfigProperty_children); };
		::Udm::ChildAttr< ::PICML::ComponentPackageReference> ComponentPackageReference_child() const;
		::Udm::ChildAttr< ::PICML::ComponentPackage> ComponentPackage_child() const;
		::Udm::ChildAttr< ::PICML::PackageConfReference> PackageConfReference_child() const;
		::Udm::ChildAttr< ::PICML::PackageConfBasePackage> PackageConfBasePackage_child() const;
		::Udm::ChildrenAttr< ::PICML::RTRequirements> RTRequirements_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RTRequirements, Pred> RTRequirements_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RTRequirements, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ECRequirements> ECRequirements_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ECRequirements, Pred> ECRequirements_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ECRequirements, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PackageConfiguration> PackageConfiguration_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageConfiguration, Pred> PackageConfiguration_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageConfiguration, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PackageConfSpecializedConfig> PackageConfSpecializedConfig_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageConfSpecializedConfig, Pred> PackageConfSpecializedConfig_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageConfSpecializedConfig, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PackageConfSelectRequirement> PackageConfSelectRequirement_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageConfSelectRequirement, Pred> PackageConfSelectRequirement_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageConfSelectRequirement, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PackageConfConfigProperty> PackageConfConfigProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageConfConfigProperty, Pred> PackageConfConfigProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageConfConfigProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PackageConfReference> PackageConfReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageConfReference, Pred> PackageConfReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageConfReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PackageConfBasePackage> PackageConfBasePackage_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageConfBasePackage, Pred> PackageConfBasePackage_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageConfBasePackage, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentPackageReference> ComponentPackageReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentPackageReference, Pred> ComponentPackageReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentPackageReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentPackage> ComponentPackage_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentPackage, Pred> ComponentPackage_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentPackage, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComplexProperty> ComplexProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred> ComplexProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SimpleProperty> SimpleProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred> SimpleProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequirementBase> RequirementBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequirementBase, Pred> RequirementBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequirementBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Requirement> Requirement_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Requirement, Pred> Requirement_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Requirement, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::PackageConfigurations> PackageConfigurations_parent() const;
		::Udm::ParentAttr< ::PICML::PackageConfigurations> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_PackageConfiguration_children;
		static ::Uml::CompositionChildRole meta_PackageConfSpecializedConfig_child;
		static ::Uml::CompositionChildRole meta_Requirement_children;
		static ::Uml::CompositionChildRole meta_PackageConfSelectRequirement_children;
		static ::Uml::CompositionChildRole meta_PackageConfConfigProperty_children;
		static ::Uml::CompositionChildRole meta_ComponentPackageReference_child;
		static ::Uml::CompositionChildRole meta_ComponentPackage_child;
		static ::Uml::CompositionChildRole meta_PackageConfReference_child;
		static ::Uml::CompositionChildRole meta_PackageConfBasePackage_child;
		static ::Uml::CompositionParentRole meta_PackageConfigurations_parent;

	};

	class PICML_Export PackageConfReference :  public MgaObject {
	public:
		PackageConfReference();
		PackageConfReference(::Udm::ObjectImpl *impl);
		PackageConfReference(const PackageConfReference &master);

#ifdef UDM_RVALUE
		PackageConfReference(PackageConfReference &&master);

		static PackageConfReference Cast(::Udm::Object &&a);
		PackageConfReference& operator=(PackageConfReference &&a);

#endif
		static PackageConfReference Cast(const ::Udm::Object &a);
		static PackageConfReference Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PackageConfReference CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PackageConfReference> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PackageConfReference, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PackageConfReference, Pred>(impl); };
		PackageConfReference CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PackageConfReference> Derived();
		template <class Pred> ::Udm::DerivedAttr< PackageConfReference, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PackageConfReference, Pred>(impl); };
		::Udm::ArchetypeAttr< PackageConfReference> Archetype() const;
		::Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::PackageConfigurationContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::PackageConfiguration> srcPackageConfReference_end() const;
		::Udm::AssocEndAttr< ::PICML::ComponentPackageReference> dstPackageConfReference_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::AssociationRole meta_srcPackageConfReference_end_;
		static ::Uml::AssociationRole meta_dstPackageConfReference_end_;

	};

	class PICML_Export PackageConfigurationReference :  public MgaObject {
	public:
		PackageConfigurationReference();
		PackageConfigurationReference(::Udm::ObjectImpl *impl);
		PackageConfigurationReference(const PackageConfigurationReference &master);

#ifdef UDM_RVALUE
		PackageConfigurationReference(PackageConfigurationReference &&master);

		static PackageConfigurationReference Cast(::Udm::Object &&a);
		PackageConfigurationReference& operator=(PackageConfigurationReference &&a);

#endif
		static PackageConfigurationReference Cast(const ::Udm::Object &a);
		static PackageConfigurationReference Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PackageConfigurationReference CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PackageConfigurationReference> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PackageConfigurationReference, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PackageConfigurationReference, Pred>(impl); };
		PackageConfigurationReference CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PackageConfigurationReference> Derived();
		template <class Pred> ::Udm::DerivedAttr< PackageConfigurationReference, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PackageConfigurationReference, Pred>(impl); };
		::Udm::ArchetypeAttr< PackageConfigurationReference> Archetype() const;
		::Udm::AClassAssocAttr< PackageConfSpecializedConfig, PackageConfiguration> srcPackageConfSpecializedConfig() const;
		template <class Pred> ::Udm::AClassAssocAttr< PackageConfSpecializedConfig, PackageConfiguration, Pred> srcPackageConfSpecializedConfig_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< PackageConfSpecializedConfig, PackageConfiguration, Pred>(impl, meta_srcPackageConfSpecializedConfig, meta_srcPackageConfSpecializedConfig_rev); };
		::Udm::PointerAttr< PackageConfiguration> ref() const;
		::Udm::AClassPointerAttr< package, TopLevelPackage> srcpackage() const;
		::Udm::ParentAttr< ::PICML::TopLevelPackageContainer> TopLevelPackageContainer_parent() const;
		::Udm::ParentAttr< ::PICML::TopLevelPackageContainer> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcPackageConfSpecializedConfig;
		static ::Uml::AssociationRole meta_srcPackageConfSpecializedConfig_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_srcpackage;
		static ::Uml::AssociationRole meta_srcpackage_rev;
		static ::Uml::CompositionParentRole meta_TopLevelPackageContainer_parent;

	};

	class PICML_Export PackageConfBasePackage :  public MgaObject {
	public:
		PackageConfBasePackage();
		PackageConfBasePackage(::Udm::ObjectImpl *impl);
		PackageConfBasePackage(const PackageConfBasePackage &master);

#ifdef UDM_RVALUE
		PackageConfBasePackage(PackageConfBasePackage &&master);

		static PackageConfBasePackage Cast(::Udm::Object &&a);
		PackageConfBasePackage& operator=(PackageConfBasePackage &&a);

#endif
		static PackageConfBasePackage Cast(const ::Udm::Object &a);
		static PackageConfBasePackage Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PackageConfBasePackage CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PackageConfBasePackage> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PackageConfBasePackage, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PackageConfBasePackage, Pred>(impl); };
		PackageConfBasePackage CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PackageConfBasePackage> Derived();
		template <class Pred> ::Udm::DerivedAttr< PackageConfBasePackage, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PackageConfBasePackage, Pred>(impl); };
		::Udm::ArchetypeAttr< PackageConfBasePackage> Archetype() const;
		::Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::PackageConfigurationContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::PackageConfiguration> srcPackageConfBasePackage_end() const;
		::Udm::AssocEndAttr< ::PICML::ComponentPackage> dstPackageConfBasePackage_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::AssociationRole meta_srcPackageConfBasePackage_end_;
		static ::Uml::AssociationRole meta_dstPackageConfBasePackage_end_;

	};

	class PICML_Export ArtifactDependency :  public MgaObject {
	public:
		ArtifactDependency();
		ArtifactDependency(::Udm::ObjectImpl *impl);
		ArtifactDependency(const ArtifactDependency &master);

#ifdef UDM_RVALUE
		ArtifactDependency(ArtifactDependency &&master);

		static ArtifactDependency Cast(::Udm::Object &&a);
		ArtifactDependency& operator=(ArtifactDependency &&a);

#endif
		static ArtifactDependency Cast(const ::Udm::Object &a);
		static ArtifactDependency Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ArtifactDependency CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ArtifactDependency> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ArtifactDependency, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ArtifactDependency, Pred>(impl); };
		ArtifactDependency CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ArtifactDependency> Derived();
		template <class Pred> ::Udm::DerivedAttr< ArtifactDependency, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ArtifactDependency, Pred>(impl); };
		::Udm::ArchetypeAttr< ArtifactDependency> Archetype() const;
		::Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ArtifactContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ImplementationArtifact> srcArtifactDependency_end() const;
		::Udm::AssocEndAttr< ::PICML::ImplementationArtifact> dstArtifactDependency_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::AssociationRole meta_srcArtifactDependency_end_;
		static ::Uml::AssociationRole meta_dstArtifactDependency_end_;

	};

	class PICML_Export ImplementationArtifact :  public MgaObject {
	public:
		ImplementationArtifact();
		ImplementationArtifact(::Udm::ObjectImpl *impl);
		ImplementationArtifact(const ImplementationArtifact &master);

#ifdef UDM_RVALUE
		ImplementationArtifact(ImplementationArtifact &&master);

		static ImplementationArtifact Cast(::Udm::Object &&a);
		ImplementationArtifact& operator=(ImplementationArtifact &&a);

#endif
		static ImplementationArtifact Cast(const ::Udm::Object &a);
		static ImplementationArtifact Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ImplementationArtifact CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ImplementationArtifact> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ImplementationArtifact, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ImplementationArtifact, Pred>(impl); };
		ImplementationArtifact CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ImplementationArtifact> Derived();
		template <class Pred> ::Udm::DerivedAttr< ImplementationArtifact, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ImplementationArtifact, Pred>(impl); };
		::Udm::ArchetypeAttr< ImplementationArtifact> Archetype() const;
		::Udm::StringAttr operatingSystem() const;
		::Udm::StringAttr configuration() const;
		::Udm::StringAttr artifactVersion() const;
		::Udm::StringAttr architecture() const;
		::Udm::StringAttr label() const;
		::Udm::StringAttr UUID() const;
		::Udm::StringAttr location() const;
		::Udm::AssocAttr< ComponentImplementationArtifact> referedbyComponentImplemenationArtifact() const;
		template <class Pred> ::Udm::AssocAttr< ComponentImplementationArtifact, Pred> referedbyComponentImplemenationArtifact_sorted(const Pred &) const { return ::Udm::AssocAttr< ComponentImplementationArtifact, Pred>(impl, meta_referedbyComponentImplemenationArtifact); };
		::Udm::AssocAttr< ComponentServantArtifact> referedbyComponentServantArtifact() const;
		template <class Pred> ::Udm::AssocAttr< ComponentServantArtifact, Pred> referedbyComponentServantArtifact_sorted(const Pred &) const { return ::Udm::AssocAttr< ComponentServantArtifact, Pred>(impl, meta_referedbyComponentServantArtifact); };
		::Udm::AClassAssocAttr< ArtifactDependency, ImplementationArtifact> dstArtifactDependency() const;
		template <class Pred> ::Udm::AClassAssocAttr< ArtifactDependency, ImplementationArtifact, Pred> dstArtifactDependency_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ArtifactDependency, ImplementationArtifact, Pred>(impl, meta_dstArtifactDependency, meta_dstArtifactDependency_rev); };
		::Udm::AClassAssocAttr< ArtifactDependency, ImplementationArtifact> srcArtifactDependency() const;
		template <class Pred> ::Udm::AClassAssocAttr< ArtifactDependency, ImplementationArtifact, Pred> srcArtifactDependency_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ArtifactDependency, ImplementationArtifact, Pred>(impl, meta_srcArtifactDependency, meta_srcArtifactDependency_rev); };
		::Udm::AClassAssocAttr< ArtifactInfoProperty, Property> dstArtifactInfoProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< ArtifactInfoProperty, Property, Pred> dstArtifactInfoProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ArtifactInfoProperty, Property, Pred>(impl, meta_dstArtifactInfoProperty, meta_dstArtifactInfoProperty_rev); };
		::Udm::AClassAssocAttr< ArtifactExecParameter, Property> dstArtifactExecParameter() const;
		template <class Pred> ::Udm::AClassAssocAttr< ArtifactExecParameter, Property, Pred> dstArtifactExecParameter_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ArtifactExecParameter, Property, Pred>(impl, meta_dstArtifactExecParameter, meta_dstArtifactExecParameter_rev); };
		::Udm::AClassAssocAttr< ArtifactDeployRequirement, Requirement> dstArtifactDeployRequirement() const;
		template <class Pred> ::Udm::AClassAssocAttr< ArtifactDeployRequirement, Requirement, Pred> dstArtifactDeployRequirement_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ArtifactDeployRequirement, Requirement, Pred>(impl, meta_dstArtifactDeployRequirement, meta_dstArtifactDeployRequirement_rev); };
		::Udm::AClassAssocAttr< ArtifactDependsOn, ImplementationArtifactReference> dstArtifactDependsOn() const;
		template <class Pred> ::Udm::AClassAssocAttr< ArtifactDependsOn, ImplementationArtifactReference, Pred> dstArtifactDependsOn_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ArtifactDependsOn, ImplementationArtifactReference, Pred>(impl, meta_dstArtifactDependsOn, meta_dstArtifactDependsOn_rev); };
		::Udm::AssocAttr< ImplementationArtifactReference> referedbyImplementationArtifactReference() const;
		template <class Pred> ::Udm::AssocAttr< ImplementationArtifactReference, Pred> referedbyImplementationArtifactReference_sorted(const Pred &) const { return ::Udm::AssocAttr< ImplementationArtifactReference, Pred>(impl, meta_referedbyImplementationArtifactReference); };
		::Udm::AssocAttr< ExternalResources> referedbyExternalResources() const;
		template <class Pred> ::Udm::AssocAttr< ExternalResources, Pred> referedbyExternalResources_sorted(const Pred &) const { return ::Udm::AssocAttr< ExternalResources, Pred>(impl, meta_referedbyExternalResources); };
		::Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const;
		::Udm::ParentAttr< ::PICML::Project> Project_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_operatingSystem;
		static ::Uml::Attribute meta_configuration;
		static ::Uml::Attribute meta_artifactVersion;
		static ::Uml::Attribute meta_architecture;
		static ::Uml::Attribute meta_label;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::Attribute meta_location;
		static ::Uml::AssociationRole meta_referedbyComponentImplemenationArtifact;
		static ::Uml::AssociationRole meta_referedbyComponentServantArtifact;
		static ::Uml::AssociationRole meta_dstArtifactDependency;
		static ::Uml::AssociationRole meta_dstArtifactDependency_rev;
		static ::Uml::AssociationRole meta_srcArtifactDependency;
		static ::Uml::AssociationRole meta_srcArtifactDependency_rev;
		static ::Uml::AssociationRole meta_dstArtifactInfoProperty;
		static ::Uml::AssociationRole meta_dstArtifactInfoProperty_rev;
		static ::Uml::AssociationRole meta_dstArtifactExecParameter;
		static ::Uml::AssociationRole meta_dstArtifactExecParameter_rev;
		static ::Uml::AssociationRole meta_dstArtifactDeployRequirement;
		static ::Uml::AssociationRole meta_dstArtifactDeployRequirement_rev;
		static ::Uml::AssociationRole meta_dstArtifactDependsOn;
		static ::Uml::AssociationRole meta_dstArtifactDependsOn_rev;
		static ::Uml::AssociationRole meta_referedbyImplementationArtifactReference;
		static ::Uml::AssociationRole meta_referedbyExternalResources;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::CompositionParentRole meta_Project_parent;

	};

	class PICML_Export ArtifactInfoProperty :  public MgaObject {
	public:
		ArtifactInfoProperty();
		ArtifactInfoProperty(::Udm::ObjectImpl *impl);
		ArtifactInfoProperty(const ArtifactInfoProperty &master);

#ifdef UDM_RVALUE
		ArtifactInfoProperty(ArtifactInfoProperty &&master);

		static ArtifactInfoProperty Cast(::Udm::Object &&a);
		ArtifactInfoProperty& operator=(ArtifactInfoProperty &&a);

#endif
		static ArtifactInfoProperty Cast(const ::Udm::Object &a);
		static ArtifactInfoProperty Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ArtifactInfoProperty CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ArtifactInfoProperty> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ArtifactInfoProperty, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ArtifactInfoProperty, Pred>(impl); };
		ArtifactInfoProperty CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ArtifactInfoProperty> Derived();
		template <class Pred> ::Udm::DerivedAttr< ArtifactInfoProperty, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ArtifactInfoProperty, Pred>(impl); };
		::Udm::ArchetypeAttr< ArtifactInfoProperty> Archetype() const;
		::Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ArtifactContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ImplementationArtifact> srcArtifactInfoProperty_end() const;
		::Udm::AssocEndAttr< ::PICML::Property> dstArtifactInfoProperty_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::AssociationRole meta_srcArtifactInfoProperty_end_;
		static ::Uml::AssociationRole meta_dstArtifactInfoProperty_end_;

	};

	class PICML_Export ArtifactExecParameter :  public MgaObject {
	public:
		ArtifactExecParameter();
		ArtifactExecParameter(::Udm::ObjectImpl *impl);
		ArtifactExecParameter(const ArtifactExecParameter &master);

#ifdef UDM_RVALUE
		ArtifactExecParameter(ArtifactExecParameter &&master);

		static ArtifactExecParameter Cast(::Udm::Object &&a);
		ArtifactExecParameter& operator=(ArtifactExecParameter &&a);

#endif
		static ArtifactExecParameter Cast(const ::Udm::Object &a);
		static ArtifactExecParameter Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ArtifactExecParameter CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ArtifactExecParameter> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ArtifactExecParameter, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ArtifactExecParameter, Pred>(impl); };
		ArtifactExecParameter CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ArtifactExecParameter> Derived();
		template <class Pred> ::Udm::DerivedAttr< ArtifactExecParameter, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ArtifactExecParameter, Pred>(impl); };
		::Udm::ArchetypeAttr< ArtifactExecParameter> Archetype() const;
		::Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ArtifactContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ImplementationArtifact> srcArtifactExecParameter_end() const;
		::Udm::AssocEndAttr< ::PICML::Property> dstArtifactExecParameter_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::AssociationRole meta_srcArtifactExecParameter_end_;
		static ::Uml::AssociationRole meta_dstArtifactExecParameter_end_;

	};

	class PICML_Export ArtifactContainer :  public MgaObject {
	public:
		ArtifactContainer();
		ArtifactContainer(::Udm::ObjectImpl *impl);
		ArtifactContainer(const ArtifactContainer &master);

#ifdef UDM_RVALUE
		ArtifactContainer(ArtifactContainer &&master);

		static ArtifactContainer Cast(::Udm::Object &&a);
		ArtifactContainer& operator=(ArtifactContainer &&a);

#endif
		static ArtifactContainer Cast(const ::Udm::Object &a);
		static ArtifactContainer Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ArtifactContainer CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ArtifactContainer> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ArtifactContainer, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ArtifactContainer, Pred>(impl); };
		ArtifactContainer CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ArtifactContainer> Derived();
		template <class Pred> ::Udm::DerivedAttr< ArtifactContainer, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ArtifactContainer, Pred>(impl); };
		::Udm::ArchetypeAttr< ArtifactContainer> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::Property> Property_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); };
		::Udm::ChildrenAttr< ::PICML::ArtifactDependency> ArtifactDependency_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ArtifactDependency, Pred> ArtifactDependency_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ArtifactDependency, Pred>(impl, meta_ArtifactDependency_children); };
		::Udm::ChildrenAttr< ::PICML::ImplementationArtifact> ImplementationArtifact_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationArtifact, Pred> ImplementationArtifact_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationArtifact, Pred>(impl, meta_ImplementationArtifact_children); };
		::Udm::ChildrenAttr< ::PICML::ArtifactInfoProperty> ArtifactInfoProperty_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ArtifactInfoProperty, Pred> ArtifactInfoProperty_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ArtifactInfoProperty, Pred>(impl, meta_ArtifactInfoProperty_children); };
		::Udm::ChildrenAttr< ::PICML::ArtifactExecParameter> ArtifactExecParameter_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ArtifactExecParameter, Pred> ArtifactExecParameter_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ArtifactExecParameter, Pred>(impl, meta_ArtifactExecParameter_children); };
		::Udm::ChildrenAttr< ::PICML::Requirement> Requirement_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Requirement, Pred> Requirement_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Requirement, Pred>(impl, meta_Requirement_children); };
		::Udm::ChildrenAttr< ::PICML::ArtifactDeployRequirement> ArtifactDeployRequirement_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ArtifactDeployRequirement, Pred> ArtifactDeployRequirement_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ArtifactDeployRequirement, Pred>(impl, meta_ArtifactDeployRequirement_children); };
		::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred> ImplementationArtifactReference_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred>(impl, meta_ImplementationArtifactReference_children); };
		::Udm::ChildrenAttr< ::PICML::ArtifactDependsOn> ArtifactDependsOn_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ArtifactDependsOn, Pred> ArtifactDependsOn_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ArtifactDependsOn, Pred>(impl, meta_ArtifactDependsOn_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact> ComponentImplementationArtifact_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred> ComponentImplementationArtifact_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentServantArtifact> ComponentServantArtifact_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred> ComponentServantArtifact_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RTRequirements> RTRequirements_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RTRequirements, Pred> RTRequirements_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RTRequirements, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ECRequirements> ECRequirements_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ECRequirements, Pred> ECRequirements_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ECRequirements, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ArtifactDependency> ArtifactDependency_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ArtifactDependency, Pred> ArtifactDependency_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ArtifactDependency, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ImplementationArtifact> ImplementationArtifact_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationArtifact, Pred> ImplementationArtifact_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationArtifact, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ArtifactInfoProperty> ArtifactInfoProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ArtifactInfoProperty, Pred> ArtifactInfoProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ArtifactInfoProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ArtifactExecParameter> ArtifactExecParameter_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ArtifactExecParameter, Pred> ArtifactExecParameter_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ArtifactExecParameter, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ArtifactDeployRequirement> ArtifactDeployRequirement_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ArtifactDeployRequirement, Pred> ArtifactDeployRequirement_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ArtifactDeployRequirement, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ArtifactDependsOn> ArtifactDependsOn_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ArtifactDependsOn, Pred> ArtifactDependsOn_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ArtifactDependsOn, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred> ImplementationArtifactReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComplexProperty> ComplexProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred> ComplexProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SimpleProperty> SimpleProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred> SimpleProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequirementBase> RequirementBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequirementBase, Pred> RequirementBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequirementBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Requirement> Requirement_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Requirement, Pred> Requirement_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Requirement, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::ImplementationArtifacts> ImplementationArtifacts_parent() const;
		::Udm::ParentAttr< ::PICML::ImplementationArtifacts> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_ArtifactDependency_children;
		static ::Uml::CompositionChildRole meta_ImplementationArtifact_children;
		static ::Uml::CompositionChildRole meta_ArtifactInfoProperty_children;
		static ::Uml::CompositionChildRole meta_ArtifactExecParameter_children;
		static ::Uml::CompositionChildRole meta_Requirement_children;
		static ::Uml::CompositionChildRole meta_ArtifactDeployRequirement_children;
		static ::Uml::CompositionChildRole meta_ImplementationArtifactReference_children;
		static ::Uml::CompositionChildRole meta_ArtifactDependsOn_children;
		static ::Uml::CompositionParentRole meta_ImplementationArtifacts_parent;

	};

	class PICML_Export ArtifactDeployRequirement :  public MgaObject {
	public:
		ArtifactDeployRequirement();
		ArtifactDeployRequirement(::Udm::ObjectImpl *impl);
		ArtifactDeployRequirement(const ArtifactDeployRequirement &master);

#ifdef UDM_RVALUE
		ArtifactDeployRequirement(ArtifactDeployRequirement &&master);

		static ArtifactDeployRequirement Cast(::Udm::Object &&a);
		ArtifactDeployRequirement& operator=(ArtifactDeployRequirement &&a);

#endif
		static ArtifactDeployRequirement Cast(const ::Udm::Object &a);
		static ArtifactDeployRequirement Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ArtifactDeployRequirement CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ArtifactDeployRequirement> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ArtifactDeployRequirement, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ArtifactDeployRequirement, Pred>(impl); };
		ArtifactDeployRequirement CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ArtifactDeployRequirement> Derived();
		template <class Pred> ::Udm::DerivedAttr< ArtifactDeployRequirement, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ArtifactDeployRequirement, Pred>(impl); };
		::Udm::ArchetypeAttr< ArtifactDeployRequirement> Archetype() const;
		::Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ArtifactContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ImplementationArtifact> srcArtifactDeployRequirement_end() const;
		::Udm::AssocEndAttr< ::PICML::Requirement> dstArtifactDeployRequirement_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::AssociationRole meta_srcArtifactDeployRequirement_end_;
		static ::Uml::AssociationRole meta_dstArtifactDeployRequirement_end_;

	};

	class PICML_Export ArtifactDependsOn :  public MgaObject {
	public:
		ArtifactDependsOn();
		ArtifactDependsOn(::Udm::ObjectImpl *impl);
		ArtifactDependsOn(const ArtifactDependsOn &master);

#ifdef UDM_RVALUE
		ArtifactDependsOn(ArtifactDependsOn &&master);

		static ArtifactDependsOn Cast(::Udm::Object &&a);
		ArtifactDependsOn& operator=(ArtifactDependsOn &&a);

#endif
		static ArtifactDependsOn Cast(const ::Udm::Object &a);
		static ArtifactDependsOn Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ArtifactDependsOn CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ArtifactDependsOn> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ArtifactDependsOn, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ArtifactDependsOn, Pred>(impl); };
		ArtifactDependsOn CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ArtifactDependsOn> Derived();
		template <class Pred> ::Udm::DerivedAttr< ArtifactDependsOn, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ArtifactDependsOn, Pred>(impl); };
		::Udm::ArchetypeAttr< ArtifactDependsOn> Archetype() const;
		::Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ArtifactContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ImplementationArtifact> srcArtifactDependsOn_end() const;
		::Udm::AssocEndAttr< ::PICML::ImplementationArtifactReference> dstArtifactDependsOn_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::AssociationRole meta_srcArtifactDependsOn_end_;
		static ::Uml::AssociationRole meta_dstArtifactDependsOn_end_;

	};

	class PICML_Export ImplementationArtifactReference :  public MgaObject {
	public:
		ImplementationArtifactReference();
		ImplementationArtifactReference(::Udm::ObjectImpl *impl);
		ImplementationArtifactReference(const ImplementationArtifactReference &master);

#ifdef UDM_RVALUE
		ImplementationArtifactReference(ImplementationArtifactReference &&master);

		static ImplementationArtifactReference Cast(::Udm::Object &&a);
		ImplementationArtifactReference& operator=(ImplementationArtifactReference &&a);

#endif
		static ImplementationArtifactReference Cast(const ::Udm::Object &a);
		static ImplementationArtifactReference Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ImplementationArtifactReference CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ImplementationArtifactReference> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ImplementationArtifactReference, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ImplementationArtifactReference, Pred>(impl); };
		ImplementationArtifactReference CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ImplementationArtifactReference> Derived();
		template <class Pred> ::Udm::DerivedAttr< ImplementationArtifactReference, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ImplementationArtifactReference, Pred>(impl); };
		::Udm::ArchetypeAttr< ImplementationArtifactReference> Archetype() const;
		::Udm::AClassAssocAttr< MonolithprimaryArtifact, MonolithicImplementationBase> srcMonolithprimaryArtifact() const;
		template <class Pred> ::Udm::AClassAssocAttr< MonolithprimaryArtifact, MonolithicImplementationBase, Pred> srcMonolithprimaryArtifact_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< MonolithprimaryArtifact, MonolithicImplementationBase, Pred>(impl, meta_srcMonolithprimaryArtifact, meta_srcMonolithprimaryArtifact_rev); };
		::Udm::AClassAssocAttr< ArtifactDependsOn, ImplementationArtifact> srcArtifactDependsOn() const;
		template <class Pred> ::Udm::AClassAssocAttr< ArtifactDependsOn, ImplementationArtifact, Pred> srcArtifactDependsOn_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ArtifactDependsOn, ImplementationArtifact, Pred>(impl, meta_srcArtifactDependsOn, meta_srcArtifactDependsOn_rev); };
		::Udm::PointerAttr< ImplementationArtifact> ref() const;
		::Udm::ParentAttr< ::PICML::ImplementationContainer> ImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ExecutorProject> ExecutorProject_parent() const;
		::Udm::ParentAttr< ::PICML::ServantProject> ServantProject_parent() const;
		::Udm::ParentAttr< ::PICML::StubProject> StubProject_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcMonolithprimaryArtifact;
		static ::Uml::AssociationRole meta_srcMonolithprimaryArtifact_rev;
		static ::Uml::AssociationRole meta_srcArtifactDependsOn;
		static ::Uml::AssociationRole meta_srcArtifactDependsOn_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ImplementationContainer_parent;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::CompositionParentRole meta_ExecutorProject_parent;
		static ::Uml::CompositionParentRole meta_ServantProject_parent;
		static ::Uml::CompositionParentRole meta_StubProject_parent;

	};

	class PICML_Export ComponentImplementationArtifact :  public ImplementationArtifactReference {
	public:
		ComponentImplementationArtifact();
		ComponentImplementationArtifact(::Udm::ObjectImpl *impl);
		ComponentImplementationArtifact(const ComponentImplementationArtifact &master);

#ifdef UDM_RVALUE
		ComponentImplementationArtifact(ComponentImplementationArtifact &&master);

		static ComponentImplementationArtifact Cast(::Udm::Object &&a);
		ComponentImplementationArtifact& operator=(ComponentImplementationArtifact &&a);

#endif
		static ComponentImplementationArtifact Cast(const ::Udm::Object &a);
		static ComponentImplementationArtifact Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentImplementationArtifact CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentImplementationArtifact> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentImplementationArtifact, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentImplementationArtifact, Pred>(impl); };
		ComponentImplementationArtifact CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentImplementationArtifact> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentImplementationArtifact, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentImplementationArtifact, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentImplementationArtifact> Archetype() const;
		::Udm::StringAttr EntryPoint() const;
		::Udm::PointerAttr< ImplementationArtifact> ref() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_EntryPoint;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export ComponentServantArtifact :  public ImplementationArtifactReference {
	public:
		ComponentServantArtifact();
		ComponentServantArtifact(::Udm::ObjectImpl *impl);
		ComponentServantArtifact(const ComponentServantArtifact &master);

#ifdef UDM_RVALUE
		ComponentServantArtifact(ComponentServantArtifact &&master);

		static ComponentServantArtifact Cast(::Udm::Object &&a);
		ComponentServantArtifact& operator=(ComponentServantArtifact &&a);

#endif
		static ComponentServantArtifact Cast(const ::Udm::Object &a);
		static ComponentServantArtifact Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentServantArtifact CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentServantArtifact> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentServantArtifact, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentServantArtifact, Pred>(impl); };
		ComponentServantArtifact CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentServantArtifact> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentServantArtifact, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentServantArtifact, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentServantArtifact> Archetype() const;
		::Udm::StringAttr EntryPoint() const;
		::Udm::PointerAttr< ImplementationArtifact> ref() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_EntryPoint;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export package :  public MgaObject {
	public:
		package();
		package(::Udm::ObjectImpl *impl);
		package(const package &master);

#ifdef UDM_RVALUE
		package(package &&master);

		static package Cast(::Udm::Object &&a);
		package& operator=(package &&a);

#endif
		static package Cast(const ::Udm::Object &a);
		static package Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		package CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< package> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< package, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< package, Pred>(impl); };
		package CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< package> Derived();
		template <class Pred> ::Udm::DerivedAttr< package, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< package, Pred>(impl); };
		::Udm::ArchetypeAttr< package> Archetype() const;
		::Udm::ParentAttr< ::PICML::TopLevelPackageContainer> TopLevelPackageContainer_parent() const;
		::Udm::ParentAttr< ::PICML::TopLevelPackageContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::TopLevelPackage> srcpackage_end() const;
		::Udm::AssocEndAttr< ::PICML::PackageConfigurationReference> dstpackage_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_TopLevelPackageContainer_parent;
		static ::Uml::AssociationRole meta_srcpackage_end_;
		static ::Uml::AssociationRole meta_dstpackage_end_;

	};

	class PICML_Export TopLevelPackage :  public MgaObject {
	public:
		TopLevelPackage();
		TopLevelPackage(::Udm::ObjectImpl *impl);
		TopLevelPackage(const TopLevelPackage &master);

#ifdef UDM_RVALUE
		TopLevelPackage(TopLevelPackage &&master);

		static TopLevelPackage Cast(::Udm::Object &&a);
		TopLevelPackage& operator=(TopLevelPackage &&a);

#endif
		static TopLevelPackage Cast(const ::Udm::Object &a);
		static TopLevelPackage Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TopLevelPackage CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TopLevelPackage> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TopLevelPackage, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TopLevelPackage, Pred>(impl); };
		TopLevelPackage CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TopLevelPackage> Derived();
		template <class Pred> ::Udm::DerivedAttr< TopLevelPackage, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TopLevelPackage, Pred>(impl); };
		::Udm::ArchetypeAttr< TopLevelPackage> Archetype() const;
		::Udm::AClassPointerAttr< package, PackageConfigurationReference> dstpackage() const;
		::Udm::ParentAttr< ::PICML::TopLevelPackageContainer> TopLevelPackageContainer_parent() const;
		::Udm::ParentAttr< ::PICML::TopLevelPackageContainer> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstpackage;
		static ::Uml::AssociationRole meta_dstpackage_rev;
		static ::Uml::CompositionParentRole meta_TopLevelPackageContainer_parent;

	};

	class PICML_Export TopLevelPackageContainer :  public MgaObject {
	public:
		TopLevelPackageContainer();
		TopLevelPackageContainer(::Udm::ObjectImpl *impl);
		TopLevelPackageContainer(const TopLevelPackageContainer &master);

#ifdef UDM_RVALUE
		TopLevelPackageContainer(TopLevelPackageContainer &&master);

		static TopLevelPackageContainer Cast(::Udm::Object &&a);
		TopLevelPackageContainer& operator=(TopLevelPackageContainer &&a);

#endif
		static TopLevelPackageContainer Cast(const ::Udm::Object &a);
		static TopLevelPackageContainer Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TopLevelPackageContainer CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TopLevelPackageContainer> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TopLevelPackageContainer, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TopLevelPackageContainer, Pred>(impl); };
		TopLevelPackageContainer CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TopLevelPackageContainer> Derived();
		template <class Pred> ::Udm::DerivedAttr< TopLevelPackageContainer, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TopLevelPackageContainer, Pred>(impl); };
		::Udm::ArchetypeAttr< TopLevelPackageContainer> Archetype() const;
		::Udm::ChildAttr< ::PICML::package> package_child() const;
		::Udm::ChildAttr< ::PICML::TopLevelPackage> TopLevelPackage_child() const;
		::Udm::ChildAttr< ::PICML::PackageConfigurationReference> PackageConfigurationReference_child() const;
		::Udm::ChildrenAttr< ::PICML::PackageConfigurationReference> PackageConfigurationReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageConfigurationReference, Pred> PackageConfigurationReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageConfigurationReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::package> package_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::package, Pred> package_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::package, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TopLevelPackage> TopLevelPackage_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TopLevelPackage, Pred> TopLevelPackage_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TopLevelPackage, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::TopLevelPackages> TopLevelPackages_parent() const;
		::Udm::ParentAttr< ::PICML::TopLevelPackages> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_package_child;
		static ::Uml::CompositionChildRole meta_TopLevelPackage_child;
		static ::Uml::CompositionChildRole meta_PackageConfigurationReference_child;
		static ::Uml::CompositionParentRole meta_TopLevelPackages_parent;

	};

	class PICML_Export ComponentPackageReference :  public MgaObject {
	public:
		ComponentPackageReference();
		ComponentPackageReference(::Udm::ObjectImpl *impl);
		ComponentPackageReference(const ComponentPackageReference &master);

#ifdef UDM_RVALUE
		ComponentPackageReference(ComponentPackageReference &&master);

		static ComponentPackageReference Cast(::Udm::Object &&a);
		ComponentPackageReference& operator=(ComponentPackageReference &&a);

#endif
		static ComponentPackageReference Cast(const ::Udm::Object &a);
		static ComponentPackageReference Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentPackageReference CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentPackageReference> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentPackageReference, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentPackageReference, Pred>(impl); };
		ComponentPackageReference CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentPackageReference> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentPackageReference, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentPackageReference, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentPackageReference> Archetype() const;
		::Udm::StringAttr requiredUUID() const;
		::Udm::StringAttr requiredName() const;
		::Udm::StringAttr requiredType() const;
		::Udm::AClassAssocAttr< PackageConfReference, PackageConfiguration> srcPackageConfReference() const;
		template <class Pred> ::Udm::AClassAssocAttr< PackageConfReference, PackageConfiguration, Pred> srcPackageConfReference_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< PackageConfReference, PackageConfiguration, Pred>(impl, meta_srcPackageConfReference, meta_srcPackageConfReference_rev); };
		::Udm::PointerAttr< ComponentPackage> ref() const;
		::Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_requiredUUID;
		static ::Uml::Attribute meta_requiredName;
		static ::Uml::Attribute meta_requiredType;
		static ::Uml::AssociationRole meta_srcPackageConfReference;
		static ::Uml::AssociationRole meta_srcPackageConfReference_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

	};

	class PICML_Export ComponentPackage :  public MgaObject {
	public:
		ComponentPackage();
		ComponentPackage(::Udm::ObjectImpl *impl);
		ComponentPackage(const ComponentPackage &master);

#ifdef UDM_RVALUE
		ComponentPackage(ComponentPackage &&master);

		static ComponentPackage Cast(::Udm::Object &&a);
		ComponentPackage& operator=(ComponentPackage &&a);

#endif
		static ComponentPackage Cast(const ::Udm::Object &a);
		static ComponentPackage Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentPackage CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentPackage> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentPackage, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentPackage, Pred>(impl); };
		ComponentPackage CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentPackage> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentPackage, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentPackage, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentPackage> Archetype() const;
		::Udm::StringAttr label() const;
		::Udm::StringAttr UUID() const;
		::Udm::AClassAssocAttr< PackageConfBasePackage, PackageConfiguration> srcPackageConfBasePackage() const;
		template <class Pred> ::Udm::AClassAssocAttr< PackageConfBasePackage, PackageConfiguration, Pred> srcPackageConfBasePackage_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< PackageConfBasePackage, PackageConfiguration, Pred>(impl, meta_srcPackageConfBasePackage, meta_srcPackageConfBasePackage_rev); };
		::Udm::AssocAttr< ComponentPackageReference> referedbyComponentPackageReference() const;
		template <class Pred> ::Udm::AssocAttr< ComponentPackageReference, Pred> referedbyComponentPackageReference_sorted(const Pred &) const { return ::Udm::AssocAttr< ComponentPackageReference, Pred>(impl, meta_referedbyComponentPackageReference); };
		::Udm::AClassAssocAttr< PackageInfoProperty, Property> dstPackageInfoProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< PackageInfoProperty, Property, Pred> dstPackageInfoProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< PackageInfoProperty, Property, Pred>(impl, meta_dstPackageInfoProperty, meta_dstPackageInfoProperty_rev); };
		::Udm::AClassAssocAttr< PackageConfigProperty, Property> dstPackageConfigProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< PackageConfigProperty, Property, Pred> dstPackageConfigProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< PackageConfigProperty, Property, Pred>(impl, meta_dstPackageConfigProperty, meta_dstPackageConfigProperty_rev); };
		::Udm::AClassAssocAttr< Implementation, ComponentImplementationReference> dstImplementation() const;
		template <class Pred> ::Udm::AClassAssocAttr< Implementation, ComponentImplementationReference, Pred> dstImplementation_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< Implementation, ComponentImplementationReference, Pred>(impl, meta_dstImplementation, meta_dstImplementation_rev); };
		::Udm::AClassPointerAttr< PackageInterface, ComponentRef> dstPackageInterface() const;
		::Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::PackageContainer> PackageContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_label;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::AssociationRole meta_srcPackageConfBasePackage;
		static ::Uml::AssociationRole meta_srcPackageConfBasePackage_rev;
		static ::Uml::AssociationRole meta_referedbyComponentPackageReference;
		static ::Uml::AssociationRole meta_dstPackageInfoProperty;
		static ::Uml::AssociationRole meta_dstPackageInfoProperty_rev;
		static ::Uml::AssociationRole meta_dstPackageConfigProperty;
		static ::Uml::AssociationRole meta_dstPackageConfigProperty_rev;
		static ::Uml::AssociationRole meta_dstImplementation;
		static ::Uml::AssociationRole meta_dstImplementation_rev;
		static ::Uml::AssociationRole meta_dstPackageInterface;
		static ::Uml::AssociationRole meta_dstPackageInterface_rev;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::CompositionParentRole meta_PackageContainer_parent;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

	};

	class PICML_Export PackageConfigProperty :  public MgaObject {
	public:
		PackageConfigProperty();
		PackageConfigProperty(::Udm::ObjectImpl *impl);
		PackageConfigProperty(const PackageConfigProperty &master);

#ifdef UDM_RVALUE
		PackageConfigProperty(PackageConfigProperty &&master);

		static PackageConfigProperty Cast(::Udm::Object &&a);
		PackageConfigProperty& operator=(PackageConfigProperty &&a);

#endif
		static PackageConfigProperty Cast(const ::Udm::Object &a);
		static PackageConfigProperty Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PackageConfigProperty CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PackageConfigProperty> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PackageConfigProperty, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PackageConfigProperty, Pred>(impl); };
		PackageConfigProperty CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PackageConfigProperty> Derived();
		template <class Pred> ::Udm::DerivedAttr< PackageConfigProperty, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PackageConfigProperty, Pred>(impl); };
		::Udm::ArchetypeAttr< PackageConfigProperty> Archetype() const;
		::Udm::ParentAttr< ::PICML::PackageContainer> PackageContainer_parent() const;
		::Udm::ParentAttr< ::PICML::PackageContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ComponentPackage> srcPackageConfigProperty_end() const;
		::Udm::AssocEndAttr< ::PICML::Property> dstPackageConfigProperty_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageContainer_parent;
		static ::Uml::AssociationRole meta_srcPackageConfigProperty_end_;
		static ::Uml::AssociationRole meta_dstPackageConfigProperty_end_;

	};

	class PICML_Export PackageContainer :  public MgaObject {
	public:
		PackageContainer();
		PackageContainer(::Udm::ObjectImpl *impl);
		PackageContainer(const PackageContainer &master);

#ifdef UDM_RVALUE
		PackageContainer(PackageContainer &&master);

		static PackageContainer Cast(::Udm::Object &&a);
		PackageContainer& operator=(PackageContainer &&a);

#endif
		static PackageContainer Cast(const ::Udm::Object &a);
		static PackageContainer Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PackageContainer CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PackageContainer> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PackageContainer, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PackageContainer, Pred>(impl); };
		PackageContainer CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PackageContainer> Derived();
		template <class Pred> ::Udm::DerivedAttr< PackageContainer, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PackageContainer, Pred>(impl); };
		::Udm::ArchetypeAttr< PackageContainer> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::Property> Property_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); };
		::Udm::ChildAttr< ::PICML::ComponentPackage> ComponentPackage_child() const;
		::Udm::ChildrenAttr< ::PICML::PackageInfoProperty> PackageInfoProperty_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageInfoProperty, Pred> PackageInfoProperty_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageInfoProperty, Pred>(impl, meta_PackageInfoProperty_children); };
		::Udm::ChildrenAttr< ::PICML::PackageConfigProperty> PackageConfigProperty_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageConfigProperty, Pred> PackageConfigProperty_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageConfigProperty, Pred>(impl, meta_PackageConfigProperty_children); };
		::Udm::ChildAttr< ::PICML::ComponentRef> ComponentRef_child() const;
		::Udm::ChildrenAttr< ::PICML::ComponentImplementationReference> ComponentImplementationReference_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentImplementationReference, Pred> ComponentImplementationReference_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentImplementationReference, Pred>(impl, meta_ComponentImplementationReference_children); };
		::Udm::ChildrenAttr< ::PICML::Implementation> Implementation_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Implementation, Pred> Implementation_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Implementation, Pred>(impl, meta_Implementation_children); };
		::Udm::ChildAttr< ::PICML::PackageInterface> PackageInterface_child() const;
		::Udm::ChildrenAttr< ::PICML::ComponentPackage> ComponentPackage_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentPackage, Pred> ComponentPackage_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentPackage, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PackageConfigProperty> PackageConfigProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageConfigProperty, Pred> PackageConfigProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageConfigProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PackageInfoProperty> PackageInfoProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageInfoProperty, Pred> PackageInfoProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageInfoProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Implementation> Implementation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Implementation, Pred> Implementation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Implementation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PackageInterface> PackageInterface_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageInterface, Pred> PackageInterface_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageInterface, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComplexProperty> ComplexProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred> ComplexProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SimpleProperty> SimpleProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred> SimpleProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentImplementationReference> ComponentImplementationReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentImplementationReference, Pred> ComponentImplementationReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentImplementationReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Manageable> Manageable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Manageable, Pred> Manageable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Manageable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::ComponentPackages> ComponentPackages_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentPackages> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_ComponentPackage_child;
		static ::Uml::CompositionChildRole meta_PackageInfoProperty_children;
		static ::Uml::CompositionChildRole meta_PackageConfigProperty_children;
		static ::Uml::CompositionChildRole meta_ComponentRef_child;
		static ::Uml::CompositionChildRole meta_ComponentImplementationReference_children;
		static ::Uml::CompositionChildRole meta_Implementation_children;
		static ::Uml::CompositionChildRole meta_PackageInterface_child;
		static ::Uml::CompositionParentRole meta_ComponentPackages_parent;

	};

	class PICML_Export PackageInfoProperty :  public MgaObject {
	public:
		PackageInfoProperty();
		PackageInfoProperty(::Udm::ObjectImpl *impl);
		PackageInfoProperty(const PackageInfoProperty &master);

#ifdef UDM_RVALUE
		PackageInfoProperty(PackageInfoProperty &&master);

		static PackageInfoProperty Cast(::Udm::Object &&a);
		PackageInfoProperty& operator=(PackageInfoProperty &&a);

#endif
		static PackageInfoProperty Cast(const ::Udm::Object &a);
		static PackageInfoProperty Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PackageInfoProperty CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PackageInfoProperty> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PackageInfoProperty, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PackageInfoProperty, Pred>(impl); };
		PackageInfoProperty CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PackageInfoProperty> Derived();
		template <class Pred> ::Udm::DerivedAttr< PackageInfoProperty, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PackageInfoProperty, Pred>(impl); };
		::Udm::ArchetypeAttr< PackageInfoProperty> Archetype() const;
		::Udm::ParentAttr< ::PICML::PackageContainer> PackageContainer_parent() const;
		::Udm::ParentAttr< ::PICML::PackageContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ComponentPackage> srcPackageInfoProperty_end() const;
		::Udm::AssocEndAttr< ::PICML::Property> dstPackageInfoProperty_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageContainer_parent;
		static ::Uml::AssociationRole meta_srcPackageInfoProperty_end_;
		static ::Uml::AssociationRole meta_dstPackageInfoProperty_end_;

	};

	class PICML_Export Implementation :  public MgaObject {
	public:
		Implementation();
		Implementation(::Udm::ObjectImpl *impl);
		Implementation(const Implementation &master);

#ifdef UDM_RVALUE
		Implementation(Implementation &&master);

		static Implementation Cast(::Udm::Object &&a);
		Implementation& operator=(Implementation &&a);

#endif
		static Implementation Cast(const ::Udm::Object &a);
		static Implementation Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Implementation CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Implementation> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Implementation, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Implementation, Pred>(impl); };
		Implementation CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Implementation> Derived();
		template <class Pred> ::Udm::DerivedAttr< Implementation, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Implementation, Pred>(impl); };
		::Udm::ArchetypeAttr< Implementation> Archetype() const;
		::Udm::ParentAttr< ::PICML::PackageContainer> PackageContainer_parent() const;
		::Udm::ParentAttr< ::PICML::PackageContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ComponentPackage> srcImplementation_end() const;
		::Udm::AssocEndAttr< ::PICML::ComponentImplementationReference> dstImplementation_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageContainer_parent;
		static ::Uml::AssociationRole meta_srcImplementation_end_;
		static ::Uml::AssociationRole meta_dstImplementation_end_;

	};

	class PICML_Export PackageInterface :  public MgaObject {
	public:
		PackageInterface();
		PackageInterface(::Udm::ObjectImpl *impl);
		PackageInterface(const PackageInterface &master);

#ifdef UDM_RVALUE
		PackageInterface(PackageInterface &&master);

		static PackageInterface Cast(::Udm::Object &&a);
		PackageInterface& operator=(PackageInterface &&a);

#endif
		static PackageInterface Cast(const ::Udm::Object &a);
		static PackageInterface Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PackageInterface CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PackageInterface> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PackageInterface, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PackageInterface, Pred>(impl); };
		PackageInterface CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PackageInterface> Derived();
		template <class Pred> ::Udm::DerivedAttr< PackageInterface, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PackageInterface, Pred>(impl); };
		::Udm::ArchetypeAttr< PackageInterface> Archetype() const;
		::Udm::ParentAttr< ::PICML::PackageContainer> PackageContainer_parent() const;
		::Udm::ParentAttr< ::PICML::PackageContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ComponentPackage> srcPackageInterface_end() const;
		::Udm::AssocEndAttr< ::PICML::ComponentRef> dstPackageInterface_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PackageContainer_parent;
		static ::Uml::AssociationRole meta_srcPackageInterface_end_;
		static ::Uml::AssociationRole meta_dstPackageInterface_end_;

	};

	class PICML_Export Property :  public MgaObject {
	public:
		Property();
		Property(::Udm::ObjectImpl *impl);
		Property(const Property &master);

#ifdef UDM_RVALUE
		Property(Property &&master);

		static Property Cast(::Udm::Object &&a);
		Property& operator=(Property &&a);

#endif
		static Property Cast(const ::Udm::Object &a);
		static Property Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Property CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Property> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Property, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Property, Pred>(impl); };
		Property CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Property> Derived();
		template <class Pred> ::Udm::DerivedAttr< Property, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Property, Pred>(impl); };
		::Udm::ArchetypeAttr< Property> Archetype() const;
		::Udm::AClassAssocAttr< MonolithExecParameter, MonolithicImplementationBase> srcMonolithExecParameter() const;
		template <class Pred> ::Udm::AClassAssocAttr< MonolithExecParameter, MonolithicImplementationBase, Pred> srcMonolithExecParameter_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< MonolithExecParameter, MonolithicImplementationBase, Pred>(impl, meta_srcMonolithExecParameter, meta_srcMonolithExecParameter_rev); };
		::Udm::AClassAssocAttr< InfoProperty, Implemenation> srcInfoProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< InfoProperty, Implemenation, Pred> srcInfoProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< InfoProperty, Implemenation, Pred>(impl, meta_srcInfoProperty, meta_srcInfoProperty_rev); };
		::Udm::AClassAssocAttr< ConfigProperty, Implemenation> srcConfigProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< ConfigProperty, Implemenation, Pred> srcConfigProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ConfigProperty, Implemenation, Pred>(impl, meta_srcConfigProperty, meta_srcConfigProperty_rev); };
		::Udm::AClassAssocAttr< PathProperty, Path> srcPathProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< PathProperty, Path, Pred> srcPathProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< PathProperty, Path, Pred>(impl, meta_srcPathProperty, meta_srcPathProperty_rev); };
		::Udm::AClassAssocAttr< PropertyMapping, NodeReference> srcPropertyMapping() const;
		template <class Pred> ::Udm::AClassAssocAttr< PropertyMapping, NodeReference, Pred> srcPropertyMapping_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< PropertyMapping, NodeReference, Pred>(impl, meta_srcPropertyMapping, meta_srcPropertyMapping_rev); };
		::Udm::AClassAssocAttr< PackageConfConfigProperty, PackageConfiguration> srcPackageConfConfigProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< PackageConfConfigProperty, PackageConfiguration, Pred> srcPackageConfConfigProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< PackageConfConfigProperty, PackageConfiguration, Pred>(impl, meta_srcPackageConfConfigProperty, meta_srcPackageConfConfigProperty_rev); };
		::Udm::AClassAssocAttr< ArtifactInfoProperty, ImplementationArtifact> srcArtifactInfoProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< ArtifactInfoProperty, ImplementationArtifact, Pred> srcArtifactInfoProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ArtifactInfoProperty, ImplementationArtifact, Pred>(impl, meta_srcArtifactInfoProperty, meta_srcArtifactInfoProperty_rev); };
		::Udm::AClassAssocAttr< ArtifactExecParameter, ImplementationArtifact> srcArtifactExecParameter() const;
		template <class Pred> ::Udm::AClassAssocAttr< ArtifactExecParameter, ImplementationArtifact, Pred> srcArtifactExecParameter_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ArtifactExecParameter, ImplementationArtifact, Pred>(impl, meta_srcArtifactExecParameter, meta_srcArtifactExecParameter_rev); };
		::Udm::AClassAssocAttr< PackageInfoProperty, ComponentPackage> srcPackageInfoProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< PackageInfoProperty, ComponentPackage, Pred> srcPackageInfoProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< PackageInfoProperty, ComponentPackage, Pred>(impl, meta_srcPackageInfoProperty, meta_srcPackageInfoProperty_rev); };
		::Udm::AClassAssocAttr< PackageConfigProperty, ComponentPackage> srcPackageConfigProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< PackageConfigProperty, ComponentPackage, Pred> srcPackageConfigProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< PackageConfigProperty, ComponentPackage, Pred>(impl, meta_srcPackageConfigProperty, meta_srcPackageConfigProperty_rev); };
		::Udm::AClassAssocAttr< EdgeProperty, Edge> dstPropertyConnector() const;
		template <class Pred> ::Udm::AClassAssocAttr< EdgeProperty, Edge, Pred> dstPropertyConnector_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< EdgeProperty, Edge, Pred>(impl, meta_dstPropertyConnector, meta_dstPropertyConnector_rev); };
		::Udm::AClassAssocAttr< CollocationGroupProperty, CollocationGroup> dstCollocationGroupProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< CollocationGroupProperty, CollocationGroup, Pred> dstCollocationGroupProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< CollocationGroupProperty, CollocationGroup, Pred>(impl, meta_dstCollocationGroupProperty, meta_dstCollocationGroupProperty_rev); };
		::Udm::AClassAssocAttr< AssemblyConfigProperty, AssemblyConfigPropertyEnd> srcAssemblyConfigProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< AssemblyConfigProperty, AssemblyConfigPropertyEnd, Pred> srcAssemblyConfigProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< AssemblyConfigProperty, AssemblyConfigPropertyEnd, Pred>(impl, meta_srcAssemblyConfigProperty, meta_srcAssemblyConfigProperty_rev); };
		::Udm::AClassPointerAttr< AttributeMappingValue, AttributeMapping> srcAttributeMappingValue() const;
		::Udm::AClassAssocAttr< AttributeValue, AttributeInstance> srcAttributeValue() const;
		template <class Pred> ::Udm::AClassAssocAttr< AttributeValue, AttributeInstance, Pred> srcAttributeValue_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< AttributeValue, AttributeInstance, Pred>(impl, meta_srcAttributeValue, meta_srcAttributeValue_rev); };
		::Udm::AClassAssocAttr< ComponentInfoProperty, ComponentRef> srcComponentInfoProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< ComponentInfoProperty, ComponentRef, Pred> srcComponentInfoProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ComponentInfoProperty, ComponentRef, Pred>(impl, meta_srcComponentInfoProperty, meta_srcComponentInfoProperty_rev); };
		::Udm::AClassAssocAttr< ComponentConfigProperty, ComponentRef> srcComponentConfigProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< ComponentConfigProperty, ComponentRef, Pred> srcComponentConfigProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ComponentConfigProperty, ComponentRef, Pred>(impl, meta_srcComponentConfigProperty, meta_srcComponentConfigProperty_rev); };
		::Udm::ParentAttr< ::PICML::ImplementationContainer> ImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::Paths> Paths_parent() const;
		::Udm::ParentAttr< ::PICML::Path> Path_parent() const;
		::Udm::ParentAttr< ::PICML::DeploymentPlan> DeploymentPlan_parent() const;
		::Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const;
		::Udm::ParentAttr< ::PICML::PackageContainer> PackageContainer_parent() const;
		::Udm::ParentAttr< ::PICML::RequirementBase> RequirementBase_parent() const;
		::Udm::ParentAttr< ::PICML::Domain> Domain_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentContainer> ComponentContainer_parent() const;
		::Udm::ParentAttr< ::PICML::QueryInputAction> QueryInputAction_parent() const;
		::Udm::ParentAttr< ::PICML::ActionBase> ActionBase_parent() const;
		::Udm::ParentAttr< ::PICML::BehaviorInputAction> BehaviorInputAction_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcMonolithExecParameter;
		static ::Uml::AssociationRole meta_srcMonolithExecParameter_rev;
		static ::Uml::AssociationRole meta_srcInfoProperty;
		static ::Uml::AssociationRole meta_srcInfoProperty_rev;
		static ::Uml::AssociationRole meta_srcConfigProperty;
		static ::Uml::AssociationRole meta_srcConfigProperty_rev;
		static ::Uml::AssociationRole meta_srcPathProperty;
		static ::Uml::AssociationRole meta_srcPathProperty_rev;
		static ::Uml::AssociationRole meta_srcPropertyMapping;
		static ::Uml::AssociationRole meta_srcPropertyMapping_rev;
		static ::Uml::AssociationRole meta_srcPackageConfConfigProperty;
		static ::Uml::AssociationRole meta_srcPackageConfConfigProperty_rev;
		static ::Uml::AssociationRole meta_srcArtifactInfoProperty;
		static ::Uml::AssociationRole meta_srcArtifactInfoProperty_rev;
		static ::Uml::AssociationRole meta_srcArtifactExecParameter;
		static ::Uml::AssociationRole meta_srcArtifactExecParameter_rev;
		static ::Uml::AssociationRole meta_srcPackageInfoProperty;
		static ::Uml::AssociationRole meta_srcPackageInfoProperty_rev;
		static ::Uml::AssociationRole meta_srcPackageConfigProperty;
		static ::Uml::AssociationRole meta_srcPackageConfigProperty_rev;
		static ::Uml::AssociationRole meta_dstPropertyConnector;
		static ::Uml::AssociationRole meta_dstPropertyConnector_rev;
		static ::Uml::AssociationRole meta_dstCollocationGroupProperty;
		static ::Uml::AssociationRole meta_dstCollocationGroupProperty_rev;
		static ::Uml::AssociationRole meta_srcAssemblyConfigProperty;
		static ::Uml::AssociationRole meta_srcAssemblyConfigProperty_rev;
		static ::Uml::AssociationRole meta_srcAttributeMappingValue;
		static ::Uml::AssociationRole meta_srcAttributeMappingValue_rev;
		static ::Uml::AssociationRole meta_srcAttributeValue;
		static ::Uml::AssociationRole meta_srcAttributeValue_rev;
		static ::Uml::AssociationRole meta_srcComponentInfoProperty;
		static ::Uml::AssociationRole meta_srcComponentInfoProperty_rev;
		static ::Uml::AssociationRole meta_srcComponentConfigProperty;
		static ::Uml::AssociationRole meta_srcComponentConfigProperty_rev;
		static ::Uml::CompositionParentRole meta_ImplementationContainer_parent;
		static ::Uml::CompositionParentRole meta_Paths_parent;
		static ::Uml::CompositionParentRole meta_Path_parent;
		static ::Uml::CompositionParentRole meta_DeploymentPlan_parent;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::CompositionParentRole meta_PackageContainer_parent;
		static ::Uml::CompositionParentRole meta_RequirementBase_parent;
		static ::Uml::CompositionParentRole meta_Domain_parent;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::CompositionParentRole meta_ComponentContainer_parent;
		static ::Uml::CompositionParentRole meta_QueryInputAction_parent;
		static ::Uml::CompositionParentRole meta_ActionBase_parent;
		static ::Uml::CompositionParentRole meta_BehaviorInputAction_parent;

	};

	class PICML_Export ComplexProperty :  public Property {
	public:
		ComplexProperty();
		ComplexProperty(::Udm::ObjectImpl *impl);
		ComplexProperty(const ComplexProperty &master);

#ifdef UDM_RVALUE
		ComplexProperty(ComplexProperty &&master);

		static ComplexProperty Cast(::Udm::Object &&a);
		ComplexProperty& operator=(ComplexProperty &&a);

#endif
		static ComplexProperty Cast(const ::Udm::Object &a);
		static ComplexProperty Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComplexProperty CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComplexProperty> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComplexProperty, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComplexProperty, Pred>(impl); };
		ComplexProperty CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComplexProperty> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComplexProperty, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComplexProperty, Pred>(impl); };
		::Udm::ArchetypeAttr< ComplexProperty> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::DataValueBase> DataValueBase_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DataValueBase, Pred> DataValueBase_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DataValueBase, Pred>(impl, meta_DataValueBase_children); };
		::Udm::ChildAttr< ::PICML::ComplexTypeReference> ComplexTypeReference_child() const;
		::Udm::ChildrenAttr< ::PICML::DataValueBase> DataValueBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DataValueBase, Pred> DataValueBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DataValueBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::DataValue> DataValue_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DataValue, Pred> DataValue_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DataValue, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComplexTypeReference> ComplexTypeReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexTypeReference, Pred> ComplexTypeReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexTypeReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::DataValueContainer> DataValueContainer_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DataValueContainer, Pred> DataValueContainer_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DataValueContainer, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_DataValueBase_children;
		static ::Uml::CompositionChildRole meta_ComplexTypeReference_child;

	};

	class PICML_Export SimpleProperty :  public Property {
	public:
		SimpleProperty();
		SimpleProperty(::Udm::ObjectImpl *impl);
		SimpleProperty(const SimpleProperty &master);

#ifdef UDM_RVALUE
		SimpleProperty(SimpleProperty &&master);

		static SimpleProperty Cast(::Udm::Object &&a);
		SimpleProperty& operator=(SimpleProperty &&a);

#endif
		static SimpleProperty Cast(const ::Udm::Object &a);
		static SimpleProperty Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		SimpleProperty CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< SimpleProperty> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< SimpleProperty, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< SimpleProperty, Pred>(impl); };
		SimpleProperty CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< SimpleProperty> Derived();
		template <class Pred> ::Udm::DerivedAttr< SimpleProperty, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< SimpleProperty, Pred>(impl); };
		::Udm::ArchetypeAttr< SimpleProperty> Archetype() const;
		::Udm::StringAttr Value() const;
		::Udm::PointerAttr< MemberType> ref() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Value;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export DataValueBase :  public MgaObject {
	public:
		DataValueBase();
		DataValueBase(::Udm::ObjectImpl *impl);
		DataValueBase(const DataValueBase &master);

#ifdef UDM_RVALUE
		DataValueBase(DataValueBase &&master);

		static DataValueBase Cast(::Udm::Object &&a);
		DataValueBase& operator=(DataValueBase &&a);

#endif
		static DataValueBase Cast(const ::Udm::Object &a);
		static DataValueBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		DataValueBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< DataValueBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< DataValueBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< DataValueBase, Pred>(impl); };
		DataValueBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< DataValueBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< DataValueBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< DataValueBase, Pred>(impl); };
		::Udm::ArchetypeAttr< DataValueBase> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComplexProperty> ComplexProperty_parent() const;
		::Udm::ParentAttr< ::PICML::DataValueContainer> DataValueContainer_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComplexProperty_parent;
		static ::Uml::CompositionParentRole meta_DataValueContainer_parent;

	};

	class PICML_Export SimpleType :  virtual  public MgaObject {
	public:
		SimpleType();
		SimpleType(::Udm::ObjectImpl *impl);
		SimpleType(const SimpleType &master);

#ifdef UDM_RVALUE
		SimpleType(SimpleType &&master);

		static SimpleType Cast(::Udm::Object &&a);
		SimpleType& operator=(SimpleType &&a);

#endif
		static SimpleType Cast(const ::Udm::Object &a);
		static SimpleType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		SimpleType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< SimpleType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< SimpleType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< SimpleType, Pred>(impl); };
		SimpleType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< SimpleType> Derived();
		template <class Pred> ::Udm::DerivedAttr< SimpleType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< SimpleType, Pred>(impl); };
		::Udm::ArchetypeAttr< SimpleType> Archetype() const;
		::Udm::AssocAttr< DataValue> referedbyDataValue() const;
		template <class Pred> ::Udm::AssocAttr< DataValue, Pred> referedbyDataValue_sorted(const Pred &) const { return ::Udm::AssocAttr< DataValue, Pred>(impl, meta_referedbyDataValue); };
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyDataValue;

	};

	class PICML_Export ComplexType :  virtual  public MgaObject {
	public:
		ComplexType();
		ComplexType(::Udm::ObjectImpl *impl);
		ComplexType(const ComplexType &master);

#ifdef UDM_RVALUE
		ComplexType(ComplexType &&master);

		static ComplexType Cast(::Udm::Object &&a);
		ComplexType& operator=(ComplexType &&a);

#endif
		static ComplexType Cast(const ::Udm::Object &a);
		static ComplexType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComplexType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComplexType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComplexType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComplexType, Pred>(impl); };
		ComplexType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComplexType> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComplexType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComplexType, Pred>(impl); };
		::Udm::ArchetypeAttr< ComplexType> Archetype() const;
		::Udm::AssocAttr< ComplexTypeReference> referedbyComplexTypeReference() const;
		template <class Pred> ::Udm::AssocAttr< ComplexTypeReference, Pred> referedbyComplexTypeReference_sorted(const Pred &) const { return ::Udm::AssocAttr< ComplexTypeReference, Pred>(impl, meta_referedbyComplexTypeReference); };
		::Udm::ParentAttr< ::PICML::ConnectorObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyComplexTypeReference;

	};

	class PICML_Export DataValue :  public DataValueBase {
	public:
		DataValue();
		DataValue(::Udm::ObjectImpl *impl);
		DataValue(const DataValue &master);

#ifdef UDM_RVALUE
		DataValue(DataValue &&master);

		static DataValue Cast(::Udm::Object &&a);
		DataValue& operator=(DataValue &&a);

#endif
		static DataValue Cast(const ::Udm::Object &a);
		static DataValue Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		DataValue CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< DataValue> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< DataValue, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< DataValue, Pred>(impl); };
		DataValue CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< DataValue> Derived();
		template <class Pred> ::Udm::DerivedAttr< DataValue, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< DataValue, Pred>(impl); };
		::Udm::ArchetypeAttr< DataValue> Archetype() const;
		::Udm::StringAttr Value() const;
		::Udm::PointerAttr< SimpleType> ref() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Value;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export ComplexTypeReference :  public MgaObject {
	public:
		ComplexTypeReference();
		ComplexTypeReference(::Udm::ObjectImpl *impl);
		ComplexTypeReference(const ComplexTypeReference &master);

#ifdef UDM_RVALUE
		ComplexTypeReference(ComplexTypeReference &&master);

		static ComplexTypeReference Cast(::Udm::Object &&a);
		ComplexTypeReference& operator=(ComplexTypeReference &&a);

#endif
		static ComplexTypeReference Cast(const ::Udm::Object &a);
		static ComplexTypeReference Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComplexTypeReference CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComplexTypeReference> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComplexTypeReference, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComplexTypeReference, Pred>(impl); };
		ComplexTypeReference CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComplexTypeReference> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComplexTypeReference, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComplexTypeReference, Pred>(impl); };
		::Udm::ArchetypeAttr< ComplexTypeReference> Archetype() const;
		::Udm::PointerAttr< ComplexType> ref() const;
		::Udm::ParentAttr< ::PICML::ComplexProperty> ComplexProperty_parent() const;
		::Udm::ParentAttr< ::PICML::DataValueContainer> DataValueContainer_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ComplexProperty_parent;
		static ::Uml::CompositionParentRole meta_DataValueContainer_parent;

	};

	class PICML_Export DataValueContainer :  public DataValueBase {
	public:
		DataValueContainer();
		DataValueContainer(::Udm::ObjectImpl *impl);
		DataValueContainer(const DataValueContainer &master);

#ifdef UDM_RVALUE
		DataValueContainer(DataValueContainer &&master);

		static DataValueContainer Cast(::Udm::Object &&a);
		DataValueContainer& operator=(DataValueContainer &&a);

#endif
		static DataValueContainer Cast(const ::Udm::Object &a);
		static DataValueContainer Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		DataValueContainer CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< DataValueContainer> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< DataValueContainer, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< DataValueContainer, Pred>(impl); };
		DataValueContainer CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< DataValueContainer> Derived();
		template <class Pred> ::Udm::DerivedAttr< DataValueContainer, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< DataValueContainer, Pred>(impl); };
		::Udm::ArchetypeAttr< DataValueContainer> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::DataValueBase> DataValueBase_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DataValueBase, Pred> DataValueBase_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DataValueBase, Pred>(impl, meta_DataValueBase_children); };
		::Udm::ChildAttr< ::PICML::ComplexTypeReference> ComplexTypeReference_child() const;
		::Udm::ChildrenAttr< ::PICML::DataValueBase> DataValueBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DataValueBase, Pred> DataValueBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DataValueBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::DataValue> DataValue_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DataValue, Pred> DataValue_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DataValue, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComplexTypeReference> ComplexTypeReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexTypeReference, Pred> ComplexTypeReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexTypeReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::DataValueContainer> DataValueContainer_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DataValueContainer, Pred> DataValueContainer_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DataValueContainer, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_DataValueBase_children;
		static ::Uml::CompositionChildRole meta_ComplexTypeReference_child;

	};

	class PICML_Export DataType :  public MgaObject {
	public:
		DataType();
		DataType(::Udm::ObjectImpl *impl);
		DataType(const DataType &master);

#ifdef UDM_RVALUE
		DataType(DataType &&master);

		static DataType Cast(::Udm::Object &&a);
		DataType& operator=(DataType &&a);

#endif
		static DataType Cast(const ::Udm::Object &a);
		static DataType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		DataType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< DataType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< DataType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< DataType, Pred>(impl); };
		DataType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< DataType> Derived();
		template <class Pred> ::Udm::DerivedAttr< DataType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< DataType, Pred>(impl); };
		::Udm::ArchetypeAttr< DataType> Archetype() const;
		::Udm::PointerAttr< MemberType> ref() const;
		::Udm::ParentAttr< ::PICML::SatisfierProperty> SatisfierProperty_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentPropertyDescription> ComponentPropertyDescription_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_SatisfierProperty_parent;
		static ::Uml::CompositionParentRole meta_ComponentPropertyDescription_parent;

	};

	class PICML_Export RequirementBase :  public MgaObject {
	public:
		RequirementBase();
		RequirementBase(::Udm::ObjectImpl *impl);
		RequirementBase(const RequirementBase &master);

#ifdef UDM_RVALUE
		RequirementBase(RequirementBase &&master);

		static RequirementBase Cast(::Udm::Object &&a);
		RequirementBase& operator=(RequirementBase &&a);

#endif
		static RequirementBase Cast(const ::Udm::Object &a);
		static RequirementBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		RequirementBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< RequirementBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< RequirementBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< RequirementBase, Pred>(impl); };
		RequirementBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< RequirementBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< RequirementBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< RequirementBase, Pred>(impl); };
		::Udm::ArchetypeAttr< RequirementBase> Archetype() const;
		::Udm::StringAttr resourceType() const;
		::Udm::ChildrenAttr< ::PICML::Property> Property_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); };
		::Udm::ChildrenAttr< ::PICML::ComplexProperty> ComplexProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred> ComplexProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SimpleProperty> SimpleProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred> SimpleProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_resourceType;
		static ::Uml::CompositionChildRole meta_Property_children;

	};

	class PICML_Export ImplementationRequirement :  public RequirementBase {
	public:
		ImplementationRequirement();
		ImplementationRequirement(::Udm::ObjectImpl *impl);
		ImplementationRequirement(const ImplementationRequirement &master);

#ifdef UDM_RVALUE
		ImplementationRequirement(ImplementationRequirement &&master);

		static ImplementationRequirement Cast(::Udm::Object &&a);
		ImplementationRequirement& operator=(ImplementationRequirement &&a);

#endif
		static ImplementationRequirement Cast(const ::Udm::Object &a);
		static ImplementationRequirement Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ImplementationRequirement CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ImplementationRequirement> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ImplementationRequirement, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ImplementationRequirement, Pred>(impl); };
		ImplementationRequirement CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ImplementationRequirement> Derived();
		template <class Pred> ::Udm::DerivedAttr< ImplementationRequirement, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ImplementationRequirement, Pred>(impl); };
		::Udm::ArchetypeAttr< ImplementationRequirement> Archetype() const;
		::Udm::StringAttr componentPort() const;
		::Udm::StringAttr ResourceUsageKind() const;
		::Udm::StringAttr resourcePort() const;
		::Udm::AClassAssocAttr< MonolithDeployRequirement, MonolithicImplementationBase> srcMonolithDeployRequirement() const;
		template <class Pred> ::Udm::AClassAssocAttr< MonolithDeployRequirement, MonolithicImplementationBase, Pred> srcMonolithDeployRequirement_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< MonolithDeployRequirement, MonolithicImplementationBase, Pred>(impl, meta_srcMonolithDeployRequirement, meta_srcMonolithDeployRequirement_rev); };
		::Udm::ParentAttr< ::PICML::ImplementationContainer> ImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ImplementationContainer> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_componentPort;
		static ::Uml::Attribute meta_ResourceUsageKind;
		static ::Uml::Attribute meta_resourcePort;
		static ::Uml::AssociationRole meta_srcMonolithDeployRequirement;
		static ::Uml::AssociationRole meta_srcMonolithDeployRequirement_rev;
		static ::Uml::CompositionParentRole meta_ImplementationContainer_parent;

	};

	class PICML_Export RequirementSatisfier :  public MgaObject {
	public:
		RequirementSatisfier();
		RequirementSatisfier(::Udm::ObjectImpl *impl);
		RequirementSatisfier(const RequirementSatisfier &master);

#ifdef UDM_RVALUE
		RequirementSatisfier(RequirementSatisfier &&master);

		static RequirementSatisfier Cast(::Udm::Object &&a);
		RequirementSatisfier& operator=(RequirementSatisfier &&a);

#endif
		static RequirementSatisfier Cast(const ::Udm::Object &a);
		static RequirementSatisfier Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		RequirementSatisfier CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< RequirementSatisfier> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< RequirementSatisfier, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< RequirementSatisfier, Pred>(impl); };
		RequirementSatisfier CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< RequirementSatisfier> Derived();
		template <class Pred> ::Udm::DerivedAttr< RequirementSatisfier, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< RequirementSatisfier, Pred>(impl); };
		::Udm::ArchetypeAttr< RequirementSatisfier> Archetype() const;
		::Udm::StringAttr resourceType() const;
		::Udm::ChildrenAttr< ::PICML::SatisfierProperty> SatisfierProperty_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SatisfierProperty, Pred> SatisfierProperty_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SatisfierProperty, Pred>(impl, meta_SatisfierProperty_children); };
		::Udm::ChildrenAttr< ::PICML::SatisfierProperty> SatisfierProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SatisfierProperty, Pred> SatisfierProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SatisfierProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_resourceType;
		static ::Uml::CompositionChildRole meta_SatisfierProperty_children;

	};

	class PICML_Export Resource :  public RequirementSatisfier {
	public:
		Resource();
		Resource(::Udm::ObjectImpl *impl);
		Resource(const Resource &master);

#ifdef UDM_RVALUE
		Resource(Resource &&master);

		static Resource Cast(::Udm::Object &&a);
		Resource& operator=(Resource &&a);

#endif
		static Resource Cast(const ::Udm::Object &a);
		static Resource Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Resource CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Resource> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Resource, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Resource, Pred>(impl); };
		Resource CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Resource> Derived();
		template <class Pred> ::Udm::DerivedAttr< Resource, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Resource, Pred>(impl); };
		::Udm::ArchetypeAttr< Resource> Archetype() const;
		::Udm::ParentAttr< ::PICML::Node> Node_parent() const;
		::Udm::ParentAttr< ::PICML::Interconnect> Interconnect_parent() const;
		::Udm::ParentAttr< ::PICML::Bridge> Bridge_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Node_parent;
		static ::Uml::CompositionParentRole meta_Interconnect_parent;
		static ::Uml::CompositionParentRole meta_Bridge_parent;

	};

	class PICML_Export SharedResource :  public RequirementSatisfier {
	public:
		SharedResource();
		SharedResource(::Udm::ObjectImpl *impl);
		SharedResource(const SharedResource &master);

#ifdef UDM_RVALUE
		SharedResource(SharedResource &&master);

		static SharedResource Cast(::Udm::Object &&a);
		SharedResource& operator=(SharedResource &&a);

#endif
		static SharedResource Cast(const ::Udm::Object &a);
		static SharedResource Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		SharedResource CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< SharedResource> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< SharedResource, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< SharedResource, Pred>(impl); };
		SharedResource CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< SharedResource> Derived();
		template <class Pred> ::Udm::DerivedAttr< SharedResource, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< SharedResource, Pred>(impl); };
		::Udm::ArchetypeAttr< SharedResource> Archetype() const;
		::Udm::AClassAssocAttr< Shares, Node> srcShares() const;
		template <class Pred> ::Udm::AClassAssocAttr< Shares, Node, Pred> srcShares_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< Shares, Node, Pred>(impl, meta_srcShares, meta_srcShares_rev); };
		::Udm::ParentAttr< ::PICML::Domain> Domain_parent() const;
		::Udm::ParentAttr< ::PICML::Domain> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcShares;
		static ::Uml::AssociationRole meta_srcShares_rev;
		static ::Uml::CompositionParentRole meta_Domain_parent;

	};

	class PICML_Export Capability :  public RequirementSatisfier {
	public:
		Capability();
		Capability(::Udm::ObjectImpl *impl);
		Capability(const Capability &master);

#ifdef UDM_RVALUE
		Capability(Capability &&master);

		static Capability Cast(::Udm::Object &&a);
		Capability& operator=(Capability &&a);

#endif
		static Capability Cast(const ::Udm::Object &a);
		static Capability Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Capability CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Capability> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Capability, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Capability, Pred>(impl); };
		Capability CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Capability> Derived();
		template <class Pred> ::Udm::DerivedAttr< Capability, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Capability, Pred>(impl); };
		::Udm::ArchetypeAttr< Capability> Archetype() const;
		::Udm::AClassAssocAttr< ImplementationCapability, ComponentImplementation> srcImplementationCapability() const;
		template <class Pred> ::Udm::AClassAssocAttr< ImplementationCapability, ComponentImplementation, Pred> srcImplementationCapability_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ImplementationCapability, ComponentImplementation, Pred>(impl, meta_srcImplementationCapability, meta_srcImplementationCapability_rev); };
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcImplementationCapability;
		static ::Uml::AssociationRole meta_srcImplementationCapability_rev;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;

	};

	class PICML_Export SatisfierProperty :  public MgaObject {
	public:
		SatisfierProperty();
		SatisfierProperty(::Udm::ObjectImpl *impl);
		SatisfierProperty(const SatisfierProperty &master);

#ifdef UDM_RVALUE
		SatisfierProperty(SatisfierProperty &&master);

		static SatisfierProperty Cast(::Udm::Object &&a);
		SatisfierProperty& operator=(SatisfierProperty &&a);

#endif
		static SatisfierProperty Cast(const ::Udm::Object &a);
		static SatisfierProperty Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		SatisfierProperty CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< SatisfierProperty> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< SatisfierProperty, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< SatisfierProperty, Pred>(impl); };
		SatisfierProperty CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< SatisfierProperty> Derived();
		template <class Pred> ::Udm::DerivedAttr< SatisfierProperty, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< SatisfierProperty, Pred>(impl); };
		::Udm::ArchetypeAttr< SatisfierProperty> Archetype() const;
		::Udm::StringAttr SatisfierPropertyKind() const;
		::Udm::StringAttr DataValue() const;
		::Udm::BooleanAttr dynamic() const;
		::Udm::ChildAttr< ::PICML::DataType> DataType_child() const;
		::Udm::ChildrenAttr< ::PICML::DataType> DataType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DataType, Pred> DataType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DataType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::RequirementSatisfier> RequirementSatisfier_parent() const;
		::Udm::ParentAttr< ::PICML::RequirementSatisfier> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_SatisfierPropertyKind;
		static ::Uml::Attribute meta_DataValue;
		static ::Uml::Attribute meta_dynamic;
		static ::Uml::CompositionChildRole meta_DataType_child;
		static ::Uml::CompositionParentRole meta_RequirementSatisfier_parent;

	};

	class PICML_Export ImplementationDependency :  public MgaObject {
	public:
		ImplementationDependency();
		ImplementationDependency(::Udm::ObjectImpl *impl);
		ImplementationDependency(const ImplementationDependency &master);

#ifdef UDM_RVALUE
		ImplementationDependency(ImplementationDependency &&master);

		static ImplementationDependency Cast(::Udm::Object &&a);
		ImplementationDependency& operator=(ImplementationDependency &&a);

#endif
		static ImplementationDependency Cast(const ::Udm::Object &a);
		static ImplementationDependency Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ImplementationDependency CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ImplementationDependency> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ImplementationDependency, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ImplementationDependency, Pred>(impl); };
		ImplementationDependency CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ImplementationDependency> Derived();
		template <class Pred> ::Udm::DerivedAttr< ImplementationDependency, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ImplementationDependency, Pred>(impl); };
		::Udm::ArchetypeAttr< ImplementationDependency> Archetype() const;
		::Udm::StringAttr requiredType() const;
		::Udm::AClassAssocAttr< ImplementationDependsOn, ComponentImplementation> srcImplementationDependsOn() const;
		template <class Pred> ::Udm::AClassAssocAttr< ImplementationDependsOn, ComponentImplementation, Pred> srcImplementationDependsOn_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ImplementationDependsOn, ComponentImplementation, Pred>(impl, meta_srcImplementationDependsOn, meta_srcImplementationDependsOn_rev); };
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_requiredType;
		static ::Uml::AssociationRole meta_srcImplementationDependsOn;
		static ::Uml::AssociationRole meta_srcImplementationDependsOn_rev;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;

	};

	class PICML_Export Requirement :  public RequirementBase {
	public:
		Requirement();
		Requirement(::Udm::ObjectImpl *impl);
		Requirement(const Requirement &master);

#ifdef UDM_RVALUE
		Requirement(Requirement &&master);

		static Requirement Cast(::Udm::Object &&a);
		Requirement& operator=(Requirement &&a);

#endif
		static Requirement Cast(const ::Udm::Object &a);
		static Requirement Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Requirement CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Requirement> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Requirement, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Requirement, Pred>(impl); };
		Requirement CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Requirement> Derived();
		template <class Pred> ::Udm::DerivedAttr< Requirement, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Requirement, Pred>(impl); };
		::Udm::ArchetypeAttr< Requirement> Archetype() const;
		::Udm::AClassAssocAttr< PackageConfSelectRequirement, PackageConfiguration> srcPackageConfSelectRequirement() const;
		template <class Pred> ::Udm::AClassAssocAttr< PackageConfSelectRequirement, PackageConfiguration, Pred> srcPackageConfSelectRequirement_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< PackageConfSelectRequirement, PackageConfiguration, Pred>(impl, meta_srcPackageConfSelectRequirement, meta_srcPackageConfSelectRequirement_rev); };
		::Udm::AClassAssocAttr< ArtifactDeployRequirement, ImplementationArtifact> srcArtifactDeployRequirement() const;
		template <class Pred> ::Udm::AClassAssocAttr< ArtifactDeployRequirement, ImplementationArtifact, Pred> srcArtifactDeployRequirement_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ArtifactDeployRequirement, ImplementationArtifact, Pred>(impl, meta_srcArtifactDeployRequirement, meta_srcArtifactDeployRequirement_rev); };
		::Udm::AClassAssocAttr< AssemblyselectRequirement, AssemblyConfigPropertyEnd> srcAssemblyselectRequirement() const;
		template <class Pred> ::Udm::AClassAssocAttr< AssemblyselectRequirement, AssemblyConfigPropertyEnd, Pred> srcAssemblyselectRequirement_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< AssemblyselectRequirement, AssemblyConfigPropertyEnd, Pred>(impl, meta_srcAssemblyselectRequirement, meta_srcAssemblyselectRequirement_rev); };
		::Udm::ParentAttr< ::PICML::PackageConfigurationContainer> PackageConfigurationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ArtifactContainer> ArtifactContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcPackageConfSelectRequirement;
		static ::Uml::AssociationRole meta_srcPackageConfSelectRequirement_rev;
		static ::Uml::AssociationRole meta_srcArtifactDeployRequirement;
		static ::Uml::AssociationRole meta_srcArtifactDeployRequirement_rev;
		static ::Uml::AssociationRole meta_srcAssemblyselectRequirement;
		static ::Uml::AssociationRole meta_srcAssemblyselectRequirement_rev;
		static ::Uml::CompositionParentRole meta_PackageConfigurationContainer_parent;
		static ::Uml::CompositionParentRole meta_ArtifactContainer_parent;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

	};

	class PICML_Export RTRequirements :  public Requirement {
	public:
		RTRequirements();
		RTRequirements(::Udm::ObjectImpl *impl);
		RTRequirements(const RTRequirements &master);

#ifdef UDM_RVALUE
		RTRequirements(RTRequirements &&master);

		static RTRequirements Cast(::Udm::Object &&a);
		RTRequirements& operator=(RTRequirements &&a);

#endif
		static RTRequirements Cast(const ::Udm::Object &a);
		static RTRequirements Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		RTRequirements CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< RTRequirements> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< RTRequirements, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< RTRequirements, Pred>(impl); };
		RTRequirements CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< RTRequirements> Derived();
		template <class Pred> ::Udm::DerivedAttr< RTRequirements, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< RTRequirements, Pred>(impl); };
		::Udm::ArchetypeAttr< RTRequirements> Archetype() const;
		::Udm::ChildAttr< ::PICML::ServiceConsumer> ServiceConsumer_child() const;
		::Udm::ChildAttr< ::PICML::ServiceProvider> ServiceProvider_child() const;
		::Udm::ChildrenAttr< ::PICML::ServiceConsumer> ServiceConsumer_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ServiceConsumer, Pred> ServiceConsumer_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ServiceConsumer, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ServiceProvider> ServiceProvider_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ServiceProvider, Pred> ServiceProvider_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ServiceProvider, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_ServiceConsumer_child;
		static ::Uml::CompositionChildRole meta_ServiceProvider_child;

	};

	class PICML_Export ECRequirements :  public Requirement {
	public:
		ECRequirements();
		ECRequirements(::Udm::ObjectImpl *impl);
		ECRequirements(const ECRequirements &master);

#ifdef UDM_RVALUE
		ECRequirements(ECRequirements &&master);

		static ECRequirements Cast(::Udm::Object &&a);
		ECRequirements& operator=(ECRequirements &&a);

#endif
		static ECRequirements Cast(const ::Udm::Object &a);
		static ECRequirements Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ECRequirements CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ECRequirements> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ECRequirements, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ECRequirements, Pred>(impl); };
		ECRequirements CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ECRequirements> Derived();
		template <class Pred> ::Udm::DerivedAttr< ECRequirements, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ECRequirements, Pred>(impl); };
		::Udm::ArchetypeAttr< ECRequirements> Archetype() const;
		::Udm::BooleanAttr ConfigureRTQoS() const;
		::Udm::ChildrenAttr< ::PICML::ECRole> ECRole_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ECRole, Pred> ECRole_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ECRole, Pred>(impl, meta_ECRole_children); };
		::Udm::ChildAttr< ::PICML::ECBehavior> ECBehavior_child() const;
		::Udm::ChildrenAttr< ::PICML::ECRole> ECRole_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ECRole, Pred> ECRole_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ECRole, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ECBehavior> ECBehavior_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ECBehavior, Pred> ECBehavior_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ECBehavior, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_ConfigureRTQoS;
		static ::Uml::CompositionChildRole meta_ECRole_children;
		static ::Uml::CompositionChildRole meta_ECBehavior_child;

	};

	class PICML_Export InterconnectConnection :  public MgaObject {
	public:
		InterconnectConnection();
		InterconnectConnection(::Udm::ObjectImpl *impl);
		InterconnectConnection(const InterconnectConnection &master);

#ifdef UDM_RVALUE
		InterconnectConnection(InterconnectConnection &&master);

		static InterconnectConnection Cast(::Udm::Object &&a);
		InterconnectConnection& operator=(InterconnectConnection &&a);

#endif
		static InterconnectConnection Cast(const ::Udm::Object &a);
		static InterconnectConnection Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		InterconnectConnection CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< InterconnectConnection> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< InterconnectConnection, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< InterconnectConnection, Pred>(impl); };
		InterconnectConnection CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< InterconnectConnection> Derived();
		template <class Pred> ::Udm::DerivedAttr< InterconnectConnection, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< InterconnectConnection, Pred>(impl); };
		::Udm::ArchetypeAttr< InterconnectConnection> Archetype() const;
		::Udm::ParentAttr< ::PICML::Domain> Domain_parent() const;
		::Udm::ParentAttr< ::PICML::Domain> parent() const;
		::Udm::AssocEndAttr< ::PICML::Node> srcInterconnectConnection_end() const;
		::Udm::AssocEndAttr< ::PICML::Interconnect> dstInterconnectConnection_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Domain_parent;
		static ::Uml::AssociationRole meta_srcInterconnectConnection_end_;
		static ::Uml::AssociationRole meta_dstInterconnectConnection_end_;

	};

	class PICML_Export Domain :  public MgaObject {
	public:
		Domain();
		Domain(::Udm::ObjectImpl *impl);
		Domain(const Domain &master);

#ifdef UDM_RVALUE
		Domain(Domain &&master);

		static Domain Cast(::Udm::Object &&a);
		Domain& operator=(Domain &&a);

#endif
		static Domain Cast(const ::Udm::Object &a);
		static Domain Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Domain CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Domain> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Domain, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Domain, Pred>(impl); };
		Domain CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Domain> Derived();
		template <class Pred> ::Udm::DerivedAttr< Domain, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Domain, Pred>(impl); };
		::Udm::ArchetypeAttr< Domain> Archetype() const;
		::Udm::StringAttr UUID() const;
		::Udm::StringAttr label() const;
		::Udm::ChildrenAttr< ::PICML::Property> Property_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); };
		::Udm::ChildrenAttr< ::PICML::Shares> Shares_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Shares, Pred> Shares_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Shares, Pred>(impl, meta_Shares_children); };
		::Udm::ChildrenAttr< ::PICML::SharedResource> SharedResource_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SharedResource, Pred> SharedResource_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SharedResource, Pred>(impl, meta_SharedResource_children); };
		::Udm::ChildrenAttr< ::PICML::Bridge> Bridge_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Bridge, Pred> Bridge_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Bridge, Pred>(impl, meta_Bridge_children); };
		::Udm::ChildrenAttr< ::PICML::BridgeConnection> BridgeConnection_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::BridgeConnection, Pred> BridgeConnection_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::BridgeConnection, Pred>(impl, meta_BridgeConnection_children); };
		::Udm::ChildrenAttr< ::PICML::Node> Node_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Node, Pred> Node_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Node, Pred>(impl, meta_Node_children); };
		::Udm::ChildrenAttr< ::PICML::Interconnect> Interconnect_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Interconnect, Pred> Interconnect_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Interconnect, Pred>(impl, meta_Interconnect_children); };
		::Udm::ChildrenAttr< ::PICML::InterconnectConnection> InterconnectConnection_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InterconnectConnection, Pred> InterconnectConnection_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InterconnectConnection, Pred>(impl, meta_InterconnectConnection_children); };
		::Udm::ChildrenAttr< ::PICML::SharedResource> SharedResource_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SharedResource, Pred> SharedResource_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SharedResource, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Node> Node_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Node, Pred> Node_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Node, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Interconnect> Interconnect_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Interconnect, Pred> Interconnect_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Interconnect, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Bridge> Bridge_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Bridge, Pred> Bridge_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Bridge, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComplexProperty> ComplexProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred> ComplexProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SimpleProperty> SimpleProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred> SimpleProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequirementSatisfier> RequirementSatisfier_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred> RequirementSatisfier_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::InterconnectConnection> InterconnectConnection_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InterconnectConnection, Pred> InterconnectConnection_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InterconnectConnection, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::BridgeConnection> BridgeConnection_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::BridgeConnection, Pred> BridgeConnection_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::BridgeConnection, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Shares> Shares_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Shares, Pred> Shares_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Shares, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::Targets> Targets_parent() const;
		::Udm::ParentAttr< ::PICML::Targets> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::Attribute meta_label;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_Shares_children;
		static ::Uml::CompositionChildRole meta_SharedResource_children;
		static ::Uml::CompositionChildRole meta_Bridge_children;
		static ::Uml::CompositionChildRole meta_BridgeConnection_children;
		static ::Uml::CompositionChildRole meta_Node_children;
		static ::Uml::CompositionChildRole meta_Interconnect_children;
		static ::Uml::CompositionChildRole meta_InterconnectConnection_children;
		static ::Uml::CompositionParentRole meta_Targets_parent;

	};

	class PICML_Export BridgeConnection :  public MgaObject {
	public:
		BridgeConnection();
		BridgeConnection(::Udm::ObjectImpl *impl);
		BridgeConnection(const BridgeConnection &master);

#ifdef UDM_RVALUE
		BridgeConnection(BridgeConnection &&master);

		static BridgeConnection Cast(::Udm::Object &&a);
		BridgeConnection& operator=(BridgeConnection &&a);

#endif
		static BridgeConnection Cast(const ::Udm::Object &a);
		static BridgeConnection Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		BridgeConnection CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< BridgeConnection> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< BridgeConnection, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< BridgeConnection, Pred>(impl); };
		BridgeConnection CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< BridgeConnection> Derived();
		template <class Pred> ::Udm::DerivedAttr< BridgeConnection, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< BridgeConnection, Pred>(impl); };
		::Udm::ArchetypeAttr< BridgeConnection> Archetype() const;
		::Udm::ParentAttr< ::PICML::Domain> Domain_parent() const;
		::Udm::ParentAttr< ::PICML::Domain> parent() const;
		::Udm::AssocEndAttr< ::PICML::Interconnect> srcBridgeConnection_end() const;
		::Udm::AssocEndAttr< ::PICML::Bridge> dstBridgeConnection_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Domain_parent;
		static ::Uml::AssociationRole meta_srcBridgeConnection_end_;
		static ::Uml::AssociationRole meta_dstBridgeConnection_end_;

	};

	class PICML_Export Shares :  public MgaObject {
	public:
		Shares();
		Shares(::Udm::ObjectImpl *impl);
		Shares(const Shares &master);

#ifdef UDM_RVALUE
		Shares(Shares &&master);

		static Shares Cast(::Udm::Object &&a);
		Shares& operator=(Shares &&a);

#endif
		static Shares Cast(const ::Udm::Object &a);
		static Shares Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Shares CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Shares> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Shares, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Shares, Pred>(impl); };
		Shares CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Shares> Derived();
		template <class Pred> ::Udm::DerivedAttr< Shares, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Shares, Pred>(impl); };
		::Udm::ArchetypeAttr< Shares> Archetype() const;
		::Udm::ParentAttr< ::PICML::Domain> Domain_parent() const;
		::Udm::ParentAttr< ::PICML::Domain> parent() const;
		::Udm::AssocEndAttr< ::PICML::Node> srcShares_end() const;
		::Udm::AssocEndAttr< ::PICML::SharedResource> dstShares_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Domain_parent;
		static ::Uml::AssociationRole meta_srcShares_end_;
		static ::Uml::AssociationRole meta_dstShares_end_;

	};

	class PICML_Export Taggable :  virtual  public MgaObject {
	public:
		Taggable();
		Taggable(::Udm::ObjectImpl *impl);
		Taggable(const Taggable &master);

#ifdef UDM_RVALUE
		Taggable(Taggable &&master);

		static Taggable Cast(::Udm::Object &&a);
		Taggable& operator=(Taggable &&a);

#endif
		static Taggable Cast(const ::Udm::Object &a);
		static Taggable Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Taggable CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Taggable> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Taggable, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Taggable, Pred>(impl); };
		Taggable CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Taggable> Derived();
		template <class Pred> ::Udm::DerivedAttr< Taggable, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Taggable, Pred>(impl); };
		::Udm::ArchetypeAttr< Taggable> Archetype() const;
		::Udm::StringAttr VersionTag() const;
		::Udm::StringAttr SpecifyIdTag() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_VersionTag;
		static ::Uml::Attribute meta_SpecifyIdTag;

	};

	class PICML_Export Prefixable :  virtual  public MgaObject {
	public:
		Prefixable();
		Prefixable(::Udm::ObjectImpl *impl);
		Prefixable(const Prefixable &master);

#ifdef UDM_RVALUE
		Prefixable(Prefixable &&master);

		static Prefixable Cast(::Udm::Object &&a);
		Prefixable& operator=(Prefixable &&a);

#endif
		static Prefixable Cast(const ::Udm::Object &a);
		static Prefixable Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Prefixable CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Prefixable> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Prefixable, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Prefixable, Pred>(impl); };
		Prefixable CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Prefixable> Derived();
		template <class Pred> ::Udm::DerivedAttr< Prefixable, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Prefixable, Pred>(impl); };
		::Udm::ArchetypeAttr< Prefixable> Archetype() const;
		::Udm::StringAttr PrefixTag() const;
		::Udm::ParentAttr< ::Udm::Object> parent() const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_PrefixTag;

	};

	class PICML_Export ParameterType :  public MgaObject {
	public:
		ParameterType();
		ParameterType(::Udm::ObjectImpl *impl);
		ParameterType(const ParameterType &master);

#ifdef UDM_RVALUE
		ParameterType(ParameterType &&master);

		static ParameterType Cast(::Udm::Object &&a);
		ParameterType& operator=(ParameterType &&a);

#endif
		static ParameterType Cast(const ::Udm::Object &a);
		static ParameterType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ParameterType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ParameterType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ParameterType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ParameterType, Pred>(impl); };
		ParameterType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ParameterType> Derived();
		template <class Pred> ::Udm::DerivedAttr< ParameterType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ParameterType, Pred>(impl); };
		::Udm::ArchetypeAttr< ParameterType> Archetype() const;
		::Udm::PointerAttr< MemberType> ref() const;
		::Udm::ParentAttr< ::PICML::Operation> Operation_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_Operation_parent;

	};

	class PICML_Export ReturnType :  public MgaObject {
	public:
		ReturnType();
		ReturnType(::Udm::ObjectImpl *impl);
		ReturnType(const ReturnType &master);

#ifdef UDM_RVALUE
		ReturnType(ReturnType &&master);

		static ReturnType Cast(::Udm::Object &&a);
		ReturnType& operator=(ReturnType &&a);

#endif
		static ReturnType Cast(const ::Udm::Object &a);
		static ReturnType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ReturnType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ReturnType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ReturnType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ReturnType, Pred>(impl); };
		ReturnType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ReturnType> Derived();
		template <class Pred> ::Udm::DerivedAttr< ReturnType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ReturnType, Pred>(impl); };
		::Udm::ArchetypeAttr< ReturnType> Archetype() const;
		::Udm::PointerAttr< MemberType> ref() const;
		::Udm::ParentAttr< ::PICML::TwowayOperation> TwowayOperation_parent() const;
		::Udm::ParentAttr< ::PICML::Operation> Operation_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_TwowayOperation_parent;
		static ::Uml::CompositionParentRole meta_Operation_parent;

	};

	class PICML_Export OutParameter :  public ParameterType {
	public:
		OutParameter();
		OutParameter(::Udm::ObjectImpl *impl);
		OutParameter(const OutParameter &master);

#ifdef UDM_RVALUE
		OutParameter(OutParameter &&master);

		static OutParameter Cast(::Udm::Object &&a);
		OutParameter& operator=(OutParameter &&a);

#endif
		static OutParameter Cast(const ::Udm::Object &a);
		static OutParameter Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		OutParameter CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< OutParameter> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< OutParameter, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< OutParameter, Pred>(impl); };
		OutParameter CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< OutParameter> Derived();
		template <class Pred> ::Udm::DerivedAttr< OutParameter, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< OutParameter, Pred>(impl); };
		::Udm::ArchetypeAttr< OutParameter> Archetype() const;
		::Udm::ParentAttr< ::PICML::TwowayOperation> TwowayOperation_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_TwowayOperation_parent;

	};

	class PICML_Export InoutParameter :  public ParameterType {
	public:
		InoutParameter();
		InoutParameter(::Udm::ObjectImpl *impl);
		InoutParameter(const InoutParameter &master);

#ifdef UDM_RVALUE
		InoutParameter(InoutParameter &&master);

		static InoutParameter Cast(::Udm::Object &&a);
		InoutParameter& operator=(InoutParameter &&a);

#endif
		static InoutParameter Cast(const ::Udm::Object &a);
		static InoutParameter Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		InoutParameter CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< InoutParameter> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< InoutParameter, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< InoutParameter, Pred>(impl); };
		InoutParameter CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< InoutParameter> Derived();
		template <class Pred> ::Udm::DerivedAttr< InoutParameter, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< InoutParameter, Pred>(impl); };
		::Udm::ArchetypeAttr< InoutParameter> Archetype() const;
		::Udm::ParentAttr< ::PICML::TwowayOperation> TwowayOperation_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_TwowayOperation_parent;

	};

	class PICML_Export InParameter :  public ParameterType {
	public:
		InParameter();
		InParameter(::Udm::ObjectImpl *impl);
		InParameter(const InParameter &master);

#ifdef UDM_RVALUE
		InParameter(InParameter &&master);

		static InParameter Cast(::Udm::Object &&a);
		InParameter& operator=(InParameter &&a);

#endif
		static InParameter Cast(const ::Udm::Object &a);
		static InParameter Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		InParameter CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< InParameter> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< InParameter, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< InParameter, Pred>(impl); };
		InParameter CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< InParameter> Derived();
		template <class Pred> ::Udm::DerivedAttr< InParameter, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< InParameter, Pred>(impl); };
		::Udm::ArchetypeAttr< InParameter> Archetype() const;
		::Udm::ParentAttr< ::PICML::OperationBase> OperationBase_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_OperationBase_parent;

	};

	class PICML_Export OperationBase :  public Taggable {
	public:
		OperationBase();
		OperationBase(::Udm::ObjectImpl *impl);
		OperationBase(const OperationBase &master);

#ifdef UDM_RVALUE
		OperationBase(OperationBase &&master);

		static OperationBase Cast(::Udm::Object &&a);
		OperationBase& operator=(OperationBase &&a);

#endif
		static OperationBase Cast(const ::Udm::Object &a);
		static OperationBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		OperationBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< OperationBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< OperationBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< OperationBase, Pred>(impl); };
		OperationBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< OperationBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< OperationBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< OperationBase, Pred>(impl); };
		::Udm::ArchetypeAttr< OperationBase> Archetype() const;
		::Udm::AssocAttr< OperationRef> referedbyOperationRef() const;
		template <class Pred> ::Udm::AssocAttr< OperationRef, Pred> referedbyOperationRef_sorted(const Pred &) const { return ::Udm::AssocAttr< OperationRef, Pred>(impl, meta_referedbyOperationRef); };
		::Udm::ChildrenAttr< ::PICML::InParameter> InParameter_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InParameter, Pred> InParameter_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InParameter, Pred>(impl, meta_InParameter_children); };
		::Udm::ChildrenAttr< ::PICML::ParameterType> ParameterType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ParameterType, Pred> ParameterType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ParameterType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::InParameter> InParameter_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InParameter, Pred> InParameter_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InParameter, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyOperationRef;
		static ::Uml::CompositionChildRole meta_InParameter_children;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

	};

	class PICML_Export HasExceptions :  public OperationBase {
	public:
		HasExceptions();
		HasExceptions(::Udm::ObjectImpl *impl);
		HasExceptions(const HasExceptions &master);

#ifdef UDM_RVALUE
		HasExceptions(HasExceptions &&master);

		static HasExceptions Cast(::Udm::Object &&a);
		HasExceptions& operator=(HasExceptions &&a);

#endif
		static HasExceptions Cast(const ::Udm::Object &a);
		static HasExceptions Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		HasExceptions CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< HasExceptions> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< HasExceptions, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< HasExceptions, Pred>(impl); };
		HasExceptions CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< HasExceptions> Derived();
		template <class Pred> ::Udm::DerivedAttr< HasExceptions, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< HasExceptions, Pred>(impl); };
		::Udm::ArchetypeAttr< HasExceptions> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::ExceptionRef> ExceptionRef_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExceptionRef, Pred> ExceptionRef_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExceptionRef, Pred>(impl, meta_ExceptionRef_children); };
		::Udm::ChildrenAttr< ::PICML::ExceptionRef> ExceptionRef_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExceptionRef, Pred> ExceptionRef_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExceptionRef, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_ExceptionRef_children;

	};

	class PICML_Export OnewayOperation :  public OperationBase {
	public:
		OnewayOperation();
		OnewayOperation(::Udm::ObjectImpl *impl);
		OnewayOperation(const OnewayOperation &master);

#ifdef UDM_RVALUE
		OnewayOperation(OnewayOperation &&master);

		static OnewayOperation Cast(::Udm::Object &&a);
		OnewayOperation& operator=(OnewayOperation &&a);

#endif
		static OnewayOperation Cast(const ::Udm::Object &a);
		static OnewayOperation Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		OnewayOperation CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< OnewayOperation> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< OnewayOperation, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< OnewayOperation, Pred>(impl); };
		OnewayOperation CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< OnewayOperation> Derived();
		template <class Pred> ::Udm::DerivedAttr< OnewayOperation, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< OnewayOperation, Pred>(impl); };
		::Udm::ArchetypeAttr< OnewayOperation> Archetype() const;
		::Udm::ParentAttr< ::PICML::HasOperations> HasOperations_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_HasOperations_parent;

	};

	class PICML_Export TwowayOperation :  public HasExceptions {
	public:
		TwowayOperation();
		TwowayOperation(::Udm::ObjectImpl *impl);
		TwowayOperation(const TwowayOperation &master);

#ifdef UDM_RVALUE
		TwowayOperation(TwowayOperation &&master);

		static TwowayOperation Cast(::Udm::Object &&a);
		TwowayOperation& operator=(TwowayOperation &&a);

#endif
		static TwowayOperation Cast(const ::Udm::Object &a);
		static TwowayOperation Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TwowayOperation CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TwowayOperation> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TwowayOperation, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TwowayOperation, Pred>(impl); };
		TwowayOperation CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TwowayOperation> Derived();
		template <class Pred> ::Udm::DerivedAttr< TwowayOperation, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TwowayOperation, Pred>(impl); };
		::Udm::ArchetypeAttr< TwowayOperation> Archetype() const;
		::Udm::ChildAttr< ::PICML::ReturnType> ReturnType_child() const;
		::Udm::ChildrenAttr< ::PICML::OutParameter> OutParameter_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OutParameter, Pred> OutParameter_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OutParameter, Pred>(impl, meta_OutParameter_children); };
		::Udm::ChildrenAttr< ::PICML::InoutParameter> InoutParameter_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InoutParameter, Pred> InoutParameter_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InoutParameter, Pred>(impl, meta_InoutParameter_children); };
		::Udm::ChildrenAttr< ::PICML::ParameterType> ParameterType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ParameterType, Pred> ParameterType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ParameterType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ReturnType> ReturnType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ReturnType, Pred> ReturnType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ReturnType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::OutParameter> OutParameter_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OutParameter, Pred> OutParameter_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OutParameter, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::InoutParameter> InoutParameter_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InoutParameter, Pred> InoutParameter_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InoutParameter, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::HasOperations> HasOperations_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_ReturnType_child;
		static ::Uml::CompositionChildRole meta_OutParameter_children;
		static ::Uml::CompositionChildRole meta_InoutParameter_children;
		static ::Uml::CompositionParentRole meta_HasOperations_parent;

	};

	class PICML_Export FactoryOperation :  public HasExceptions {
	public:
		FactoryOperation();
		FactoryOperation(::Udm::ObjectImpl *impl);
		FactoryOperation(const FactoryOperation &master);

#ifdef UDM_RVALUE
		FactoryOperation(FactoryOperation &&master);

		static FactoryOperation Cast(::Udm::Object &&a);
		FactoryOperation& operator=(FactoryOperation &&a);

#endif
		static FactoryOperation Cast(const ::Udm::Object &a);
		static FactoryOperation Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		FactoryOperation CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< FactoryOperation> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< FactoryOperation, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< FactoryOperation, Pred>(impl); };
		FactoryOperation CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< FactoryOperation> Derived();
		template <class Pred> ::Udm::DerivedAttr< FactoryOperation, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< FactoryOperation, Pred>(impl); };
		::Udm::ArchetypeAttr< FactoryOperation> Archetype() const;
		::Udm::ParentAttr< ::PICML::ObjectByValue> ObjectByValue_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentFactory> ComponentFactory_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ObjectByValue_parent;
		static ::Uml::CompositionParentRole meta_ComponentFactory_parent;

	};

	class PICML_Export LookupOperation :  public HasExceptions {
	public:
		LookupOperation();
		LookupOperation(::Udm::ObjectImpl *impl);
		LookupOperation(const LookupOperation &master);

#ifdef UDM_RVALUE
		LookupOperation(LookupOperation &&master);

		static LookupOperation Cast(::Udm::Object &&a);
		LookupOperation& operator=(LookupOperation &&a);

#endif
		static LookupOperation Cast(const ::Udm::Object &a);
		static LookupOperation Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		LookupOperation CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< LookupOperation> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< LookupOperation, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< LookupOperation, Pred>(impl); };
		LookupOperation CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< LookupOperation> Derived();
		template <class Pred> ::Udm::DerivedAttr< LookupOperation, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< LookupOperation, Pred>(impl); };
		::Udm::ArchetypeAttr< LookupOperation> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentFactory> ComponentFactory_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentFactory_parent;

	};

	class PICML_Export ExceptionRef :  public MgaObject {
	public:
		ExceptionRef();
		ExceptionRef(::Udm::ObjectImpl *impl);
		ExceptionRef(const ExceptionRef &master);

#ifdef UDM_RVALUE
		ExceptionRef(ExceptionRef &&master);

		static ExceptionRef Cast(::Udm::Object &&a);
		ExceptionRef& operator=(ExceptionRef &&a);

#endif
		static ExceptionRef Cast(const ::Udm::Object &a);
		static ExceptionRef Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ExceptionRef CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ExceptionRef> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ExceptionRef, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ExceptionRef, Pred>(impl); };
		ExceptionRef CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ExceptionRef> Derived();
		template <class Pred> ::Udm::DerivedAttr< ExceptionRef, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ExceptionRef, Pred>(impl); };
		::Udm::ArchetypeAttr< ExceptionRef> Archetype() const;
		::Udm::PointerAttr< ExceptionType> ref() const;
		::Udm::ParentAttr< ::PICML::HasExceptions> HasExceptions_parent() const;
		::Udm::ParentAttr< ::PICML::HasExceptions> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_HasExceptions_parent;

	};

	class PICML_Export AttributeMember :  public MgaObject {
	public:
		AttributeMember();
		AttributeMember(::Udm::ObjectImpl *impl);
		AttributeMember(const AttributeMember &master);

#ifdef UDM_RVALUE
		AttributeMember(AttributeMember &&master);

		static AttributeMember Cast(::Udm::Object &&a);
		AttributeMember& operator=(AttributeMember &&a);

#endif
		static AttributeMember Cast(const ::Udm::Object &a);
		static AttributeMember Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		AttributeMember CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< AttributeMember> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< AttributeMember, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< AttributeMember, Pred>(impl); };
		AttributeMember CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< AttributeMember> Derived();
		template <class Pred> ::Udm::DerivedAttr< AttributeMember, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< AttributeMember, Pred>(impl); };
		::Udm::ArchetypeAttr< AttributeMember> Archetype() const;
		::Udm::PointerAttr< MemberType> ref() const;
		::Udm::ParentAttr< ::PICML::ReadonlyAttribute> ReadonlyAttribute_parent() const;
		::Udm::ParentAttr< ::PICML::ReadonlyAttribute> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ReadonlyAttribute_parent;

	};

	class PICML_Export MakeMemberPrivate :  public MgaObject {
	public:
		MakeMemberPrivate();
		MakeMemberPrivate(::Udm::ObjectImpl *impl);
		MakeMemberPrivate(const MakeMemberPrivate &master);

#ifdef UDM_RVALUE
		MakeMemberPrivate(MakeMemberPrivate &&master);

		static MakeMemberPrivate Cast(::Udm::Object &&a);
		MakeMemberPrivate& operator=(MakeMemberPrivate &&a);

#endif
		static MakeMemberPrivate Cast(const ::Udm::Object &a);
		static MakeMemberPrivate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MakeMemberPrivate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MakeMemberPrivate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MakeMemberPrivate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MakeMemberPrivate, Pred>(impl); };
		MakeMemberPrivate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MakeMemberPrivate> Derived();
		template <class Pred> ::Udm::DerivedAttr< MakeMemberPrivate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MakeMemberPrivate, Pred>(impl); };
		::Udm::ArchetypeAttr< MakeMemberPrivate> Archetype() const;
		::Udm::ParentAttr< ::PICML::ObjectByValue> ObjectByValue_parent() const;
		::Udm::ParentAttr< ::PICML::ObjectByValue> parent() const;
		::Udm::AssocEndAttr< ::PICML::Member> srcMakeMemberPrivate_end() const;
		::Udm::AssocEndAttr< ::PICML::PrivateFlag> dstMakeMemberPrivate_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ObjectByValue_parent;
		static ::Uml::AssociationRole meta_srcMakeMemberPrivate_end_;
		static ::Uml::AssociationRole meta_dstMakeMemberPrivate_end_;

	};

	class PICML_Export PrivateFlag :  public MgaObject {
	public:
		PrivateFlag();
		PrivateFlag(::Udm::ObjectImpl *impl);
		PrivateFlag(const PrivateFlag &master);

#ifdef UDM_RVALUE
		PrivateFlag(PrivateFlag &&master);

		static PrivateFlag Cast(::Udm::Object &&a);
		PrivateFlag& operator=(PrivateFlag &&a);

#endif
		static PrivateFlag Cast(const ::Udm::Object &a);
		static PrivateFlag Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PrivateFlag CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PrivateFlag> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PrivateFlag, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PrivateFlag, Pred>(impl); };
		PrivateFlag CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PrivateFlag> Derived();
		template <class Pred> ::Udm::DerivedAttr< PrivateFlag, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PrivateFlag, Pred>(impl); };
		::Udm::ArchetypeAttr< PrivateFlag> Archetype() const;
		::Udm::AClassPointerAttr< MakeMemberPrivate, Member> srcMakeMemberPrivate() const;
		::Udm::ParentAttr< ::PICML::ObjectByValue> ObjectByValue_parent() const;
		::Udm::ParentAttr< ::PICML::ObjectByValue> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcMakeMemberPrivate;
		static ::Uml::AssociationRole meta_srcMakeMemberPrivate_rev;
		static ::Uml::CompositionParentRole meta_ObjectByValue_parent;

	};

	class PICML_Export GetException :  public MgaObject {
	public:
		GetException();
		GetException(::Udm::ObjectImpl *impl);
		GetException(const GetException &master);

#ifdef UDM_RVALUE
		GetException(GetException &&master);

		static GetException Cast(::Udm::Object &&a);
		GetException& operator=(GetException &&a);

#endif
		static GetException Cast(const ::Udm::Object &a);
		static GetException Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		GetException CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< GetException> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< GetException, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< GetException, Pred>(impl); };
		GetException CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< GetException> Derived();
		template <class Pred> ::Udm::DerivedAttr< GetException, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< GetException, Pred>(impl); };
		::Udm::ArchetypeAttr< GetException> Archetype() const;
		::Udm::PointerAttr< ExceptionType> ref() const;
		::Udm::ParentAttr< ::PICML::ReadonlyAttribute> ReadonlyAttribute_parent() const;
		::Udm::ParentAttr< ::PICML::ReadonlyAttribute> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ReadonlyAttribute_parent;

	};

	class PICML_Export SetException :  public MgaObject {
	public:
		SetException();
		SetException(::Udm::ObjectImpl *impl);
		SetException(const SetException &master);

#ifdef UDM_RVALUE
		SetException(SetException &&master);

		static SetException Cast(::Udm::Object &&a);
		SetException& operator=(SetException &&a);

#endif
		static SetException Cast(const ::Udm::Object &a);
		static SetException Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		SetException CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< SetException> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< SetException, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< SetException, Pred>(impl); };
		SetException CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< SetException> Derived();
		template <class Pred> ::Udm::DerivedAttr< SetException, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< SetException, Pred>(impl); };
		::Udm::ArchetypeAttr< SetException> Archetype() const;
		::Udm::PointerAttr< ExceptionType> ref() const;
		::Udm::ParentAttr< ::PICML::Attribute> Attribute_parent() const;
		::Udm::ParentAttr< ::PICML::Attribute> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_Attribute_parent;

	};

	class PICML_Export ReadonlyAttribute :  public Taggable {
	public:
		ReadonlyAttribute();
		ReadonlyAttribute(::Udm::ObjectImpl *impl);
		ReadonlyAttribute(const ReadonlyAttribute &master);

#ifdef UDM_RVALUE
		ReadonlyAttribute(ReadonlyAttribute &&master);

		static ReadonlyAttribute Cast(::Udm::Object &&a);
		ReadonlyAttribute& operator=(ReadonlyAttribute &&a);

#endif
		static ReadonlyAttribute Cast(const ::Udm::Object &a);
		static ReadonlyAttribute Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ReadonlyAttribute CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ReadonlyAttribute> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ReadonlyAttribute, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ReadonlyAttribute, Pred>(impl); };
		ReadonlyAttribute CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ReadonlyAttribute> Derived();
		template <class Pred> ::Udm::DerivedAttr< ReadonlyAttribute, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ReadonlyAttribute, Pred>(impl); };
		::Udm::ArchetypeAttr< ReadonlyAttribute> Archetype() const;
		::Udm::AssocAttr< AttributeInstance> referedbyAttributeInstance() const;
		template <class Pred> ::Udm::AssocAttr< AttributeInstance, Pred> referedbyAttributeInstance_sorted(const Pred &) const { return ::Udm::AssocAttr< AttributeInstance, Pred>(impl, meta_referedbyAttributeInstance); };
		::Udm::ChildAttr< ::PICML::AttributeMember> AttributeMember_child() const;
		::Udm::ChildrenAttr< ::PICML::GetException> GetException_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::GetException, Pred> GetException_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::GetException, Pred>(impl, meta_GetException_children); };
		::Udm::ChildrenAttr< ::PICML::AttributeMember> AttributeMember_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AttributeMember, Pred> AttributeMember_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AttributeMember, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::GetException> GetException_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::GetException, Pred> GetException_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::GetException, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::Inheritable> Inheritable_parent() const;
		::Udm::ParentAttr< ::PICML::PortType> PortType_parent() const;
		::Udm::ParentAttr< ::PICML::Component> Component_parent() const;
		::Udm::ParentAttr< ::PICML::ConnectorObject> ConnectorObject_parent() const;
		::Udm::ParentAttr< ::PICML::NamedType> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyAttributeInstance;
		static ::Uml::CompositionChildRole meta_AttributeMember_child;
		static ::Uml::CompositionChildRole meta_GetException_children;
		static ::Uml::CompositionParentRole meta_Inheritable_parent;
		static ::Uml::CompositionParentRole meta_PortType_parent;
		static ::Uml::CompositionParentRole meta_Component_parent;
		static ::Uml::CompositionParentRole meta_ConnectorObject_parent;

	};

	class PICML_Export Attribute :  public ReadonlyAttribute {
	public:
		Attribute();
		Attribute(::Udm::ObjectImpl *impl);
		Attribute(const Attribute &master);

#ifdef UDM_RVALUE
		Attribute(Attribute &&master);

		static Attribute Cast(::Udm::Object &&a);
		Attribute& operator=(Attribute &&a);

#endif
		static Attribute Cast(const ::Udm::Object &a);
		static Attribute Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Attribute CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Attribute> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Attribute, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Attribute, Pred>(impl); };
		Attribute CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Attribute> Derived();
		template <class Pred> ::Udm::DerivedAttr< Attribute, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Attribute, Pred>(impl); };
		::Udm::ArchetypeAttr< Attribute> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::SetException> SetException_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SetException, Pred> SetException_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SetException, Pred>(impl, meta_SetException_children); };
		::Udm::ChildrenAttr< ::PICML::SetException> SetException_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SetException, Pred> SetException_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SetException, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::NamedType> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_SetException_children;

	};

	class PICML_Export Supports :  public MgaObject {
	public:
		Supports();
		Supports(::Udm::ObjectImpl *impl);
		Supports(const Supports &master);

#ifdef UDM_RVALUE
		Supports(Supports &&master);

		static Supports Cast(::Udm::Object &&a);
		Supports& operator=(Supports &&a);

#endif
		static Supports Cast(const ::Udm::Object &a);
		static Supports Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Supports CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Supports> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Supports, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Supports, Pred>(impl); };
		Supports CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Supports> Derived();
		template <class Pred> ::Udm::DerivedAttr< Supports, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Supports, Pred>(impl); };
		::Udm::ArchetypeAttr< Supports> Archetype() const;
		::Udm::PointerAttr< ::PICML::Object> ref() const;
		::Udm::AssocAttr< SupportsInstance> referedbySupportsInstance() const;
		template <class Pred> ::Udm::AssocAttr< SupportsInstance, Pred> referedbySupportsInstance_sorted(const Pred &) const { return ::Udm::AssocAttr< SupportsInstance, Pred>(impl, meta_referedbySupportsInstance); };
		::Udm::ParentAttr< ::PICML::SupportsInterfaces> SupportsInterfaces_parent() const;
		::Udm::ParentAttr< ::PICML::SupportsInterfaces> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_referedbySupportsInstance;
		static ::Uml::CompositionParentRole meta_SupportsInterfaces_parent;

	};

	class PICML_Export SupportsInterfaces :  virtual  public MgaObject {
	public:
		SupportsInterfaces();
		SupportsInterfaces(::Udm::ObjectImpl *impl);
		SupportsInterfaces(const SupportsInterfaces &master);

#ifdef UDM_RVALUE
		SupportsInterfaces(SupportsInterfaces &&master);

		static SupportsInterfaces Cast(::Udm::Object &&a);
		SupportsInterfaces& operator=(SupportsInterfaces &&a);

#endif
		static SupportsInterfaces Cast(const ::Udm::Object &a);
		static SupportsInterfaces Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		SupportsInterfaces CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< SupportsInterfaces> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< SupportsInterfaces, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< SupportsInterfaces, Pred>(impl); };
		SupportsInterfaces CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< SupportsInterfaces> Derived();
		template <class Pred> ::Udm::DerivedAttr< SupportsInterfaces, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< SupportsInterfaces, Pred>(impl); };
		::Udm::ArchetypeAttr< SupportsInterfaces> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::Supports> Supports_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Supports, Pred> Supports_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Supports, Pred>(impl, meta_Supports_children); };
		::Udm::ChildrenAttr< ::PICML::Supports> Supports_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Supports, Pred> Supports_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Supports, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> parent() const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Supports_children;

	};

	class PICML_Export Inherits :  public MgaObject {
	public:
		Inherits();
		Inherits(::Udm::ObjectImpl *impl);
		Inherits(const Inherits &master);

#ifdef UDM_RVALUE
		Inherits(Inherits &&master);

		static Inherits Cast(::Udm::Object &&a);
		Inherits& operator=(Inherits &&a);

#endif
		static Inherits Cast(const ::Udm::Object &a);
		static Inherits Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Inherits CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Inherits> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Inherits, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Inherits, Pred>(impl); };
		Inherits CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Inherits> Derived();
		template <class Pred> ::Udm::DerivedAttr< Inherits, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Inherits, Pred>(impl); };
		::Udm::ArchetypeAttr< Inherits> Archetype() const;
		::Udm::PointerAttr< Inheritable> ref() const;
		::Udm::ParentAttr< ::PICML::Inheritable> Inheritable_parent() const;
		::Udm::ParentAttr< ::PICML::Inheritable> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_Inheritable_parent;

	};

	class PICML_Export Key :  public MgaObject {
	public:
		Key();
		Key(::Udm::ObjectImpl *impl);
		Key(const Key &master);

#ifdef UDM_RVALUE
		Key(Key &&master);

		static Key Cast(::Udm::Object &&a);
		Key& operator=(Key &&a);

#endif
		static Key Cast(const ::Udm::Object &a);
		static Key Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Key CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Key> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Key, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Key, Pred>(impl); };
		Key CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Key> Derived();
		template <class Pred> ::Udm::DerivedAttr< Key, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Key, Pred>(impl); };
		::Udm::ArchetypeAttr< Key> Archetype() const;
		::Udm::AClassAssocAttr< KeyMember, Member> dstKeyMember() const;
		template <class Pred> ::Udm::AClassAssocAttr< KeyMember, Member, Pred> dstKeyMember_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< KeyMember, Member, Pred>(impl, meta_dstKeyMember, meta_dstKeyMember_rev); };
		::Udm::ParentAttr< ::PICML::Aggregate> Aggregate_parent() const;
		::Udm::ParentAttr< ::PICML::Aggregate> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstKeyMember;
		static ::Uml::AssociationRole meta_dstKeyMember_rev;
		static ::Uml::CompositionParentRole meta_Aggregate_parent;

	};

	class PICML_Export KeyMember :  public MgaObject {
	public:
		KeyMember();
		KeyMember(::Udm::ObjectImpl *impl);
		KeyMember(const KeyMember &master);

#ifdef UDM_RVALUE
		KeyMember(KeyMember &&master);

		static KeyMember Cast(::Udm::Object &&a);
		KeyMember& operator=(KeyMember &&a);

#endif
		static KeyMember Cast(const ::Udm::Object &a);
		static KeyMember Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		KeyMember CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< KeyMember> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< KeyMember, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< KeyMember, Pred>(impl); };
		KeyMember CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< KeyMember> Derived();
		template <class Pred> ::Udm::DerivedAttr< KeyMember, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< KeyMember, Pred>(impl); };
		::Udm::ArchetypeAttr< KeyMember> Archetype() const;
		::Udm::ParentAttr< ::PICML::Aggregate> Aggregate_parent() const;
		::Udm::ParentAttr< ::PICML::Aggregate> parent() const;
		::Udm::AssocEndAttr< ::PICML::Key> srcKeyMember_end() const;
		::Udm::AssocEndAttr< ::PICML::Member> dstKeyMember_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Aggregate_parent;
		static ::Uml::AssociationRole meta_srcKeyMember_end_;
		static ::Uml::AssociationRole meta_dstKeyMember_end_;

	};

	class PICML_Export Member :  public MgaObject {
	public:
		Member();
		Member(::Udm::ObjectImpl *impl);
		Member(const Member &master);

#ifdef UDM_RVALUE
		Member(Member &&master);

		static Member Cast(::Udm::Object &&a);
		Member& operator=(Member &&a);

#endif
		static Member Cast(const ::Udm::Object &a);
		static Member Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Member CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Member> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Member, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Member, Pred>(impl); };
		Member CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Member> Derived();
		template <class Pred> ::Udm::DerivedAttr< Member, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Member, Pred>(impl); };
		::Udm::ArchetypeAttr< Member> Archetype() const;
		::Udm::AClassPointerAttr< KeyMember, Key> srcKeyMember() const;
		::Udm::AClassAssocAttr< LabelConnection, Label> dstLabelConnection() const;
		template <class Pred> ::Udm::AClassAssocAttr< LabelConnection, Label, Pred> dstLabelConnection_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< LabelConnection, Label, Pred>(impl, meta_dstLabelConnection, meta_dstLabelConnection_rev); };
		::Udm::PointerAttr< MemberType> ref() const;
		::Udm::AClassPointerAttr< MakeMemberPrivate, PrivateFlag> dstMakeMemberPrivate() const;
		::Udm::ParentAttr< ::PICML::ObjectByValue> ObjectByValue_parent() const;
		::Udm::ParentAttr< ::PICML::SwitchedAggregate> SwitchedAggregate_parent() const;
		::Udm::ParentAttr< ::PICML::Aggregate> Aggregate_parent() const;
		::Udm::ParentAttr< ::PICML::Exception> Exception_parent() const;
		::Udm::ParentAttr< ::Udm::Object> parent() const;
		::Udm::ParentAttr< ::PICML::Taggable> Taggable_parent() const;
		::Udm::ParentAttr< ::PICML::TemplateParameterValueType> TemplateParameterValueType_parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcKeyMember;
		static ::Uml::AssociationRole meta_srcKeyMember_rev;
		static ::Uml::AssociationRole meta_dstLabelConnection;
		static ::Uml::AssociationRole meta_dstLabelConnection_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_dstMakeMemberPrivate;
		static ::Uml::AssociationRole meta_dstMakeMemberPrivate_rev;
		static ::Uml::CompositionParentRole meta_ObjectByValue_parent;
		static ::Uml::CompositionParentRole meta_SwitchedAggregate_parent;
		static ::Uml::CompositionParentRole meta_Aggregate_parent;
		static ::Uml::CompositionParentRole meta_Exception_parent;

	};

	class PICML_Export ArrayMember :  public Member {
	public:
		ArrayMember();
		ArrayMember(::Udm::ObjectImpl *impl);
		ArrayMember(const ArrayMember &master);

#ifdef UDM_RVALUE
		ArrayMember(ArrayMember &&master);

		static ArrayMember Cast(::Udm::Object &&a);
		ArrayMember& operator=(ArrayMember &&a);

#endif
		static ArrayMember Cast(const ::Udm::Object &a);
		static ArrayMember Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ArrayMember CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ArrayMember> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ArrayMember, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ArrayMember, Pred>(impl); };
		ArrayMember CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ArrayMember> Derived();
		template <class Pred> ::Udm::DerivedAttr< ArrayMember, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ArrayMember, Pred>(impl); };
		::Udm::ArchetypeAttr< ArrayMember> Archetype() const;
		::Udm::IntegerAttr Size() const;
		::Udm::ParentAttr< ::Udm::Object> parent() const;
		::Udm::ParentAttr< ::PICML::Taggable> Taggable_parent() const;
		::Udm::ParentAttr< ::PICML::TemplateParameterValueType> TemplateParameterValueType_parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Size;

	};

	class PICML_Export Discriminator :  public MgaObject {
	public:
		Discriminator();
		Discriminator(::Udm::ObjectImpl *impl);
		Discriminator(const Discriminator &master);

#ifdef UDM_RVALUE
		Discriminator(Discriminator &&master);

		static Discriminator Cast(::Udm::Object &&a);
		Discriminator& operator=(Discriminator &&a);

#endif
		static Discriminator Cast(const ::Udm::Object &a);
		static Discriminator Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Discriminator CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Discriminator> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Discriminator, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Discriminator, Pred>(impl); };
		Discriminator CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Discriminator> Derived();
		template <class Pred> ::Udm::DerivedAttr< Discriminator, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Discriminator, Pred>(impl); };
		::Udm::ArchetypeAttr< Discriminator> Archetype() const;
		::Udm::PointerAttr< ConstantType> ref() const;
		::Udm::ParentAttr< ::PICML::SwitchedAggregate> SwitchedAggregate_parent() const;
		::Udm::ParentAttr< ::PICML::SwitchedAggregate> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_SwitchedAggregate_parent;

	};

	class PICML_Export LabelConnection :  public MgaObject {
	public:
		LabelConnection();
		LabelConnection(::Udm::ObjectImpl *impl);
		LabelConnection(const LabelConnection &master);

#ifdef UDM_RVALUE
		LabelConnection(LabelConnection &&master);

		static LabelConnection Cast(::Udm::Object &&a);
		LabelConnection& operator=(LabelConnection &&a);

#endif
		static LabelConnection Cast(const ::Udm::Object &a);
		static LabelConnection Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		LabelConnection CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< LabelConnection> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< LabelConnection, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< LabelConnection, Pred>(impl); };
		LabelConnection CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< LabelConnection> Derived();
		template <class Pred> ::Udm::DerivedAttr< LabelConnection, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< LabelConnection, Pred>(impl); };
		::Udm::ArchetypeAttr< LabelConnection> Archetype() const;
		::Udm::ParentAttr< ::PICML::SwitchedAggregate> SwitchedAggregate_parent() const;
		::Udm::ParentAttr< ::PICML::SwitchedAggregate> parent() const;
		::Udm::AssocEndAttr< ::PICML::Member> srcLabelConnection_end() const;
		::Udm::AssocEndAttr< ::PICML::Label> dstLabelConnection_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_SwitchedAggregate_parent;
		static ::Uml::AssociationRole meta_srcLabelConnection_end_;
		static ::Uml::AssociationRole meta_dstLabelConnection_end_;

	};

	class PICML_Export Label :  public MgaObject {
	public:
		Label();
		Label(::Udm::ObjectImpl *impl);
		Label(const Label &master);

#ifdef UDM_RVALUE
		Label(Label &&master);

		static Label Cast(::Udm::Object &&a);
		Label& operator=(Label &&a);

#endif
		static Label Cast(const ::Udm::Object &a);
		static Label Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Label CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Label> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Label, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Label, Pred>(impl); };
		Label CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Label> Derived();
		template <class Pred> ::Udm::DerivedAttr< Label, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Label, Pred>(impl); };
		::Udm::ArchetypeAttr< Label> Archetype() const;
		::Udm::AClassPointerAttr< LabelConnection, Member> srcLabelConnection() const;
		::Udm::ParentAttr< ::PICML::SwitchedAggregate> SwitchedAggregate_parent() const;
		::Udm::ParentAttr< ::PICML::SwitchedAggregate> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcLabelConnection;
		static ::Uml::AssociationRole meta_srcLabelConnection_rev;
		static ::Uml::CompositionParentRole meta_SwitchedAggregate_parent;

	};

	class PICML_Export EnumValue :  public MgaObject {
	public:
		EnumValue();
		EnumValue(::Udm::ObjectImpl *impl);
		EnumValue(const EnumValue &master);

#ifdef UDM_RVALUE
		EnumValue(EnumValue &&master);

		static EnumValue Cast(::Udm::Object &&a);
		EnumValue& operator=(EnumValue &&a);

#endif
		static EnumValue Cast(const ::Udm::Object &a);
		static EnumValue Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		EnumValue CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< EnumValue> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< EnumValue, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< EnumValue, Pred>(impl); };
		EnumValue CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< EnumValue> Derived();
		template <class Pred> ::Udm::DerivedAttr< EnumValue, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< EnumValue, Pred>(impl); };
		::Udm::ArchetypeAttr< EnumValue> Archetype() const;
		::Udm::ParentAttr< ::PICML::Enum> Enum_parent() const;
		::Udm::ParentAttr< ::PICML::Enum> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Enum_parent;

	};

	class PICML_Export TemplateParameterValueType :  virtual  public MgaObject {
	public:
		TemplateParameterValueType();
		TemplateParameterValueType(::Udm::ObjectImpl *impl);
		TemplateParameterValueType(const TemplateParameterValueType &master);

#ifdef UDM_RVALUE
		TemplateParameterValueType(TemplateParameterValueType &&master);

		static TemplateParameterValueType Cast(::Udm::Object &&a);
		TemplateParameterValueType& operator=(TemplateParameterValueType &&a);

#endif
		static TemplateParameterValueType Cast(const ::Udm::Object &a);
		static TemplateParameterValueType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TemplateParameterValueType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TemplateParameterValueType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TemplateParameterValueType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TemplateParameterValueType, Pred>(impl); };
		TemplateParameterValueType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TemplateParameterValueType> Derived();
		template <class Pred> ::Udm::DerivedAttr< TemplateParameterValueType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TemplateParameterValueType, Pred>(impl); };
		::Udm::ArchetypeAttr< TemplateParameterValueType> Archetype() const;
		::Udm::AssocAttr< TemplateParameterValue> referedbyTemplateParameterValue() const;
		template <class Pred> ::Udm::AssocAttr< TemplateParameterValue, Pred> referedbyTemplateParameterValue_sorted(const Pred &) const { return ::Udm::AssocAttr< TemplateParameterValue, Pred>(impl, meta_referedbyTemplateParameterValue); };
		::Udm::ParentAttr< ::Udm::Object> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyTemplateParameterValue;

	};

	class PICML_Export MemberType :  public TemplateParameterValueType {
	public:
		MemberType();
		MemberType(::Udm::ObjectImpl *impl);
		MemberType(const MemberType &master);

#ifdef UDM_RVALUE
		MemberType(MemberType &&master);

		static MemberType Cast(::Udm::Object &&a);
		MemberType& operator=(MemberType &&a);

#endif
		static MemberType Cast(const ::Udm::Object &a);
		static MemberType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MemberType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MemberType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MemberType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MemberType, Pred>(impl); };
		MemberType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MemberType> Derived();
		template <class Pred> ::Udm::DerivedAttr< MemberType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MemberType, Pred>(impl); };
		::Udm::ArchetypeAttr< MemberType> Archetype() const;
		::Udm::AssocAttr< SimpleProperty> referedbySimpleProperty() const;
		template <class Pred> ::Udm::AssocAttr< SimpleProperty, Pred> referedbySimpleProperty_sorted(const Pred &) const { return ::Udm::AssocAttr< SimpleProperty, Pred>(impl, meta_referedbySimpleProperty); };
		::Udm::AssocAttr< DataType> referedbyDataType() const;
		template <class Pred> ::Udm::AssocAttr< DataType, Pred> referedbyDataType_sorted(const Pred &) const { return ::Udm::AssocAttr< DataType, Pred>(impl, meta_referedbyDataType); };
		::Udm::AssocAttr< ParameterType> referedbyParameterType() const;
		template <class Pred> ::Udm::AssocAttr< ParameterType, Pred> referedbyParameterType_sorted(const Pred &) const { return ::Udm::AssocAttr< ParameterType, Pred>(impl, meta_referedbyParameterType); };
		::Udm::AssocAttr< ReturnType> referedbyReturnType() const;
		template <class Pred> ::Udm::AssocAttr< ReturnType, Pred> referedbyReturnType_sorted(const Pred &) const { return ::Udm::AssocAttr< ReturnType, Pred>(impl, meta_referedbyReturnType); };
		::Udm::AssocAttr< AttributeMember> referedbyAttributeMember() const;
		template <class Pred> ::Udm::AssocAttr< AttributeMember, Pred> referedbyAttributeMember_sorted(const Pred &) const { return ::Udm::AssocAttr< AttributeMember, Pred>(impl, meta_referedbyAttributeMember); };
		::Udm::AssocAttr< Member> referedbyMember() const;
		template <class Pred> ::Udm::AssocAttr< Member, Pred> referedbyMember_sorted(const Pred &) const { return ::Udm::AssocAttr< Member, Pred>(impl, meta_referedbyMember); };
		::Udm::AssocAttr< Boxed> referedbyBoxed() const;
		template <class Pred> ::Udm::AssocAttr< Boxed, Pred> referedbyBoxed_sorted(const Pred &) const { return ::Udm::AssocAttr< Boxed, Pred>(impl, meta_referedbyBoxed); };
		::Udm::AssocAttr< Alias> referedbyAlias() const;
		template <class Pred> ::Udm::AssocAttr< Alias, Pred> referedbyAlias_sorted(const Pred &) const { return ::Udm::AssocAttr< Alias, Pred>(impl, meta_referedbyAlias); };
		::Udm::AssocAttr< Collection> referedbyCollection() const;
		template <class Pred> ::Udm::AssocAttr< Collection, Pred> referedbyCollection_sorted(const Pred &) const { return ::Udm::AssocAttr< Collection, Pred>(impl, meta_referedbyCollection); };
		::Udm::ParentAttr< ::Udm::Object> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbySimpleProperty;
		static ::Uml::AssociationRole meta_referedbyDataType;
		static ::Uml::AssociationRole meta_referedbyParameterType;
		static ::Uml::AssociationRole meta_referedbyReturnType;
		static ::Uml::AssociationRole meta_referedbyAttributeMember;
		static ::Uml::AssociationRole meta_referedbyMember;
		static ::Uml::AssociationRole meta_referedbyBoxed;
		static ::Uml::AssociationRole meta_referedbyAlias;
		static ::Uml::AssociationRole meta_referedbyCollection;

	};

	class PICML_Export NamedType :  public MemberType,  public Taggable {
	public:
		NamedType();
		NamedType(::Udm::ObjectImpl *impl);
		NamedType(const NamedType &master);

#ifdef UDM_RVALUE
		NamedType(NamedType &&master);

		static NamedType Cast(::Udm::Object &&a);
		NamedType& operator=(NamedType &&a);

#endif
		static NamedType Cast(const ::Udm::Object &a);
		static NamedType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		NamedType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< NamedType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< NamedType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< NamedType, Pred>(impl); };
		NamedType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< NamedType> Derived();
		template <class Pred> ::Udm::DerivedAttr< NamedType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< NamedType, Pred>(impl); };
		::Udm::ArchetypeAttr< NamedType> Archetype() const;
		::Udm::ParentAttr< ::PICML::File> File_parent() const;
		::Udm::ParentAttr< ::PICML::Package> Package_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_File_parent;
		static ::Uml::CompositionParentRole meta_Package_parent;

	};

	class PICML_Export Inheritable :  public NamedType {
	public:
		Inheritable();
		Inheritable(::Udm::ObjectImpl *impl);
		Inheritable(const Inheritable &master);

#ifdef UDM_RVALUE
		Inheritable(Inheritable &&master);

		static Inheritable Cast(::Udm::Object &&a);
		Inheritable& operator=(Inheritable &&a);

#endif
		static Inheritable Cast(const ::Udm::Object &a);
		static Inheritable Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Inheritable CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Inheritable> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Inheritable, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Inheritable, Pred>(impl); };
		Inheritable CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Inheritable> Derived();
		template <class Pred> ::Udm::DerivedAttr< Inheritable, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Inheritable, Pred>(impl); };
		::Udm::ArchetypeAttr< Inheritable> Archetype() const;
		::Udm::AssocAttr< Inherits> referedbyInherits() const;
		template <class Pred> ::Udm::AssocAttr< Inherits, Pred> referedbyInherits_sorted(const Pred &) const { return ::Udm::AssocAttr< Inherits, Pred>(impl, meta_referedbyInherits); };
		::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute> ReadonlyAttribute_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred> ReadonlyAttribute_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred>(impl, meta_ReadonlyAttribute_children); };
		::Udm::ChildrenAttr< ::PICML::Inherits> Inherits_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Inherits, Pred> Inherits_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Inherits, Pred>(impl, meta_Inherits_children); };
		::Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Attribute> Attribute_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Attribute, Pred> Attribute_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Attribute, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute> ReadonlyAttribute_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred> ReadonlyAttribute_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Inherits> Inherits_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Inherits, Pred> Inherits_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Inherits, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyInherits;
		static ::Uml::CompositionChildRole meta_ReadonlyAttribute_children;
		static ::Uml::CompositionChildRole meta_Inherits_children;

	};

	class PICML_Export HasOperations :  public Inheritable {
	public:
		HasOperations();
		HasOperations(::Udm::ObjectImpl *impl);
		HasOperations(const HasOperations &master);

#ifdef UDM_RVALUE
		HasOperations(HasOperations &&master);

		static HasOperations Cast(::Udm::Object &&a);
		HasOperations& operator=(HasOperations &&a);

#endif
		static HasOperations Cast(const ::Udm::Object &a);
		static HasOperations Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		HasOperations CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< HasOperations> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< HasOperations, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< HasOperations, Pred>(impl); };
		HasOperations CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< HasOperations> Derived();
		template <class Pred> ::Udm::DerivedAttr< HasOperations, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< HasOperations, Pred>(impl); };
		::Udm::ArchetypeAttr< HasOperations> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::NoInheritable> NoInheritable_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NoInheritable, Pred> NoInheritable_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NoInheritable, Pred>(impl, meta_NoInheritable_children); };
		::Udm::ChildrenAttr< ::PICML::Constant> Constant_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Constant, Pred> Constant_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Constant, Pred>(impl, meta_Constant_children); };
		::Udm::ChildrenAttr< ::PICML::Exception> Exception_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Exception, Pred> Exception_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Exception, Pred>(impl, meta_Exception_children); };
		::Udm::ChildrenAttr< ::PICML::TwowayOperation> TwowayOperation_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TwowayOperation, Pred> TwowayOperation_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TwowayOperation, Pred>(impl, meta_TwowayOperation_children); };
		::Udm::ChildrenAttr< ::PICML::OnewayOperation> OnewayOperation_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OnewayOperation, Pred> OnewayOperation_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OnewayOperation, Pred>(impl, meta_OnewayOperation_children); };
		::Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::HasExceptions> HasExceptions_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::HasExceptions, Pred> HasExceptions_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::HasExceptions, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::OnewayOperation> OnewayOperation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OnewayOperation, Pred> OnewayOperation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OnewayOperation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TwowayOperation> TwowayOperation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TwowayOperation, Pred> TwowayOperation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TwowayOperation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::OperationBase> OperationBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OperationBase, Pred> OperationBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OperationBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::NoInheritable> NoInheritable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NoInheritable, Pred> NoInheritable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NoInheritable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Alias> Alias_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Alias, Pred> Alias_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Alias, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Collection> Collection_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Collection, Pred> Collection_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Collection, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::NamedType> NamedType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NamedType, Pred> NamedType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NamedType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MemberType> MemberType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MemberType, Pred> MemberType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MemberType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SwitchedAggregate> SwitchedAggregate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SwitchedAggregate, Pred> SwitchedAggregate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SwitchedAggregate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Aggregate> Aggregate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Aggregate, Pred> Aggregate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Aggregate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Enum> Enum_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Enum, Pred> Enum_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Enum, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType> TemplateParameterValueType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType, Pred> TemplateParameterValueType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExceptionType> ExceptionType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExceptionType, Pred> ExceptionType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExceptionType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Constant> Constant_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Constant, Pred> Constant_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Constant, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Exception> Exception_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Exception, Pred> Exception_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Exception, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PortType> PortType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PortType, Pred> PortType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PortType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_NoInheritable_children;
		static ::Uml::CompositionChildRole meta_Constant_children;
		static ::Uml::CompositionChildRole meta_Exception_children;
		static ::Uml::CompositionChildRole meta_TwowayOperation_children;
		static ::Uml::CompositionChildRole meta_OnewayOperation_children;

	};

	class PICML_Export ObjectByValue :  public HasOperations,  public Prefixable,  public SupportsInterfaces {
	public:
		ObjectByValue();
		ObjectByValue(::Udm::ObjectImpl *impl);
		ObjectByValue(const ObjectByValue &master);

#ifdef UDM_RVALUE
		ObjectByValue(ObjectByValue &&master);

		static ObjectByValue Cast(::Udm::Object &&a);
		ObjectByValue& operator=(ObjectByValue &&a);

#endif
		static ObjectByValue Cast(const ::Udm::Object &a);
		static ObjectByValue Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ObjectByValue CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ObjectByValue> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ObjectByValue, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ObjectByValue, Pred>(impl); };
		ObjectByValue CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ObjectByValue> Derived();
		template <class Pred> ::Udm::DerivedAttr< ObjectByValue, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ObjectByValue, Pred>(impl); };
		::Udm::ArchetypeAttr< ObjectByValue> Archetype() const;
		::Udm::BooleanAttr abstract() const;
		::Udm::ChildrenAttr< ::PICML::Member> Member_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Member, Pred> Member_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Member, Pred>(impl, meta_Member_children); };
		::Udm::ChildrenAttr< ::PICML::MakeMemberPrivate> MakeMemberPrivate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MakeMemberPrivate, Pred> MakeMemberPrivate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MakeMemberPrivate, Pred>(impl, meta_MakeMemberPrivate_children); };
		::Udm::ChildrenAttr< ::PICML::PrivateFlag> PrivateFlag_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PrivateFlag, Pred> PrivateFlag_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PrivateFlag, Pred>(impl, meta_PrivateFlag_children); };
		::Udm::ChildrenAttr< ::PICML::FactoryOperation> FactoryOperation_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred> FactoryOperation_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred>(impl, meta_FactoryOperation_children); };
		::Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::HasExceptions> HasExceptions_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::HasExceptions, Pred> HasExceptions_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::HasExceptions, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::FactoryOperation> FactoryOperation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred> FactoryOperation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::OperationBase> OperationBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OperationBase, Pred> OperationBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OperationBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MakeMemberPrivate> MakeMemberPrivate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MakeMemberPrivate, Pred> MakeMemberPrivate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MakeMemberPrivate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PrivateFlag> PrivateFlag_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PrivateFlag, Pred> PrivateFlag_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PrivateFlag, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ArrayMember> ArrayMember_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ArrayMember, Pred> ArrayMember_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ArrayMember, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Member> Member_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Member, Pred> Member_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Member, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_abstract;
		static ::Uml::CompositionChildRole meta_Member_children;
		static ::Uml::CompositionChildRole meta_MakeMemberPrivate_children;
		static ::Uml::CompositionChildRole meta_PrivateFlag_children;
		static ::Uml::CompositionChildRole meta_FactoryOperation_children;

	};

	class PICML_Export NoInheritable :  public NamedType {
	public:
		NoInheritable();
		NoInheritable(::Udm::ObjectImpl *impl);
		NoInheritable(const NoInheritable &master);

#ifdef UDM_RVALUE
		NoInheritable(NoInheritable &&master);

		static NoInheritable Cast(::Udm::Object &&a);
		NoInheritable& operator=(NoInheritable &&a);

#endif
		static NoInheritable Cast(const ::Udm::Object &a);
		static NoInheritable Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		NoInheritable CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< NoInheritable> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< NoInheritable, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< NoInheritable, Pred>(impl); };
		NoInheritable CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< NoInheritable> Derived();
		template <class Pred> ::Udm::DerivedAttr< NoInheritable, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< NoInheritable, Pred>(impl); };
		::Udm::ArchetypeAttr< NoInheritable> Archetype() const;
		::Udm::ParentAttr< ::PICML::HasOperations> HasOperations_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_HasOperations_parent;

	};

	class PICML_Export Boxed :  public NamedType {
	public:
		Boxed();
		Boxed(::Udm::ObjectImpl *impl);
		Boxed(const Boxed &master);

#ifdef UDM_RVALUE
		Boxed(Boxed &&master);

		static Boxed Cast(::Udm::Object &&a);
		Boxed& operator=(Boxed &&a);

#endif
		static Boxed Cast(const ::Udm::Object &a);
		static Boxed Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Boxed CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Boxed> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Boxed, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Boxed, Pred>(impl); };
		Boxed CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Boxed> Derived();
		template <class Pred> ::Udm::DerivedAttr< Boxed, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Boxed, Pred>(impl); };
		::Udm::ArchetypeAttr< Boxed> Archetype() const;
		::Udm::PointerAttr< MemberType> ref() const;
		::Udm::ParentAttr< ::PICML::Prefixable> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export Alias :  public NoInheritable {
	public:
		Alias();
		Alias(::Udm::ObjectImpl *impl);
		Alias(const Alias &master);

#ifdef UDM_RVALUE
		Alias(Alias &&master);

		static Alias Cast(::Udm::Object &&a);
		Alias& operator=(Alias &&a);

#endif
		static Alias Cast(const ::Udm::Object &a);
		static Alias Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Alias CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Alias> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Alias, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Alias, Pred>(impl); };
		Alias CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Alias> Derived();
		template <class Pred> ::Udm::DerivedAttr< Alias, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Alias, Pred>(impl); };
		::Udm::ArchetypeAttr< Alias> Archetype() const;
		::Udm::PointerAttr< MemberType> ref() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export Collection :  public ComplexType,  public NoInheritable {
	public:
		Collection();
		Collection(::Udm::ObjectImpl *impl);
		Collection(const Collection &master);

#ifdef UDM_RVALUE
		Collection(Collection &&master);

		static Collection Cast(::Udm::Object &&a);
		Collection& operator=(Collection &&a);

#endif
		static Collection Cast(const ::Udm::Object &a);
		static Collection Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Collection CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Collection> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Collection, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Collection, Pred>(impl); };
		Collection CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Collection> Derived();
		template <class Pred> ::Udm::DerivedAttr< Collection, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Collection, Pred>(impl); };
		::Udm::ArchetypeAttr< Collection> Archetype() const;
		::Udm::StringAttr bound() const;
		::Udm::PointerAttr< MemberType> ref() const;
		::Udm::ParentAttr< ::PICML::ConnectorObject> ConnectorObject_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_bound;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ConnectorObject_parent;

	};

	class PICML_Export SwitchedAggregate :  public NoInheritable {
	public:
		SwitchedAggregate();
		SwitchedAggregate(::Udm::ObjectImpl *impl);
		SwitchedAggregate(const SwitchedAggregate &master);

#ifdef UDM_RVALUE
		SwitchedAggregate(SwitchedAggregate &&master);

		static SwitchedAggregate Cast(::Udm::Object &&a);
		SwitchedAggregate& operator=(SwitchedAggregate &&a);

#endif
		static SwitchedAggregate Cast(const ::Udm::Object &a);
		static SwitchedAggregate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		SwitchedAggregate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< SwitchedAggregate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< SwitchedAggregate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< SwitchedAggregate, Pred>(impl); };
		SwitchedAggregate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< SwitchedAggregate> Derived();
		template <class Pred> ::Udm::DerivedAttr< SwitchedAggregate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< SwitchedAggregate, Pred>(impl); };
		::Udm::ArchetypeAttr< SwitchedAggregate> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::LabelConnection> LabelConnection_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::LabelConnection, Pred> LabelConnection_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::LabelConnection, Pred>(impl, meta_LabelConnection_children); };
		::Udm::ChildAttr< ::PICML::Discriminator> Discriminator_child() const;
		::Udm::ChildrenAttr< ::PICML::Member> Member_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Member, Pred> Member_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Member, Pred>(impl, meta_Member_children); };
		::Udm::ChildrenAttr< ::PICML::Label> Label_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Label, Pred> Label_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Label, Pred>(impl, meta_Label_children); };
		::Udm::ChildrenAttr< ::PICML::ArrayMember> ArrayMember_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ArrayMember, Pred> ArrayMember_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ArrayMember, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Member> Member_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Member, Pred> Member_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Member, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Discriminator> Discriminator_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Discriminator, Pred> Discriminator_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Discriminator, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::LabelConnection> LabelConnection_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::LabelConnection, Pred> LabelConnection_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::LabelConnection, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Label> Label_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Label, Pred> Label_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Label, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_LabelConnection_children;
		static ::Uml::CompositionChildRole meta_Discriminator_child;
		static ::Uml::CompositionChildRole meta_Member_children;
		static ::Uml::CompositionChildRole meta_Label_children;

	};

	class PICML_Export Aggregate :  public ComplexType,  public NoInheritable {
	public:
		Aggregate();
		Aggregate(::Udm::ObjectImpl *impl);
		Aggregate(const Aggregate &master);

#ifdef UDM_RVALUE
		Aggregate(Aggregate &&master);

		static Aggregate Cast(::Udm::Object &&a);
		Aggregate& operator=(Aggregate &&a);

#endif
		static Aggregate Cast(const ::Udm::Object &a);
		static Aggregate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Aggregate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Aggregate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Aggregate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Aggregate, Pred>(impl); };
		Aggregate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Aggregate> Derived();
		template <class Pred> ::Udm::DerivedAttr< Aggregate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Aggregate, Pred>(impl); };
		::Udm::ArchetypeAttr< Aggregate> Archetype() const;
		::Udm::ChildAttr< ::PICML::Key> Key_child() const;
		::Udm::ChildrenAttr< ::PICML::KeyMember> KeyMember_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::KeyMember, Pred> KeyMember_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::KeyMember, Pred>(impl, meta_KeyMember_children); };
		::Udm::ChildrenAttr< ::PICML::Member> Member_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Member, Pred> Member_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Member, Pred>(impl, meta_Member_children); };
		::Udm::ChildrenAttr< ::PICML::Key> Key_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Key, Pred> Key_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Key, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::KeyMember> KeyMember_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::KeyMember, Pred> KeyMember_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::KeyMember, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ArrayMember> ArrayMember_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ArrayMember, Pred> ArrayMember_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ArrayMember, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Member> Member_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Member, Pred> Member_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Member, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::ConnectorObject> ConnectorObject_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Key_child;
		static ::Uml::CompositionChildRole meta_KeyMember_children;
		static ::Uml::CompositionChildRole meta_Member_children;
		static ::Uml::CompositionParentRole meta_ConnectorObject_parent;

	};

	class PICML_Export PredefinedType :  public MemberType,  public SimpleType {
	public:
		PredefinedType();
		PredefinedType(::Udm::ObjectImpl *impl);
		PredefinedType(const PredefinedType &master);

#ifdef UDM_RVALUE
		PredefinedType(PredefinedType &&master);

		static PredefinedType Cast(::Udm::Object &&a);
		PredefinedType& operator=(PredefinedType &&a);

#endif
		static PredefinedType Cast(const ::Udm::Object &a);
		static PredefinedType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PredefinedType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PredefinedType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PredefinedType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PredefinedType, Pred>(impl); };
		PredefinedType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PredefinedType> Derived();
		template <class Pred> ::Udm::DerivedAttr< PredefinedType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PredefinedType, Pred>(impl); };
		::Udm::ArchetypeAttr< PredefinedType> Archetype() const;
		::Udm::AssocAttr< Variable> referedbyVariable() const;
		template <class Pred> ::Udm::AssocAttr< Variable, Pred> referedbyVariable_sorted(const Pred &) const { return ::Udm::AssocAttr< Variable, Pred>(impl, meta_referedbyVariable); };
		::Udm::ParentAttr< ::PICML::PredefinedTypes> PredefinedTypes_parent() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyVariable;
		static ::Uml::CompositionParentRole meta_PredefinedTypes_parent;

	};

	class PICML_Export TypeKind :  public PredefinedType {
	public:
		TypeKind();
		TypeKind(::Udm::ObjectImpl *impl);
		TypeKind(const TypeKind &master);

#ifdef UDM_RVALUE
		TypeKind(TypeKind &&master);

		static TypeKind Cast(::Udm::Object &&a);
		TypeKind& operator=(TypeKind &&a);

#endif
		static TypeKind Cast(const ::Udm::Object &a);
		static TypeKind Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TypeKind CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TypeKind> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TypeKind, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TypeKind, Pred>(impl); };
		TypeKind CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TypeKind> Derived();
		template <class Pred> ::Udm::DerivedAttr< TypeKind, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TypeKind, Pred>(impl); };
		::Udm::ArchetypeAttr< TypeKind> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export TypeEncoding :  public PredefinedType {
	public:
		TypeEncoding();
		TypeEncoding(::Udm::ObjectImpl *impl);
		TypeEncoding(const TypeEncoding &master);

#ifdef UDM_RVALUE
		TypeEncoding(TypeEncoding &&master);

		static TypeEncoding Cast(::Udm::Object &&a);
		TypeEncoding& operator=(TypeEncoding &&a);

#endif
		static TypeEncoding Cast(const ::Udm::Object &a);
		static TypeEncoding Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TypeEncoding CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TypeEncoding> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TypeEncoding, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TypeEncoding, Pred>(impl); };
		TypeEncoding CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TypeEncoding> Derived();
		template <class Pred> ::Udm::DerivedAttr< TypeEncoding, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TypeEncoding, Pred>(impl); };
		::Udm::ArchetypeAttr< TypeEncoding> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export GenericValue :  public PredefinedType {
	public:
		GenericValue();
		GenericValue(::Udm::ObjectImpl *impl);
		GenericValue(const GenericValue &master);

#ifdef UDM_RVALUE
		GenericValue(GenericValue &&master);

		static GenericValue Cast(::Udm::Object &&a);
		GenericValue& operator=(GenericValue &&a);

#endif
		static GenericValue Cast(const ::Udm::Object &a);
		static GenericValue Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		GenericValue CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< GenericValue> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< GenericValue, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< GenericValue, Pred>(impl); };
		GenericValue CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< GenericValue> Derived();
		template <class Pred> ::Udm::DerivedAttr< GenericValue, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< GenericValue, Pred>(impl); };
		::Udm::ArchetypeAttr< GenericValue> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export GenericValueObject :  public PredefinedType {
	public:
		GenericValueObject();
		GenericValueObject(::Udm::ObjectImpl *impl);
		GenericValueObject(const GenericValueObject &master);

#ifdef UDM_RVALUE
		GenericValueObject(GenericValueObject &&master);

		static GenericValueObject Cast(::Udm::Object &&a);
		GenericValueObject& operator=(GenericValueObject &&a);

#endif
		static GenericValueObject Cast(const ::Udm::Object &a);
		static GenericValueObject Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		GenericValueObject CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< GenericValueObject> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< GenericValueObject, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< GenericValueObject, Pred>(impl); };
		GenericValueObject CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< GenericValueObject> Derived();
		template <class Pred> ::Udm::DerivedAttr< GenericValueObject, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< GenericValueObject, Pred>(impl); };
		::Udm::ArchetypeAttr< GenericValueObject> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export TemplateParameterReference :  public MemberType {
	public:
		TemplateParameterReference();
		TemplateParameterReference(::Udm::ObjectImpl *impl);
		TemplateParameterReference(const TemplateParameterReference &master);

#ifdef UDM_RVALUE
		TemplateParameterReference(TemplateParameterReference &&master);

		static TemplateParameterReference Cast(::Udm::Object &&a);
		TemplateParameterReference& operator=(TemplateParameterReference &&a);

#endif
		static TemplateParameterReference Cast(const ::Udm::Object &a);
		static TemplateParameterReference Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TemplateParameterReference CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TemplateParameterReference> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TemplateParameterReference, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TemplateParameterReference, Pred>(impl); };
		TemplateParameterReference CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TemplateParameterReference> Derived();
		template <class Pred> ::Udm::DerivedAttr< TemplateParameterReference, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TemplateParameterReference, Pred>(impl); };
		::Udm::ArchetypeAttr< TemplateParameterReference> Archetype() const;
		::Udm::PointerAttr< TemplateParameter> ref() const;
		::Udm::ParentAttr< ::PICML::TemplatePackageAlias> TemplatePackageAlias_parent() const;
		::Udm::ParentAttr< ::PICML::TemplatePackageAlias> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_TemplatePackageAlias_parent;

	};

	class PICML_Export ExceptionType :  virtual  public MgaObject {
	public:
		ExceptionType();
		ExceptionType(::Udm::ObjectImpl *impl);
		ExceptionType(const ExceptionType &master);

#ifdef UDM_RVALUE
		ExceptionType(ExceptionType &&master);

		static ExceptionType Cast(::Udm::Object &&a);
		ExceptionType& operator=(ExceptionType &&a);

#endif
		static ExceptionType Cast(const ::Udm::Object &a);
		static ExceptionType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ExceptionType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ExceptionType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ExceptionType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ExceptionType, Pred>(impl); };
		ExceptionType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ExceptionType> Derived();
		template <class Pred> ::Udm::DerivedAttr< ExceptionType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ExceptionType, Pred>(impl); };
		::Udm::ArchetypeAttr< ExceptionType> Archetype() const;
		::Udm::AssocAttr< ExceptionRef> referedbyExceptionRef() const;
		template <class Pred> ::Udm::AssocAttr< ExceptionRef, Pred> referedbyExceptionRef_sorted(const Pred &) const { return ::Udm::AssocAttr< ExceptionRef, Pred>(impl, meta_referedbyExceptionRef); };
		::Udm::AssocAttr< GetException> referedbyGetException() const;
		template <class Pred> ::Udm::AssocAttr< GetException, Pred> referedbyGetException_sorted(const Pred &) const { return ::Udm::AssocAttr< GetException, Pred>(impl, meta_referedbyGetException); };
		::Udm::AssocAttr< SetException> referedbySetException() const;
		template <class Pred> ::Udm::AssocAttr< SetException, Pred> referedbySetException_sorted(const Pred &) const { return ::Udm::AssocAttr< SetException, Pred>(impl, meta_referedbySetException); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyExceptionRef;
		static ::Uml::AssociationRole meta_referedbyGetException;
		static ::Uml::AssociationRole meta_referedbySetException;

	};

	class PICML_Export NativeValue :  public MgaObject {
	public:
		NativeValue();
		NativeValue(::Udm::ObjectImpl *impl);
		NativeValue(const NativeValue &master);

#ifdef UDM_RVALUE
		NativeValue(NativeValue &&master);

		static NativeValue Cast(::Udm::Object &&a);
		NativeValue& operator=(NativeValue &&a);

#endif
		static NativeValue Cast(const ::Udm::Object &a);
		static NativeValue Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		NativeValue CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< NativeValue> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< NativeValue, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< NativeValue, Pred>(impl); };
		NativeValue CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< NativeValue> Derived();
		template <class Pred> ::Udm::DerivedAttr< NativeValue, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< NativeValue, Pred>(impl); };
		::Udm::ArchetypeAttr< NativeValue> Archetype() const;
		::Udm::ParentAttr< ::PICML::File> File_parent() const;
		::Udm::ParentAttr< ::PICML::Package> Package_parent() const;
		::Udm::ParentAttr< ::PICML::Prefixable> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_File_parent;
		static ::Uml::CompositionParentRole meta_Package_parent;

	};

	class PICML_Export TemplateParameterValue :  public MgaObject {
	public:
		TemplateParameterValue();
		TemplateParameterValue(::Udm::ObjectImpl *impl);
		TemplateParameterValue(const TemplateParameterValue &master);

#ifdef UDM_RVALUE
		TemplateParameterValue(TemplateParameterValue &&master);

		static TemplateParameterValue Cast(::Udm::Object &&a);
		TemplateParameterValue& operator=(TemplateParameterValue &&a);

#endif
		static TemplateParameterValue Cast(const ::Udm::Object &a);
		static TemplateParameterValue Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TemplateParameterValue CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TemplateParameterValue> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TemplateParameterValue, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TemplateParameterValue, Pred>(impl); };
		TemplateParameterValue CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TemplateParameterValue> Derived();
		template <class Pred> ::Udm::DerivedAttr< TemplateParameterValue, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TemplateParameterValue, Pred>(impl); };
		::Udm::ArchetypeAttr< TemplateParameterValue> Archetype() const;
		::Udm::PointerAttr< TemplateParameterValueType> ref() const;
		::Udm::ParentAttr< ::PICML::TemplatePackageInstance> TemplatePackageInstance_parent() const;
		::Udm::ParentAttr< ::PICML::TemplatePackageInstance> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_TemplatePackageInstance_parent;

	};

	class PICML_Export PackageType :  public MgaObject {
	public:
		PackageType();
		PackageType(::Udm::ObjectImpl *impl);
		PackageType(const PackageType &master);

#ifdef UDM_RVALUE
		PackageType(PackageType &&master);

		static PackageType Cast(::Udm::Object &&a);
		PackageType& operator=(PackageType &&a);

#endif
		static PackageType Cast(const ::Udm::Object &a);
		static PackageType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PackageType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PackageType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PackageType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PackageType, Pred>(impl); };
		PackageType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PackageType> Derived();
		template <class Pred> ::Udm::DerivedAttr< PackageType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PackageType, Pred>(impl); };
		::Udm::ArchetypeAttr< PackageType> Archetype() const;
		::Udm::PointerAttr< Package> ref() const;
		::Udm::ParentAttr< ::PICML::TemplatePackageAlias> TemplatePackageAlias_parent() const;
		::Udm::ParentAttr< ::PICML::TemplatePackageInstance> TemplatePackageInstance_parent() const;
		::Udm::ParentAttr< ::PICML::Package> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_TemplatePackageAlias_parent;
		static ::Uml::CompositionParentRole meta_TemplatePackageInstance_parent;

	};

	class PICML_Export Constant :  public Taggable {
	public:
		Constant();
		Constant(::Udm::ObjectImpl *impl);
		Constant(const Constant &master);

#ifdef UDM_RVALUE
		Constant(Constant &&master);

		static Constant Cast(::Udm::Object &&a);
		Constant& operator=(Constant &&a);

#endif
		static Constant Cast(const ::Udm::Object &a);
		static Constant Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Constant CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Constant> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Constant, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Constant, Pred>(impl); };
		Constant CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Constant> Derived();
		template <class Pred> ::Udm::DerivedAttr< Constant, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Constant, Pred>(impl); };
		::Udm::ArchetypeAttr< Constant> Archetype() const;
		::Udm::StringAttr value() const;
		::Udm::PointerAttr< ConstantType> ref() const;
		::Udm::ParentAttr< ::PICML::HasOperations> HasOperations_parent() const;
		::Udm::ParentAttr< ::PICML::File> File_parent() const;
		::Udm::ParentAttr< ::PICML::Package> Package_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_value;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_HasOperations_parent;
		static ::Uml::CompositionParentRole meta_File_parent;
		static ::Uml::CompositionParentRole meta_Package_parent;

	};

	class PICML_Export ConstantType :  virtual  public MgaObject {
	public:
		ConstantType();
		ConstantType(::Udm::ObjectImpl *impl);
		ConstantType(const ConstantType &master);

#ifdef UDM_RVALUE
		ConstantType(ConstantType &&master);

		static ConstantType Cast(::Udm::Object &&a);
		ConstantType& operator=(ConstantType &&a);

#endif
		static ConstantType Cast(const ::Udm::Object &a);
		static ConstantType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ConstantType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ConstantType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ConstantType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ConstantType, Pred>(impl); };
		ConstantType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ConstantType> Derived();
		template <class Pred> ::Udm::DerivedAttr< ConstantType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ConstantType, Pred>(impl); };
		::Udm::ArchetypeAttr< ConstantType> Archetype() const;
		::Udm::AssocAttr< Discriminator> referedbyDiscriminator() const;
		template <class Pred> ::Udm::AssocAttr< Discriminator, Pred> referedbyDiscriminator_sorted(const Pred &) const { return ::Udm::AssocAttr< Discriminator, Pred>(impl, meta_referedbyDiscriminator); };
		::Udm::AssocAttr< Constant> referedbyConstant() const;
		template <class Pred> ::Udm::AssocAttr< Constant, Pred> referedbyConstant_sorted(const Pred &) const { return ::Udm::AssocAttr< Constant, Pred>(impl, meta_referedbyConstant); };
		::Udm::ParentAttr< ::Udm::Object> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyDiscriminator;
		static ::Uml::AssociationRole meta_referedbyConstant;

	};

	class PICML_Export Enum :  public ConstantType,  public NoInheritable,  public SimpleType {
	public:
		Enum();
		Enum(::Udm::ObjectImpl *impl);
		Enum(const Enum &master);

#ifdef UDM_RVALUE
		Enum(Enum &&master);

		static Enum Cast(::Udm::Object &&a);
		Enum& operator=(Enum &&a);

#endif
		static Enum Cast(const ::Udm::Object &a);
		static Enum Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Enum CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Enum> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Enum, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Enum, Pred>(impl); };
		Enum CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Enum> Derived();
		template <class Pred> ::Udm::DerivedAttr< Enum, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Enum, Pred>(impl); };
		::Udm::ArchetypeAttr< Enum> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::EnumValue> EnumValue_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::EnumValue, Pred> EnumValue_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::EnumValue, Pred>(impl, meta_EnumValue_children); };
		::Udm::ChildrenAttr< ::PICML::EnumValue> EnumValue_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::EnumValue, Pred> EnumValue_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::EnumValue, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_EnumValue_children;

	};

	class PICML_Export StringType :  public ConstantType,  public PredefinedType {
	public:
		StringType();
		StringType(::Udm::ObjectImpl *impl);
		StringType(const StringType &master);

#ifdef UDM_RVALUE
		StringType(StringType &&master);

		static StringType Cast(::Udm::Object &&a);
		StringType& operator=(StringType &&a);

#endif
		static StringType Cast(const ::Udm::Object &a);
		static StringType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		StringType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< StringType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< StringType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< StringType, Pred>(impl); };
		StringType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< StringType> Derived();
		template <class Pred> ::Udm::DerivedAttr< StringType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< StringType, Pred>(impl); };
		::Udm::ArchetypeAttr< StringType> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;

		static ::Uml::Class meta;

	};

	class PICML_Export WideString :  public StringType {
	public:
		WideString();
		WideString(::Udm::ObjectImpl *impl);
		WideString(const WideString &master);

#ifdef UDM_RVALUE
		WideString(WideString &&master);

		static WideString Cast(::Udm::Object &&a);
		WideString& operator=(WideString &&a);

#endif
		static WideString Cast(const ::Udm::Object &a);
		static WideString Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		WideString CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< WideString> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< WideString, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< WideString, Pred>(impl); };
		WideString CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< WideString> Derived();
		template <class Pred> ::Udm::DerivedAttr< WideString, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< WideString, Pred>(impl); };
		::Udm::ArchetypeAttr< WideString> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export CharType :  public ConstantType,  public PredefinedType {
	public:
		CharType();
		CharType(::Udm::ObjectImpl *impl);
		CharType(const CharType &master);

#ifdef UDM_RVALUE
		CharType(CharType &&master);

		static CharType Cast(::Udm::Object &&a);
		CharType& operator=(CharType &&a);

#endif
		static CharType Cast(const ::Udm::Object &a);
		static CharType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		CharType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< CharType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< CharType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< CharType, Pred>(impl); };
		CharType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< CharType> Derived();
		template <class Pred> ::Udm::DerivedAttr< CharType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< CharType, Pred>(impl); };
		::Udm::ArchetypeAttr< CharType> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;

		static ::Uml::Class meta;

	};

	class PICML_Export Char :  public CharType {
	public:
		Char();
		Char(::Udm::ObjectImpl *impl);
		Char(const Char &master);

#ifdef UDM_RVALUE
		Char(Char &&master);

		static Char Cast(::Udm::Object &&a);
		Char& operator=(Char &&a);

#endif
		static Char Cast(const ::Udm::Object &a);
		static Char Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Char CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Char> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Char, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Char, Pred>(impl); };
		Char CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Char> Derived();
		template <class Pred> ::Udm::DerivedAttr< Char, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Char, Pred>(impl); };
		::Udm::ArchetypeAttr< Char> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export WideChar :  public CharType {
	public:
		WideChar();
		WideChar(::Udm::ObjectImpl *impl);
		WideChar(const WideChar &master);

#ifdef UDM_RVALUE
		WideChar(WideChar &&master);

		static WideChar Cast(::Udm::Object &&a);
		WideChar& operator=(WideChar &&a);

#endif
		static WideChar Cast(const ::Udm::Object &a);
		static WideChar Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		WideChar CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< WideChar> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< WideChar, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< WideChar, Pred>(impl); };
		WideChar CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< WideChar> Derived();
		template <class Pred> ::Udm::DerivedAttr< WideChar, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< WideChar, Pred>(impl); };
		::Udm::ArchetypeAttr< WideChar> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export IntegerType :  public ConstantType,  public PredefinedType {
	public:
		IntegerType();
		IntegerType(::Udm::ObjectImpl *impl);
		IntegerType(const IntegerType &master);

#ifdef UDM_RVALUE
		IntegerType(IntegerType &&master);

		static IntegerType Cast(::Udm::Object &&a);
		IntegerType& operator=(IntegerType &&a);

#endif
		static IntegerType Cast(const ::Udm::Object &a);
		static IntegerType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		IntegerType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< IntegerType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< IntegerType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< IntegerType, Pred>(impl); };
		IntegerType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< IntegerType> Derived();
		template <class Pred> ::Udm::DerivedAttr< IntegerType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< IntegerType, Pred>(impl); };
		::Udm::ArchetypeAttr< IntegerType> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;

		static ::Uml::Class meta;

	};

	class PICML_Export UnsignedIntegerType :  public IntegerType {
	public:
		UnsignedIntegerType();
		UnsignedIntegerType(::Udm::ObjectImpl *impl);
		UnsignedIntegerType(const UnsignedIntegerType &master);

#ifdef UDM_RVALUE
		UnsignedIntegerType(UnsignedIntegerType &&master);

		static UnsignedIntegerType Cast(::Udm::Object &&a);
		UnsignedIntegerType& operator=(UnsignedIntegerType &&a);

#endif
		static UnsignedIntegerType Cast(const ::Udm::Object &a);
		static UnsignedIntegerType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		UnsignedIntegerType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< UnsignedIntegerType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< UnsignedIntegerType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< UnsignedIntegerType, Pred>(impl); };
		UnsignedIntegerType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< UnsignedIntegerType> Derived();
		template <class Pred> ::Udm::DerivedAttr< UnsignedIntegerType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< UnsignedIntegerType, Pred>(impl); };
		::Udm::ArchetypeAttr< UnsignedIntegerType> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;

		static ::Uml::Class meta;

	};

	class PICML_Export UnsignedShortInteger :  public UnsignedIntegerType {
	public:
		UnsignedShortInteger();
		UnsignedShortInteger(::Udm::ObjectImpl *impl);
		UnsignedShortInteger(const UnsignedShortInteger &master);

#ifdef UDM_RVALUE
		UnsignedShortInteger(UnsignedShortInteger &&master);

		static UnsignedShortInteger Cast(::Udm::Object &&a);
		UnsignedShortInteger& operator=(UnsignedShortInteger &&a);

#endif
		static UnsignedShortInteger Cast(const ::Udm::Object &a);
		static UnsignedShortInteger Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		UnsignedShortInteger CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< UnsignedShortInteger> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< UnsignedShortInteger, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< UnsignedShortInteger, Pred>(impl); };
		UnsignedShortInteger CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< UnsignedShortInteger> Derived();
		template <class Pred> ::Udm::DerivedAttr< UnsignedShortInteger, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< UnsignedShortInteger, Pred>(impl); };
		::Udm::ArchetypeAttr< UnsignedShortInteger> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export UnsignedLongLongInteger :  public UnsignedIntegerType {
	public:
		UnsignedLongLongInteger();
		UnsignedLongLongInteger(::Udm::ObjectImpl *impl);
		UnsignedLongLongInteger(const UnsignedLongLongInteger &master);

#ifdef UDM_RVALUE
		UnsignedLongLongInteger(UnsignedLongLongInteger &&master);

		static UnsignedLongLongInteger Cast(::Udm::Object &&a);
		UnsignedLongLongInteger& operator=(UnsignedLongLongInteger &&a);

#endif
		static UnsignedLongLongInteger Cast(const ::Udm::Object &a);
		static UnsignedLongLongInteger Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		UnsignedLongLongInteger CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< UnsignedLongLongInteger> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< UnsignedLongLongInteger, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< UnsignedLongLongInteger, Pred>(impl); };
		UnsignedLongLongInteger CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< UnsignedLongLongInteger> Derived();
		template <class Pred> ::Udm::DerivedAttr< UnsignedLongLongInteger, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< UnsignedLongLongInteger, Pred>(impl); };
		::Udm::ArchetypeAttr< UnsignedLongLongInteger> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export UnsignedLongInteger :  public UnsignedIntegerType {
	public:
		UnsignedLongInteger();
		UnsignedLongInteger(::Udm::ObjectImpl *impl);
		UnsignedLongInteger(const UnsignedLongInteger &master);

#ifdef UDM_RVALUE
		UnsignedLongInteger(UnsignedLongInteger &&master);

		static UnsignedLongInteger Cast(::Udm::Object &&a);
		UnsignedLongInteger& operator=(UnsignedLongInteger &&a);

#endif
		static UnsignedLongInteger Cast(const ::Udm::Object &a);
		static UnsignedLongInteger Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		UnsignedLongInteger CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< UnsignedLongInteger> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< UnsignedLongInteger, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< UnsignedLongInteger, Pred>(impl); };
		UnsignedLongInteger CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< UnsignedLongInteger> Derived();
		template <class Pred> ::Udm::DerivedAttr< UnsignedLongInteger, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< UnsignedLongInteger, Pred>(impl); };
		::Udm::ArchetypeAttr< UnsignedLongInteger> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export SignedIntegerType :  public IntegerType {
	public:
		SignedIntegerType();
		SignedIntegerType(::Udm::ObjectImpl *impl);
		SignedIntegerType(const SignedIntegerType &master);

#ifdef UDM_RVALUE
		SignedIntegerType(SignedIntegerType &&master);

		static SignedIntegerType Cast(::Udm::Object &&a);
		SignedIntegerType& operator=(SignedIntegerType &&a);

#endif
		static SignedIntegerType Cast(const ::Udm::Object &a);
		static SignedIntegerType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		SignedIntegerType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< SignedIntegerType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< SignedIntegerType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< SignedIntegerType, Pred>(impl); };
		SignedIntegerType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< SignedIntegerType> Derived();
		template <class Pred> ::Udm::DerivedAttr< SignedIntegerType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< SignedIntegerType, Pred>(impl); };
		::Udm::ArchetypeAttr< SignedIntegerType> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;

		static ::Uml::Class meta;

	};

	class PICML_Export LongLongInteger :  public SignedIntegerType {
	public:
		LongLongInteger();
		LongLongInteger(::Udm::ObjectImpl *impl);
		LongLongInteger(const LongLongInteger &master);

#ifdef UDM_RVALUE
		LongLongInteger(LongLongInteger &&master);

		static LongLongInteger Cast(::Udm::Object &&a);
		LongLongInteger& operator=(LongLongInteger &&a);

#endif
		static LongLongInteger Cast(const ::Udm::Object &a);
		static LongLongInteger Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		LongLongInteger CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< LongLongInteger> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< LongLongInteger, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< LongLongInteger, Pred>(impl); };
		LongLongInteger CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< LongLongInteger> Derived();
		template <class Pred> ::Udm::DerivedAttr< LongLongInteger, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< LongLongInteger, Pred>(impl); };
		::Udm::ArchetypeAttr< LongLongInteger> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export FloatingPointType :  public ConstantType,  public PredefinedType {
	public:
		FloatingPointType();
		FloatingPointType(::Udm::ObjectImpl *impl);
		FloatingPointType(const FloatingPointType &master);

#ifdef UDM_RVALUE
		FloatingPointType(FloatingPointType &&master);

		static FloatingPointType Cast(::Udm::Object &&a);
		FloatingPointType& operator=(FloatingPointType &&a);

#endif
		static FloatingPointType Cast(const ::Udm::Object &a);
		static FloatingPointType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		FloatingPointType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< FloatingPointType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< FloatingPointType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< FloatingPointType, Pred>(impl); };
		FloatingPointType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< FloatingPointType> Derived();
		template <class Pred> ::Udm::DerivedAttr< FloatingPointType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< FloatingPointType, Pred>(impl); };
		::Udm::ArchetypeAttr< FloatingPointType> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;

		static ::Uml::Class meta;

	};

	class PICML_Export LongDoubleNumber :  public FloatingPointType {
	public:
		LongDoubleNumber();
		LongDoubleNumber(::Udm::ObjectImpl *impl);
		LongDoubleNumber(const LongDoubleNumber &master);

#ifdef UDM_RVALUE
		LongDoubleNumber(LongDoubleNumber &&master);

		static LongDoubleNumber Cast(::Udm::Object &&a);
		LongDoubleNumber& operator=(LongDoubleNumber &&a);

#endif
		static LongDoubleNumber Cast(const ::Udm::Object &a);
		static LongDoubleNumber Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		LongDoubleNumber CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< LongDoubleNumber> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< LongDoubleNumber, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< LongDoubleNumber, Pred>(impl); };
		LongDoubleNumber CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< LongDoubleNumber> Derived();
		template <class Pred> ::Udm::DerivedAttr< LongDoubleNumber, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< LongDoubleNumber, Pred>(impl); };
		::Udm::ArchetypeAttr< LongDoubleNumber> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export DoubleNumber :  public FloatingPointType {
	public:
		DoubleNumber();
		DoubleNumber(::Udm::ObjectImpl *impl);
		DoubleNumber(const DoubleNumber &master);

#ifdef UDM_RVALUE
		DoubleNumber(DoubleNumber &&master);

		static DoubleNumber Cast(::Udm::Object &&a);
		DoubleNumber& operator=(DoubleNumber &&a);

#endif
		static DoubleNumber Cast(const ::Udm::Object &a);
		static DoubleNumber Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		DoubleNumber CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< DoubleNumber> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< DoubleNumber, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< DoubleNumber, Pred>(impl); };
		DoubleNumber CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< DoubleNumber> Derived();
		template <class Pred> ::Udm::DerivedAttr< DoubleNumber, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< DoubleNumber, Pred>(impl); };
		::Udm::ArchetypeAttr< DoubleNumber> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export String :  public StringType {
	public:
		String();
		String(::Udm::ObjectImpl *impl);
		String(const String &master);

#ifdef UDM_RVALUE
		String(String &&master);

		static String Cast(::Udm::Object &&a);
		String& operator=(String &&a);

#endif
		static String Cast(const ::Udm::Object &a);
		static String Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		String CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< String> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< String, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< String, Pred>(impl); };
		String CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< String> Derived();
		template <class Pred> ::Udm::DerivedAttr< String, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< String, Pred>(impl); };
		::Udm::ArchetypeAttr< String> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export FloatNumber :  public FloatingPointType {
	public:
		FloatNumber();
		FloatNumber(::Udm::ObjectImpl *impl);
		FloatNumber(const FloatNumber &master);

#ifdef UDM_RVALUE
		FloatNumber(FloatNumber &&master);

		static FloatNumber Cast(::Udm::Object &&a);
		FloatNumber& operator=(FloatNumber &&a);

#endif
		static FloatNumber Cast(const ::Udm::Object &a);
		static FloatNumber Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		FloatNumber CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< FloatNumber> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< FloatNumber, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< FloatNumber, Pred>(impl); };
		FloatNumber CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< FloatNumber> Derived();
		template <class Pred> ::Udm::DerivedAttr< FloatNumber, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< FloatNumber, Pred>(impl); };
		::Udm::ArchetypeAttr< FloatNumber> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export LongInteger :  public SignedIntegerType {
	public:
		LongInteger();
		LongInteger(::Udm::ObjectImpl *impl);
		LongInteger(const LongInteger &master);

#ifdef UDM_RVALUE
		LongInteger(LongInteger &&master);

		static LongInteger Cast(::Udm::Object &&a);
		LongInteger& operator=(LongInteger &&a);

#endif
		static LongInteger Cast(const ::Udm::Object &a);
		static LongInteger Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		LongInteger CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< LongInteger> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< LongInteger, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< LongInteger, Pred>(impl); };
		LongInteger CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< LongInteger> Derived();
		template <class Pred> ::Udm::DerivedAttr< LongInteger, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< LongInteger, Pred>(impl); };
		::Udm::ArchetypeAttr< LongInteger> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export ShortInteger :  public SignedIntegerType {
	public:
		ShortInteger();
		ShortInteger(::Udm::ObjectImpl *impl);
		ShortInteger(const ShortInteger &master);

#ifdef UDM_RVALUE
		ShortInteger(ShortInteger &&master);

		static ShortInteger Cast(::Udm::Object &&a);
		ShortInteger& operator=(ShortInteger &&a);

#endif
		static ShortInteger Cast(const ::Udm::Object &a);
		static ShortInteger Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ShortInteger CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ShortInteger> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ShortInteger, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ShortInteger, Pred>(impl); };
		ShortInteger CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ShortInteger> Derived();
		template <class Pred> ::Udm::DerivedAttr< ShortInteger, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ShortInteger, Pred>(impl); };
		::Udm::ArchetypeAttr< ShortInteger> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export Boolean :  public ConstantType,  public PredefinedType {
	public:
		Boolean();
		Boolean(::Udm::ObjectImpl *impl);
		Boolean(const Boolean &master);

#ifdef UDM_RVALUE
		Boolean(Boolean &&master);

		static Boolean Cast(::Udm::Object &&a);
		Boolean& operator=(Boolean &&a);

#endif
		static Boolean Cast(const ::Udm::Object &a);
		static Boolean Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Boolean CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Boolean> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Boolean, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Boolean, Pred>(impl); };
		Boolean CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Boolean> Derived();
		template <class Pred> ::Udm::DerivedAttr< Boolean, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Boolean, Pred>(impl); };
		::Udm::ArchetypeAttr< Boolean> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export Byte :  public ConstantType,  public PredefinedType {
	public:
		Byte();
		Byte(::Udm::ObjectImpl *impl);
		Byte(const Byte &master);

#ifdef UDM_RVALUE
		Byte(Byte &&master);

		static Byte Cast(::Udm::Object &&a);
		Byte& operator=(Byte &&a);

#endif
		static Byte Cast(const ::Udm::Object &a);
		static Byte Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Byte CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Byte> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Byte, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Byte, Pred>(impl); };
		Byte CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Byte> Derived();
		template <class Pred> ::Udm::DerivedAttr< Byte, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Byte, Pred>(impl); };
		::Udm::ArchetypeAttr< Byte> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export FileRef :  public MgaObject {
	public:
		FileRef();
		FileRef(::Udm::ObjectImpl *impl);
		FileRef(const FileRef &master);

#ifdef UDM_RVALUE
		FileRef(FileRef &&master);

		static FileRef Cast(::Udm::Object &&a);
		FileRef& operator=(FileRef &&a);

#endif
		static FileRef Cast(const ::Udm::Object &a);
		static FileRef Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		FileRef CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< FileRef> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< FileRef, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< FileRef, Pred>(impl); };
		FileRef CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< FileRef> Derived();
		template <class Pred> ::Udm::DerivedAttr< FileRef, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< FileRef, Pred>(impl); };
		::Udm::ArchetypeAttr< FileRef> Archetype() const;
		::Udm::PointerAttr< File> ref() const;
		::Udm::ParentAttr< ::PICML::File> File_parent() const;
		::Udm::ParentAttr< ::PICML::ServantProject> ServantProject_parent() const;
		::Udm::ParentAttr< ::PICML::StubProject> StubProject_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_File_parent;
		static ::Uml::CompositionParentRole meta_ServantProject_parent;
		static ::Uml::CompositionParentRole meta_StubProject_parent;

	};

	class PICML_Export Exception :  public ExceptionType,  public Taggable,  public TemplateParameterValueType {
	public:
		Exception();
		Exception(::Udm::ObjectImpl *impl);
		Exception(const Exception &master);

#ifdef UDM_RVALUE
		Exception(Exception &&master);

		static Exception Cast(::Udm::Object &&a);
		Exception& operator=(Exception &&a);

#endif
		static Exception Cast(const ::Udm::Object &a);
		static Exception Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Exception CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Exception> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Exception, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Exception, Pred>(impl); };
		Exception CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Exception> Derived();
		template <class Pred> ::Udm::DerivedAttr< Exception, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Exception, Pred>(impl); };
		::Udm::ArchetypeAttr< Exception> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::Member> Member_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Member, Pred> Member_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Member, Pred>(impl, meta_Member_children); };
		::Udm::ChildrenAttr< ::PICML::ArrayMember> ArrayMember_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ArrayMember, Pred> ArrayMember_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ArrayMember, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Member> Member_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Member, Pred> Member_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Member, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::HasOperations> HasOperations_parent() const;
		::Udm::ParentAttr< ::PICML::File> File_parent() const;
		::Udm::ParentAttr< ::PICML::Package> Package_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Member_children;
		static ::Uml::CompositionParentRole meta_HasOperations_parent;
		static ::Uml::CompositionParentRole meta_File_parent;
		static ::Uml::CompositionParentRole meta_Package_parent;

	};

	class PICML_Export File :  public Prefixable {
	public:
		File();
		File(::Udm::ObjectImpl *impl);
		File(const File &master);

#ifdef UDM_RVALUE
		File(File &&master);

		static File Cast(::Udm::Object &&a);
		File& operator=(File &&a);

#endif
		static File Cast(const ::Udm::Object &a);
		static File Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		File CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< File> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< File, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< File, Pred>(impl); };
		File CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< File> Derived();
		template <class Pred> ::Udm::DerivedAttr< File, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< File, Pred>(impl); };
		::Udm::ArchetypeAttr< File> Archetype() const;
		::Udm::StringAttr Path() const;
		::Udm::AssocAttr< FileRef> referedbyFileRef() const;
		template <class Pred> ::Udm::AssocAttr< FileRef, Pred> referedbyFileRef_sorted(const Pred &) const { return ::Udm::AssocAttr< FileRef, Pred>(impl, meta_referedbyFileRef); };
		::Udm::ChildrenAttr< ::PICML::NativeValue> NativeValue_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NativeValue, Pred> NativeValue_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NativeValue, Pred>(impl, meta_NativeValue_children); };
		::Udm::ChildrenAttr< ::PICML::ManagesComponent> ManagesComponent_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ManagesComponent, Pred> ManagesComponent_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ManagesComponent, Pred>(impl, meta_ManagesComponent_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, meta_ComponentRef_children); };
		::Udm::ChildrenAttr< ::PICML::NamedType> NamedType_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NamedType, Pred> NamedType_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NamedType, Pred>(impl, meta_NamedType_children); };
		::Udm::ChildrenAttr< ::PICML::Constant> Constant_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Constant, Pred> Constant_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Constant, Pred>(impl, meta_Constant_children); };
		::Udm::ChildrenAttr< ::PICML::FileRef> FileRef_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::FileRef, Pred> FileRef_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::FileRef, Pred>(impl, meta_FileRef_children); };
		::Udm::ChildrenAttr< ::PICML::Exception> Exception_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Exception, Pred> Exception_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Exception, Pred>(impl, meta_Exception_children); };
		::Udm::ChildrenAttr< ::PICML::Package> Package_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Package, Pred> Package_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Package, Pred>(impl, meta_Package_children); };
		::Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Prefixable> Prefixable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Prefixable, Pred> Prefixable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Prefixable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ObjectByValue> ObjectByValue_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ObjectByValue, Pred> ObjectByValue_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ObjectByValue, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::HasOperations> HasOperations_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::HasOperations, Pred> HasOperations_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::HasOperations, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Inheritable> Inheritable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Inheritable, Pred> Inheritable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Inheritable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ValueObject> ValueObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ValueObject, Pred> ValueObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ValueObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Event> Event_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Event, Pred> Event_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Event, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Object> Object_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Object, Pred> Object_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Object, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::NoInheritable> NoInheritable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NoInheritable, Pred> NoInheritable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NoInheritable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Boxed> Boxed_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Boxed, Pred> Boxed_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Boxed, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Alias> Alias_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Alias, Pred> Alias_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Alias, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Collection> Collection_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Collection, Pred> Collection_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Collection, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::NamedType> NamedType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NamedType, Pred> NamedType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NamedType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MemberType> MemberType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MemberType, Pred> MemberType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MemberType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SwitchedAggregate> SwitchedAggregate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SwitchedAggregate, Pred> SwitchedAggregate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SwitchedAggregate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Aggregate> Aggregate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Aggregate, Pred> Aggregate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Aggregate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Enum> Enum_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Enum, Pred> Enum_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Enum, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TemplatePackageAlias> TemplatePackageAlias_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplatePackageAlias, Pred> TemplatePackageAlias_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplatePackageAlias, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType> TemplateParameterValueType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType, Pred> TemplateParameterValueType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExceptionType> ExceptionType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExceptionType, Pred> ExceptionType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExceptionType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::NativeValue> NativeValue_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NativeValue, Pred> NativeValue_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NativeValue, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TemplatePackageInstance> TemplatePackageInstance_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplatePackageInstance, Pred> TemplatePackageInstance_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplatePackageInstance, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Constant> Constant_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Constant, Pred> Constant_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Constant, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::FileRef> FileRef_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::FileRef, Pred> FileRef_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::FileRef, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Exception> Exception_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Exception, Pred> Exception_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Exception, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Package> Package_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Package, Pred> Package_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Package, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PortType> PortType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PortType, Pred> PortType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PortType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ManagesComponent> ManagesComponent_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ManagesComponent, Pred> ManagesComponent_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ManagesComponent, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentFactory> ComponentFactory_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentFactory, Pred> ComponentFactory_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentFactory, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Manageable> Manageable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Manageable, Pred> Manageable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Manageable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Component> Component_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Component, Pred> Component_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Component, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ConnectorObject> ConnectorObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorObject, Pred> ConnectorObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::InterfaceDefinitions> InterfaceDefinitions_parent() const;
		::Udm::ParentAttr< ::PICML::InterfaceDefinitions> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Path;
		static ::Uml::AssociationRole meta_referedbyFileRef;
		static ::Uml::CompositionChildRole meta_NativeValue_children;
		static ::Uml::CompositionChildRole meta_ManagesComponent_children;
		static ::Uml::CompositionChildRole meta_ComponentRef_children;
		static ::Uml::CompositionChildRole meta_NamedType_children;
		static ::Uml::CompositionChildRole meta_Constant_children;
		static ::Uml::CompositionChildRole meta_FileRef_children;
		static ::Uml::CompositionChildRole meta_Exception_children;
		static ::Uml::CompositionChildRole meta_Package_children;
		static ::Uml::CompositionParentRole meta_InterfaceDefinitions_parent;

	};

	class PICML_Export Package :  public Prefixable,  public Taggable {
	public:
		Package();
		Package(::Udm::ObjectImpl *impl);
		Package(const Package &master);

#ifdef UDM_RVALUE
		Package(Package &&master);

		static Package Cast(::Udm::Object &&a);
		Package& operator=(Package &&a);

#endif
		static Package Cast(const ::Udm::Object &a);
		static Package Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Package CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Package> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Package, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Package, Pred>(impl); };
		Package CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Package> Derived();
		template <class Pred> ::Udm::DerivedAttr< Package, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Package, Pred>(impl); };
		::Udm::ArchetypeAttr< Package> Archetype() const;
		::Udm::AssocAttr< PackageType> referedbyPackageType() const;
		template <class Pred> ::Udm::AssocAttr< PackageType, Pred> referedbyPackageType_sorted(const Pred &) const { return ::Udm::AssocAttr< PackageType, Pred>(impl, meta_referedbyPackageType); };
		::Udm::ChildrenAttr< ::PICML::NativeValue> NativeValue_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NativeValue, Pred> NativeValue_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NativeValue, Pred>(impl, meta_NativeValue_children); };
		::Udm::ChildrenAttr< ::PICML::TemplateParameter> TemplateParameter_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplateParameter, Pred> TemplateParameter_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplateParameter, Pred>(impl, meta_TemplateParameter_children); };
		::Udm::ChildrenAttr< ::PICML::ManagesComponent> ManagesComponent_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ManagesComponent, Pred> ManagesComponent_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ManagesComponent, Pred>(impl, meta_ManagesComponent_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, meta_ComponentRef_children); };
		::Udm::ChildrenAttr< ::PICML::NamedType> NamedType_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NamedType, Pred> NamedType_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NamedType, Pred>(impl, meta_NamedType_children); };
		::Udm::ChildrenAttr< ::PICML::Constant> Constant_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Constant, Pred> Constant_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Constant, Pred>(impl, meta_Constant_children); };
		::Udm::ChildrenAttr< ::PICML::Exception> Exception_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Exception, Pred> Exception_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Exception, Pred>(impl, meta_Exception_children); };
		::Udm::ChildrenAttr< ::PICML::Package> Package_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Package, Pred> Package_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Package, Pred>(impl, meta_Package_children); };
		::Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Prefixable> Prefixable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Prefixable, Pred> Prefixable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Prefixable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ObjectByValue> ObjectByValue_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ObjectByValue, Pred> ObjectByValue_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ObjectByValue, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::HasOperations> HasOperations_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::HasOperations, Pred> HasOperations_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::HasOperations, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Inheritable> Inheritable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Inheritable, Pred> Inheritable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Inheritable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ValueObject> ValueObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ValueObject, Pred> ValueObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ValueObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Event> Event_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Event, Pred> Event_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Event, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Object> Object_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Object, Pred> Object_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Object, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::NoInheritable> NoInheritable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NoInheritable, Pred> NoInheritable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NoInheritable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Boxed> Boxed_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Boxed, Pred> Boxed_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Boxed, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Alias> Alias_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Alias, Pred> Alias_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Alias, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Collection> Collection_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Collection, Pred> Collection_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Collection, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::NamedType> NamedType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NamedType, Pred> NamedType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NamedType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MemberType> MemberType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MemberType, Pred> MemberType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MemberType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SwitchedAggregate> SwitchedAggregate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SwitchedAggregate, Pred> SwitchedAggregate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SwitchedAggregate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Aggregate> Aggregate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Aggregate, Pred> Aggregate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Aggregate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Enum> Enum_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Enum, Pred> Enum_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Enum, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TemplatePackageAlias> TemplatePackageAlias_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplatePackageAlias, Pred> TemplatePackageAlias_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplatePackageAlias, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType> TemplateParameterValueType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType, Pred> TemplateParameterValueType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExceptionType> ExceptionType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExceptionType, Pred> ExceptionType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExceptionType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::NativeValue> NativeValue_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NativeValue, Pred> NativeValue_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NativeValue, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TypeParameter> TypeParameter_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TypeParameter, Pred> TypeParameter_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TypeParameter, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TemplateParameter> TemplateParameter_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplateParameter, Pred> TemplateParameter_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplateParameter, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TemplatePackageInstance> TemplatePackageInstance_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplatePackageInstance, Pred> TemplatePackageInstance_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplatePackageInstance, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::CollectionParameter> CollectionParameter_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CollectionParameter, Pred> CollectionParameter_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CollectionParameter, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::NameParameter> NameParameter_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NameParameter, Pred> NameParameter_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NameParameter, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Constant> Constant_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Constant, Pred> Constant_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Constant, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Exception> Exception_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Exception, Pred> Exception_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Exception, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Package> Package_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Package, Pred> Package_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Package, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::EventType> EventType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::EventType, Pred> EventType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::EventType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PortType> PortType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PortType, Pred> PortType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PortType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Provideable> Provideable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Provideable, Pred> Provideable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Provideable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ManagesComponent> ManagesComponent_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ManagesComponent, Pred> ManagesComponent_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ManagesComponent, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentFactory> ComponentFactory_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentFactory, Pred> ComponentFactory_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentFactory, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Manageable> Manageable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Manageable, Pred> Manageable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Manageable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Component> Component_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Component, Pred> Component_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Component, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ConnectorObject> ConnectorObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorObject, Pred> ConnectorObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::File> File_parent() const;
		::Udm::ParentAttr< ::PICML::Package> Package_parent() const;
		::Udm::ParentAttr< ::PICML::Prefixable> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyPackageType;
		static ::Uml::CompositionChildRole meta_NativeValue_children;
		static ::Uml::CompositionChildRole meta_TemplateParameter_children;
		static ::Uml::CompositionChildRole meta_ManagesComponent_children;
		static ::Uml::CompositionChildRole meta_ComponentRef_children;
		static ::Uml::CompositionChildRole meta_NamedType_children;
		static ::Uml::CompositionChildRole meta_Constant_children;
		static ::Uml::CompositionChildRole meta_Exception_children;
		static ::Uml::CompositionChildRole meta_Package_children;
		static ::Uml::CompositionParentRole meta_File_parent;
		static ::Uml::CompositionParentRole meta_Package_parent;

	};

	class PICML_Export TemplatePackageAlias :  public Package {
	public:
		TemplatePackageAlias();
		TemplatePackageAlias(::Udm::ObjectImpl *impl);
		TemplatePackageAlias(const TemplatePackageAlias &master);

#ifdef UDM_RVALUE
		TemplatePackageAlias(TemplatePackageAlias &&master);

		static TemplatePackageAlias Cast(::Udm::Object &&a);
		TemplatePackageAlias& operator=(TemplatePackageAlias &&a);

#endif
		static TemplatePackageAlias Cast(const ::Udm::Object &a);
		static TemplatePackageAlias Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TemplatePackageAlias CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TemplatePackageAlias> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TemplatePackageAlias, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TemplatePackageAlias, Pred>(impl); };
		TemplatePackageAlias CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TemplatePackageAlias> Derived();
		template <class Pred> ::Udm::DerivedAttr< TemplatePackageAlias, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TemplatePackageAlias, Pred>(impl); };
		::Udm::ArchetypeAttr< TemplatePackageAlias> Archetype() const;
		::Udm::ChildAttr< ::PICML::PackageType> PackageType_child() const;
		::Udm::ChildrenAttr< ::PICML::TemplateParameterReference> TemplateParameterReference_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplateParameterReference, Pred> TemplateParameterReference_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplateParameterReference, Pred>(impl, meta_TemplateParameterReference_children); };
		::Udm::ChildrenAttr< ::PICML::MemberType> MemberType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MemberType, Pred> MemberType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MemberType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TemplateParameterReference> TemplateParameterReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplateParameterReference, Pred> TemplateParameterReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplateParameterReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType> TemplateParameterValueType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType, Pred> TemplateParameterValueType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PackageType> PackageType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageType, Pred> PackageType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::Prefixable> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_PackageType_child;
		static ::Uml::CompositionChildRole meta_TemplateParameterReference_children;

	};

	class PICML_Export TemplatePackageInstance :  public Package {
	public:
		TemplatePackageInstance();
		TemplatePackageInstance(::Udm::ObjectImpl *impl);
		TemplatePackageInstance(const TemplatePackageInstance &master);

#ifdef UDM_RVALUE
		TemplatePackageInstance(TemplatePackageInstance &&master);

		static TemplatePackageInstance Cast(::Udm::Object &&a);
		TemplatePackageInstance& operator=(TemplatePackageInstance &&a);

#endif
		static TemplatePackageInstance Cast(const ::Udm::Object &a);
		static TemplatePackageInstance Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TemplatePackageInstance CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TemplatePackageInstance> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TemplatePackageInstance, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TemplatePackageInstance, Pred>(impl); };
		TemplatePackageInstance CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TemplatePackageInstance> Derived();
		template <class Pred> ::Udm::DerivedAttr< TemplatePackageInstance, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TemplatePackageInstance, Pred>(impl); };
		::Udm::ArchetypeAttr< TemplatePackageInstance> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::TemplateParameterValue> TemplateParameterValue_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplateParameterValue, Pred> TemplateParameterValue_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplateParameterValue, Pred>(impl, meta_TemplateParameterValue_children); };
		::Udm::ChildAttr< ::PICML::PackageType> PackageType_child() const;
		::Udm::ChildrenAttr< ::PICML::TemplateParameterValue> TemplateParameterValue_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplateParameterValue, Pred> TemplateParameterValue_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplateParameterValue, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PackageType> PackageType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PackageType, Pred> PackageType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PackageType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::Prefixable> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_TemplateParameterValue_children;
		static ::Uml::CompositionChildRole meta_PackageType_child;

	};

	class PICML_Export Workspaces :  public MgaObject {
	public:
		Workspaces();
		Workspaces(::Udm::ObjectImpl *impl);
		Workspaces(const Workspaces &master);

#ifdef UDM_RVALUE
		Workspaces(Workspaces &&master);

		static Workspaces Cast(::Udm::Object &&a);
		Workspaces& operator=(Workspaces &&a);

#endif
		static Workspaces Cast(const ::Udm::Object &a);
		static Workspaces Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Workspaces CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Workspaces> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Workspaces, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Workspaces, Pred>(impl); };
		Workspaces CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Workspaces> Derived();
		template <class Pred> ::Udm::DerivedAttr< Workspaces, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Workspaces, Pred>(impl); };
		::Udm::ArchetypeAttr< Workspaces> Archetype() const;
		::Udm::AssocAttr< Project> members() const;
		template <class Pred> ::Udm::AssocAttr< Project, Pred> members_sorted(const Pred &) const { return ::Udm::AssocAttr< Project, Pred>(impl, meta_members); };
		::Udm::ParentAttr< ::PICML::MPC> MPC_parent() const;
		::Udm::ParentAttr< ::PICML::MPC> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_members;
		static ::Uml::CompositionParentRole meta_MPC_parent;

	};

	class PICML_Export MPC :  public MgaObject {
	public:
		MPC();
		MPC(::Udm::ObjectImpl *impl);
		MPC(const MPC &master);

#ifdef UDM_RVALUE
		MPC(MPC &&master);

		static MPC Cast(::Udm::Object &&a);
		MPC& operator=(MPC &&a);

#endif
		static MPC Cast(const ::Udm::Object &a);
		static MPC Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MPC CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MPC> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MPC, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MPC, Pred>(impl); };
		MPC CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MPC> Derived();
		template <class Pred> ::Udm::DerivedAttr< MPC, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MPC, Pred>(impl); };
		::Udm::ArchetypeAttr< MPC> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::Project> Project_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Project, Pred> Project_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Project, Pred>(impl, meta_Project_children); };
		::Udm::ChildrenAttr< ::PICML::Workspaces> Workspaces_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Workspaces, Pred> Workspaces_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Workspaces, Pred>(impl, meta_Workspaces_children); };
		::Udm::ChildrenAttr< ::PICML::Workspaces> Workspaces_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Workspaces, Pred> Workspaces_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Workspaces, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Project> Project_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Project, Pred> Project_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Project, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::ComponentBuild> ComponentBuild_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentBuild> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Project_children;
		static ::Uml::CompositionChildRole meta_Workspaces_children;
		static ::Uml::CompositionParentRole meta_ComponentBuild_parent;

	};

	class PICML_Export ComponentLib :  public MgaObject {
	public:
		ComponentLib();
		ComponentLib(::Udm::ObjectImpl *impl);
		ComponentLib(const ComponentLib &master);

#ifdef UDM_RVALUE
		ComponentLib(ComponentLib &&master);

		static ComponentLib Cast(::Udm::Object &&a);
		ComponentLib& operator=(ComponentLib &&a);

#endif
		static ComponentLib Cast(const ::Udm::Object &a);
		static ComponentLib Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentLib CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentLib> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentLib, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentLib, Pred>(impl); };
		ComponentLib CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentLib> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentLib, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentLib, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentLib> Archetype() const;
		::Udm::StringAttr libraryexport() const;
		::Udm::StringAttr sharedname() const;
		::Udm::StringAttr ORBServices() const;
		::Udm::AClassAssocAttr< ExtResourceConn, ExternalResources> dstExtResourceConn() const;
		template <class Pred> ::Udm::AClassAssocAttr< ExtResourceConn, ExternalResources, Pred> dstExtResourceConn_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ExtResourceConn, ExternalResources, Pred>(impl, meta_dstExtResourceConn, meta_dstExtResourceConn_rev); };
		::Udm::ParentAttr< ::PICML::Project> Project_parent() const;
		::Udm::ParentAttr< ::PICML::Project> parent() const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_libraryexport;
		static ::Uml::Attribute meta_sharedname;
		static ::Uml::Attribute meta_ORBServices;
		static ::Uml::AssociationRole meta_dstExtResourceConn;
		static ::Uml::AssociationRole meta_dstExtResourceConn_rev;
		static ::Uml::CompositionParentRole meta_Project_parent;

	};

	class PICML_Export ExecutorProject :  public ComponentLib {
	public:
		ExecutorProject();
		ExecutorProject(::Udm::ObjectImpl *impl);
		ExecutorProject(const ExecutorProject &master);

#ifdef UDM_RVALUE
		ExecutorProject(ExecutorProject &&master);

		static ExecutorProject Cast(::Udm::Object &&a);
		ExecutorProject& operator=(ExecutorProject &&a);

#endif
		static ExecutorProject Cast(const ::Udm::Object &a);
		static ExecutorProject Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ExecutorProject CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ExecutorProject> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ExecutorProject, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ExecutorProject, Pred>(impl); };
		ExecutorProject CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ExecutorProject> Derived();
		template <class Pred> ::Udm::DerivedAttr< ExecutorProject, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ExecutorProject, Pred>(impl); };
		::Udm::ArchetypeAttr< ExecutorProject> Archetype() const;
		::Udm::ChildAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_child() const;
		::Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact> ComponentImplementationArtifact_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred> ComponentImplementationArtifact_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentServantArtifact> ComponentServantArtifact_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred> ComponentServantArtifact_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred> ImplementationArtifactReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::Project> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_ImplementationArtifactReference_child;

	};

	class PICML_Export ServantProject :  public ComponentLib {
	public:
		ServantProject();
		ServantProject(::Udm::ObjectImpl *impl);
		ServantProject(const ServantProject &master);

#ifdef UDM_RVALUE
		ServantProject(ServantProject &&master);

		static ServantProject Cast(::Udm::Object &&a);
		ServantProject& operator=(ServantProject &&a);

#endif
		static ServantProject Cast(const ::Udm::Object &a);
		static ServantProject Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ServantProject CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ServantProject> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ServantProject, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ServantProject, Pred>(impl); };
		ServantProject CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ServantProject> Derived();
		template <class Pred> ::Udm::DerivedAttr< ServantProject, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ServantProject, Pred>(impl); };
		::Udm::ArchetypeAttr< ServantProject> Archetype() const;
		::Udm::ChildAttr< ::PICML::FileRef> FileRef_child() const;
		::Udm::ChildAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_child() const;
		::Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact> ComponentImplementationArtifact_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred> ComponentImplementationArtifact_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentServantArtifact> ComponentServantArtifact_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred> ComponentServantArtifact_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred> ImplementationArtifactReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::FileRef> FileRef_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::FileRef, Pred> FileRef_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::FileRef, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::Project> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_FileRef_child;
		static ::Uml::CompositionChildRole meta_ImplementationArtifactReference_child;

	};

	class PICML_Export StubProject :  public ComponentLib {
	public:
		StubProject();
		StubProject(::Udm::ObjectImpl *impl);
		StubProject(const StubProject &master);

#ifdef UDM_RVALUE
		StubProject(StubProject &&master);

		static StubProject Cast(::Udm::Object &&a);
		StubProject& operator=(StubProject &&a);

#endif
		static StubProject Cast(const ::Udm::Object &a);
		static StubProject Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		StubProject CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< StubProject> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< StubProject, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< StubProject, Pred>(impl); };
		StubProject CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< StubProject> Derived();
		template <class Pred> ::Udm::DerivedAttr< StubProject, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< StubProject, Pred>(impl); };
		::Udm::ArchetypeAttr< StubProject> Archetype() const;
		::Udm::ChildAttr< ::PICML::FileRef> FileRef_child() const;
		::Udm::ChildAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_child() const;
		::Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact> ComponentImplementationArtifact_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred> ComponentImplementationArtifact_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentImplementationArtifact, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentServantArtifact> ComponentServantArtifact_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred> ComponentServantArtifact_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentServantArtifact, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference> ImplementationArtifactReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred> ImplementationArtifactReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationArtifactReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::FileRef> FileRef_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::FileRef, Pred> FileRef_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::FileRef, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::Project> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_FileRef_child;
		static ::Uml::CompositionChildRole meta_ImplementationArtifactReference_child;

	};

	class PICML_Export ExtResourceConn :  public MgaObject {
	public:
		ExtResourceConn();
		ExtResourceConn(::Udm::ObjectImpl *impl);
		ExtResourceConn(const ExtResourceConn &master);

#ifdef UDM_RVALUE
		ExtResourceConn(ExtResourceConn &&master);

		static ExtResourceConn Cast(::Udm::Object &&a);
		ExtResourceConn& operator=(ExtResourceConn &&a);

#endif
		static ExtResourceConn Cast(const ::Udm::Object &a);
		static ExtResourceConn Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ExtResourceConn CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ExtResourceConn> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ExtResourceConn, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ExtResourceConn, Pred>(impl); };
		ExtResourceConn CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ExtResourceConn> Derived();
		template <class Pred> ::Udm::DerivedAttr< ExtResourceConn, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ExtResourceConn, Pred>(impl); };
		::Udm::ArchetypeAttr< ExtResourceConn> Archetype() const;
		::Udm::ParentAttr< ::PICML::Project> Project_parent() const;
		::Udm::ParentAttr< ::PICML::Project> parent() const;
		::Udm::AssocEndAttr< ::PICML::ComponentLib> srcExtResourceConn_end() const;
		::Udm::AssocEndAttr< ::PICML::ExternalResources> dstExtResourceConn_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_Project_parent;
		static ::Uml::AssociationRole meta_srcExtResourceConn_end_;
		static ::Uml::AssociationRole meta_dstExtResourceConn_end_;

	};

	class PICML_Export ExternalResources :  public MgaObject {
	public:
		ExternalResources();
		ExternalResources(::Udm::ObjectImpl *impl);
		ExternalResources(const ExternalResources &master);

#ifdef UDM_RVALUE
		ExternalResources(ExternalResources &&master);

		static ExternalResources Cast(::Udm::Object &&a);
		ExternalResources& operator=(ExternalResources &&a);

#endif
		static ExternalResources Cast(const ::Udm::Object &a);
		static ExternalResources Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ExternalResources CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ExternalResources> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ExternalResources, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ExternalResources, Pred>(impl); };
		ExternalResources CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ExternalResources> Derived();
		template <class Pred> ::Udm::DerivedAttr< ExternalResources, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ExternalResources, Pred>(impl); };
		::Udm::ArchetypeAttr< ExternalResources> Archetype() const;
		::Udm::AClassAssocAttr< ExtResourceConn, ComponentLib> srcExtResourceConn() const;
		template <class Pred> ::Udm::AClassAssocAttr< ExtResourceConn, ComponentLib, Pred> srcExtResourceConn_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ExtResourceConn, ComponentLib, Pred>(impl, meta_srcExtResourceConn, meta_srcExtResourceConn_rev); };
		::Udm::PointerAttr< ImplementationArtifact> ref() const;
		::Udm::ParentAttr< ::PICML::Project> Project_parent() const;
		::Udm::ParentAttr< ::PICML::Project> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcExtResourceConn;
		static ::Uml::AssociationRole meta_srcExtResourceConn_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_Project_parent;

	};

	class PICML_Export Project :  public MgaObject {
	public:
		Project();
		Project(::Udm::ObjectImpl *impl);
		Project(const Project &master);

#ifdef UDM_RVALUE
		Project(Project &&master);

		static Project Cast(::Udm::Object &&a);
		Project& operator=(Project &&a);

#endif
		static Project Cast(const ::Udm::Object &a);
		static Project Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Project CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Project> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Project, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Project, Pred>(impl); };
		Project CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Project> Derived();
		template <class Pred> ::Udm::DerivedAttr< Project, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Project, Pred>(impl); };
		::Udm::ArchetypeAttr< Project> Archetype() const;
		::Udm::AssocAttr< Workspaces> setWorkspace() const;
		template <class Pred> ::Udm::AssocAttr< Workspaces, Pred> setWorkspace_sorted(const Pred &) const { return ::Udm::AssocAttr< Workspaces, Pred>(impl, meta_setWorkspace); };
		::Udm::ChildrenAttr< ::PICML::ImplementationArtifact> ImplementationArtifact_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationArtifact, Pred> ImplementationArtifact_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationArtifact, Pred>(impl, meta_ImplementationArtifact_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentLib> ComponentLib_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentLib, Pred> ComponentLib_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentLib, Pred>(impl, meta_ComponentLib_children); };
		::Udm::ChildrenAttr< ::PICML::ExtResourceConn> ExtResourceConn_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExtResourceConn, Pred> ExtResourceConn_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExtResourceConn, Pred>(impl, meta_ExtResourceConn_children); };
		::Udm::ChildrenAttr< ::PICML::ExternalResources> ExternalResources_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExternalResources, Pred> ExternalResources_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExternalResources, Pred>(impl, meta_ExternalResources_children); };
		::Udm::ChildrenAttr< ::PICML::ImplementationArtifact> ImplementationArtifact_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationArtifact, Pred> ImplementationArtifact_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationArtifact, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExecutorProject> ExecutorProject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExecutorProject, Pred> ExecutorProject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExecutorProject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ServantProject> ServantProject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ServantProject, Pred> ServantProject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ServantProject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentLib> ComponentLib_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentLib, Pred> ComponentLib_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentLib, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::StubProject> StubProject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::StubProject, Pred> StubProject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::StubProject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExtResourceConn> ExtResourceConn_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExtResourceConn, Pred> ExtResourceConn_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExtResourceConn, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExternalResources> ExternalResources_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExternalResources, Pred> ExternalResources_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExternalResources, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::MPC> MPC_parent() const;
		::Udm::ParentAttr< ::PICML::MPC> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_setWorkspace;
		static ::Uml::CompositionChildRole meta_ImplementationArtifact_children;
		static ::Uml::CompositionChildRole meta_ComponentLib_children;
		static ::Uml::CompositionChildRole meta_ExtResourceConn_children;
		static ::Uml::CompositionChildRole meta_ExternalResources_children;
		static ::Uml::CompositionParentRole meta_MPC_parent;

	};

	class PICML_Export ExternalPort :  public MgaObject {
	public:
		ExternalPort();
		ExternalPort(::Udm::ObjectImpl *impl);
		ExternalPort(const ExternalPort &master);

#ifdef UDM_RVALUE
		ExternalPort(ExternalPort &&master);

		static ExternalPort Cast(::Udm::Object &&a);
		ExternalPort& operator=(ExternalPort &&a);

#endif
		static ExternalPort Cast(const ::Udm::Object &a);
		static ExternalPort Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ExternalPort CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ExternalPort> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ExternalPort, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ExternalPort, Pred>(impl); };
		ExternalPort CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ExternalPort> Derived();
		template <class Pred> ::Udm::DerivedAttr< ExternalPort, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ExternalPort, Pred>(impl); };
		::Udm::ArchetypeAttr< ExternalPort> Archetype() const;
		::Udm::StringAttr location() const;
		::Udm::AClassAssocAttr< ExternalDelegate, ExternalPortEnd> dstExternalDelegate() const;
		template <class Pred> ::Udm::AClassAssocAttr< ExternalDelegate, ExternalPortEnd, Pred> dstExternalDelegate_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ExternalDelegate, ExternalPortEnd, Pred>(impl, meta_dstExternalDelegate, meta_dstExternalDelegate_rev); };
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_location;
		static ::Uml::AssociationRole meta_dstExternalDelegate;
		static ::Uml::AssociationRole meta_dstExternalDelegate_rev;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

	};

	class PICML_Export ComponentAssemblyReference :  public CollocationGroupMember {
	public:
		ComponentAssemblyReference();
		ComponentAssemblyReference(::Udm::ObjectImpl *impl);
		ComponentAssemblyReference(const ComponentAssemblyReference &master);

#ifdef UDM_RVALUE
		ComponentAssemblyReference(ComponentAssemblyReference &&master);

		static ComponentAssemblyReference Cast(::Udm::Object &&a);
		ComponentAssemblyReference& operator=(ComponentAssemblyReference &&a);

#endif
		static ComponentAssemblyReference Cast(const ::Udm::Object &a);
		static ComponentAssemblyReference Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentAssemblyReference CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentAssemblyReference> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentAssemblyReference, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentAssemblyReference, Pred>(impl); };
		ComponentAssemblyReference CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentAssemblyReference> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentAssemblyReference, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentAssemblyReference, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentAssemblyReference> Archetype() const;
		::Udm::PointerAttr< ComponentAssembly> ref() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

	};

	class PICML_Export ExtendedDelegate :  public MgaObject {
	public:
		ExtendedDelegate();
		ExtendedDelegate(::Udm::ObjectImpl *impl);
		ExtendedDelegate(const ExtendedDelegate &master);

#ifdef UDM_RVALUE
		ExtendedDelegate(ExtendedDelegate &&master);

		static ExtendedDelegate Cast(::Udm::Object &&a);
		ExtendedDelegate& operator=(ExtendedDelegate &&a);

#endif
		static ExtendedDelegate Cast(const ::Udm::Object &a);
		static ExtendedDelegate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ExtendedDelegate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ExtendedDelegate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ExtendedDelegate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ExtendedDelegate, Pred>(impl); };
		ExtendedDelegate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ExtendedDelegate> Derived();
		template <class Pred> ::Udm::DerivedAttr< ExtendedDelegate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ExtendedDelegate, Pred>(impl); };
		::Udm::ArchetypeAttr< ExtendedDelegate> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::ExtendedPortInstanceBase> srcExtendedDelegate_end() const;
		::Udm::AssocEndAttr< ::PICML::ExtendedPortDelegate> dstExtendedDelegate_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcExtendedDelegate_end_;
		static ::Uml::AssociationRole meta_dstExtendedDelegate_end_;

	};

	class PICML_Export MirrorDelegate :  public MgaObject {
	public:
		MirrorDelegate();
		MirrorDelegate(::Udm::ObjectImpl *impl);
		MirrorDelegate(const MirrorDelegate &master);

#ifdef UDM_RVALUE
		MirrorDelegate(MirrorDelegate &&master);

		static MirrorDelegate Cast(::Udm::Object &&a);
		MirrorDelegate& operator=(MirrorDelegate &&a);

#endif
		static MirrorDelegate Cast(const ::Udm::Object &a);
		static MirrorDelegate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MirrorDelegate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MirrorDelegate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MirrorDelegate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MirrorDelegate, Pred>(impl); };
		MirrorDelegate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MirrorDelegate> Derived();
		template <class Pred> ::Udm::DerivedAttr< MirrorDelegate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MirrorDelegate, Pred>(impl); };
		::Udm::ArchetypeAttr< MirrorDelegate> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::MirrorPortInstanceBase> srcMirrorDelegate_end() const;
		::Udm::AssocEndAttr< ::PICML::MirrorPortDelegate> dstMirrorDelegate_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcMirrorDelegate_end_;
		static ::Uml::AssociationRole meta_dstMirrorDelegate_end_;

	};

	class PICML_Export AssemblyConfigPropertyEnd :  public MgaObject {
	public:
		AssemblyConfigPropertyEnd();
		AssemblyConfigPropertyEnd(::Udm::ObjectImpl *impl);
		AssemblyConfigPropertyEnd(const AssemblyConfigPropertyEnd &master);

#ifdef UDM_RVALUE
		AssemblyConfigPropertyEnd(AssemblyConfigPropertyEnd &&master);

		static AssemblyConfigPropertyEnd Cast(::Udm::Object &&a);
		AssemblyConfigPropertyEnd& operator=(AssemblyConfigPropertyEnd &&a);

#endif
		static AssemblyConfigPropertyEnd Cast(const ::Udm::Object &a);
		static AssemblyConfigPropertyEnd Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		AssemblyConfigPropertyEnd CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< AssemblyConfigPropertyEnd> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< AssemblyConfigPropertyEnd, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< AssemblyConfigPropertyEnd, Pred>(impl); };
		AssemblyConfigPropertyEnd CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< AssemblyConfigPropertyEnd> Derived();
		template <class Pred> ::Udm::DerivedAttr< AssemblyConfigPropertyEnd, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< AssemblyConfigPropertyEnd, Pred>(impl); };
		::Udm::ArchetypeAttr< AssemblyConfigPropertyEnd> Archetype() const;
		::Udm::AClassAssocAttr< AssemblyConfigProperty, Property> dstAssemblyConfigProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< AssemblyConfigProperty, Property, Pred> dstAssemblyConfigProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< AssemblyConfigProperty, Property, Pred>(impl, meta_dstAssemblyConfigProperty, meta_dstAssemblyConfigProperty_rev); };
		::Udm::AClassAssocAttr< AssemblyselectRequirement, Requirement> dstAssemblyselectRequirement() const;
		template <class Pred> ::Udm::AClassAssocAttr< AssemblyselectRequirement, Requirement, Pred> dstAssemblyselectRequirement_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< AssemblyselectRequirement, Requirement, Pred>(impl, meta_dstAssemblyselectRequirement, meta_dstAssemblyselectRequirement_rev); };
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstAssemblyConfigProperty;
		static ::Uml::AssociationRole meta_dstAssemblyConfigProperty_rev;
		static ::Uml::AssociationRole meta_dstAssemblyselectRequirement;
		static ::Uml::AssociationRole meta_dstAssemblyselectRequirement_rev;

	};

	class PICML_Export ConnectorToFacet :  public MgaObject {
	public:
		ConnectorToFacet();
		ConnectorToFacet(::Udm::ObjectImpl *impl);
		ConnectorToFacet(const ConnectorToFacet &master);

#ifdef UDM_RVALUE
		ConnectorToFacet(ConnectorToFacet &&master);

		static ConnectorToFacet Cast(::Udm::Object &&a);
		ConnectorToFacet& operator=(ConnectorToFacet &&a);

#endif
		static ConnectorToFacet Cast(const ::Udm::Object &a);
		static ConnectorToFacet Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ConnectorToFacet CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ConnectorToFacet> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ConnectorToFacet, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ConnectorToFacet, Pred>(impl); };
		ConnectorToFacet CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ConnectorToFacet> Derived();
		template <class Pred> ::Udm::DerivedAttr< ConnectorToFacet, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ConnectorToFacet, Pred>(impl); };
		::Udm::ArchetypeAttr< ConnectorToFacet> Archetype() const;
		::Udm::StringAttr InnerName() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::ConnectorInstance> srcConnectorToFacet_end() const;
		::Udm::AssocEndAttr< ::PICML::ProvidedRequestPortEnd> dstConnectorToFacet_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_InnerName;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcConnectorToFacet_end_;
		static ::Uml::AssociationRole meta_dstConnectorToFacet_end_;

	};

	class PICML_Export ConnectorToReceptacle :  public MgaObject {
	public:
		ConnectorToReceptacle();
		ConnectorToReceptacle(::Udm::ObjectImpl *impl);
		ConnectorToReceptacle(const ConnectorToReceptacle &master);

#ifdef UDM_RVALUE
		ConnectorToReceptacle(ConnectorToReceptacle &&master);

		static ConnectorToReceptacle Cast(::Udm::Object &&a);
		ConnectorToReceptacle& operator=(ConnectorToReceptacle &&a);

#endif
		static ConnectorToReceptacle Cast(const ::Udm::Object &a);
		static ConnectorToReceptacle Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ConnectorToReceptacle CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ConnectorToReceptacle> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ConnectorToReceptacle, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ConnectorToReceptacle, Pred>(impl); };
		ConnectorToReceptacle CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ConnectorToReceptacle> Derived();
		template <class Pred> ::Udm::DerivedAttr< ConnectorToReceptacle, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ConnectorToReceptacle, Pred>(impl); };
		::Udm::ArchetypeAttr< ConnectorToReceptacle> Archetype() const;
		::Udm::StringAttr InnerName() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::RequiredRequestPortEnd> srcConnectorToReceptacle_end() const;
		::Udm::AssocEndAttr< ::PICML::ConnectorInstance> dstConnectorToReceptacle_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_InnerName;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcConnectorToReceptacle_end_;
		static ::Uml::AssociationRole meta_dstConnectorToReceptacle_end_;

	};

	class PICML_Export ExternalPortEnd :  virtual  public MgaObject {
	public:
		ExternalPortEnd();
		ExternalPortEnd(::Udm::ObjectImpl *impl);
		ExternalPortEnd(const ExternalPortEnd &master);

#ifdef UDM_RVALUE
		ExternalPortEnd(ExternalPortEnd &&master);

		static ExternalPortEnd Cast(::Udm::Object &&a);
		ExternalPortEnd& operator=(ExternalPortEnd &&a);

#endif
		static ExternalPortEnd Cast(const ::Udm::Object &a);
		static ExternalPortEnd Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ExternalPortEnd CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ExternalPortEnd> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ExternalPortEnd, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ExternalPortEnd, Pred>(impl); };
		ExternalPortEnd CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ExternalPortEnd> Derived();
		template <class Pred> ::Udm::DerivedAttr< ExternalPortEnd, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ExternalPortEnd, Pred>(impl); };
		::Udm::ArchetypeAttr< ExternalPortEnd> Archetype() const;
		::Udm::AClassAssocAttr< ExternalDelegate, ExternalPort> srcExternalDelegate() const;
		template <class Pred> ::Udm::AClassAssocAttr< ExternalDelegate, ExternalPort, Pred> srcExternalDelegate_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ExternalDelegate, ExternalPort, Pred>(impl, meta_srcExternalDelegate, meta_srcExternalDelegate_rev); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcExternalDelegate;
		static ::Uml::AssociationRole meta_srcExternalDelegate_rev;

	};

	class PICML_Export ProvidedRequestPortEnd :  public ExternalPortEnd {
	public:
		ProvidedRequestPortEnd();
		ProvidedRequestPortEnd(::Udm::ObjectImpl *impl);
		ProvidedRequestPortEnd(const ProvidedRequestPortEnd &master);

#ifdef UDM_RVALUE
		ProvidedRequestPortEnd(ProvidedRequestPortEnd &&master);

		static ProvidedRequestPortEnd Cast(::Udm::Object &&a);
		ProvidedRequestPortEnd& operator=(ProvidedRequestPortEnd &&a);

#endif
		static ProvidedRequestPortEnd Cast(const ::Udm::Object &a);
		static ProvidedRequestPortEnd Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ProvidedRequestPortEnd CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ProvidedRequestPortEnd> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ProvidedRequestPortEnd, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ProvidedRequestPortEnd, Pred>(impl); };
		ProvidedRequestPortEnd CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ProvidedRequestPortEnd> Derived();
		template <class Pred> ::Udm::DerivedAttr< ProvidedRequestPortEnd, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ProvidedRequestPortEnd, Pred>(impl); };
		::Udm::ArchetypeAttr< ProvidedRequestPortEnd> Archetype() const;
		::Udm::AClassAssocAttr< FacetDelegate, ProvidedRequestPortDelegate> srcFacetDelegate() const;
		template <class Pred> ::Udm::AClassAssocAttr< FacetDelegate, ProvidedRequestPortDelegate, Pred> srcFacetDelegate_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< FacetDelegate, ProvidedRequestPortDelegate, Pred>(impl, meta_srcFacetDelegate, meta_srcFacetDelegate_rev); };
		::Udm::AClassAssocAttr< Invoke, RequiredRequestPortEnd> srcinvoke() const;
		template <class Pred> ::Udm::AClassAssocAttr< Invoke, RequiredRequestPortEnd, Pred> srcinvoke_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< Invoke, RequiredRequestPortEnd, Pred>(impl, meta_srcinvoke, meta_srcinvoke_rev); };
		::Udm::AClassAssocAttr< ConnectorToFacet, ConnectorInstance> srcConnectorToFacet() const;
		template <class Pred> ::Udm::AClassAssocAttr< ConnectorToFacet, ConnectorInstance, Pred> srcConnectorToFacet_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ConnectorToFacet, ConnectorInstance, Pred>(impl, meta_srcConnectorToFacet, meta_srcConnectorToFacet_rev); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcFacetDelegate;
		static ::Uml::AssociationRole meta_srcFacetDelegate_rev;
		static ::Uml::AssociationRole meta_srcinvoke;
		static ::Uml::AssociationRole meta_srcinvoke_rev;
		static ::Uml::AssociationRole meta_srcConnectorToFacet;
		static ::Uml::AssociationRole meta_srcConnectorToFacet_rev;

	};

	class PICML_Export ProvidedRequestPortDelegate :  public ProvidedRequestPortEnd {
	public:
		ProvidedRequestPortDelegate();
		ProvidedRequestPortDelegate(::Udm::ObjectImpl *impl);
		ProvidedRequestPortDelegate(const ProvidedRequestPortDelegate &master);

#ifdef UDM_RVALUE
		ProvidedRequestPortDelegate(ProvidedRequestPortDelegate &&master);

		static ProvidedRequestPortDelegate Cast(::Udm::Object &&a);
		ProvidedRequestPortDelegate& operator=(ProvidedRequestPortDelegate &&a);

#endif
		static ProvidedRequestPortDelegate Cast(const ::Udm::Object &a);
		static ProvidedRequestPortDelegate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ProvidedRequestPortDelegate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ProvidedRequestPortDelegate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ProvidedRequestPortDelegate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ProvidedRequestPortDelegate, Pred>(impl); };
		ProvidedRequestPortDelegate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ProvidedRequestPortDelegate> Derived();
		template <class Pred> ::Udm::DerivedAttr< ProvidedRequestPortDelegate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ProvidedRequestPortDelegate, Pred>(impl); };
		::Udm::ArchetypeAttr< ProvidedRequestPortDelegate> Archetype() const;
		::Udm::AClassAssocAttr< FacetDelegate, ProvidedRequestPortEnd> dstFacetDelegate() const;
		template <class Pred> ::Udm::AClassAssocAttr< FacetDelegate, ProvidedRequestPortEnd, Pred> dstFacetDelegate_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< FacetDelegate, ProvidedRequestPortEnd, Pred>(impl, meta_dstFacetDelegate, meta_dstFacetDelegate_rev); };
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstFacetDelegate;
		static ::Uml::AssociationRole meta_dstFacetDelegate_rev;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

	};

	class PICML_Export RequiredRequestPortEnd :  public ExternalPortEnd {
	public:
		RequiredRequestPortEnd();
		RequiredRequestPortEnd(::Udm::ObjectImpl *impl);
		RequiredRequestPortEnd(const RequiredRequestPortEnd &master);

#ifdef UDM_RVALUE
		RequiredRequestPortEnd(RequiredRequestPortEnd &&master);

		static RequiredRequestPortEnd Cast(::Udm::Object &&a);
		RequiredRequestPortEnd& operator=(RequiredRequestPortEnd &&a);

#endif
		static RequiredRequestPortEnd Cast(const ::Udm::Object &a);
		static RequiredRequestPortEnd Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		RequiredRequestPortEnd CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< RequiredRequestPortEnd> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< RequiredRequestPortEnd, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< RequiredRequestPortEnd, Pred>(impl); };
		RequiredRequestPortEnd CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< RequiredRequestPortEnd> Derived();
		template <class Pred> ::Udm::DerivedAttr< RequiredRequestPortEnd, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< RequiredRequestPortEnd, Pred>(impl); };
		::Udm::ArchetypeAttr< RequiredRequestPortEnd> Archetype() const;
		::Udm::AClassAssocAttr< ReceptacleDelegate, RequiredRequestPortDelegate> srcReceptacleDelegate() const;
		template <class Pred> ::Udm::AClassAssocAttr< ReceptacleDelegate, RequiredRequestPortDelegate, Pred> srcReceptacleDelegate_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ReceptacleDelegate, RequiredRequestPortDelegate, Pred>(impl, meta_srcReceptacleDelegate, meta_srcReceptacleDelegate_rev); };
		::Udm::AClassAssocAttr< ConnectorToReceptacle, ConnectorInstance> dstConnectorToReceptacle() const;
		template <class Pred> ::Udm::AClassAssocAttr< ConnectorToReceptacle, ConnectorInstance, Pred> dstConnectorToReceptacle_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ConnectorToReceptacle, ConnectorInstance, Pred>(impl, meta_dstConnectorToReceptacle, meta_dstConnectorToReceptacle_rev); };
		::Udm::AClassAssocAttr< Invoke, ProvidedRequestPortEnd> dstinvoke() const;
		template <class Pred> ::Udm::AClassAssocAttr< Invoke, ProvidedRequestPortEnd, Pred> dstinvoke_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< Invoke, ProvidedRequestPortEnd, Pred>(impl, meta_dstinvoke, meta_dstinvoke_rev); };
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcReceptacleDelegate;
		static ::Uml::AssociationRole meta_srcReceptacleDelegate_rev;
		static ::Uml::AssociationRole meta_dstConnectorToReceptacle;
		static ::Uml::AssociationRole meta_dstConnectorToReceptacle_rev;
		static ::Uml::AssociationRole meta_dstinvoke;
		static ::Uml::AssociationRole meta_dstinvoke_rev;

	};

	class PICML_Export RequiredRequestPortDelegate :  public RequiredRequestPortEnd {
	public:
		RequiredRequestPortDelegate();
		RequiredRequestPortDelegate(::Udm::ObjectImpl *impl);
		RequiredRequestPortDelegate(const RequiredRequestPortDelegate &master);

#ifdef UDM_RVALUE
		RequiredRequestPortDelegate(RequiredRequestPortDelegate &&master);

		static RequiredRequestPortDelegate Cast(::Udm::Object &&a);
		RequiredRequestPortDelegate& operator=(RequiredRequestPortDelegate &&a);

#endif
		static RequiredRequestPortDelegate Cast(const ::Udm::Object &a);
		static RequiredRequestPortDelegate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		RequiredRequestPortDelegate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< RequiredRequestPortDelegate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< RequiredRequestPortDelegate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< RequiredRequestPortDelegate, Pred>(impl); };
		RequiredRequestPortDelegate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< RequiredRequestPortDelegate> Derived();
		template <class Pred> ::Udm::DerivedAttr< RequiredRequestPortDelegate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< RequiredRequestPortDelegate, Pred>(impl); };
		::Udm::ArchetypeAttr< RequiredRequestPortDelegate> Archetype() const;
		::Udm::AClassAssocAttr< ReceptacleDelegate, RequiredRequestPortEnd> dstReceptacleDelegate() const;
		template <class Pred> ::Udm::AClassAssocAttr< ReceptacleDelegate, RequiredRequestPortEnd, Pred> dstReceptacleDelegate_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ReceptacleDelegate, RequiredRequestPortEnd, Pred>(impl, meta_dstReceptacleDelegate, meta_dstReceptacleDelegate_rev); };
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstReceptacleDelegate;
		static ::Uml::AssociationRole meta_dstReceptacleDelegate_rev;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

	};

	class PICML_Export ExtendPortEnd :  public ExternalPortEnd {
	public:
		ExtendPortEnd();
		ExtendPortEnd(::Udm::ObjectImpl *impl);
		ExtendPortEnd(const ExtendPortEnd &master);

#ifdef UDM_RVALUE
		ExtendPortEnd(ExtendPortEnd &&master);

		static ExtendPortEnd Cast(::Udm::Object &&a);
		ExtendPortEnd& operator=(ExtendPortEnd &&a);

#endif
		static ExtendPortEnd Cast(const ::Udm::Object &a);
		static ExtendPortEnd Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ExtendPortEnd CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ExtendPortEnd> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ExtendPortEnd, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ExtendPortEnd, Pred>(impl); };
		ExtendPortEnd CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ExtendPortEnd> Derived();
		template <class Pred> ::Udm::DerivedAttr< ExtendPortEnd, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ExtendPortEnd, Pred>(impl); };
		::Udm::ArchetypeAttr< ExtendPortEnd> Archetype() const;
		::Udm::AClassPointerAttr< Publish, ConnectorInstance> dstPublish() const;
		::Udm::AClassPointerAttr< Consume, ConnectorInstance> srcConsume() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstPublish;
		static ::Uml::AssociationRole meta_dstPublish_rev;
		static ::Uml::AssociationRole meta_srcConsume;
		static ::Uml::AssociationRole meta_srcConsume_rev;

	};

	class PICML_Export ExtendedPortInstanceBase :  public ExtendPortEnd {
	public:
		ExtendedPortInstanceBase();
		ExtendedPortInstanceBase(::Udm::ObjectImpl *impl);
		ExtendedPortInstanceBase(const ExtendedPortInstanceBase &master);

#ifdef UDM_RVALUE
		ExtendedPortInstanceBase(ExtendedPortInstanceBase &&master);

		static ExtendedPortInstanceBase Cast(::Udm::Object &&a);
		ExtendedPortInstanceBase& operator=(ExtendedPortInstanceBase &&a);

#endif
		static ExtendedPortInstanceBase Cast(const ::Udm::Object &a);
		static ExtendedPortInstanceBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ExtendedPortInstanceBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ExtendedPortInstanceBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ExtendedPortInstanceBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ExtendedPortInstanceBase, Pred>(impl); };
		ExtendedPortInstanceBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ExtendedPortInstanceBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< ExtendedPortInstanceBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ExtendedPortInstanceBase, Pred>(impl); };
		::Udm::ArchetypeAttr< ExtendedPortInstanceBase> Archetype() const;
		::Udm::AClassPointerAttr< ExtendedDelegate, ExtendedPortDelegate> dstExtendedDelegate() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstExtendedDelegate;
		static ::Uml::AssociationRole meta_dstExtendedDelegate_rev;

	};

	class PICML_Export ExtendedPortDelegate :  public ExtendedPortInstanceBase {
	public:
		ExtendedPortDelegate();
		ExtendedPortDelegate(::Udm::ObjectImpl *impl);
		ExtendedPortDelegate(const ExtendedPortDelegate &master);

#ifdef UDM_RVALUE
		ExtendedPortDelegate(ExtendedPortDelegate &&master);

		static ExtendedPortDelegate Cast(::Udm::Object &&a);
		ExtendedPortDelegate& operator=(ExtendedPortDelegate &&a);

#endif
		static ExtendedPortDelegate Cast(const ::Udm::Object &a);
		static ExtendedPortDelegate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ExtendedPortDelegate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ExtendedPortDelegate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ExtendedPortDelegate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ExtendedPortDelegate, Pred>(impl); };
		ExtendedPortDelegate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ExtendedPortDelegate> Derived();
		template <class Pred> ::Udm::DerivedAttr< ExtendedPortDelegate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ExtendedPortDelegate, Pred>(impl); };
		::Udm::ArchetypeAttr< ExtendedPortDelegate> Archetype() const;
		::Udm::AClassAssocAttr< ExtendedDelegate, ExtendedPortInstanceBase> srcExtendedDelegate() const;
		template <class Pred> ::Udm::AClassAssocAttr< ExtendedDelegate, ExtendedPortInstanceBase, Pred> srcExtendedDelegate_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ExtendedDelegate, ExtendedPortInstanceBase, Pred>(impl, meta_srcExtendedDelegate, meta_srcExtendedDelegate_rev); };
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcExtendedDelegate;
		static ::Uml::AssociationRole meta_srcExtendedDelegate_rev;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

	};

	class PICML_Export MirrorPortInstanceBase :  public ExtendPortEnd {
	public:
		MirrorPortInstanceBase();
		MirrorPortInstanceBase(::Udm::ObjectImpl *impl);
		MirrorPortInstanceBase(const MirrorPortInstanceBase &master);

#ifdef UDM_RVALUE
		MirrorPortInstanceBase(MirrorPortInstanceBase &&master);

		static MirrorPortInstanceBase Cast(::Udm::Object &&a);
		MirrorPortInstanceBase& operator=(MirrorPortInstanceBase &&a);

#endif
		static MirrorPortInstanceBase Cast(const ::Udm::Object &a);
		static MirrorPortInstanceBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MirrorPortInstanceBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MirrorPortInstanceBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MirrorPortInstanceBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MirrorPortInstanceBase, Pred>(impl); };
		MirrorPortInstanceBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MirrorPortInstanceBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< MirrorPortInstanceBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MirrorPortInstanceBase, Pred>(impl); };
		::Udm::ArchetypeAttr< MirrorPortInstanceBase> Archetype() const;
		::Udm::AClassPointerAttr< MirrorDelegate, MirrorPortDelegate> dstMirrorDelegate() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstMirrorDelegate;
		static ::Uml::AssociationRole meta_dstMirrorDelegate_rev;

	};

	class PICML_Export MirrorPortDelegate :  public MirrorPortInstanceBase {
	public:
		MirrorPortDelegate();
		MirrorPortDelegate(::Udm::ObjectImpl *impl);
		MirrorPortDelegate(const MirrorPortDelegate &master);

#ifdef UDM_RVALUE
		MirrorPortDelegate(MirrorPortDelegate &&master);

		static MirrorPortDelegate Cast(::Udm::Object &&a);
		MirrorPortDelegate& operator=(MirrorPortDelegate &&a);

#endif
		static MirrorPortDelegate Cast(const ::Udm::Object &a);
		static MirrorPortDelegate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MirrorPortDelegate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MirrorPortDelegate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MirrorPortDelegate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MirrorPortDelegate, Pred>(impl); };
		MirrorPortDelegate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MirrorPortDelegate> Derived();
		template <class Pred> ::Udm::DerivedAttr< MirrorPortDelegate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MirrorPortDelegate, Pred>(impl); };
		::Udm::ArchetypeAttr< MirrorPortDelegate> Archetype() const;
		::Udm::AClassAssocAttr< MirrorDelegate, MirrorPortInstanceBase> srcMirrorDelegate() const;
		template <class Pred> ::Udm::AClassAssocAttr< MirrorDelegate, MirrorPortInstanceBase, Pred> srcMirrorDelegate_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< MirrorDelegate, MirrorPortInstanceBase, Pred>(impl, meta_srcMirrorDelegate, meta_srcMirrorDelegate_rev); };
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcMirrorDelegate;
		static ::Uml::AssociationRole meta_srcMirrorDelegate_rev;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

	};

	class PICML_Export OutEventPortEnd :  public ExternalPortEnd {
	public:
		OutEventPortEnd();
		OutEventPortEnd(::Udm::ObjectImpl *impl);
		OutEventPortEnd(const OutEventPortEnd &master);

#ifdef UDM_RVALUE
		OutEventPortEnd(OutEventPortEnd &&master);

		static OutEventPortEnd Cast(::Udm::Object &&a);
		OutEventPortEnd& operator=(OutEventPortEnd &&a);

#endif
		static OutEventPortEnd Cast(const ::Udm::Object &a);
		static OutEventPortEnd Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		OutEventPortEnd CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< OutEventPortEnd> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< OutEventPortEnd, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< OutEventPortEnd, Pred>(impl); };
		OutEventPortEnd CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< OutEventPortEnd> Derived();
		template <class Pred> ::Udm::DerivedAttr< OutEventPortEnd, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< OutEventPortEnd, Pred>(impl); };
		::Udm::ArchetypeAttr< OutEventPortEnd> Archetype() const;
		::Udm::AClassAssocAttr< EventSourceDelegate, OutEventPortDelegate> dstEventSourceDelegate() const;
		template <class Pred> ::Udm::AClassAssocAttr< EventSourceDelegate, OutEventPortDelegate, Pred> dstEventSourceDelegate_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< EventSourceDelegate, OutEventPortDelegate, Pred>(impl, meta_dstEventSourceDelegate, meta_dstEventSourceDelegate_rev); };
		::Udm::AClassAssocAttr< SendsTo, InEventPortEnd> dstSendsTo() const;
		template <class Pred> ::Udm::AClassAssocAttr< SendsTo, InEventPortEnd, Pred> dstSendsTo_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< SendsTo, InEventPortEnd, Pred>(impl, meta_dstSendsTo, meta_dstSendsTo_rev); };
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstEventSourceDelegate;
		static ::Uml::AssociationRole meta_dstEventSourceDelegate_rev;
		static ::Uml::AssociationRole meta_dstSendsTo;
		static ::Uml::AssociationRole meta_dstSendsTo_rev;

	};

	class PICML_Export OutEventPortDelegate :  public OutEventPortEnd {
	public:
		OutEventPortDelegate();
		OutEventPortDelegate(::Udm::ObjectImpl *impl);
		OutEventPortDelegate(const OutEventPortDelegate &master);

#ifdef UDM_RVALUE
		OutEventPortDelegate(OutEventPortDelegate &&master);

		static OutEventPortDelegate Cast(::Udm::Object &&a);
		OutEventPortDelegate& operator=(OutEventPortDelegate &&a);

#endif
		static OutEventPortDelegate Cast(const ::Udm::Object &a);
		static OutEventPortDelegate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		OutEventPortDelegate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< OutEventPortDelegate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< OutEventPortDelegate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< OutEventPortDelegate, Pred>(impl); };
		OutEventPortDelegate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< OutEventPortDelegate> Derived();
		template <class Pred> ::Udm::DerivedAttr< OutEventPortDelegate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< OutEventPortDelegate, Pred>(impl); };
		::Udm::ArchetypeAttr< OutEventPortDelegate> Archetype() const;
		::Udm::AClassAssocAttr< EventSourceDelegate, OutEventPortEnd> srcEventSourceDelegate() const;
		template <class Pred> ::Udm::AClassAssocAttr< EventSourceDelegate, OutEventPortEnd, Pred> srcEventSourceDelegate_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< EventSourceDelegate, OutEventPortEnd, Pred>(impl, meta_srcEventSourceDelegate, meta_srcEventSourceDelegate_rev); };
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcEventSourceDelegate;
		static ::Uml::AssociationRole meta_srcEventSourceDelegate_rev;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

	};

	class PICML_Export InEventPortEnd :  public ExternalPortEnd {
	public:
		InEventPortEnd();
		InEventPortEnd(::Udm::ObjectImpl *impl);
		InEventPortEnd(const InEventPortEnd &master);

#ifdef UDM_RVALUE
		InEventPortEnd(InEventPortEnd &&master);

		static InEventPortEnd Cast(::Udm::Object &&a);
		InEventPortEnd& operator=(InEventPortEnd &&a);

#endif
		static InEventPortEnd Cast(const ::Udm::Object &a);
		static InEventPortEnd Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		InEventPortEnd CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< InEventPortEnd> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< InEventPortEnd, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< InEventPortEnd, Pred>(impl); };
		InEventPortEnd CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< InEventPortEnd> Derived();
		template <class Pred> ::Udm::DerivedAttr< InEventPortEnd, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< InEventPortEnd, Pred>(impl); };
		::Udm::ArchetypeAttr< InEventPortEnd> Archetype() const;
		::Udm::AClassAssocAttr< EventSinkDelegate, InEventPortDelegate> srcEventSinkDelegate() const;
		template <class Pred> ::Udm::AClassAssocAttr< EventSinkDelegate, InEventPortDelegate, Pred> srcEventSinkDelegate_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< EventSinkDelegate, InEventPortDelegate, Pred>(impl, meta_srcEventSinkDelegate, meta_srcEventSinkDelegate_rev); };
		::Udm::AClassAssocAttr< SendsTo, OutEventPortEnd> srcSendsTo() const;
		template <class Pred> ::Udm::AClassAssocAttr< SendsTo, OutEventPortEnd, Pred> srcSendsTo_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< SendsTo, OutEventPortEnd, Pred>(impl, meta_srcSendsTo, meta_srcSendsTo_rev); };
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcEventSinkDelegate;
		static ::Uml::AssociationRole meta_srcEventSinkDelegate_rev;
		static ::Uml::AssociationRole meta_srcSendsTo;
		static ::Uml::AssociationRole meta_srcSendsTo_rev;

	};

	class PICML_Export InEventPortDelegate :  public InEventPortEnd {
	public:
		InEventPortDelegate();
		InEventPortDelegate(::Udm::ObjectImpl *impl);
		InEventPortDelegate(const InEventPortDelegate &master);

#ifdef UDM_RVALUE
		InEventPortDelegate(InEventPortDelegate &&master);

		static InEventPortDelegate Cast(::Udm::Object &&a);
		InEventPortDelegate& operator=(InEventPortDelegate &&a);

#endif
		static InEventPortDelegate Cast(const ::Udm::Object &a);
		static InEventPortDelegate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		InEventPortDelegate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< InEventPortDelegate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< InEventPortDelegate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< InEventPortDelegate, Pred>(impl); };
		InEventPortDelegate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< InEventPortDelegate> Derived();
		template <class Pred> ::Udm::DerivedAttr< InEventPortDelegate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< InEventPortDelegate, Pred>(impl); };
		::Udm::ArchetypeAttr< InEventPortDelegate> Archetype() const;
		::Udm::AClassAssocAttr< EventSinkDelegate, InEventPortEnd> dstEventSinkDelegate() const;
		template <class Pred> ::Udm::AClassAssocAttr< EventSinkDelegate, InEventPortEnd, Pred> dstEventSinkDelegate_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< EventSinkDelegate, InEventPortEnd, Pred>(impl, meta_dstEventSinkDelegate, meta_dstEventSinkDelegate_rev); };
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstEventSinkDelegate;
		static ::Uml::AssociationRole meta_dstEventSinkDelegate_rev;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

	};

	class PICML_Export Consume :  public MgaObject {
	public:
		Consume();
		Consume(::Udm::ObjectImpl *impl);
		Consume(const Consume &master);

#ifdef UDM_RVALUE
		Consume(Consume &&master);

		static Consume Cast(::Udm::Object &&a);
		Consume& operator=(Consume &&a);

#endif
		static Consume Cast(const ::Udm::Object &a);
		static Consume Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Consume CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Consume> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Consume, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Consume, Pred>(impl); };
		Consume CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Consume> Derived();
		template <class Pred> ::Udm::DerivedAttr< Consume, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Consume, Pred>(impl); };
		::Udm::ArchetypeAttr< Consume> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::ConnectorInstance> srcConsume_end() const;
		::Udm::AssocEndAttr< ::PICML::ExtendPortEnd> dstConsume_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcConsume_end_;
		static ::Uml::AssociationRole meta_dstConsume_end_;

	};

	class PICML_Export Publish :  public MgaObject {
	public:
		Publish();
		Publish(::Udm::ObjectImpl *impl);
		Publish(const Publish &master);

#ifdef UDM_RVALUE
		Publish(Publish &&master);

		static Publish Cast(::Udm::Object &&a);
		Publish& operator=(Publish &&a);

#endif
		static Publish Cast(const ::Udm::Object &a);
		static Publish Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Publish CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Publish> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Publish, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Publish, Pred>(impl); };
		Publish CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Publish> Derived();
		template <class Pred> ::Udm::DerivedAttr< Publish, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Publish, Pred>(impl); };
		::Udm::ArchetypeAttr< Publish> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::ExtendPortEnd> srcPublish_end() const;
		::Udm::AssocEndAttr< ::PICML::ConnectorInstance> dstPublish_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcPublish_end_;
		static ::Uml::AssociationRole meta_dstPublish_end_;

	};

	class PICML_Export AttributeMappingDelegate :  public MgaObject {
	public:
		AttributeMappingDelegate();
		AttributeMappingDelegate(::Udm::ObjectImpl *impl);
		AttributeMappingDelegate(const AttributeMappingDelegate &master);

#ifdef UDM_RVALUE
		AttributeMappingDelegate(AttributeMappingDelegate &&master);

		static AttributeMappingDelegate Cast(::Udm::Object &&a);
		AttributeMappingDelegate& operator=(AttributeMappingDelegate &&a);

#endif
		static AttributeMappingDelegate Cast(const ::Udm::Object &a);
		static AttributeMappingDelegate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		AttributeMappingDelegate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< AttributeMappingDelegate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< AttributeMappingDelegate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< AttributeMappingDelegate, Pred>(impl); };
		AttributeMappingDelegate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< AttributeMappingDelegate> Derived();
		template <class Pred> ::Udm::DerivedAttr< AttributeMappingDelegate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< AttributeMappingDelegate, Pred>(impl); };
		::Udm::ArchetypeAttr< AttributeMappingDelegate> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::AttributeMapping> srcAttributeMappingDelegate_end() const;
		::Udm::AssocEndAttr< ::PICML::AttributeMapping> dstAttributeMappingDelegate_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcAttributeMappingDelegate_end_;
		static ::Uml::AssociationRole meta_dstAttributeMappingDelegate_end_;

	};

	class PICML_Export AttributeMappingValue :  public MgaObject {
	public:
		AttributeMappingValue();
		AttributeMappingValue(::Udm::ObjectImpl *impl);
		AttributeMappingValue(const AttributeMappingValue &master);

#ifdef UDM_RVALUE
		AttributeMappingValue(AttributeMappingValue &&master);

		static AttributeMappingValue Cast(::Udm::Object &&a);
		AttributeMappingValue& operator=(AttributeMappingValue &&a);

#endif
		static AttributeMappingValue Cast(const ::Udm::Object &a);
		static AttributeMappingValue Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		AttributeMappingValue CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< AttributeMappingValue> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< AttributeMappingValue, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< AttributeMappingValue, Pred>(impl); };
		AttributeMappingValue CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< AttributeMappingValue> Derived();
		template <class Pred> ::Udm::DerivedAttr< AttributeMappingValue, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< AttributeMappingValue, Pred>(impl); };
		::Udm::ArchetypeAttr< AttributeMappingValue> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::AttributeMapping> srcAttributeMappingValue_end() const;
		::Udm::AssocEndAttr< ::PICML::Property> dstAttributeMappingValue_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcAttributeMappingValue_end_;
		static ::Uml::AssociationRole meta_dstAttributeMappingValue_end_;

	};

	class PICML_Export AttributeMapping :  public MgaObject {
	public:
		AttributeMapping();
		AttributeMapping(::Udm::ObjectImpl *impl);
		AttributeMapping(const AttributeMapping &master);

#ifdef UDM_RVALUE
		AttributeMapping(AttributeMapping &&master);

		static AttributeMapping Cast(::Udm::Object &&a);
		AttributeMapping& operator=(AttributeMapping &&a);

#endif
		static AttributeMapping Cast(const ::Udm::Object &a);
		static AttributeMapping Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		AttributeMapping CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< AttributeMapping> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< AttributeMapping, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< AttributeMapping, Pred>(impl); };
		AttributeMapping CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< AttributeMapping> Derived();
		template <class Pred> ::Udm::DerivedAttr< AttributeMapping, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< AttributeMapping, Pred>(impl); };
		::Udm::ArchetypeAttr< AttributeMapping> Archetype() const;
		::Udm::AClassAssocAttr< AttributeMappingDelegate, AttributeMapping> dstAttributeMappingDelegate() const;
		template <class Pred> ::Udm::AClassAssocAttr< AttributeMappingDelegate, AttributeMapping, Pred> dstAttributeMappingDelegate_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< AttributeMappingDelegate, AttributeMapping, Pred>(impl, meta_dstAttributeMappingDelegate, meta_dstAttributeMappingDelegate_rev); };
		::Udm::AClassPointerAttr< AttributeMappingDelegate, AttributeMapping> srcAttributeMappingDelegate() const;
		::Udm::AClassPointerAttr< AttributeMappingValue, Property> dstAttributeMappingValue() const;
		::Udm::AClassAssocAttr< AttributeDelegate, AttributeInstance> dstAttributeDelegate() const;
		template <class Pred> ::Udm::AClassAssocAttr< AttributeDelegate, AttributeInstance, Pred> dstAttributeDelegate_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< AttributeDelegate, AttributeInstance, Pred>(impl, meta_dstAttributeDelegate, meta_dstAttributeDelegate_rev); };
		::Udm::PointerAttr< AttributeInstance> ref() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstAttributeMappingDelegate;
		static ::Uml::AssociationRole meta_dstAttributeMappingDelegate_rev;
		static ::Uml::AssociationRole meta_srcAttributeMappingDelegate;
		static ::Uml::AssociationRole meta_srcAttributeMappingDelegate_rev;
		static ::Uml::AssociationRole meta_dstAttributeMappingValue;
		static ::Uml::AssociationRole meta_dstAttributeMappingValue_rev;
		static ::Uml::AssociationRole meta_dstAttributeDelegate;
		static ::Uml::AssociationRole meta_dstAttributeDelegate_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

	};

	class PICML_Export AttributeDelegate :  public MgaObject {
	public:
		AttributeDelegate();
		AttributeDelegate(::Udm::ObjectImpl *impl);
		AttributeDelegate(const AttributeDelegate &master);

#ifdef UDM_RVALUE
		AttributeDelegate(AttributeDelegate &&master);

		static AttributeDelegate Cast(::Udm::Object &&a);
		AttributeDelegate& operator=(AttributeDelegate &&a);

#endif
		static AttributeDelegate Cast(const ::Udm::Object &a);
		static AttributeDelegate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		AttributeDelegate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< AttributeDelegate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< AttributeDelegate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< AttributeDelegate, Pred>(impl); };
		AttributeDelegate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< AttributeDelegate> Derived();
		template <class Pred> ::Udm::DerivedAttr< AttributeDelegate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< AttributeDelegate, Pred>(impl); };
		::Udm::ArchetypeAttr< AttributeDelegate> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::AttributeMapping> srcAttributeDelegate_end() const;
		::Udm::AssocEndAttr< ::PICML::AttributeInstance> dstAttributeDelegate_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcAttributeDelegate_end_;
		static ::Uml::AssociationRole meta_dstAttributeDelegate_end_;

	};

	class PICML_Export AttributeValue :  public MgaObject {
	public:
		AttributeValue();
		AttributeValue(::Udm::ObjectImpl *impl);
		AttributeValue(const AttributeValue &master);

#ifdef UDM_RVALUE
		AttributeValue(AttributeValue &&master);

		static AttributeValue Cast(::Udm::Object &&a);
		AttributeValue& operator=(AttributeValue &&a);

#endif
		static AttributeValue Cast(const ::Udm::Object &a);
		static AttributeValue Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		AttributeValue CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< AttributeValue> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< AttributeValue, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< AttributeValue, Pred>(impl); };
		AttributeValue CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< AttributeValue> Derived();
		template <class Pred> ::Udm::DerivedAttr< AttributeValue, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< AttributeValue, Pred>(impl); };
		::Udm::ArchetypeAttr< AttributeValue> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::AttributeInstance> srcAttributeValue_end() const;
		::Udm::AssocEndAttr< ::PICML::Property> dstAttributeValue_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcAttributeValue_end_;
		static ::Uml::AssociationRole meta_dstAttributeValue_end_;

	};

	class PICML_Export ExternalDelegate :  public MgaObject {
	public:
		ExternalDelegate();
		ExternalDelegate(::Udm::ObjectImpl *impl);
		ExternalDelegate(const ExternalDelegate &master);

#ifdef UDM_RVALUE
		ExternalDelegate(ExternalDelegate &&master);

		static ExternalDelegate Cast(::Udm::Object &&a);
		ExternalDelegate& operator=(ExternalDelegate &&a);

#endif
		static ExternalDelegate Cast(const ::Udm::Object &a);
		static ExternalDelegate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ExternalDelegate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ExternalDelegate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ExternalDelegate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ExternalDelegate, Pred>(impl); };
		ExternalDelegate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ExternalDelegate> Derived();
		template <class Pred> ::Udm::DerivedAttr< ExternalDelegate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ExternalDelegate, Pred>(impl); };
		::Udm::ArchetypeAttr< ExternalDelegate> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::ExternalPort> srcExternalDelegate_end() const;
		::Udm::AssocEndAttr< ::PICML::ExternalPortEnd> dstExternalDelegate_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcExternalDelegate_end_;
		static ::Uml::AssociationRole meta_dstExternalDelegate_end_;

	};

	class PICML_Export EventSinkDelegate :  public MgaObject {
	public:
		EventSinkDelegate();
		EventSinkDelegate(::Udm::ObjectImpl *impl);
		EventSinkDelegate(const EventSinkDelegate &master);

#ifdef UDM_RVALUE
		EventSinkDelegate(EventSinkDelegate &&master);

		static EventSinkDelegate Cast(::Udm::Object &&a);
		EventSinkDelegate& operator=(EventSinkDelegate &&a);

#endif
		static EventSinkDelegate Cast(const ::Udm::Object &a);
		static EventSinkDelegate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		EventSinkDelegate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< EventSinkDelegate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< EventSinkDelegate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< EventSinkDelegate, Pred>(impl); };
		EventSinkDelegate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< EventSinkDelegate> Derived();
		template <class Pred> ::Udm::DerivedAttr< EventSinkDelegate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< EventSinkDelegate, Pred>(impl); };
		::Udm::ArchetypeAttr< EventSinkDelegate> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::InEventPortDelegate> srcEventSinkDelegate_end() const;
		::Udm::AssocEndAttr< ::PICML::InEventPortEnd> dstEventSinkDelegate_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcEventSinkDelegate_end_;
		static ::Uml::AssociationRole meta_dstEventSinkDelegate_end_;

	};

	class PICML_Export EventSourceDelegate :  public MgaObject {
	public:
		EventSourceDelegate();
		EventSourceDelegate(::Udm::ObjectImpl *impl);
		EventSourceDelegate(const EventSourceDelegate &master);

#ifdef UDM_RVALUE
		EventSourceDelegate(EventSourceDelegate &&master);

		static EventSourceDelegate Cast(::Udm::Object &&a);
		EventSourceDelegate& operator=(EventSourceDelegate &&a);

#endif
		static EventSourceDelegate Cast(const ::Udm::Object &a);
		static EventSourceDelegate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		EventSourceDelegate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< EventSourceDelegate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< EventSourceDelegate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< EventSourceDelegate, Pred>(impl); };
		EventSourceDelegate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< EventSourceDelegate> Derived();
		template <class Pred> ::Udm::DerivedAttr< EventSourceDelegate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< EventSourceDelegate, Pred>(impl); };
		::Udm::ArchetypeAttr< EventSourceDelegate> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::OutEventPortEnd> srcEventSourceDelegate_end() const;
		::Udm::AssocEndAttr< ::PICML::OutEventPortDelegate> dstEventSourceDelegate_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcEventSourceDelegate_end_;
		static ::Uml::AssociationRole meta_dstEventSourceDelegate_end_;

	};

	class PICML_Export FacetDelegate :  public MgaObject {
	public:
		FacetDelegate();
		FacetDelegate(::Udm::ObjectImpl *impl);
		FacetDelegate(const FacetDelegate &master);

#ifdef UDM_RVALUE
		FacetDelegate(FacetDelegate &&master);

		static FacetDelegate Cast(::Udm::Object &&a);
		FacetDelegate& operator=(FacetDelegate &&a);

#endif
		static FacetDelegate Cast(const ::Udm::Object &a);
		static FacetDelegate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		FacetDelegate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< FacetDelegate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< FacetDelegate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< FacetDelegate, Pred>(impl); };
		FacetDelegate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< FacetDelegate> Derived();
		template <class Pred> ::Udm::DerivedAttr< FacetDelegate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< FacetDelegate, Pred>(impl); };
		::Udm::ArchetypeAttr< FacetDelegate> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::ProvidedRequestPortDelegate> srcFacetDelegate_end() const;
		::Udm::AssocEndAttr< ::PICML::ProvidedRequestPortEnd> dstFacetDelegate_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcFacetDelegate_end_;
		static ::Uml::AssociationRole meta_dstFacetDelegate_end_;

	};

	class PICML_Export ReceptacleDelegate :  public MgaObject {
	public:
		ReceptacleDelegate();
		ReceptacleDelegate(::Udm::ObjectImpl *impl);
		ReceptacleDelegate(const ReceptacleDelegate &master);

#ifdef UDM_RVALUE
		ReceptacleDelegate(ReceptacleDelegate &&master);

		static ReceptacleDelegate Cast(::Udm::Object &&a);
		ReceptacleDelegate& operator=(ReceptacleDelegate &&a);

#endif
		static ReceptacleDelegate Cast(const ::Udm::Object &a);
		static ReceptacleDelegate Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ReceptacleDelegate CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ReceptacleDelegate> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ReceptacleDelegate, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ReceptacleDelegate, Pred>(impl); };
		ReceptacleDelegate CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ReceptacleDelegate> Derived();
		template <class Pred> ::Udm::DerivedAttr< ReceptacleDelegate, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ReceptacleDelegate, Pred>(impl); };
		::Udm::ArchetypeAttr< ReceptacleDelegate> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::RequiredRequestPortDelegate> srcReceptacleDelegate_end() const;
		::Udm::AssocEndAttr< ::PICML::RequiredRequestPortEnd> dstReceptacleDelegate_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcReceptacleDelegate_end_;
		static ::Uml::AssociationRole meta_dstReceptacleDelegate_end_;

	};

	class PICML_Export SendsTo :  public MgaObject {
	public:
		SendsTo();
		SendsTo(::Udm::ObjectImpl *impl);
		SendsTo(const SendsTo &master);

#ifdef UDM_RVALUE
		SendsTo(SendsTo &&master);

		static SendsTo Cast(::Udm::Object &&a);
		SendsTo& operator=(SendsTo &&a);

#endif
		static SendsTo Cast(const ::Udm::Object &a);
		static SendsTo Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		SendsTo CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< SendsTo> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< SendsTo, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< SendsTo, Pred>(impl); };
		SendsTo CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< SendsTo> Derived();
		template <class Pred> ::Udm::DerivedAttr< SendsTo, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< SendsTo, Pred>(impl); };
		::Udm::ArchetypeAttr< SendsTo> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::OutEventPortEnd> srcSendsTo_end() const;
		::Udm::AssocEndAttr< ::PICML::InEventPortEnd> dstSendsTo_end() const;
		void Accept(Visitor &v) const const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcSendsTo_end_;
		static ::Uml::AssociationRole meta_dstSendsTo_end_;

	};

	class PICML_Export AssemblyConfigProperty :  public MgaObject {
	public:
		AssemblyConfigProperty();
		AssemblyConfigProperty(::Udm::ObjectImpl *impl);
		AssemblyConfigProperty(const AssemblyConfigProperty &master);

#ifdef UDM_RVALUE
		AssemblyConfigProperty(AssemblyConfigProperty &&master);

		static AssemblyConfigProperty Cast(::Udm::Object &&a);
		AssemblyConfigProperty& operator=(AssemblyConfigProperty &&a);

#endif
		static AssemblyConfigProperty Cast(const ::Udm::Object &a);
		static AssemblyConfigProperty Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		AssemblyConfigProperty CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< AssemblyConfigProperty> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< AssemblyConfigProperty, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< AssemblyConfigProperty, Pred>(impl); };
		AssemblyConfigProperty CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< AssemblyConfigProperty> Derived();
		template <class Pred> ::Udm::DerivedAttr< AssemblyConfigProperty, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< AssemblyConfigProperty, Pred>(impl); };
		::Udm::ArchetypeAttr< AssemblyConfigProperty> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::AssemblyConfigPropertyEnd> srcAssemblyConfigProperty_end() const;
		::Udm::AssocEndAttr< ::PICML::Property> dstAssemblyConfigProperty_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcAssemblyConfigProperty_end_;
		static ::Uml::AssociationRole meta_dstAssemblyConfigProperty_end_;

	};

	class PICML_Export AssemblyselectRequirement :  public MgaObject {
	public:
		AssemblyselectRequirement();
		AssemblyselectRequirement(::Udm::ObjectImpl *impl);
		AssemblyselectRequirement(const AssemblyselectRequirement &master);

#ifdef UDM_RVALUE
		AssemblyselectRequirement(AssemblyselectRequirement &&master);

		static AssemblyselectRequirement Cast(::Udm::Object &&a);
		AssemblyselectRequirement& operator=(AssemblyselectRequirement &&a);

#endif
		static AssemblyselectRequirement Cast(const ::Udm::Object &a);
		static AssemblyselectRequirement Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		AssemblyselectRequirement CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< AssemblyselectRequirement> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< AssemblyselectRequirement, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< AssemblyselectRequirement, Pred>(impl); };
		AssemblyselectRequirement CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< AssemblyselectRequirement> Derived();
		template <class Pred> ::Udm::DerivedAttr< AssemblyselectRequirement, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< AssemblyselectRequirement, Pred>(impl); };
		::Udm::ArchetypeAttr< AssemblyselectRequirement> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::AssemblyConfigPropertyEnd> srcAssemblyselectRequirement_end() const;
		::Udm::AssocEndAttr< ::PICML::Requirement> dstAssemblyselectRequirement_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcAssemblyselectRequirement_end_;
		static ::Uml::AssociationRole meta_dstAssemblyselectRequirement_end_;

	};

	class PICML_Export Invoke :  public MgaObject {
	public:
		Invoke();
		Invoke(::Udm::ObjectImpl *impl);
		Invoke(const Invoke &master);

#ifdef UDM_RVALUE
		Invoke(Invoke &&master);

		static Invoke Cast(::Udm::Object &&a);
		Invoke& operator=(Invoke &&a);

#endif
		static Invoke Cast(const ::Udm::Object &a);
		static Invoke Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Invoke CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Invoke> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Invoke, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Invoke, Pred>(impl); };
		Invoke CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Invoke> Derived();
		template <class Pred> ::Udm::DerivedAttr< Invoke, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Invoke, Pred>(impl); };
		::Udm::ArchetypeAttr< Invoke> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		::Udm::AssocEndAttr< ::PICML::RequiredRequestPortEnd> srcinvoke_end() const;
		::Udm::AssocEndAttr< ::PICML::ProvidedRequestPortEnd> dstinvoke_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;
		static ::Uml::AssociationRole meta_srcinvoke_end_;
		static ::Uml::AssociationRole meta_dstinvoke_end_;

	};

	class PICML_Export PortInstance :  virtual  public MgaObject {
	public:
		PortInstance();
		PortInstance(::Udm::ObjectImpl *impl);
		PortInstance(const PortInstance &master);

#ifdef UDM_RVALUE
		PortInstance(PortInstance &&master);

		static PortInstance Cast(::Udm::Object &&a);
		PortInstance& operator=(PortInstance &&a);

#endif
		static PortInstance Cast(const ::Udm::Object &a);
		static PortInstance Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PortInstance CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PortInstance> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PortInstance, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PortInstance, Pred>(impl); };
		PortInstance CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PortInstance> Derived();
		template <class Pred> ::Udm::DerivedAttr< PortInstance, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PortInstance, Pred>(impl); };
		::Udm::ArchetypeAttr< PortInstance> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentInstance> ComponentInstance_parent() const;
		::Udm::ParentAttr< ::PICML::AssemblyConfigPropertyEnd> parent() const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentInstance_parent;

	};

	class PICML_Export SupportsInstance :  public ProvidedRequestPortEnd {
	public:
		SupportsInstance();
		SupportsInstance(::Udm::ObjectImpl *impl);
		SupportsInstance(const SupportsInstance &master);

#ifdef UDM_RVALUE
		SupportsInstance(SupportsInstance &&master);

		static SupportsInstance Cast(::Udm::Object &&a);
		SupportsInstance& operator=(SupportsInstance &&a);

#endif
		static SupportsInstance Cast(const ::Udm::Object &a);
		static SupportsInstance Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		SupportsInstance CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< SupportsInstance> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< SupportsInstance, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< SupportsInstance, Pred>(impl); };
		SupportsInstance CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< SupportsInstance> Derived();
		template <class Pred> ::Udm::DerivedAttr< SupportsInstance, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< SupportsInstance, Pred>(impl); };
		::Udm::ArchetypeAttr< SupportsInstance> Archetype() const;
		::Udm::PointerAttr< Supports> ref() const;
		::Udm::ParentAttr< ::PICML::ComponentInstance> ComponentInstance_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentInstance> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ComponentInstance_parent;

	};

	class PICML_Export RequiredRequestPortInstance :  public PortInstance,  public RequiredRequestPortEnd {
	public:
		RequiredRequestPortInstance();
		RequiredRequestPortInstance(::Udm::ObjectImpl *impl);
		RequiredRequestPortInstance(const RequiredRequestPortInstance &master);

#ifdef UDM_RVALUE
		RequiredRequestPortInstance(RequiredRequestPortInstance &&master);

		static RequiredRequestPortInstance Cast(::Udm::Object &&a);
		RequiredRequestPortInstance& operator=(RequiredRequestPortInstance &&a);

#endif
		static RequiredRequestPortInstance Cast(const ::Udm::Object &a);
		static RequiredRequestPortInstance Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		RequiredRequestPortInstance CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< RequiredRequestPortInstance> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< RequiredRequestPortInstance, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< RequiredRequestPortInstance, Pred>(impl); };
		RequiredRequestPortInstance CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< RequiredRequestPortInstance> Derived();
		template <class Pred> ::Udm::DerivedAttr< RequiredRequestPortInstance, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< RequiredRequestPortInstance, Pred>(impl); };
		::Udm::ArchetypeAttr< RequiredRequestPortInstance> Archetype() const;
		::Udm::PointerAttr< RequiredRequestPort> ref() const;
		::Udm::ParentAttr< ::PICML::ComponentInstance> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export InEventPortInstance :  public InEventPortEnd,  public PortInstance {
	public:
		InEventPortInstance();
		InEventPortInstance(::Udm::ObjectImpl *impl);
		InEventPortInstance(const InEventPortInstance &master);

#ifdef UDM_RVALUE
		InEventPortInstance(InEventPortInstance &&master);

		static InEventPortInstance Cast(::Udm::Object &&a);
		InEventPortInstance& operator=(InEventPortInstance &&a);

#endif
		static InEventPortInstance Cast(const ::Udm::Object &a);
		static InEventPortInstance Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		InEventPortInstance CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< InEventPortInstance> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< InEventPortInstance, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< InEventPortInstance, Pred>(impl); };
		InEventPortInstance CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< InEventPortInstance> Derived();
		template <class Pred> ::Udm::DerivedAttr< InEventPortInstance, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< InEventPortInstance, Pred>(impl); };
		::Udm::ArchetypeAttr< InEventPortInstance> Archetype() const;
		::Udm::PointerAttr< InEventPort> ref() const;
		::Udm::ParentAttr< ::PICML::ComponentInstance> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export ProvidedRequestPortInstance :  public PortInstance,  public ProvidedRequestPortEnd {
	public:
		ProvidedRequestPortInstance();
		ProvidedRequestPortInstance(::Udm::ObjectImpl *impl);
		ProvidedRequestPortInstance(const ProvidedRequestPortInstance &master);

#ifdef UDM_RVALUE
		ProvidedRequestPortInstance(ProvidedRequestPortInstance &&master);

		static ProvidedRequestPortInstance Cast(::Udm::Object &&a);
		ProvidedRequestPortInstance& operator=(ProvidedRequestPortInstance &&a);

#endif
		static ProvidedRequestPortInstance Cast(const ::Udm::Object &a);
		static ProvidedRequestPortInstance Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ProvidedRequestPortInstance CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ProvidedRequestPortInstance> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ProvidedRequestPortInstance, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ProvidedRequestPortInstance, Pred>(impl); };
		ProvidedRequestPortInstance CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ProvidedRequestPortInstance> Derived();
		template <class Pred> ::Udm::DerivedAttr< ProvidedRequestPortInstance, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ProvidedRequestPortInstance, Pred>(impl); };
		::Udm::ArchetypeAttr< ProvidedRequestPortInstance> Archetype() const;
		::Udm::PointerAttr< ProvidedRequestPort> ref() const;
		::Udm::ParentAttr< ::PICML::ComponentInstance> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export OutEventPortInstance :  public OutEventPortEnd,  public PortInstance {
	public:
		OutEventPortInstance();
		OutEventPortInstance(::Udm::ObjectImpl *impl);
		OutEventPortInstance(const OutEventPortInstance &master);

#ifdef UDM_RVALUE
		OutEventPortInstance(OutEventPortInstance &&master);

		static OutEventPortInstance Cast(::Udm::Object &&a);
		OutEventPortInstance& operator=(OutEventPortInstance &&a);

#endif
		static OutEventPortInstance Cast(const ::Udm::Object &a);
		static OutEventPortInstance Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		OutEventPortInstance CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< OutEventPortInstance> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< OutEventPortInstance, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< OutEventPortInstance, Pred>(impl); };
		OutEventPortInstance CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< OutEventPortInstance> Derived();
		template <class Pred> ::Udm::DerivedAttr< OutEventPortInstance, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< OutEventPortInstance, Pred>(impl); };
		::Udm::ArchetypeAttr< OutEventPortInstance> Archetype() const;
		::Udm::PointerAttr< OutEventPort> ref() const;
		::Udm::ParentAttr< ::PICML::ComponentInstance> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export MirrorPortInstance :  public MirrorPortInstanceBase,  public PortInstance {
	public:
		MirrorPortInstance();
		MirrorPortInstance(::Udm::ObjectImpl *impl);
		MirrorPortInstance(const MirrorPortInstance &master);

#ifdef UDM_RVALUE
		MirrorPortInstance(MirrorPortInstance &&master);

		static MirrorPortInstance Cast(::Udm::Object &&a);
		MirrorPortInstance& operator=(MirrorPortInstance &&a);

#endif
		static MirrorPortInstance Cast(const ::Udm::Object &a);
		static MirrorPortInstance Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MirrorPortInstance CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MirrorPortInstance> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MirrorPortInstance, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MirrorPortInstance, Pred>(impl); };
		MirrorPortInstance CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MirrorPortInstance> Derived();
		template <class Pred> ::Udm::DerivedAttr< MirrorPortInstance, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MirrorPortInstance, Pred>(impl); };
		::Udm::ArchetypeAttr< MirrorPortInstance> Archetype() const;
		::Udm::PointerAttr< MirrorPort> ref() const;
		::Udm::ParentAttr< ::PICML::ComponentInstance> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export ExtendedPortInstance :  public ExtendedPortInstanceBase,  public PortInstance {
	public:
		ExtendedPortInstance();
		ExtendedPortInstance(::Udm::ObjectImpl *impl);
		ExtendedPortInstance(const ExtendedPortInstance &master);

#ifdef UDM_RVALUE
		ExtendedPortInstance(ExtendedPortInstance &&master);

		static ExtendedPortInstance Cast(::Udm::Object &&a);
		ExtendedPortInstance& operator=(ExtendedPortInstance &&a);

#endif
		static ExtendedPortInstance Cast(const ::Udm::Object &a);
		static ExtendedPortInstance Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ExtendedPortInstance CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ExtendedPortInstance> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ExtendedPortInstance, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ExtendedPortInstance, Pred>(impl); };
		ExtendedPortInstance CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ExtendedPortInstance> Derived();
		template <class Pred> ::Udm::DerivedAttr< ExtendedPortInstance, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ExtendedPortInstance, Pred>(impl); };
		::Udm::ArchetypeAttr< ExtendedPortInstance> Archetype() const;
		::Udm::PointerAttr< ExtendedPort> ref() const;
		::Udm::ParentAttr< ::PICML::ComponentInstance> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export AttributeInstance :  public PortInstance {
	public:
		AttributeInstance();
		AttributeInstance(::Udm::ObjectImpl *impl);
		AttributeInstance(const AttributeInstance &master);

#ifdef UDM_RVALUE
		AttributeInstance(AttributeInstance &&master);

		static AttributeInstance Cast(::Udm::Object &&a);
		AttributeInstance& operator=(AttributeInstance &&a);

#endif
		static AttributeInstance Cast(const ::Udm::Object &a);
		static AttributeInstance Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		AttributeInstance CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< AttributeInstance> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< AttributeInstance, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< AttributeInstance, Pred>(impl); };
		AttributeInstance CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< AttributeInstance> Derived();
		template <class Pred> ::Udm::DerivedAttr< AttributeInstance, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< AttributeInstance, Pred>(impl); };
		::Udm::ArchetypeAttr< AttributeInstance> Archetype() const;
		::Udm::AClassPointerAttr< AttributeDelegate, AttributeMapping> srcAttributeDelegate() const;
		::Udm::AssocAttr< AttributeMapping> referedbyAttributeMapping() const;
		template <class Pred> ::Udm::AssocAttr< AttributeMapping, Pred> referedbyAttributeMapping_sorted(const Pred &) const { return ::Udm::AssocAttr< AttributeMapping, Pred>(impl, meta_referedbyAttributeMapping); };
		::Udm::PointerAttr< ReadonlyAttribute> ref() const;
		::Udm::AClassPointerAttr< AttributeValue, Property> dstAttributeValue() const;
		::Udm::ParentAttr< ::PICML::ConnectorInstance> ConnectorInstance_parent() const;
		::Udm::ParentAttr< ::PICML::AssemblyConfigPropertyEnd> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcAttributeDelegate;
		static ::Uml::AssociationRole meta_srcAttributeDelegate_rev;
		static ::Uml::AssociationRole meta_referedbyAttributeMapping;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_dstAttributeValue;
		static ::Uml::AssociationRole meta_dstAttributeValue_rev;
		static ::Uml::CompositionParentRole meta_ConnectorInstance_parent;

	};

	class PICML_Export ComponentInstanceType :  public MgaObject {
	public:
		ComponentInstanceType();
		ComponentInstanceType(::Udm::ObjectImpl *impl);
		ComponentInstanceType(const ComponentInstanceType &master);

#ifdef UDM_RVALUE
		ComponentInstanceType(ComponentInstanceType &&master);

		static ComponentInstanceType Cast(::Udm::Object &&a);
		ComponentInstanceType& operator=(ComponentInstanceType &&a);

#endif
		static ComponentInstanceType Cast(const ::Udm::Object &a);
		static ComponentInstanceType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentInstanceType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentInstanceType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentInstanceType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentInstanceType, Pred>(impl); };
		ComponentInstanceType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentInstanceType> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentInstanceType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentInstanceType, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentInstanceType> Archetype() const;
		::Udm::PointerAttr< MonolithicImplementation> ref() const;
		::Udm::ParentAttr< ::PICML::ComponentInstance> ComponentInstance_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentInstance> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ComponentInstance_parent;

	};

	class PICML_Export ComponentInstance :  public AssemblyConfigPropertyEnd {
	public:
		ComponentInstance();
		ComponentInstance(::Udm::ObjectImpl *impl);
		ComponentInstance(const ComponentInstance &master);

#ifdef UDM_RVALUE
		ComponentInstance(ComponentInstance &&master);

		static ComponentInstance Cast(::Udm::Object &&a);
		ComponentInstance& operator=(ComponentInstance &&a);

#endif
		static ComponentInstance Cast(const ::Udm::Object &a);
		static ComponentInstance Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentInstance CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentInstance> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentInstance, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentInstance, Pred>(impl); };
		ComponentInstance CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentInstance> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentInstance, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentInstance, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentInstance> Archetype() const;
		::Udm::StringAttr UUID() const;
		::Udm::AssocAttr< ComponentInstanceRef> referedbyComponentInstanceRef() const;
		template <class Pred> ::Udm::AssocAttr< ComponentInstanceRef, Pred> referedbyComponentInstanceRef_sorted(const Pred &) const { return ::Udm::AssocAttr< ComponentInstanceRef, Pred>(impl, meta_referedbyComponentInstanceRef); };
		::Udm::ChildrenAttr< ::PICML::PortInstance> PortInstance_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PortInstance, Pred> PortInstance_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PortInstance, Pred>(impl, meta_PortInstance_children); };
		::Udm::ChildrenAttr< ::PICML::SupportsInstance> SupportsInstance_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SupportsInstance, Pred> SupportsInstance_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SupportsInstance, Pred>(impl, meta_SupportsInstance_children); };
		::Udm::ChildAttr< ::PICML::ComponentInstanceType> ComponentInstanceType_child() const;
		::Udm::ChildrenAttr< ::PICML::ExternalPortEnd> ExternalPortEnd_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExternalPortEnd, Pred> ExternalPortEnd_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExternalPortEnd, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ProvidedRequestPortEnd> ProvidedRequestPortEnd_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPortEnd, Pred> ProvidedRequestPortEnd_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPortEnd, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PortInstance> PortInstance_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PortInstance, Pred> PortInstance_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PortInstance, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SupportsInstance> SupportsInstance_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SupportsInstance, Pred> SupportsInstance_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SupportsInstance, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequiredRequestPortInstance> RequiredRequestPortInstance_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequiredRequestPortInstance, Pred> RequiredRequestPortInstance_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequiredRequestPortInstance, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::InEventPortInstance> InEventPortInstance_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InEventPortInstance, Pred> InEventPortInstance_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InEventPortInstance, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ProvidedRequestPortInstance> ProvidedRequestPortInstance_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPortInstance, Pred> ProvidedRequestPortInstance_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPortInstance, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::OutEventPortInstance> OutEventPortInstance_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OutEventPortInstance, Pred> OutEventPortInstance_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OutEventPortInstance, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MirrorPortInstance> MirrorPortInstance_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MirrorPortInstance, Pred> MirrorPortInstance_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MirrorPortInstance, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExtendedPortInstance> ExtendedPortInstance_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExtendedPortInstance, Pred> ExtendedPortInstance_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExtendedPortInstance, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::AttributeInstance> AttributeInstance_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AttributeInstance, Pred> AttributeInstance_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AttributeInstance, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentInstanceType> ComponentInstanceType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentInstanceType, Pred> ComponentInstanceType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentInstanceType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::AssociationRole meta_referedbyComponentInstanceRef;
		static ::Uml::CompositionChildRole meta_PortInstance_children;
		static ::Uml::CompositionChildRole meta_SupportsInstance_children;
		static ::Uml::CompositionChildRole meta_ComponentInstanceType_child;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

	};

	class PICML_Export CriticalPath :  public MgaObject {
	public:
		CriticalPath();
		CriticalPath(::Udm::ObjectImpl *impl);
		CriticalPath(const CriticalPath &master);

#ifdef UDM_RVALUE
		CriticalPath(CriticalPath &&master);

		static CriticalPath Cast(::Udm::Object &&a);
		CriticalPath& operator=(CriticalPath &&a);

#endif
		static CriticalPath Cast(const ::Udm::Object &a);
		static CriticalPath Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		CriticalPath CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< CriticalPath> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< CriticalPath, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< CriticalPath, Pred>(impl); };
		CriticalPath CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< CriticalPath> Derived();
		template <class Pred> ::Udm::DerivedAttr< CriticalPath, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< CriticalPath, Pred>(impl); };
		::Udm::ArchetypeAttr< CriticalPath> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ComponentAssembly> srcCriticalPath_end() const;
		::Udm::AssocEndAttr< ::PICML::PathReference> dstCriticalPath_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcCriticalPath_end_;
		static ::Uml::AssociationRole meta_dstCriticalPath_end_;

	};

	class PICML_Export ComponentImplementationContainer :  public ImplementationContainer {
	public:
		ComponentImplementationContainer();
		ComponentImplementationContainer(::Udm::ObjectImpl *impl);
		ComponentImplementationContainer(const ComponentImplementationContainer &master);

#ifdef UDM_RVALUE
		ComponentImplementationContainer(ComponentImplementationContainer &&master);

		static ComponentImplementationContainer Cast(::Udm::Object &&a);
		ComponentImplementationContainer& operator=(ComponentImplementationContainer &&a);

#endif
		static ComponentImplementationContainer Cast(const ::Udm::Object &a);
		static ComponentImplementationContainer Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentImplementationContainer CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentImplementationContainer> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentImplementationContainer, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentImplementationContainer, Pred>(impl); };
		ComponentImplementationContainer CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentImplementationContainer> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentImplementationContainer, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentImplementationContainer, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentImplementationContainer> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::ComponentImplementation> ComponentImplementation_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentImplementation, Pred> ComponentImplementation_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentImplementation, Pred>(impl, meta_ComponentImplementation_children); };
		::Udm::ChildAttr< ::PICML::PathReference> PathReference_child() const;
		::Udm::ChildrenAttr< ::PICML::CriticalPath> CriticalPath_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CriticalPath, Pred> CriticalPath_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CriticalPath, Pred>(impl, meta_CriticalPath_children); };
		::Udm::ChildrenAttr< ::PICML::Capability> Capability_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Capability, Pred> Capability_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Capability, Pred>(impl, meta_Capability_children); };
		::Udm::ChildrenAttr< ::PICML::ImplementationCapability> ImplementationCapability_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationCapability, Pred> ImplementationCapability_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationCapability, Pred>(impl, meta_ImplementationCapability_children); };
		::Udm::ChildrenAttr< ::PICML::ImplementationDependency> ImplementationDependency_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationDependency, Pred> ImplementationDependency_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationDependency, Pred>(impl, meta_ImplementationDependency_children); };
		::Udm::ChildAttr< ::PICML::ComponentRef> ComponentRef_child() const;
		::Udm::ChildAttr< ::PICML::Implements> Implements_child() const;
		::Udm::ChildrenAttr< ::PICML::ImplementationDependsOn> ImplementationDependsOn_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationDependsOn, Pred> ImplementationDependsOn_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationDependsOn, Pred>(impl, meta_ImplementationDependsOn_children); };
		::Udm::ChildrenAttr< ::PICML::Implemenation> Implemenation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Implemenation, Pred> Implemenation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Implemenation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PathReference> PathReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PathReference, Pred> PathReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PathReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Capability> Capability_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Capability, Pred> Capability_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Capability, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequirementSatisfier> RequirementSatisfier_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred> RequirementSatisfier_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequirementSatisfier, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ImplementationDependency> ImplementationDependency_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationDependency, Pred> ImplementationDependency_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationDependency, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentAssembly> ComponentAssembly_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentAssembly, Pred> ComponentAssembly_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentAssembly, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::CriticalPath> CriticalPath_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CriticalPath, Pred> CriticalPath_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CriticalPath, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MonolithicImplementation> MonolithicImplementation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MonolithicImplementation, Pred> MonolithicImplementation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MonolithicImplementation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentImplementation> ComponentImplementation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentImplementation, Pred> ComponentImplementation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentImplementation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Implements> Implements_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Implements, Pred> Implements_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Implements, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ImplementationDependsOn> ImplementationDependsOn_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationDependsOn, Pred> ImplementationDependsOn_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationDependsOn, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ImplementationCapability> ImplementationCapability_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ImplementationCapability, Pred> ImplementationCapability_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ImplementationCapability, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Manageable> Manageable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Manageable, Pred> Manageable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Manageable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::ComponentImplementations> ComponentImplementations_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentImplementations> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_ComponentImplementation_children;
		static ::Uml::CompositionChildRole meta_PathReference_child;
		static ::Uml::CompositionChildRole meta_CriticalPath_children;
		static ::Uml::CompositionChildRole meta_Capability_children;
		static ::Uml::CompositionChildRole meta_ImplementationCapability_children;
		static ::Uml::CompositionChildRole meta_ImplementationDependency_children;
		static ::Uml::CompositionChildRole meta_ComponentRef_child;
		static ::Uml::CompositionChildRole meta_Implements_child;
		static ::Uml::CompositionChildRole meta_ImplementationDependsOn_children;
		static ::Uml::CompositionParentRole meta_ComponentImplementations_parent;

	};

	class PICML_Export ComponentImplementation :  virtual  public Implemenation {
	public:
		ComponentImplementation();
		ComponentImplementation(::Udm::ObjectImpl *impl);
		ComponentImplementation(const ComponentImplementation &master);

#ifdef UDM_RVALUE
		ComponentImplementation(ComponentImplementation &&master);

		static ComponentImplementation Cast(::Udm::Object &&a);
		ComponentImplementation& operator=(ComponentImplementation &&a);

#endif
		static ComponentImplementation Cast(const ::Udm::Object &a);
		static ComponentImplementation Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentImplementation CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentImplementation> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentImplementation, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentImplementation, Pred>(impl); };
		ComponentImplementation CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentImplementation> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentImplementation, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentImplementation, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentImplementation> Archetype() const;
		::Udm::AClassPointerAttr< Implements, ComponentRef> dstImplements() const;
		::Udm::AClassAssocAttr< ImplementationDependsOn, ImplementationDependency> dstImplementationDependsOn() const;
		template <class Pred> ::Udm::AClassAssocAttr< ImplementationDependsOn, ImplementationDependency, Pred> dstImplementationDependsOn_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ImplementationDependsOn, ImplementationDependency, Pred>(impl, meta_dstImplementationDependsOn, meta_dstImplementationDependsOn_rev); };
		::Udm::AClassAssocAttr< ImplementationCapability, Capability> dstImplementationCapability() const;
		template <class Pred> ::Udm::AClassAssocAttr< ImplementationCapability, Capability, Pred> dstImplementationCapability_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ImplementationCapability, Capability, Pred>(impl, meta_dstImplementationCapability, meta_dstImplementationCapability_rev); };
		::Udm::AssocAttr< ComponentImplementationReference> referedbyComponentImplementationReference() const;
		template <class Pred> ::Udm::AssocAttr< ComponentImplementationReference, Pred> referedbyComponentImplementationReference_sorted(const Pred &) const { return ::Udm::AssocAttr< ComponentImplementationReference, Pred>(impl, meta_referedbyComponentImplementationReference); };
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstImplements;
		static ::Uml::AssociationRole meta_dstImplements_rev;
		static ::Uml::AssociationRole meta_dstImplementationDependsOn;
		static ::Uml::AssociationRole meta_dstImplementationDependsOn_rev;
		static ::Uml::AssociationRole meta_dstImplementationCapability;
		static ::Uml::AssociationRole meta_dstImplementationCapability_rev;
		static ::Uml::AssociationRole meta_referedbyComponentImplementationReference;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;

	};

	class PICML_Export ComponentAssembly :  public ComponentImplementation {
	public:
		ComponentAssembly();
		ComponentAssembly(::Udm::ObjectImpl *impl);
		ComponentAssembly(const ComponentAssembly &master);

#ifdef UDM_RVALUE
		ComponentAssembly(ComponentAssembly &&master);

		static ComponentAssembly Cast(::Udm::Object &&a);
		ComponentAssembly& operator=(ComponentAssembly &&a);

#endif
		static ComponentAssembly Cast(const ::Udm::Object &a);
		static ComponentAssembly Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentAssembly CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentAssembly> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentAssembly, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentAssembly, Pred>(impl); };
		ComponentAssembly CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentAssembly> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentAssembly, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentAssembly, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentAssembly> Archetype() const;
		::Udm::AssocAttr< ComponentAssemblyReference> referedbyComponentAssemblyReference() const;
		template <class Pred> ::Udm::AssocAttr< ComponentAssemblyReference, Pred> referedbyComponentAssemblyReference_sorted(const Pred &) const { return ::Udm::AssocAttr< ComponentAssemblyReference, Pred>(impl, meta_referedbyComponentAssemblyReference); };
		::Udm::AClassPointerAttr< CriticalPath, PathReference> dstCriticalPath() const;
		::Udm::ChildrenAttr< ::PICML::Property> Property_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); };
		::Udm::ChildrenAttr< ::PICML::MirrorDelegate> MirrorDelegate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MirrorDelegate, Pred> MirrorDelegate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MirrorDelegate, Pred>(impl, meta_MirrorDelegate_children); };
		::Udm::ChildrenAttr< ::PICML::MirrorPortDelegate> MirrorPortDelegate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MirrorPortDelegate, Pred> MirrorPortDelegate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MirrorPortDelegate, Pred>(impl, meta_MirrorPortDelegate_children); };
		::Udm::ChildrenAttr< ::PICML::ExtendedPortDelegate> ExtendedPortDelegate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExtendedPortDelegate, Pred> ExtendedPortDelegate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExtendedPortDelegate, Pred>(impl, meta_ExtendedPortDelegate_children); };
		::Udm::ChildrenAttr< ::PICML::ExtendedDelegate> ExtendedDelegate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExtendedDelegate, Pred> ExtendedDelegate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExtendedDelegate, Pred>(impl, meta_ExtendedDelegate_children); };
		::Udm::ChildrenAttr< ::PICML::ConnectorToFacet> ConnectorToFacet_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorToFacet, Pred> ConnectorToFacet_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorToFacet, Pred>(impl, meta_ConnectorToFacet_children); };
		::Udm::ChildrenAttr< ::PICML::ConnectorToReceptacle> ConnectorToReceptacle_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorToReceptacle, Pred> ConnectorToReceptacle_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorToReceptacle, Pred>(impl, meta_ConnectorToReceptacle_children); };
		::Udm::ChildrenAttr< ::PICML::ProvidedRequestPortDelegate> ProvidedRequestPortDelegate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPortDelegate, Pred> ProvidedRequestPortDelegate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPortDelegate, Pred>(impl, meta_ProvidedRequestPortDelegate_children); };
		::Udm::ChildrenAttr< ::PICML::RequiredRequestPortDelegate> RequiredRequestPortDelegate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequiredRequestPortDelegate, Pred> RequiredRequestPortDelegate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequiredRequestPortDelegate, Pred>(impl, meta_RequiredRequestPortDelegate_children); };
		::Udm::ChildrenAttr< ::PICML::OutEventPortDelegate> OutEventPortDelegate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OutEventPortDelegate, Pred> OutEventPortDelegate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OutEventPortDelegate, Pred>(impl, meta_OutEventPortDelegate_children); };
		::Udm::ChildrenAttr< ::PICML::InEventPortDelegate> InEventPortDelegate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InEventPortDelegate, Pred> InEventPortDelegate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InEventPortDelegate, Pred>(impl, meta_InEventPortDelegate_children); };
		::Udm::ChildrenAttr< ::PICML::Consume> Consume_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Consume, Pred> Consume_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Consume, Pred>(impl, meta_Consume_children); };
		::Udm::ChildrenAttr< ::PICML::Publish> Publish_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Publish, Pred> Publish_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Publish, Pred>(impl, meta_Publish_children); };
		::Udm::ChildrenAttr< ::PICML::ConnectorInstance> ConnectorInstance_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorInstance, Pred> ConnectorInstance_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorInstance, Pred>(impl, meta_ConnectorInstance_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentInstance> ComponentInstance_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentInstance, Pred> ComponentInstance_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentInstance, Pred>(impl, meta_ComponentInstance_children); };
		::Udm::ChildrenAttr< ::PICML::ExternalPort> ExternalPort_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExternalPort, Pred> ExternalPort_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExternalPort, Pred>(impl, meta_ExternalPort_children); };
		::Udm::ChildrenAttr< ::PICML::AttributeMapping> AttributeMapping_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AttributeMapping, Pred> AttributeMapping_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AttributeMapping, Pred>(impl, meta_AttributeMapping_children); };
		::Udm::ChildrenAttr< ::PICML::ExternalDelegate> ExternalDelegate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExternalDelegate, Pred> ExternalDelegate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExternalDelegate, Pred>(impl, meta_ExternalDelegate_children); };
		::Udm::ChildrenAttr< ::PICML::AttributeMappingDelegate> AttributeMappingDelegate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AttributeMappingDelegate, Pred> AttributeMappingDelegate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AttributeMappingDelegate, Pred>(impl, meta_AttributeMappingDelegate_children); };
		::Udm::ChildrenAttr< ::PICML::ReceptacleDelegate> ReceptacleDelegate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ReceptacleDelegate, Pred> ReceptacleDelegate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ReceptacleDelegate, Pred>(impl, meta_ReceptacleDelegate_children); };
		::Udm::ChildrenAttr< ::PICML::Invoke> Invoke_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Invoke, Pred> Invoke_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Invoke, Pred>(impl, meta_Invoke_children); };
		::Udm::ChildrenAttr< ::PICML::FacetDelegate> FacetDelegate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::FacetDelegate, Pred> FacetDelegate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::FacetDelegate, Pred>(impl, meta_FacetDelegate_children); };
		::Udm::ChildrenAttr< ::PICML::AssemblyConfigProperty> AssemblyConfigProperty_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AssemblyConfigProperty, Pred> AssemblyConfigProperty_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AssemblyConfigProperty, Pred>(impl, meta_AssemblyConfigProperty_children); };
		::Udm::ChildrenAttr< ::PICML::AttributeMappingValue> AttributeMappingValue_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AttributeMappingValue, Pred> AttributeMappingValue_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AttributeMappingValue, Pred>(impl, meta_AttributeMappingValue_children); };
		::Udm::ChildrenAttr< ::PICML::AttributeDelegate> AttributeDelegate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AttributeDelegate, Pred> AttributeDelegate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AttributeDelegate, Pred>(impl, meta_AttributeDelegate_children); };
		::Udm::ChildrenAttr< ::PICML::AttributeValue> AttributeValue_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AttributeValue, Pred> AttributeValue_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AttributeValue, Pred>(impl, meta_AttributeValue_children); };
		::Udm::ChildrenAttr< ::PICML::AssemblyselectRequirement> AssemblyselectRequirement_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AssemblyselectRequirement, Pred> AssemblyselectRequirement_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AssemblyselectRequirement, Pred>(impl, meta_AssemblyselectRequirement_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference> ComponentAssemblyReference_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference, Pred> ComponentAssemblyReference_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference, Pred>(impl, meta_ComponentAssemblyReference_children); };
		::Udm::ChildrenAttr< ::PICML::EventSinkDelegate> EventSinkDelegate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::EventSinkDelegate, Pred> EventSinkDelegate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::EventSinkDelegate, Pred>(impl, meta_EventSinkDelegate_children); };
		::Udm::ChildrenAttr< ::PICML::EventSourceDelegate> EventSourceDelegate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::EventSourceDelegate, Pred> EventSourceDelegate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::EventSourceDelegate, Pred>(impl, meta_EventSourceDelegate_children); };
		::Udm::ChildrenAttr< ::PICML::SendsTo> SendsTo_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SendsTo, Pred> SendsTo_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SendsTo, Pred>(impl, meta_SendsTo_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentAssembly> ComponentAssembly_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentAssembly, Pred> ComponentAssembly_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentAssembly, Pred>(impl, meta_ComponentAssembly_children); };
		::Udm::ChildrenAttr< ::PICML::Requirement> Requirement_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Requirement, Pred> Requirement_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Requirement, Pred>(impl, meta_Requirement_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentPackageReference> ComponentPackageReference_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentPackageReference, Pred> ComponentPackageReference_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentPackageReference, Pred>(impl, meta_ComponentPackageReference_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentPackage> ComponentPackage_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentPackage, Pred> ComponentPackage_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentPackage, Pred>(impl, meta_ComponentPackage_children); };
		::Udm::ChildrenAttr< ::PICML::Implemenation> Implemenation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Implemenation, Pred> Implemenation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Implemenation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RTRequirements> RTRequirements_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RTRequirements, Pred> RTRequirements_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RTRequirements, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ECRequirements> ECRequirements_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ECRequirements, Pred> ECRequirements_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ECRequirements, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::CollocationGroupMember> CollocationGroupMember_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred> CollocationGroupMember_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CollocationGroupMember, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentPackageReference> ComponentPackageReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentPackageReference, Pred> ComponentPackageReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentPackageReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentPackage> ComponentPackage_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentPackage, Pred> ComponentPackage_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentPackage, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComplexProperty> ComplexProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred> ComplexProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SimpleProperty> SimpleProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred> SimpleProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequirementBase> RequirementBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequirementBase, Pred> RequirementBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequirementBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Requirement> Requirement_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Requirement, Pred> Requirement_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Requirement, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExternalPort> ExternalPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExternalPort, Pred> ExternalPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExternalPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference> ComponentAssemblyReference_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference, Pred> ComponentAssemblyReference_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentAssemblyReference, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentAssembly> ComponentAssembly_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentAssembly, Pred> ComponentAssembly_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentAssembly, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExtendedDelegate> ExtendedDelegate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExtendedDelegate, Pred> ExtendedDelegate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExtendedDelegate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExtendedPortDelegate> ExtendedPortDelegate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExtendedPortDelegate, Pred> ExtendedPortDelegate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExtendedPortDelegate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExtendedPortInstanceBase> ExtendedPortInstanceBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExtendedPortInstanceBase, Pred> ExtendedPortInstanceBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExtendedPortInstanceBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MirrorPortInstanceBase> MirrorPortInstanceBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MirrorPortInstanceBase, Pred> MirrorPortInstanceBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MirrorPortInstanceBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MirrorPortDelegate> MirrorPortDelegate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MirrorPortDelegate, Pred> MirrorPortDelegate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MirrorPortDelegate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MirrorDelegate> MirrorDelegate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MirrorDelegate, Pred> MirrorDelegate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MirrorDelegate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::AssemblyConfigPropertyEnd> AssemblyConfigPropertyEnd_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AssemblyConfigPropertyEnd, Pred> AssemblyConfigPropertyEnd_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AssemblyConfigPropertyEnd, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ConnectorToFacet> ConnectorToFacet_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorToFacet, Pred> ConnectorToFacet_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorToFacet, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ConnectorToReceptacle> ConnectorToReceptacle_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorToReceptacle, Pred> ConnectorToReceptacle_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorToReceptacle, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExternalPortEnd> ExternalPortEnd_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExternalPortEnd, Pred> ExternalPortEnd_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExternalPortEnd, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ProvidedRequestPortEnd> ProvidedRequestPortEnd_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPortEnd, Pred> ProvidedRequestPortEnd_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPortEnd, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ProvidedRequestPortDelegate> ProvidedRequestPortDelegate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPortDelegate, Pred> ProvidedRequestPortDelegate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPortDelegate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequiredRequestPortDelegate> RequiredRequestPortDelegate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequiredRequestPortDelegate, Pred> RequiredRequestPortDelegate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequiredRequestPortDelegate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::OutEventPortDelegate> OutEventPortDelegate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OutEventPortDelegate, Pred> OutEventPortDelegate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OutEventPortDelegate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::InEventPortDelegate> InEventPortDelegate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InEventPortDelegate, Pred> InEventPortDelegate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InEventPortDelegate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequiredRequestPortEnd> RequiredRequestPortEnd_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequiredRequestPortEnd, Pred> RequiredRequestPortEnd_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequiredRequestPortEnd, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExtendPortEnd> ExtendPortEnd_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExtendPortEnd, Pred> ExtendPortEnd_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExtendPortEnd, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::OutEventPortEnd> OutEventPortEnd_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OutEventPortEnd, Pred> OutEventPortEnd_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OutEventPortEnd, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::InEventPortEnd> InEventPortEnd_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InEventPortEnd, Pred> InEventPortEnd_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InEventPortEnd, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Consume> Consume_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Consume, Pred> Consume_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Consume, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Publish> Publish_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Publish, Pred> Publish_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Publish, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::AttributeMappingDelegate> AttributeMappingDelegate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AttributeMappingDelegate, Pred> AttributeMappingDelegate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AttributeMappingDelegate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::AttributeMappingValue> AttributeMappingValue_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AttributeMappingValue, Pred> AttributeMappingValue_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AttributeMappingValue, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::AttributeMapping> AttributeMapping_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AttributeMapping, Pred> AttributeMapping_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AttributeMapping, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::AttributeDelegate> AttributeDelegate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AttributeDelegate, Pred> AttributeDelegate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AttributeDelegate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::AttributeValue> AttributeValue_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AttributeValue, Pred> AttributeValue_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AttributeValue, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExternalDelegate> ExternalDelegate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExternalDelegate, Pred> ExternalDelegate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExternalDelegate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::EventSinkDelegate> EventSinkDelegate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::EventSinkDelegate, Pred> EventSinkDelegate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::EventSinkDelegate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::EventSourceDelegate> EventSourceDelegate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::EventSourceDelegate, Pred> EventSourceDelegate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::EventSourceDelegate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::FacetDelegate> FacetDelegate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::FacetDelegate, Pred> FacetDelegate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::FacetDelegate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ReceptacleDelegate> ReceptacleDelegate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ReceptacleDelegate, Pred> ReceptacleDelegate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ReceptacleDelegate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SendsTo> SendsTo_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SendsTo, Pred> SendsTo_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SendsTo, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::AssemblyConfigProperty> AssemblyConfigProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AssemblyConfigProperty, Pred> AssemblyConfigProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AssemblyConfigProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::AssemblyselectRequirement> AssemblyselectRequirement_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AssemblyselectRequirement, Pred> AssemblyselectRequirement_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AssemblyselectRequirement, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Invoke> Invoke_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Invoke, Pred> Invoke_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Invoke, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentInstance> ComponentInstance_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentInstance, Pred> ComponentInstance_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentInstance, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentImplementation> ComponentImplementation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentImplementation, Pred> ComponentImplementation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentImplementation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ConnectorInstance> ConnectorInstance_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorInstance, Pred> ConnectorInstance_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorInstance, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyComponentAssemblyReference;
		static ::Uml::AssociationRole meta_dstCriticalPath;
		static ::Uml::AssociationRole meta_dstCriticalPath_rev;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_MirrorDelegate_children;
		static ::Uml::CompositionChildRole meta_MirrorPortDelegate_children;
		static ::Uml::CompositionChildRole meta_ExtendedPortDelegate_children;
		static ::Uml::CompositionChildRole meta_ExtendedDelegate_children;
		static ::Uml::CompositionChildRole meta_ConnectorToFacet_children;
		static ::Uml::CompositionChildRole meta_ConnectorToReceptacle_children;
		static ::Uml::CompositionChildRole meta_ProvidedRequestPortDelegate_children;
		static ::Uml::CompositionChildRole meta_RequiredRequestPortDelegate_children;
		static ::Uml::CompositionChildRole meta_OutEventPortDelegate_children;
		static ::Uml::CompositionChildRole meta_InEventPortDelegate_children;
		static ::Uml::CompositionChildRole meta_Consume_children;
		static ::Uml::CompositionChildRole meta_Publish_children;
		static ::Uml::CompositionChildRole meta_ConnectorInstance_children;
		static ::Uml::CompositionChildRole meta_ComponentInstance_children;
		static ::Uml::CompositionChildRole meta_ExternalPort_children;
		static ::Uml::CompositionChildRole meta_AttributeMapping_children;
		static ::Uml::CompositionChildRole meta_ExternalDelegate_children;
		static ::Uml::CompositionChildRole meta_AttributeMappingDelegate_children;
		static ::Uml::CompositionChildRole meta_ReceptacleDelegate_children;
		static ::Uml::CompositionChildRole meta_Invoke_children;
		static ::Uml::CompositionChildRole meta_FacetDelegate_children;
		static ::Uml::CompositionChildRole meta_AssemblyConfigProperty_children;
		static ::Uml::CompositionChildRole meta_AttributeMappingValue_children;
		static ::Uml::CompositionChildRole meta_AttributeDelegate_children;
		static ::Uml::CompositionChildRole meta_AttributeValue_children;
		static ::Uml::CompositionChildRole meta_AssemblyselectRequirement_children;
		static ::Uml::CompositionChildRole meta_ComponentAssemblyReference_children;
		static ::Uml::CompositionChildRole meta_EventSinkDelegate_children;
		static ::Uml::CompositionChildRole meta_EventSourceDelegate_children;
		static ::Uml::CompositionChildRole meta_SendsTo_children;
		static ::Uml::CompositionChildRole meta_ComponentAssembly_children;
		static ::Uml::CompositionChildRole meta_Requirement_children;
		static ::Uml::CompositionChildRole meta_ComponentPackageReference_children;
		static ::Uml::CompositionChildRole meta_ComponentPackage_children;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

	};

	class PICML_Export MonolithicImplementation :  public ComponentImplementation,  public MonolithicImplementationBase {
	public:
		MonolithicImplementation();
		MonolithicImplementation(::Udm::ObjectImpl *impl);
		MonolithicImplementation(const MonolithicImplementation &master);

#ifdef UDM_RVALUE
		MonolithicImplementation(MonolithicImplementation &&master);

		static MonolithicImplementation Cast(::Udm::Object &&a);
		MonolithicImplementation& operator=(MonolithicImplementation &&a);

#endif
		static MonolithicImplementation Cast(const ::Udm::Object &a);
		static MonolithicImplementation Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MonolithicImplementation CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MonolithicImplementation> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MonolithicImplementation, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MonolithicImplementation, Pred>(impl); };
		MonolithicImplementation CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MonolithicImplementation> Derived();
		template <class Pred> ::Udm::DerivedAttr< MonolithicImplementation, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MonolithicImplementation, Pred>(impl); };
		::Udm::ArchetypeAttr< MonolithicImplementation> Archetype() const;
		::Udm::StringAttr defaultVersion() const;
		::Udm::AssocAttr< ComponentInstanceType> referedbyComponentInstanceType() const;
		template <class Pred> ::Udm::AssocAttr< ComponentInstanceType, Pred> referedbyComponentInstanceType_sorted(const Pred &) const { return ::Udm::AssocAttr< ComponentInstanceType, Pred>(impl, meta_referedbyComponentInstanceType); };
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_defaultVersion;
		static ::Uml::AssociationRole meta_referedbyComponentInstanceType;

	};

	class PICML_Export ComponentImplementationReference :  public MgaObject {
	public:
		ComponentImplementationReference();
		ComponentImplementationReference(::Udm::ObjectImpl *impl);
		ComponentImplementationReference(const ComponentImplementationReference &master);

#ifdef UDM_RVALUE
		ComponentImplementationReference(ComponentImplementationReference &&master);

		static ComponentImplementationReference Cast(::Udm::Object &&a);
		ComponentImplementationReference& operator=(ComponentImplementationReference &&a);

#endif
		static ComponentImplementationReference Cast(const ::Udm::Object &a);
		static ComponentImplementationReference Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentImplementationReference CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentImplementationReference> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentImplementationReference, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentImplementationReference, Pred>(impl); };
		ComponentImplementationReference CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentImplementationReference> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentImplementationReference, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentImplementationReference, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentImplementationReference> Archetype() const;
		::Udm::AClassAssocAttr< Implementation, ComponentPackage> srcImplementation() const;
		template <class Pred> ::Udm::AClassAssocAttr< Implementation, ComponentPackage, Pred> srcImplementation_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< Implementation, ComponentPackage, Pred>(impl, meta_srcImplementation, meta_srcImplementation_rev); };
		::Udm::PointerAttr< ComponentImplementation> ref() const;
		::Udm::ParentAttr< ::PICML::PackageContainer> PackageContainer_parent() const;
		::Udm::ParentAttr< ::PICML::PackageContainer> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcImplementation;
		static ::Uml::AssociationRole meta_srcImplementation_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_PackageContainer_parent;

	};

	class PICML_Export Implements :  public MgaObject {
	public:
		Implements();
		Implements(::Udm::ObjectImpl *impl);
		Implements(const Implements &master);

#ifdef UDM_RVALUE
		Implements(Implements &&master);

		static Implements Cast(::Udm::Object &&a);
		Implements& operator=(Implements &&a);

#endif
		static Implements Cast(const ::Udm::Object &a);
		static Implements Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Implements CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Implements> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Implements, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Implements, Pred>(impl); };
		Implements CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Implements> Derived();
		template <class Pred> ::Udm::DerivedAttr< Implements, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Implements, Pred>(impl); };
		::Udm::ArchetypeAttr< Implements> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ComponentImplementation> srcImplements_end() const;
		::Udm::AssocEndAttr< ::PICML::ComponentRef> dstImplements_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcImplements_end_;
		static ::Uml::AssociationRole meta_dstImplements_end_;

	};

	class PICML_Export ImplementationDependsOn :  public MgaObject {
	public:
		ImplementationDependsOn();
		ImplementationDependsOn(::Udm::ObjectImpl *impl);
		ImplementationDependsOn(const ImplementationDependsOn &master);

#ifdef UDM_RVALUE
		ImplementationDependsOn(ImplementationDependsOn &&master);

		static ImplementationDependsOn Cast(::Udm::Object &&a);
		ImplementationDependsOn& operator=(ImplementationDependsOn &&a);

#endif
		static ImplementationDependsOn Cast(const ::Udm::Object &a);
		static ImplementationDependsOn Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ImplementationDependsOn CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ImplementationDependsOn> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ImplementationDependsOn, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ImplementationDependsOn, Pred>(impl); };
		ImplementationDependsOn CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ImplementationDependsOn> Derived();
		template <class Pred> ::Udm::DerivedAttr< ImplementationDependsOn, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ImplementationDependsOn, Pred>(impl); };
		::Udm::ArchetypeAttr< ImplementationDependsOn> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ComponentImplementation> srcImplementationDependsOn_end() const;
		::Udm::AssocEndAttr< ::PICML::ImplementationDependency> dstImplementationDependsOn_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcImplementationDependsOn_end_;
		static ::Uml::AssociationRole meta_dstImplementationDependsOn_end_;

	};

	class PICML_Export ImplementationCapability :  public MgaObject {
	public:
		ImplementationCapability();
		ImplementationCapability(::Udm::ObjectImpl *impl);
		ImplementationCapability(const ImplementationCapability &master);

#ifdef UDM_RVALUE
		ImplementationCapability(ImplementationCapability &&master);

		static ImplementationCapability Cast(::Udm::Object &&a);
		ImplementationCapability& operator=(ImplementationCapability &&a);

#endif
		static ImplementationCapability Cast(const ::Udm::Object &a);
		static ImplementationCapability Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ImplementationCapability CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ImplementationCapability> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ImplementationCapability, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ImplementationCapability, Pred>(impl); };
		ImplementationCapability CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ImplementationCapability> Derived();
		template <class Pred> ::Udm::DerivedAttr< ImplementationCapability, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ImplementationCapability, Pred>(impl); };
		::Udm::ArchetypeAttr< ImplementationCapability> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ComponentImplementation> srcImplementationCapability_end() const;
		::Udm::AssocEndAttr< ::PICML::Capability> dstImplementationCapability_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcImplementationCapability_end_;
		static ::Uml::AssociationRole meta_dstImplementationCapability_end_;

	};

	class PICML_Export CommonPortAttrs :  virtual  public MgaObject {
	public:
		CommonPortAttrs();
		CommonPortAttrs(::Udm::ObjectImpl *impl);
		CommonPortAttrs(const CommonPortAttrs &master);

#ifdef UDM_RVALUE
		CommonPortAttrs(CommonPortAttrs &&master);

		static CommonPortAttrs Cast(::Udm::Object &&a);
		CommonPortAttrs& operator=(CommonPortAttrs &&a);

#endif
		static CommonPortAttrs Cast(const ::Udm::Object &a);
		static CommonPortAttrs Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		CommonPortAttrs CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< CommonPortAttrs> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< CommonPortAttrs, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< CommonPortAttrs, Pred>(impl); };
		CommonPortAttrs CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< CommonPortAttrs> Derived();
		template <class Pred> ::Udm::DerivedAttr< CommonPortAttrs, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< CommonPortAttrs, Pred>(impl); };
		::Udm::ArchetypeAttr< CommonPortAttrs> Archetype() const;
		::Udm::BooleanAttr optional() const;
		::Udm::BooleanAttr exclusiveUser() const;
		::Udm::BooleanAttr exclusiveProvider() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_optional;
		static ::Uml::Attribute meta_exclusiveUser;
		static ::Uml::Attribute meta_exclusiveProvider;

	};

	class PICML_Export ComponentConfigProperty :  public MgaObject {
	public:
		ComponentConfigProperty();
		ComponentConfigProperty(::Udm::ObjectImpl *impl);
		ComponentConfigProperty(const ComponentConfigProperty &master);

#ifdef UDM_RVALUE
		ComponentConfigProperty(ComponentConfigProperty &&master);

		static ComponentConfigProperty Cast(::Udm::Object &&a);
		ComponentConfigProperty& operator=(ComponentConfigProperty &&a);

#endif
		static ComponentConfigProperty Cast(const ::Udm::Object &a);
		static ComponentConfigProperty Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentConfigProperty CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentConfigProperty> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentConfigProperty, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentConfigProperty, Pred>(impl); };
		ComponentConfigProperty CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentConfigProperty> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentConfigProperty, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentConfigProperty, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentConfigProperty> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentContainer> ComponentContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ComponentRef> srcComponentConfigProperty_end() const;
		::Udm::AssocEndAttr< ::PICML::Property> dstComponentConfigProperty_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentContainer_parent;
		static ::Uml::AssociationRole meta_srcComponentConfigProperty_end_;
		static ::Uml::AssociationRole meta_dstComponentConfigProperty_end_;

	};

	class PICML_Export ComponentInfoProperty :  public MgaObject {
	public:
		ComponentInfoProperty();
		ComponentInfoProperty(::Udm::ObjectImpl *impl);
		ComponentInfoProperty(const ComponentInfoProperty &master);

#ifdef UDM_RVALUE
		ComponentInfoProperty(ComponentInfoProperty &&master);

		static ComponentInfoProperty Cast(::Udm::Object &&a);
		ComponentInfoProperty& operator=(ComponentInfoProperty &&a);

#endif
		static ComponentInfoProperty Cast(const ::Udm::Object &a);
		static ComponentInfoProperty Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentInfoProperty CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentInfoProperty> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentInfoProperty, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentInfoProperty, Pred>(impl); };
		ComponentInfoProperty CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentInfoProperty> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentInfoProperty, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentInfoProperty, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentInfoProperty> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentContainer> ComponentContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ComponentRef> srcComponentInfoProperty_end() const;
		::Udm::AssocEndAttr< ::PICML::Property> dstComponentInfoProperty_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentContainer_parent;
		static ::Uml::AssociationRole meta_srcComponentInfoProperty_end_;
		static ::Uml::AssociationRole meta_dstComponentInfoProperty_end_;

	};

	class PICML_Export ComponentContainer :  public MgaObject {
	public:
		ComponentContainer();
		ComponentContainer(::Udm::ObjectImpl *impl);
		ComponentContainer(const ComponentContainer &master);

#ifdef UDM_RVALUE
		ComponentContainer(ComponentContainer &&master);

		static ComponentContainer Cast(::Udm::Object &&a);
		ComponentContainer& operator=(ComponentContainer &&a);

#endif
		static ComponentContainer Cast(const ::Udm::Object &a);
		static ComponentContainer Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentContainer CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentContainer> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentContainer, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentContainer, Pred>(impl); };
		ComponentContainer CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentContainer> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentContainer, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentContainer, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentContainer> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::Property> Property_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); };
		::Udm::ChildAttr< ::PICML::ComponentRef> ComponentRef_child() const;
		::Udm::ChildrenAttr< ::PICML::ComponentPropertyDescription> ComponentPropertyDescription_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentPropertyDescription, Pred> ComponentPropertyDescription_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentPropertyDescription, Pred>(impl, meta_ComponentPropertyDescription_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentProperty> ComponentProperty_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentProperty, Pred> ComponentProperty_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentProperty, Pred>(impl, meta_ComponentProperty_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentInfoProperty> ComponentInfoProperty_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentInfoProperty, Pred> ComponentInfoProperty_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentInfoProperty, Pred>(impl, meta_ComponentInfoProperty_children); };
		::Udm::ChildrenAttr< ::PICML::ComponentConfigProperty> ComponentConfigProperty_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentConfigProperty, Pred> ComponentConfigProperty_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentConfigProperty, Pred>(impl, meta_ComponentConfigProperty_children); };
		::Udm::ChildrenAttr< ::PICML::ComplexProperty> ComplexProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred> ComplexProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SimpleProperty> SimpleProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred> SimpleProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentConfigProperty> ComponentConfigProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentConfigProperty, Pred> ComponentConfigProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentConfigProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentInfoProperty> ComponentInfoProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentInfoProperty, Pred> ComponentInfoProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentInfoProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentProperty> ComponentProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentProperty, Pred> ComponentProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentPropertyDescription> ComponentPropertyDescription_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentPropertyDescription, Pred> ComponentPropertyDescription_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentPropertyDescription, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Manageable> Manageable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Manageable, Pred> Manageable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Manageable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentRef> ComponentRef_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred> ComponentRef_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentRef, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::ComponentTypes> ComponentTypes_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionChildRole meta_ComponentRef_child;
		static ::Uml::CompositionChildRole meta_ComponentPropertyDescription_children;
		static ::Uml::CompositionChildRole meta_ComponentProperty_children;
		static ::Uml::CompositionChildRole meta_ComponentInfoProperty_children;
		static ::Uml::CompositionChildRole meta_ComponentConfigProperty_children;
		static ::Uml::CompositionParentRole meta_ComponentTypes_parent;

	};

	class PICML_Export ComponentProperty :  public MgaObject {
	public:
		ComponentProperty();
		ComponentProperty(::Udm::ObjectImpl *impl);
		ComponentProperty(const ComponentProperty &master);

#ifdef UDM_RVALUE
		ComponentProperty(ComponentProperty &&master);

		static ComponentProperty Cast(::Udm::Object &&a);
		ComponentProperty& operator=(ComponentProperty &&a);

#endif
		static ComponentProperty Cast(const ::Udm::Object &a);
		static ComponentProperty Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentProperty CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentProperty> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentProperty, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentProperty, Pred>(impl); };
		ComponentProperty CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentProperty> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentProperty, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentProperty, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentProperty> Archetype() const;
		::Udm::ParentAttr< ::PICML::ComponentContainer> ComponentContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ComponentRef> srcComponentProperty_end() const;
		::Udm::AssocEndAttr< ::PICML::ComponentPropertyDescription> dstComponentProperty_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ComponentContainer_parent;
		static ::Uml::AssociationRole meta_srcComponentProperty_end_;
		static ::Uml::AssociationRole meta_dstComponentProperty_end_;

	};

	class PICML_Export ComponentPropertyDescription :  public MgaObject {
	public:
		ComponentPropertyDescription();
		ComponentPropertyDescription(::Udm::ObjectImpl *impl);
		ComponentPropertyDescription(const ComponentPropertyDescription &master);

#ifdef UDM_RVALUE
		ComponentPropertyDescription(ComponentPropertyDescription &&master);

		static ComponentPropertyDescription Cast(::Udm::Object &&a);
		ComponentPropertyDescription& operator=(ComponentPropertyDescription &&a);

#endif
		static ComponentPropertyDescription Cast(const ::Udm::Object &a);
		static ComponentPropertyDescription Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentPropertyDescription CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentPropertyDescription> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentPropertyDescription, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentPropertyDescription, Pred>(impl); };
		ComponentPropertyDescription CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentPropertyDescription> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentPropertyDescription, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentPropertyDescription, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentPropertyDescription> Archetype() const;
		::Udm::AClassAssocAttr< ComponentProperty, ComponentRef> srcComponentProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< ComponentProperty, ComponentRef, Pred> srcComponentProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ComponentProperty, ComponentRef, Pred>(impl, meta_srcComponentProperty, meta_srcComponentProperty_rev); };
		::Udm::ChildAttr< ::PICML::DataType> DataType_child() const;
		::Udm::ChildrenAttr< ::PICML::DataType> DataType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DataType, Pred> DataType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DataType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::ComponentContainer> ComponentContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentContainer> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcComponentProperty;
		static ::Uml::AssociationRole meta_srcComponentProperty_rev;
		static ::Uml::CompositionChildRole meta_DataType_child;
		static ::Uml::CompositionParentRole meta_ComponentContainer_parent;

	};

	class PICML_Export LookupKeyType :  virtual  public MgaObject {
	public:
		LookupKeyType();
		LookupKeyType(::Udm::ObjectImpl *impl);
		LookupKeyType(const LookupKeyType &master);

#ifdef UDM_RVALUE
		LookupKeyType(LookupKeyType &&master);

		static LookupKeyType Cast(::Udm::Object &&a);
		LookupKeyType& operator=(LookupKeyType &&a);

#endif
		static LookupKeyType Cast(const ::Udm::Object &a);
		static LookupKeyType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		LookupKeyType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< LookupKeyType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< LookupKeyType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< LookupKeyType, Pred>(impl); };
		LookupKeyType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< LookupKeyType> Derived();
		template <class Pred> ::Udm::DerivedAttr< LookupKeyType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< LookupKeyType, Pred>(impl); };
		::Udm::ArchetypeAttr< LookupKeyType> Archetype() const;
		::Udm::AssocAttr< LookupKey> referedbyLookupKey() const;
		template <class Pred> ::Udm::AssocAttr< LookupKey, Pred> referedbyLookupKey_sorted(const Pred &) const { return ::Udm::AssocAttr< LookupKey, Pred>(impl, meta_referedbyLookupKey); };
		::Udm::ParentAttr< ::Udm::Object> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyLookupKey;

	};

	class PICML_Export ValueObject :  public LookupKeyType,  public ObjectByValue {
	public:
		ValueObject();
		ValueObject(::Udm::ObjectImpl *impl);
		ValueObject(const ValueObject &master);

#ifdef UDM_RVALUE
		ValueObject(ValueObject &&master);

		static ValueObject Cast(::Udm::Object &&a);
		ValueObject& operator=(ValueObject &&a);

#endif
		static ValueObject Cast(const ::Udm::Object &a);
		static ValueObject Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ValueObject CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ValueObject> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ValueObject, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ValueObject, Pred>(impl); };
		ValueObject CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ValueObject> Derived();
		template <class Pred> ::Udm::DerivedAttr< ValueObject, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ValueObject, Pred>(impl); };
		::Udm::ArchetypeAttr< ValueObject> Archetype() const;
		::Udm::ParentAttr< ::PICML::Prefixable> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export LookupKey :  public MgaObject {
	public:
		LookupKey();
		LookupKey(::Udm::ObjectImpl *impl);
		LookupKey(const LookupKey &master);

#ifdef UDM_RVALUE
		LookupKey(LookupKey &&master);

		static LookupKey Cast(::Udm::Object &&a);
		LookupKey& operator=(LookupKey &&a);

#endif
		static LookupKey Cast(const ::Udm::Object &a);
		static LookupKey Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		LookupKey CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< LookupKey> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< LookupKey, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< LookupKey, Pred>(impl); };
		LookupKey CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< LookupKey> Derived();
		template <class Pred> ::Udm::DerivedAttr< LookupKey, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< LookupKey, Pred>(impl); };
		::Udm::ArchetypeAttr< LookupKey> Archetype() const;
		::Udm::PointerAttr< LookupKeyType> ref() const;
		::Udm::ParentAttr< ::PICML::ComponentFactory> ComponentFactory_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentFactory> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ComponentFactory_parent;

	};

	class PICML_Export ExtendedPortBase :  public MgaObject {
	public:
		ExtendedPortBase();
		ExtendedPortBase(::Udm::ObjectImpl *impl);
		ExtendedPortBase(const ExtendedPortBase &master);

#ifdef UDM_RVALUE
		ExtendedPortBase(ExtendedPortBase &&master);

		static ExtendedPortBase Cast(::Udm::Object &&a);
		ExtendedPortBase& operator=(ExtendedPortBase &&a);

#endif
		static ExtendedPortBase Cast(const ::Udm::Object &a);
		static ExtendedPortBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ExtendedPortBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ExtendedPortBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ExtendedPortBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ExtendedPortBase, Pred>(impl); };
		ExtendedPortBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ExtendedPortBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< ExtendedPortBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ExtendedPortBase, Pred>(impl); };
		::Udm::ArchetypeAttr< ExtendedPortBase> Archetype() const;
		::Udm::PointerAttr< PortType> ref() const;
		::Udm::ParentAttr< ::PICML::Component> Component_parent() const;
		::Udm::ParentAttr< ::PICML::ConnectorObject> ConnectorObject_parent() const;
		::Udm::ParentAttr< ::PICML::NamedType> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_Component_parent;
		static ::Uml::CompositionParentRole meta_ConnectorObject_parent;

	};

	class PICML_Export MirrorPort :  public ExtendedPortBase {
	public:
		MirrorPort();
		MirrorPort(::Udm::ObjectImpl *impl);
		MirrorPort(const MirrorPort &master);

#ifdef UDM_RVALUE
		MirrorPort(MirrorPort &&master);

		static MirrorPort Cast(::Udm::Object &&a);
		MirrorPort& operator=(MirrorPort &&a);

#endif
		static MirrorPort Cast(const ::Udm::Object &a);
		static MirrorPort Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MirrorPort CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MirrorPort> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MirrorPort, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MirrorPort, Pred>(impl); };
		MirrorPort CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MirrorPort> Derived();
		template <class Pred> ::Udm::DerivedAttr< MirrorPort, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MirrorPort, Pred>(impl); };
		::Udm::ArchetypeAttr< MirrorPort> Archetype() const;
		::Udm::AssocAttr< MirrorPortInstance> referedbyMirrorPortInstance() const;
		template <class Pred> ::Udm::AssocAttr< MirrorPortInstance, Pred> referedbyMirrorPortInstance_sorted(const Pred &) const { return ::Udm::AssocAttr< MirrorPortInstance, Pred>(impl, meta_referedbyMirrorPortInstance); };
		::Udm::ParentAttr< ::PICML::NamedType> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyMirrorPortInstance;

	};

	class PICML_Export ComponentInherits :  public MgaObject {
	public:
		ComponentInherits();
		ComponentInherits(::Udm::ObjectImpl *impl);
		ComponentInherits(const ComponentInherits &master);

#ifdef UDM_RVALUE
		ComponentInherits(ComponentInherits &&master);

		static ComponentInherits Cast(::Udm::Object &&a);
		ComponentInherits& operator=(ComponentInherits &&a);

#endif
		static ComponentInherits Cast(const ::Udm::Object &a);
		static ComponentInherits Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentInherits CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentInherits> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentInherits, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentInherits, Pred>(impl); };
		ComponentInherits CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentInherits> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentInherits, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentInherits, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentInherits> Archetype() const;
		::Udm::PointerAttr< Component> ref() const;
		::Udm::ParentAttr< ::PICML::Component> Component_parent() const;
		::Udm::ParentAttr< ::PICML::Component> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_Component_parent;

	};

	class PICML_Export EventType :  virtual  public MgaObject {
	public:
		EventType();
		EventType(::Udm::ObjectImpl *impl);
		EventType(const EventType &master);

#ifdef UDM_RVALUE
		EventType(EventType &&master);

		static EventType Cast(::Udm::Object &&a);
		EventType& operator=(EventType &&a);

#endif
		static EventType Cast(const ::Udm::Object &a);
		static EventType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		EventType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< EventType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< EventType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< EventType, Pred>(impl); };
		EventType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< EventType> Derived();
		template <class Pred> ::Udm::DerivedAttr< EventType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< EventType, Pred>(impl); };
		::Udm::ArchetypeAttr< EventType> Archetype() const;
		::Udm::AssocAttr< InEventPort> referedbyInEventPort() const;
		template <class Pred> ::Udm::AssocAttr< InEventPort, Pred> referedbyInEventPort_sorted(const Pred &) const { return ::Udm::AssocAttr< InEventPort, Pred>(impl, meta_referedbyInEventPort); };
		::Udm::AssocAttr< OutEventPort> referedbyOutEventPort() const;
		template <class Pred> ::Udm::AssocAttr< OutEventPort, Pred> referedbyOutEventPort_sorted(const Pred &) const { return ::Udm::AssocAttr< OutEventPort, Pred>(impl, meta_referedbyOutEventPort); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyInEventPort;
		static ::Uml::AssociationRole meta_referedbyOutEventPort;

	};

	class PICML_Export Event :  public EventType,  public ObjectByValue {
	public:
		Event();
		Event(::Udm::ObjectImpl *impl);
		Event(const Event &master);

#ifdef UDM_RVALUE
		Event(Event &&master);

		static Event Cast(::Udm::Object &&a);
		Event& operator=(Event &&a);

#endif
		static Event Cast(const ::Udm::Object &a);
		static Event Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Event CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Event> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Event, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Event, Pred>(impl); };
		Event CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Event> Derived();
		template <class Pred> ::Udm::DerivedAttr< Event, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Event, Pred>(impl); };
		::Udm::ArchetypeAttr< Event> Archetype() const;
		::Udm::AssocAttr< EventRef> referedbyEventRef() const;
		template <class Pred> ::Udm::AssocAttr< EventRef, Pred> referedbyEventRef_sorted(const Pred &) const { return ::Udm::AssocAttr< EventRef, Pred>(impl, meta_referedbyEventRef); };
		::Udm::ParentAttr< ::PICML::BenchmarkAnalysis> BenchmarkAnalysis_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyEventRef;
		static ::Uml::CompositionParentRole meta_BenchmarkAnalysis_parent;

	};

	class PICML_Export PortType :  public NoInheritable {
	public:
		PortType();
		PortType(::Udm::ObjectImpl *impl);
		PortType(const PortType &master);

#ifdef UDM_RVALUE
		PortType(PortType &&master);

		static PortType Cast(::Udm::Object &&a);
		PortType& operator=(PortType &&a);

#endif
		static PortType Cast(const ::Udm::Object &a);
		static PortType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PortType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PortType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PortType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PortType, Pred>(impl); };
		PortType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PortType> Derived();
		template <class Pred> ::Udm::DerivedAttr< PortType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PortType, Pred>(impl); };
		::Udm::ArchetypeAttr< PortType> Archetype() const;
		::Udm::AssocAttr< ExtendedPortBase> referedbyExtendedPortBase() const;
		template <class Pred> ::Udm::AssocAttr< ExtendedPortBase, Pred> referedbyExtendedPortBase_sorted(const Pred &) const { return ::Udm::AssocAttr< ExtendedPortBase, Pred>(impl, meta_referedbyExtendedPortBase); };
		::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute> ReadonlyAttribute_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred> ReadonlyAttribute_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred>(impl, meta_ReadonlyAttribute_children); };
		::Udm::ChildrenAttr< ::PICML::ObjectPort> ObjectPort_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ObjectPort, Pred> ObjectPort_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ObjectPort, Pred>(impl, meta_ObjectPort_children); };
		::Udm::ChildrenAttr< ::PICML::GraphVertex> GraphVertex_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::GraphVertex, Pred> GraphVertex_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::GraphVertex, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Attribute> Attribute_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Attribute, Pred> Attribute_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Attribute, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute> ReadonlyAttribute_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred> ReadonlyAttribute_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::CommonPortAttrs> CommonPortAttrs_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CommonPortAttrs, Pred> CommonPortAttrs_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CommonPortAttrs, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ObjectPort> ObjectPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ObjectPort, Pred> ObjectPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ObjectPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Port> Port_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Port, Pred> Port_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Port, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequiredRequestPort> RequiredRequestPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred> RequiredRequestPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ProvidedRequestPort> ProvidedRequestPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred> ProvidedRequestPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyExtendedPortBase;
		static ::Uml::CompositionChildRole meta_ReadonlyAttribute_children;
		static ::Uml::CompositionChildRole meta_ObjectPort_children;

	};

	class PICML_Export ExtendedPort :  public ExtendedPortBase {
	public:
		ExtendedPort();
		ExtendedPort(::Udm::ObjectImpl *impl);
		ExtendedPort(const ExtendedPort &master);

#ifdef UDM_RVALUE
		ExtendedPort(ExtendedPort &&master);

		static ExtendedPort Cast(::Udm::Object &&a);
		ExtendedPort& operator=(ExtendedPort &&a);

#endif
		static ExtendedPort Cast(const ::Udm::Object &a);
		static ExtendedPort Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ExtendedPort CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ExtendedPort> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ExtendedPort, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ExtendedPort, Pred>(impl); };
		ExtendedPort CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ExtendedPort> Derived();
		template <class Pred> ::Udm::DerivedAttr< ExtendedPort, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ExtendedPort, Pred>(impl); };
		::Udm::ArchetypeAttr< ExtendedPort> Archetype() const;
		::Udm::AssocAttr< ExtendedPortInstance> referedbyExtendedPortInstance() const;
		template <class Pred> ::Udm::AssocAttr< ExtendedPortInstance, Pred> referedbyExtendedPortInstance_sorted(const Pred &) const { return ::Udm::AssocAttr< ExtendedPortInstance, Pred>(impl, meta_referedbyExtendedPortInstance); };
		::Udm::ParentAttr< ::PICML::NamedType> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyExtendedPortInstance;

	};

	class PICML_Export Provideable :  virtual  public MgaObject {
	public:
		Provideable();
		Provideable(::Udm::ObjectImpl *impl);
		Provideable(const Provideable &master);

#ifdef UDM_RVALUE
		Provideable(Provideable &&master);

		static Provideable Cast(::Udm::Object &&a);
		Provideable& operator=(Provideable &&a);

#endif
		static Provideable Cast(const ::Udm::Object &a);
		static Provideable Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Provideable CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Provideable> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Provideable, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Provideable, Pred>(impl); };
		Provideable CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Provideable> Derived();
		template <class Pred> ::Udm::DerivedAttr< Provideable, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Provideable, Pred>(impl); };
		::Udm::ArchetypeAttr< Provideable> Archetype() const;
		::Udm::AssocAttr< RequiredRequestPort> referedbyRequiredRequestPort() const;
		template <class Pred> ::Udm::AssocAttr< RequiredRequestPort, Pred> referedbyRequiredRequestPort_sorted(const Pred &) const { return ::Udm::AssocAttr< RequiredRequestPort, Pred>(impl, meta_referedbyRequiredRequestPort); };
		::Udm::AssocAttr< ProvidedRequestPort> referedbyProvidedRequestPort() const;
		template <class Pred> ::Udm::AssocAttr< ProvidedRequestPort, Pred> referedbyProvidedRequestPort_sorted(const Pred &) const { return ::Udm::AssocAttr< ProvidedRequestPort, Pred>(impl, meta_referedbyProvidedRequestPort); };
		::Udm::ParentAttr< ::PICML::Package> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyRequiredRequestPort;
		static ::Uml::AssociationRole meta_referedbyProvidedRequestPort;

	};

	class PICML_Export Object :  public HasOperations,  public Prefixable,  public Provideable {
	public:
		Object();
		Object(::Udm::ObjectImpl *impl);
		Object(const Object &master);

#ifdef UDM_RVALUE
		Object(Object &&master);

		static Object Cast(::Udm::Object &&a);
		Object& operator=(Object &&a);

#endif
		static Object Cast(const ::Udm::Object &a);
		static Object Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Object CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Object> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Object, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Object, Pred>(impl); };
		Object CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Object> Derived();
		template <class Pred> ::Udm::DerivedAttr< Object, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Object, Pred>(impl); };
		::Udm::ArchetypeAttr< Object> Archetype() const;
		::Udm::StringAttr InterfaceSemantics() const;
		::Udm::BooleanAttr SupportsAsync() const;
		::Udm::AssocAttr< Supports> referedbySupports() const;
		template <class Pred> ::Udm::AssocAttr< Supports, Pred> referedbySupports_sorted(const Pred &) const { return ::Udm::AssocAttr< Supports, Pred>(impl, meta_referedbySupports); };
		::Udm::ParentAttr< ::PICML::Prefixable> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_InterfaceSemantics;
		static ::Uml::Attribute meta_SupportsAsync;
		static ::Uml::AssociationRole meta_referedbySupports;

	};

	class PICML_Export GenericObject :  public PredefinedType,  public Provideable {
	public:
		GenericObject();
		GenericObject(::Udm::ObjectImpl *impl);
		GenericObject(const GenericObject &master);

#ifdef UDM_RVALUE
		GenericObject(GenericObject &&master);

		static GenericObject Cast(::Udm::Object &&a);
		GenericObject& operator=(GenericObject &&a);

#endif
		static GenericObject Cast(const ::Udm::Object &a);
		static GenericObject Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		GenericObject CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< GenericObject> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< GenericObject, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< GenericObject, Pred>(impl); };
		GenericObject CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< GenericObject> Derived();
		template <class Pred> ::Udm::DerivedAttr< GenericObject, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< GenericObject, Pred>(impl); };
		::Udm::ArchetypeAttr< GenericObject> Archetype() const;
		::Udm::ParentAttr< ::PICML::PredefinedTypes> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export TemplateParameter :  public EventType,  public MemberType,  public Provideable {
	public:
		TemplateParameter();
		TemplateParameter(::Udm::ObjectImpl *impl);
		TemplateParameter(const TemplateParameter &master);

#ifdef UDM_RVALUE
		TemplateParameter(TemplateParameter &&master);

		static TemplateParameter Cast(::Udm::Object &&a);
		TemplateParameter& operator=(TemplateParameter &&a);

#endif
		static TemplateParameter Cast(const ::Udm::Object &a);
		static TemplateParameter Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TemplateParameter CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TemplateParameter> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TemplateParameter, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TemplateParameter, Pred>(impl); };
		TemplateParameter CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TemplateParameter> Derived();
		template <class Pred> ::Udm::DerivedAttr< TemplateParameter, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TemplateParameter, Pred>(impl); };
		::Udm::ArchetypeAttr< TemplateParameter> Archetype() const;
		::Udm::AssocAttr< TemplateParameterReference> referedbyTemplateParameterReference() const;
		template <class Pred> ::Udm::AssocAttr< TemplateParameterReference, Pred> referedbyTemplateParameterReference_sorted(const Pred &) const { return ::Udm::AssocAttr< TemplateParameterReference, Pred>(impl, meta_referedbyTemplateParameterReference); };
		::Udm::ParentAttr< ::PICML::Package> Package_parent() const;
		::Udm::ParentAttr< ::PICML::Package> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyTemplateParameterReference;
		static ::Uml::CompositionParentRole meta_Package_parent;

	};

	class PICML_Export TypeParameter :  public ExceptionType,  public LookupKeyType,  public TemplateParameter {
	public:
		TypeParameter();
		TypeParameter(::Udm::ObjectImpl *impl);
		TypeParameter(const TypeParameter &master);

#ifdef UDM_RVALUE
		TypeParameter(TypeParameter &&master);

		static TypeParameter Cast(::Udm::Object &&a);
		TypeParameter& operator=(TypeParameter &&a);

#endif
		static TypeParameter Cast(const ::Udm::Object &a);
		static TypeParameter Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TypeParameter CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TypeParameter> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TypeParameter, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TypeParameter, Pred>(impl); };
		TypeParameter CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TypeParameter> Derived();
		template <class Pred> ::Udm::DerivedAttr< TypeParameter, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TypeParameter, Pred>(impl); };
		::Udm::ArchetypeAttr< TypeParameter> Archetype() const;
		::Udm::StringAttr Type() const;
		::Udm::ParentAttr< ::PICML::Package> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Type;

	};

	class PICML_Export CollectionParameter :  public TemplateParameter {
	public:
		CollectionParameter();
		CollectionParameter(::Udm::ObjectImpl *impl);
		CollectionParameter(const CollectionParameter &master);

#ifdef UDM_RVALUE
		CollectionParameter(CollectionParameter &&master);

		static CollectionParameter Cast(::Udm::Object &&a);
		CollectionParameter& operator=(CollectionParameter &&a);

#endif
		static CollectionParameter Cast(const ::Udm::Object &a);
		static CollectionParameter Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		CollectionParameter CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< CollectionParameter> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< CollectionParameter, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< CollectionParameter, Pred>(impl); };
		CollectionParameter CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< CollectionParameter> Derived();
		template <class Pred> ::Udm::DerivedAttr< CollectionParameter, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< CollectionParameter, Pred>(impl); };
		::Udm::ArchetypeAttr< CollectionParameter> Archetype() const;
		::Udm::PointerAttr< NameParameter> ref() const;
		::Udm::ParentAttr< ::PICML::Package> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export NameParameter :  public TemplateParameter {
	public:
		NameParameter();
		NameParameter(::Udm::ObjectImpl *impl);
		NameParameter(const NameParameter &master);

#ifdef UDM_RVALUE
		NameParameter(NameParameter &&master);

		static NameParameter Cast(::Udm::Object &&a);
		NameParameter& operator=(NameParameter &&a);

#endif
		static NameParameter Cast(const ::Udm::Object &a);
		static NameParameter Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		NameParameter CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< NameParameter> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< NameParameter, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< NameParameter, Pred>(impl); };
		NameParameter CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< NameParameter> Derived();
		template <class Pred> ::Udm::DerivedAttr< NameParameter, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< NameParameter, Pred>(impl); };
		::Udm::ArchetypeAttr< NameParameter> Archetype() const;
		::Udm::AssocAttr< CollectionParameter> referedbyCollectionParameter() const;
		template <class Pred> ::Udm::AssocAttr< CollectionParameter, Pred> referedbyCollectionParameter_sorted(const Pred &) const { return ::Udm::AssocAttr< CollectionParameter, Pred>(impl, meta_referedbyCollectionParameter); };
		::Udm::ParentAttr< ::PICML::Package> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyCollectionParameter;

	};

	class PICML_Export ManagesComponent :  public MgaObject {
	public:
		ManagesComponent();
		ManagesComponent(::Udm::ObjectImpl *impl);
		ManagesComponent(const ManagesComponent &master);

#ifdef UDM_RVALUE
		ManagesComponent(ManagesComponent &&master);

		static ManagesComponent Cast(::Udm::Object &&a);
		ManagesComponent& operator=(ManagesComponent &&a);

#endif
		static ManagesComponent Cast(const ::Udm::Object &a);
		static ManagesComponent Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ManagesComponent CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ManagesComponent> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ManagesComponent, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ManagesComponent, Pred>(impl); };
		ManagesComponent CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ManagesComponent> Derived();
		template <class Pred> ::Udm::DerivedAttr< ManagesComponent, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ManagesComponent, Pred>(impl); };
		::Udm::ArchetypeAttr< ManagesComponent> Archetype() const;
		::Udm::ParentAttr< ::PICML::File> File_parent() const;
		::Udm::ParentAttr< ::PICML::Package> Package_parent() const;
		::Udm::ParentAttr< ::PICML::Prefixable> parent() const;
		::Udm::AssocEndAttr< ::PICML::ComponentFactory> srcManagesComponent_end() const;
		::Udm::AssocEndAttr< ::PICML::Manageable> dstManagesComponent_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_File_parent;
		static ::Uml::CompositionParentRole meta_Package_parent;
		static ::Uml::AssociationRole meta_srcManagesComponent_end_;
		static ::Uml::AssociationRole meta_dstManagesComponent_end_;

	};

	class PICML_Export ComponentFactory :  public HasOperations,  public SupportsInterfaces {
	public:
		ComponentFactory();
		ComponentFactory(::Udm::ObjectImpl *impl);
		ComponentFactory(const ComponentFactory &master);

#ifdef UDM_RVALUE
		ComponentFactory(ComponentFactory &&master);

		static ComponentFactory Cast(::Udm::Object &&a);
		ComponentFactory& operator=(ComponentFactory &&a);

#endif
		static ComponentFactory Cast(const ::Udm::Object &a);
		static ComponentFactory Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentFactory CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentFactory> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentFactory, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentFactory, Pred>(impl); };
		ComponentFactory CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentFactory> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentFactory, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentFactory, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentFactory> Archetype() const;
		::Udm::AssocAttr< ComponentFactoryInstance> referedbyComponentFactoryInstance() const;
		template <class Pred> ::Udm::AssocAttr< ComponentFactoryInstance, Pred> referedbyComponentFactoryInstance_sorted(const Pred &) const { return ::Udm::AssocAttr< ComponentFactoryInstance, Pred>(impl, meta_referedbyComponentFactoryInstance); };
		::Udm::AClassPointerAttr< ManagesComponent, Manageable> dstManagesComponent() const;
		::Udm::ChildAttr< ::PICML::LookupKey> LookupKey_child() const;
		::Udm::ChildrenAttr< ::PICML::LookupOperation> LookupOperation_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::LookupOperation, Pred> LookupOperation_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::LookupOperation, Pred>(impl, meta_LookupOperation_children); };
		::Udm::ChildrenAttr< ::PICML::FactoryOperation> FactoryOperation_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred> FactoryOperation_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred>(impl, meta_FactoryOperation_children); };
		::Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::HasExceptions> HasExceptions_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::HasExceptions, Pred> HasExceptions_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::HasExceptions, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::FactoryOperation> FactoryOperation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred> FactoryOperation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::FactoryOperation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::OperationBase> OperationBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OperationBase, Pred> OperationBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OperationBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::LookupOperation> LookupOperation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::LookupOperation, Pred> LookupOperation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::LookupOperation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::LookupKey> LookupKey_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::LookupKey, Pred> LookupKey_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::LookupKey, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::Prefixable> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyComponentFactoryInstance;
		static ::Uml::AssociationRole meta_dstManagesComponent;
		static ::Uml::AssociationRole meta_dstManagesComponent_rev;
		static ::Uml::CompositionChildRole meta_LookupKey_child;
		static ::Uml::CompositionChildRole meta_LookupOperation_children;
		static ::Uml::CompositionChildRole meta_FactoryOperation_children;

	};

	class PICML_Export Manageable :  virtual  public MgaObject {
	public:
		Manageable();
		Manageable(::Udm::ObjectImpl *impl);
		Manageable(const Manageable &master);

#ifdef UDM_RVALUE
		Manageable(Manageable &&master);

		static Manageable Cast(::Udm::Object &&a);
		Manageable& operator=(Manageable &&a);

#endif
		static Manageable Cast(const ::Udm::Object &a);
		static Manageable Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Manageable CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Manageable> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Manageable, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Manageable, Pred>(impl); };
		Manageable CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Manageable> Derived();
		template <class Pred> ::Udm::DerivedAttr< Manageable, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Manageable, Pred>(impl); };
		::Udm::ArchetypeAttr< Manageable> Archetype() const;
		::Udm::AClassAssocAttr< ManagesComponent, ComponentFactory> srcManagesComponent() const;
		template <class Pred> ::Udm::AClassAssocAttr< ManagesComponent, ComponentFactory, Pred> srcManagesComponent_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ManagesComponent, ComponentFactory, Pred>(impl, meta_srcManagesComponent, meta_srcManagesComponent_rev); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcManagesComponent;
		static ::Uml::AssociationRole meta_srcManagesComponent_rev;

	};

	class PICML_Export ComponentRef :  public Manageable {
	public:
		ComponentRef();
		ComponentRef(::Udm::ObjectImpl *impl);
		ComponentRef(const ComponentRef &master);

#ifdef UDM_RVALUE
		ComponentRef(ComponentRef &&master);

		static ComponentRef Cast(::Udm::Object &&a);
		ComponentRef& operator=(ComponentRef &&a);

#endif
		static ComponentRef Cast(const ::Udm::Object &a);
		static ComponentRef Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ComponentRef CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ComponentRef> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ComponentRef, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ComponentRef, Pred>(impl); };
		ComponentRef CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ComponentRef> Derived();
		template <class Pred> ::Udm::DerivedAttr< ComponentRef, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ComponentRef, Pred>(impl); };
		::Udm::ArchetypeAttr< ComponentRef> Archetype() const;
		::Udm::AClassPointerAttr< PackageInterface, ComponentPackage> srcPackageInterface() const;
		::Udm::AClassPointerAttr< Implements, ComponentImplementation> srcImplements() const;
		::Udm::PointerAttr< Component> ref() const;
		::Udm::AClassAssocAttr< ComponentInfoProperty, Property> dstComponentInfoProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< ComponentInfoProperty, Property, Pred> dstComponentInfoProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ComponentInfoProperty, Property, Pred>(impl, meta_dstComponentInfoProperty, meta_dstComponentInfoProperty_rev); };
		::Udm::AClassAssocAttr< ComponentConfigProperty, Property> dstComponentConfigProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< ComponentConfigProperty, Property, Pred> dstComponentConfigProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ComponentConfigProperty, Property, Pred>(impl, meta_dstComponentConfigProperty, meta_dstComponentConfigProperty_rev); };
		::Udm::AClassAssocAttr< ComponentProperty, ComponentPropertyDescription> dstComponentProperty() const;
		template <class Pred> ::Udm::AClassAssocAttr< ComponentProperty, ComponentPropertyDescription, Pred> dstComponentProperty_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ComponentProperty, ComponentPropertyDescription, Pred>(impl, meta_dstComponentProperty, meta_dstComponentProperty_rev); };
		::Udm::ParentAttr< ::PICML::Path> Path_parent() const;
		::Udm::ParentAttr< ::PICML::PackageContainer> PackageContainer_parent() const;
		::Udm::ParentAttr< ::PICML::File> File_parent() const;
		::Udm::ParentAttr< ::PICML::Package> Package_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentImplementationContainer> ComponentImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentContainer> ComponentContainer_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcPackageInterface;
		static ::Uml::AssociationRole meta_srcPackageInterface_rev;
		static ::Uml::AssociationRole meta_srcImplements;
		static ::Uml::AssociationRole meta_srcImplements_rev;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_dstComponentInfoProperty;
		static ::Uml::AssociationRole meta_dstComponentInfoProperty_rev;
		static ::Uml::AssociationRole meta_dstComponentConfigProperty;
		static ::Uml::AssociationRole meta_dstComponentConfigProperty_rev;
		static ::Uml::AssociationRole meta_dstComponentProperty;
		static ::Uml::AssociationRole meta_dstComponentProperty_rev;
		static ::Uml::CompositionParentRole meta_Path_parent;
		static ::Uml::CompositionParentRole meta_PackageContainer_parent;
		static ::Uml::CompositionParentRole meta_File_parent;
		static ::Uml::CompositionParentRole meta_Package_parent;
		static ::Uml::CompositionParentRole meta_ComponentImplementationContainer_parent;
		static ::Uml::CompositionParentRole meta_ComponentContainer_parent;

	};

	class PICML_Export Port :  public CommonPortAttrs,  public GraphVertex,  public Taggable {
	public:
		Port();
		Port(::Udm::ObjectImpl *impl);
		Port(const Port &master);

#ifdef UDM_RVALUE
		Port(Port &&master);

		static Port Cast(::Udm::Object &&a);
		Port& operator=(Port &&a);

#endif
		static Port Cast(const ::Udm::Object &a);
		static Port Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Port CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Port> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Port, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Port, Pred>(impl); };
		Port CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Port> Derived();
		template <class Pred> ::Udm::DerivedAttr< Port, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Port, Pred>(impl); };
		::Udm::ArchetypeAttr< Port> Archetype() const;
		::Udm::ParentAttr< ::PICML::ConnectedComponent> ConnectedComponent_parent() const;
		::Udm::ParentAttr< ::PICML::Component> Component_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ConnectedComponent_parent;
		static ::Uml::CompositionParentRole meta_Component_parent;

	};

	class PICML_Export EventPort :  public Port {
	public:
		EventPort();
		EventPort(::Udm::ObjectImpl *impl);
		EventPort(const EventPort &master);

#ifdef UDM_RVALUE
		EventPort(EventPort &&master);

		static EventPort Cast(::Udm::Object &&a);
		EventPort& operator=(EventPort &&a);

#endif
		static EventPort Cast(const ::Udm::Object &a);
		static EventPort Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		EventPort CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< EventPort> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< EventPort, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< EventPort, Pred>(impl); };
		EventPort CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< EventPort> Derived();
		template <class Pred> ::Udm::DerivedAttr< EventPort, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< EventPort, Pred>(impl); };
		::Udm::ArchetypeAttr< EventPort> Archetype() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;

	};

	class PICML_Export ObjectPort :  public Port {
	public:
		ObjectPort();
		ObjectPort(::Udm::ObjectImpl *impl);
		ObjectPort(const ObjectPort &master);

#ifdef UDM_RVALUE
		ObjectPort(ObjectPort &&master);

		static ObjectPort Cast(::Udm::Object &&a);
		ObjectPort& operator=(ObjectPort &&a);

#endif
		static ObjectPort Cast(const ::Udm::Object &a);
		static ObjectPort Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ObjectPort CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ObjectPort> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ObjectPort, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ObjectPort, Pred>(impl); };
		ObjectPort CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ObjectPort> Derived();
		template <class Pred> ::Udm::DerivedAttr< ObjectPort, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ObjectPort, Pred>(impl); };
		::Udm::ArchetypeAttr< ObjectPort> Archetype() const;
		::Udm::ParentAttr< ::PICML::PortType> PortType_parent() const;
		::Udm::ParentAttr< ::PICML::ConnectorObject> ConnectorObject_parent() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_PortType_parent;
		static ::Uml::CompositionParentRole meta_ConnectorObject_parent;

	};

	class PICML_Export ConnectorType :  public MgaObject {
	public:
		ConnectorType();
		ConnectorType(::Udm::ObjectImpl *impl);
		ConnectorType(const ConnectorType &master);

#ifdef UDM_RVALUE
		ConnectorType(ConnectorType &&master);

		static ConnectorType Cast(::Udm::Object &&a);
		ConnectorType& operator=(ConnectorType &&a);

#endif
		static ConnectorType Cast(const ::Udm::Object &a);
		static ConnectorType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ConnectorType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ConnectorType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ConnectorType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ConnectorType, Pred>(impl); };
		ConnectorType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ConnectorType> Derived();
		template <class Pred> ::Udm::DerivedAttr< ConnectorType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ConnectorType, Pred>(impl); };
		::Udm::ArchetypeAttr< ConnectorType> Archetype() const;
		::Udm::PointerAttr< ConnectorObject> ref() const;
		::Udm::AClassPointerAttr< ConnectorImplements, ConnectorImplementation> srcConnectorImplements() const;
		::Udm::ParentAttr< ::PICML::ConnectorImplementationContainer> ConnectorImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ConnectorImplementationContainer> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_srcConnectorImplements;
		static ::Uml::AssociationRole meta_srcConnectorImplements_rev;
		static ::Uml::CompositionParentRole meta_ConnectorImplementationContainer_parent;

	};

	class PICML_Export ConnectorImplements :  public MgaObject {
	public:
		ConnectorImplements();
		ConnectorImplements(::Udm::ObjectImpl *impl);
		ConnectorImplements(const ConnectorImplements &master);

#ifdef UDM_RVALUE
		ConnectorImplements(ConnectorImplements &&master);

		static ConnectorImplements Cast(::Udm::Object &&a);
		ConnectorImplements& operator=(ConnectorImplements &&a);

#endif
		static ConnectorImplements Cast(const ::Udm::Object &a);
		static ConnectorImplements Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ConnectorImplements CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ConnectorImplements> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ConnectorImplements, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ConnectorImplements, Pred>(impl); };
		ConnectorImplements CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ConnectorImplements> Derived();
		template <class Pred> ::Udm::DerivedAttr< ConnectorImplements, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ConnectorImplements, Pred>(impl); };
		::Udm::ArchetypeAttr< ConnectorImplements> Archetype() const;
		::Udm::ParentAttr< ::PICML::ConnectorImplementationContainer> ConnectorImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ConnectorImplementationContainer> parent() const;
		::Udm::AssocEndAttr< ::PICML::ConnectorImplementation> srcConnectorImplements_end() const;
		::Udm::AssocEndAttr< ::PICML::ConnectorType> dstConnectorImplements_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_ConnectorImplementationContainer_parent;
		static ::Uml::AssociationRole meta_srcConnectorImplements_end_;
		static ::Uml::AssociationRole meta_dstConnectorImplements_end_;

	};

	class PICML_Export ConnectorImplementationContainer :  public ImplementationContainer {
	public:
		ConnectorImplementationContainer();
		ConnectorImplementationContainer(::Udm::ObjectImpl *impl);
		ConnectorImplementationContainer(const ConnectorImplementationContainer &master);

#ifdef UDM_RVALUE
		ConnectorImplementationContainer(ConnectorImplementationContainer &&master);

		static ConnectorImplementationContainer Cast(::Udm::Object &&a);
		ConnectorImplementationContainer& operator=(ConnectorImplementationContainer &&a);

#endif
		static ConnectorImplementationContainer Cast(const ::Udm::Object &a);
		static ConnectorImplementationContainer Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ConnectorImplementationContainer CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ConnectorImplementationContainer> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ConnectorImplementationContainer, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ConnectorImplementationContainer, Pred>(impl); };
		ConnectorImplementationContainer CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ConnectorImplementationContainer> Derived();
		template <class Pred> ::Udm::DerivedAttr< ConnectorImplementationContainer, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ConnectorImplementationContainer, Pred>(impl); };
		::Udm::ArchetypeAttr< ConnectorImplementationContainer> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::ConnectorImplements> ConnectorImplements_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorImplements, Pred> ConnectorImplements_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorImplements, Pred>(impl, meta_ConnectorImplements_children); };
		::Udm::ChildrenAttr< ::PICML::ConnectorType> ConnectorType_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorType, Pred> ConnectorType_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorType, Pred>(impl, meta_ConnectorType_children); };
		::Udm::ChildrenAttr< ::PICML::ConnectorImplementation> ConnectorImplementation_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorImplementation, Pred> ConnectorImplementation_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorImplementation, Pred>(impl, meta_ConnectorImplementation_children); };
		::Udm::ChildrenAttr< ::PICML::MonolithicImplementationBase> MonolithicImplementationBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MonolithicImplementationBase, Pred> MonolithicImplementationBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MonolithicImplementationBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Implemenation> Implemenation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Implemenation, Pred> Implemenation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Implemenation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ConnectorType> ConnectorType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorType, Pred> ConnectorType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ConnectorImplements> ConnectorImplements_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorImplements, Pred> ConnectorImplements_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorImplements, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ConnectorImplementation> ConnectorImplementation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorImplementation, Pred> ConnectorImplementation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorImplementation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::ConnectorImplementations> ConnectorImplementations_parent() const;
		::Udm::ParentAttr< ::PICML::ConnectorImplementations> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_ConnectorImplements_children;
		static ::Uml::CompositionChildRole meta_ConnectorType_children;
		static ::Uml::CompositionChildRole meta_ConnectorImplementation_children;
		static ::Uml::CompositionParentRole meta_ConnectorImplementations_parent;

	};

	class PICML_Export ConnectorImplementation :  public MonolithicImplementationBase {
	public:
		ConnectorImplementation();
		ConnectorImplementation(::Udm::ObjectImpl *impl);
		ConnectorImplementation(const ConnectorImplementation &master);

#ifdef UDM_RVALUE
		ConnectorImplementation(ConnectorImplementation &&master);

		static ConnectorImplementation Cast(::Udm::Object &&a);
		ConnectorImplementation& operator=(ConnectorImplementation &&a);

#endif
		static ConnectorImplementation Cast(const ::Udm::Object &a);
		static ConnectorImplementation Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ConnectorImplementation CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ConnectorImplementation> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ConnectorImplementation, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ConnectorImplementation, Pred>(impl); };
		ConnectorImplementation CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ConnectorImplementation> Derived();
		template <class Pred> ::Udm::DerivedAttr< ConnectorImplementation, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ConnectorImplementation, Pred>(impl); };
		::Udm::ArchetypeAttr< ConnectorImplementation> Archetype() const;
		::Udm::AClassPointerAttr< ConnectorImplements, ConnectorType> dstConnectorImplements() const;
		::Udm::AssocAttr< ConnectorImplementationType> referedbyConnectorImplementationType() const;
		template <class Pred> ::Udm::AssocAttr< ConnectorImplementationType, Pred> referedbyConnectorImplementationType_sorted(const Pred &) const { return ::Udm::AssocAttr< ConnectorImplementationType, Pred>(impl, meta_referedbyConnectorImplementationType); };
		::Udm::ParentAttr< ::PICML::ConnectorImplementationContainer> ConnectorImplementationContainer_parent() const;
		::Udm::ParentAttr< ::PICML::ConnectorImplementationContainer> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstConnectorImplements;
		static ::Uml::AssociationRole meta_dstConnectorImplements_rev;
		static ::Uml::AssociationRole meta_referedbyConnectorImplementationType;
		static ::Uml::CompositionParentRole meta_ConnectorImplementationContainer_parent;

	};

	class PICML_Export ConnectorImplementationType :  public MgaObject {
	public:
		ConnectorImplementationType();
		ConnectorImplementationType(::Udm::ObjectImpl *impl);
		ConnectorImplementationType(const ConnectorImplementationType &master);

#ifdef UDM_RVALUE
		ConnectorImplementationType(ConnectorImplementationType &&master);

		static ConnectorImplementationType Cast(::Udm::Object &&a);
		ConnectorImplementationType& operator=(ConnectorImplementationType &&a);

#endif
		static ConnectorImplementationType Cast(const ::Udm::Object &a);
		static ConnectorImplementationType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ConnectorImplementationType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ConnectorImplementationType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ConnectorImplementationType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ConnectorImplementationType, Pred>(impl); };
		ConnectorImplementationType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ConnectorImplementationType> Derived();
		template <class Pred> ::Udm::DerivedAttr< ConnectorImplementationType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ConnectorImplementationType, Pred>(impl); };
		::Udm::ArchetypeAttr< ConnectorImplementationType> Archetype() const;
		::Udm::PointerAttr< ConnectorImplementation> ref() const;
		::Udm::ParentAttr< ::PICML::ConnectorInstance> ConnectorInstance_parent() const;
		::Udm::ParentAttr< ::PICML::ConnectorInstance> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ConnectorInstance_parent;

	};

	class PICML_Export ConnectorInstance :  public AssemblyConfigPropertyEnd {
	public:
		ConnectorInstance();
		ConnectorInstance(::Udm::ObjectImpl *impl);
		ConnectorInstance(const ConnectorInstance &master);

#ifdef UDM_RVALUE
		ConnectorInstance(ConnectorInstance &&master);

		static ConnectorInstance Cast(::Udm::Object &&a);
		ConnectorInstance& operator=(ConnectorInstance &&a);

#endif
		static ConnectorInstance Cast(const ::Udm::Object &a);
		static ConnectorInstance Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ConnectorInstance CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ConnectorInstance> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ConnectorInstance, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ConnectorInstance, Pred>(impl); };
		ConnectorInstance CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ConnectorInstance> Derived();
		template <class Pred> ::Udm::DerivedAttr< ConnectorInstance, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ConnectorInstance, Pred>(impl); };
		::Udm::ArchetypeAttr< ConnectorInstance> Archetype() const;
		::Udm::StringAttr UUID() const;
		::Udm::AClassAssocAttr< ConnectorToReceptacle, RequiredRequestPortEnd> srcConnectorToReceptacle() const;
		template <class Pred> ::Udm::AClassAssocAttr< ConnectorToReceptacle, RequiredRequestPortEnd, Pred> srcConnectorToReceptacle_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ConnectorToReceptacle, RequiredRequestPortEnd, Pred>(impl, meta_srcConnectorToReceptacle, meta_srcConnectorToReceptacle_rev); };
		::Udm::AClassAssocAttr< Publish, ExtendPortEnd> srcPublish() const;
		template <class Pred> ::Udm::AClassAssocAttr< Publish, ExtendPortEnd, Pred> srcPublish_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< Publish, ExtendPortEnd, Pred>(impl, meta_srcPublish, meta_srcPublish_rev); };
		::Udm::AClassAssocAttr< ConnectorToFacet, ProvidedRequestPortEnd> dstConnectorToFacet() const;
		template <class Pred> ::Udm::AClassAssocAttr< ConnectorToFacet, ProvidedRequestPortEnd, Pred> dstConnectorToFacet_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< ConnectorToFacet, ProvidedRequestPortEnd, Pred>(impl, meta_dstConnectorToFacet, meta_dstConnectorToFacet_rev); };
		::Udm::AClassAssocAttr< Consume, ExtendPortEnd> dstConsume() const;
		template <class Pred> ::Udm::AClassAssocAttr< Consume, ExtendPortEnd, Pred> dstConsume_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< Consume, ExtendPortEnd, Pred>(impl, meta_dstConsume, meta_dstConsume_rev); };
		::Udm::ChildrenAttr< ::PICML::AttributeInstance> AttributeInstance_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AttributeInstance, Pred> AttributeInstance_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AttributeInstance, Pred>(impl, meta_AttributeInstance_children); };
		::Udm::ChildAttr< ::PICML::ConnectorImplementationType> ConnectorImplementationType_child() const;
		::Udm::ChildrenAttr< ::PICML::PortInstance> PortInstance_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PortInstance, Pred> PortInstance_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PortInstance, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::AttributeInstance> AttributeInstance_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::AttributeInstance, Pred> AttributeInstance_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::AttributeInstance, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ConnectorImplementationType> ConnectorImplementationType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorImplementationType, Pred> ConnectorImplementationType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorImplementationType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::ComponentAssembly> ComponentAssembly_parent() const;
		::Udm::ParentAttr< ::PICML::ComponentAssembly> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::AssociationRole meta_srcConnectorToReceptacle;
		static ::Uml::AssociationRole meta_srcConnectorToReceptacle_rev;
		static ::Uml::AssociationRole meta_srcPublish;
		static ::Uml::AssociationRole meta_srcPublish_rev;
		static ::Uml::AssociationRole meta_dstConnectorToFacet;
		static ::Uml::AssociationRole meta_dstConnectorToFacet_rev;
		static ::Uml::AssociationRole meta_dstConsume;
		static ::Uml::AssociationRole meta_dstConsume_rev;
		static ::Uml::CompositionChildRole meta_AttributeInstance_children;
		static ::Uml::CompositionChildRole meta_ConnectorImplementationType_child;
		static ::Uml::CompositionParentRole meta_ComponentAssembly_parent;

	};

	class PICML_Export ConnectorInherits :  public MgaObject {
	public:
		ConnectorInherits();
		ConnectorInherits(::Udm::ObjectImpl *impl);
		ConnectorInherits(const ConnectorInherits &master);

#ifdef UDM_RVALUE
		ConnectorInherits(ConnectorInherits &&master);

		static ConnectorInherits Cast(::Udm::Object &&a);
		ConnectorInherits& operator=(ConnectorInherits &&a);

#endif
		static ConnectorInherits Cast(const ::Udm::Object &a);
		static ConnectorInherits Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ConnectorInherits CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ConnectorInherits> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ConnectorInherits, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ConnectorInherits, Pred>(impl); };
		ConnectorInherits CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ConnectorInherits> Derived();
		template <class Pred> ::Udm::DerivedAttr< ConnectorInherits, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ConnectorInherits, Pred>(impl); };
		::Udm::ArchetypeAttr< ConnectorInherits> Archetype() const;
		::Udm::PointerAttr< ConnectorObject> ref() const;
		::Udm::ParentAttr< ::PICML::ConnectorObject> ConnectorObject_parent() const;
		::Udm::ParentAttr< ::PICML::ConnectorObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_ConnectorObject_parent;

	};

	class PICML_Export ConnectorObject :  public NamedType {
	public:
		ConnectorObject();
		ConnectorObject(::Udm::ObjectImpl *impl);
		ConnectorObject(const ConnectorObject &master);

#ifdef UDM_RVALUE
		ConnectorObject(ConnectorObject &&master);

		static ConnectorObject Cast(::Udm::Object &&a);
		ConnectorObject& operator=(ConnectorObject &&a);

#endif
		static ConnectorObject Cast(const ::Udm::Object &a);
		static ConnectorObject Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ConnectorObject CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ConnectorObject> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ConnectorObject, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ConnectorObject, Pred>(impl); };
		ConnectorObject CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ConnectorObject> Derived();
		template <class Pred> ::Udm::DerivedAttr< ConnectorObject, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ConnectorObject, Pred>(impl); };
		::Udm::ArchetypeAttr< ConnectorObject> Archetype() const;
		::Udm::StringAttr UUID() const;
		::Udm::AssocAttr< ConnectorType> referedbyConnectorType() const;
		template <class Pred> ::Udm::AssocAttr< ConnectorType, Pred> referedbyConnectorType_sorted(const Pred &) const { return ::Udm::AssocAttr< ConnectorType, Pred>(impl, meta_referedbyConnectorType); };
		::Udm::AssocAttr< ConnectorInherits> referedbyConnectorInherits() const;
		template <class Pred> ::Udm::AssocAttr< ConnectorInherits, Pred> referedbyConnectorInherits_sorted(const Pred &) const { return ::Udm::AssocAttr< ConnectorInherits, Pred>(impl, meta_referedbyConnectorInherits); };
		::Udm::ChildrenAttr< ::PICML::Collection> Collection_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Collection, Pred> Collection_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Collection, Pred>(impl, meta_Collection_children); };
		::Udm::ChildrenAttr< ::PICML::Aggregate> Aggregate_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Aggregate, Pred> Aggregate_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Aggregate, Pred>(impl, meta_Aggregate_children); };
		::Udm::ChildrenAttr< ::PICML::ExtendedPortBase> ExtendedPortBase_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExtendedPortBase, Pred> ExtendedPortBase_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExtendedPortBase, Pred>(impl, meta_ExtendedPortBase_children); };
		::Udm::ChildAttr< ::PICML::ConnectorInherits> ConnectorInherits_child() const;
		::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute> ReadonlyAttribute_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred> ReadonlyAttribute_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred>(impl, meta_ReadonlyAttribute_children); };
		::Udm::ChildrenAttr< ::PICML::ObjectPort> ObjectPort_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ObjectPort, Pred> ObjectPort_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ObjectPort, Pred>(impl, meta_ObjectPort_children); };
		::Udm::ChildrenAttr< ::PICML::GraphVertex> GraphVertex_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::GraphVertex, Pred> GraphVertex_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::GraphVertex, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComplexType> ComplexType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexType, Pred> ComplexType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Attribute> Attribute_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Attribute, Pred> Attribute_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Attribute, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute> ReadonlyAttribute_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred> ReadonlyAttribute_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::NoInheritable> NoInheritable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NoInheritable, Pred> NoInheritable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NoInheritable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Collection> Collection_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Collection, Pred> Collection_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Collection, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::NamedType> NamedType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::NamedType, Pred> NamedType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::NamedType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MemberType> MemberType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MemberType, Pred> MemberType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MemberType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Aggregate> Aggregate_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Aggregate, Pred> Aggregate_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Aggregate, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType> TemplateParameterValueType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType, Pred> TemplateParameterValueType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TemplateParameterValueType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::CommonPortAttrs> CommonPortAttrs_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CommonPortAttrs, Pred> CommonPortAttrs_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CommonPortAttrs, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExtendedPortBase> ExtendedPortBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExtendedPortBase, Pred> ExtendedPortBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExtendedPortBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MirrorPort> MirrorPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MirrorPort, Pred> MirrorPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MirrorPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExtendedPort> ExtendedPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExtendedPort, Pred> ExtendedPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExtendedPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ObjectPort> ObjectPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ObjectPort, Pred> ObjectPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ObjectPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Port> Port_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Port, Pred> Port_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Port, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequiredRequestPort> RequiredRequestPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred> RequiredRequestPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ProvidedRequestPort> ProvidedRequestPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred> ProvidedRequestPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ConnectorInherits> ConnectorInherits_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ConnectorInherits, Pred> ConnectorInherits_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ConnectorInherits, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::Prefixable> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::AssociationRole meta_referedbyConnectorType;
		static ::Uml::AssociationRole meta_referedbyConnectorInherits;
		static ::Uml::CompositionChildRole meta_Collection_children;
		static ::Uml::CompositionChildRole meta_Aggregate_children;
		static ::Uml::CompositionChildRole meta_ExtendedPortBase_children;
		static ::Uml::CompositionChildRole meta_ConnectorInherits_child;
		static ::Uml::CompositionChildRole meta_ReadonlyAttribute_children;
		static ::Uml::CompositionChildRole meta_ObjectPort_children;

	};

	class PICML_Export EffectBase :  public MgaObject {
	public:
		EffectBase();
		EffectBase(::Udm::ObjectImpl *impl);
		EffectBase(const EffectBase &master);

#ifdef UDM_RVALUE
		EffectBase(EffectBase &&master);

		static EffectBase Cast(::Udm::Object &&a);
		EffectBase& operator=(EffectBase &&a);

#endif
		static EffectBase Cast(const ::Udm::Object &a);
		static EffectBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		EffectBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< EffectBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< EffectBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< EffectBase, Pred>(impl); };
		EffectBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< EffectBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< EffectBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< EffectBase, Pred>(impl); };
		::Udm::ArchetypeAttr< EffectBase> Archetype() const;
		::Udm::StringAttr Postcondition() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Postcondition;

	};

	class PICML_Export TerminalEffect :  public EffectBase {
	public:
		TerminalEffect();
		TerminalEffect(::Udm::ObjectImpl *impl);
		TerminalEffect(const TerminalEffect &master);

#ifdef UDM_RVALUE
		TerminalEffect(TerminalEffect &&master);

		static TerminalEffect Cast(::Udm::Object &&a);
		TerminalEffect& operator=(TerminalEffect &&a);

#endif
		static TerminalEffect Cast(const ::Udm::Object &a);
		static TerminalEffect Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TerminalEffect CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TerminalEffect> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TerminalEffect, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TerminalEffect, Pred>(impl); };
		TerminalEffect CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TerminalEffect> Derived();
		template <class Pred> ::Udm::DerivedAttr< TerminalEffect, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TerminalEffect, Pred>(impl); };
		::Udm::ArchetypeAttr< TerminalEffect> Archetype() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		::Udm::AssocEndAttr< ::PICML::Terminal> srcTerminalEffect_end() const;
		::Udm::AssocEndAttr< ::PICML::StateBase> dstTerminalEffect_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;
		static ::Uml::AssociationRole meta_srcTerminalEffect_end_;
		static ::Uml::AssociationRole meta_dstTerminalEffect_end_;

	};

	class PICML_Export InputEffect :  public EffectBase {
	public:
		InputEffect();
		InputEffect(::Udm::ObjectImpl *impl);
		InputEffect(const InputEffect &master);

#ifdef UDM_RVALUE
		InputEffect(InputEffect &&master);

		static InputEffect Cast(::Udm::Object &&a);
		InputEffect& operator=(InputEffect &&a);

#endif
		static InputEffect Cast(const ::Udm::Object &a);
		static InputEffect Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		InputEffect CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< InputEffect> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< InputEffect, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< InputEffect, Pred>(impl); };
		InputEffect CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< InputEffect> Derived();
		template <class Pred> ::Udm::DerivedAttr< InputEffect, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< InputEffect, Pred>(impl); };
		::Udm::ArchetypeAttr< InputEffect> Archetype() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		::Udm::AssocEndAttr< ::PICML::BehaviorInputAction> srcInputEffect_end() const;
		::Udm::AssocEndAttr< ::PICML::StateBase> dstInputEffect_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;
		static ::Uml::AssociationRole meta_srcInputEffect_end_;
		static ::Uml::AssociationRole meta_dstInputEffect_end_;

	};

	class PICML_Export Effect :  public EffectBase {
	public:
		Effect();
		Effect(::Udm::ObjectImpl *impl);
		Effect(const Effect &master);

#ifdef UDM_RVALUE
		Effect(Effect &&master);

		static Effect Cast(::Udm::Object &&a);
		Effect& operator=(Effect &&a);

#endif
		static Effect Cast(const ::Udm::Object &a);
		static Effect Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Effect CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Effect> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Effect, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Effect, Pred>(impl); };
		Effect CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Effect> Derived();
		template <class Pred> ::Udm::DerivedAttr< Effect, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Effect, Pred>(impl); };
		::Udm::ArchetypeAttr< Effect> Archetype() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		::Udm::AssocEndAttr< ::PICML::ActionBase> srcEffect_end() const;
		::Udm::AssocEndAttr< ::PICML::StateBase> dstEffect_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;
		static ::Uml::AssociationRole meta_srcEffect_end_;
		static ::Uml::AssociationRole meta_dstEffect_end_;

	};

	class PICML_Export TerminalTransition :  public MgaObject {
	public:
		TerminalTransition();
		TerminalTransition(::Udm::ObjectImpl *impl);
		TerminalTransition(const TerminalTransition &master);

#ifdef UDM_RVALUE
		TerminalTransition(TerminalTransition &&master);

		static TerminalTransition Cast(::Udm::Object &&a);
		TerminalTransition& operator=(TerminalTransition &&a);

#endif
		static TerminalTransition Cast(const ::Udm::Object &a);
		static TerminalTransition Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TerminalTransition CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TerminalTransition> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TerminalTransition, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TerminalTransition, Pred>(impl); };
		TerminalTransition CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TerminalTransition> Derived();
		template <class Pred> ::Udm::DerivedAttr< TerminalTransition, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TerminalTransition, Pred>(impl); };
		::Udm::ArchetypeAttr< TerminalTransition> Archetype() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		::Udm::AssocEndAttr< ::PICML::State> srcTerminalTransition_end() const;
		::Udm::AssocEndAttr< ::PICML::Terminal> dstTerminalTransition_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;
		static ::Uml::AssociationRole meta_srcTerminalTransition_end_;
		static ::Uml::AssociationRole meta_dstTerminalTransition_end_;

	};

	class PICML_Export Terminal :  public MgaObject {
	public:
		Terminal();
		Terminal(::Udm::ObjectImpl *impl);
		Terminal(const Terminal &master);

#ifdef UDM_RVALUE
		Terminal(Terminal &&master);

		static Terminal Cast(::Udm::Object &&a);
		Terminal& operator=(Terminal &&a);

#endif
		static Terminal Cast(const ::Udm::Object &a);
		static Terminal Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Terminal CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Terminal> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Terminal, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Terminal, Pred>(impl); };
		Terminal CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Terminal> Derived();
		template <class Pred> ::Udm::DerivedAttr< Terminal, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Terminal, Pred>(impl); };
		::Udm::ArchetypeAttr< Terminal> Archetype() const;
		::Udm::AClassPointerAttr< TerminalEffect, StateBase> dstTerminalEffect() const;
		::Udm::AClassAssocAttr< TerminalTransition, State> srcTerminalTransition() const;
		template <class Pred> ::Udm::AClassAssocAttr< TerminalTransition, State, Pred> srcTerminalTransition_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< TerminalTransition, State, Pred>(impl, meta_srcTerminalTransition, meta_srcTerminalTransition_rev); };
		::Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstTerminalEffect;
		static ::Uml::AssociationRole meta_dstTerminalEffect_rev;
		static ::Uml::AssociationRole meta_srcTerminalTransition;
		static ::Uml::AssociationRole meta_srcTerminalTransition_rev;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;

	};

	class PICML_Export LoopTransition :  public MgaObject {
	public:
		LoopTransition();
		LoopTransition(::Udm::ObjectImpl *impl);
		LoopTransition(const LoopTransition &master);

#ifdef UDM_RVALUE
		LoopTransition(LoopTransition &&master);

		static LoopTransition Cast(::Udm::Object &&a);
		LoopTransition& operator=(LoopTransition &&a);

#endif
		static LoopTransition Cast(const ::Udm::Object &a);
		static LoopTransition Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		LoopTransition CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< LoopTransition> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< LoopTransition, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< LoopTransition, Pred>(impl); };
		LoopTransition CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< LoopTransition> Derived();
		template <class Pred> ::Udm::DerivedAttr< LoopTransition, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< LoopTransition, Pred>(impl); };
		::Udm::ArchetypeAttr< LoopTransition> Archetype() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		::Udm::AssocEndAttr< ::PICML::LoopState> srcLoopTransition_end() const;
		::Udm::AssocEndAttr< ::PICML::ActionBase> dstLoopTransition_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;
		static ::Uml::AssociationRole meta_srcLoopTransition_end_;
		static ::Uml::AssociationRole meta_dstLoopTransition_end_;

	};

	class PICML_Export StateBase :  public MgaObject {
	public:
		StateBase();
		StateBase(::Udm::ObjectImpl *impl);
		StateBase(const StateBase &master);

#ifdef UDM_RVALUE
		StateBase(StateBase &&master);

		static StateBase Cast(::Udm::Object &&a);
		StateBase& operator=(StateBase &&a);

#endif
		static StateBase Cast(const ::Udm::Object &a);
		static StateBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		StateBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< StateBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< StateBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< StateBase, Pred>(impl); };
		StateBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< StateBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< StateBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< StateBase, Pred>(impl); };
		::Udm::ArchetypeAttr< StateBase> Archetype() const;
		::Udm::AClassPointerAttr< TerminalEffect, Terminal> srcTerminalEffect() const;
		::Udm::AClassAssocAttr< Finish, BehaviorInputAction> dstFinish() const;
		template <class Pred> ::Udm::AClassAssocAttr< Finish, BehaviorInputAction, Pred> dstFinish_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< Finish, BehaviorInputAction, Pred>(impl, meta_dstFinish, meta_dstFinish_rev); };
		::Udm::AClassAssocAttr< Effect, ActionBase> srcEffect() const;
		template <class Pred> ::Udm::AClassAssocAttr< Effect, ActionBase, Pred> srcEffect_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< Effect, ActionBase, Pred>(impl, meta_srcEffect, meta_srcEffect_rev); };
		::Udm::AClassAssocAttr< InputEffect, BehaviorInputAction> srcInputEffect() const;
		template <class Pred> ::Udm::AClassAssocAttr< InputEffect, BehaviorInputAction, Pred> srcInputEffect_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< InputEffect, BehaviorInputAction, Pred>(impl, meta_srcInputEffect, meta_srcInputEffect_rev); };
		::Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcTerminalEffect;
		static ::Uml::AssociationRole meta_srcTerminalEffect_rev;
		static ::Uml::AssociationRole meta_dstFinish;
		static ::Uml::AssociationRole meta_dstFinish_rev;
		static ::Uml::AssociationRole meta_srcEffect;
		static ::Uml::AssociationRole meta_srcEffect_rev;
		static ::Uml::AssociationRole meta_srcInputEffect;
		static ::Uml::AssociationRole meta_srcInputEffect_rev;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;

	};

	class PICML_Export LoopState :  public StateBase {
	public:
		LoopState();
		LoopState(::Udm::ObjectImpl *impl);
		LoopState(const LoopState &master);

#ifdef UDM_RVALUE
		LoopState(LoopState &&master);

		static LoopState Cast(::Udm::Object &&a);
		LoopState& operator=(LoopState &&a);

#endif
		static LoopState Cast(const ::Udm::Object &a);
		static LoopState Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		LoopState CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< LoopState> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< LoopState, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< LoopState, Pred>(impl); };
		LoopState CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< LoopState> Derived();
		template <class Pred> ::Udm::DerivedAttr< LoopState, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< LoopState, Pred>(impl); };
		::Udm::ArchetypeAttr< LoopState> Archetype() const;
		::Udm::StringAttr LoopingCondition() const;
		::Udm::AClassPointerAttr< LoopTransition, ActionBase> dstLoopTransition() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_LoopingCondition;
		static ::Uml::AssociationRole meta_dstLoopTransition;
		static ::Uml::AssociationRole meta_dstLoopTransition_rev;

	};

	class PICML_Export WhileState :  public LoopState {
	public:
		WhileState();
		WhileState(::Udm::ObjectImpl *impl);
		WhileState(const WhileState &master);

#ifdef UDM_RVALUE
		WhileState(WhileState &&master);

		static WhileState Cast(::Udm::Object &&a);
		WhileState& operator=(WhileState &&a);

#endif
		static WhileState Cast(const ::Udm::Object &a);
		static WhileState Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		WhileState CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< WhileState> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< WhileState, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< WhileState, Pred>(impl); };
		WhileState CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< WhileState> Derived();
		template <class Pred> ::Udm::DerivedAttr< WhileState, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< WhileState, Pred>(impl); };
		::Udm::ArchetypeAttr< WhileState> Archetype() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export DoWhileState :  public LoopState {
	public:
		DoWhileState();
		DoWhileState(::Udm::ObjectImpl *impl);
		DoWhileState(const DoWhileState &master);

#ifdef UDM_RVALUE
		DoWhileState(DoWhileState &&master);

		static DoWhileState Cast(::Udm::Object &&a);
		DoWhileState& operator=(DoWhileState &&a);

#endif
		static DoWhileState Cast(const ::Udm::Object &a);
		static DoWhileState Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		DoWhileState CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< DoWhileState> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< DoWhileState, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< DoWhileState, Pred>(impl); };
		DoWhileState CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< DoWhileState> Derived();
		template <class Pred> ::Udm::DerivedAttr< DoWhileState, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< DoWhileState, Pred>(impl); };
		::Udm::ArchetypeAttr< DoWhileState> Archetype() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export ForState :  public LoopState {
	public:
		ForState();
		ForState(::Udm::ObjectImpl *impl);
		ForState(const ForState &master);

#ifdef UDM_RVALUE
		ForState(ForState &&master);

		static ForState Cast(::Udm::Object &&a);
		ForState& operator=(ForState &&a);

#endif
		static ForState Cast(const ::Udm::Object &a);
		static ForState Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ForState CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ForState> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ForState, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ForState, Pred>(impl); };
		ForState CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ForState> Derived();
		template <class Pred> ::Udm::DerivedAttr< ForState, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ForState, Pred>(impl); };
		::Udm::ArchetypeAttr< ForState> Archetype() const;
		::Udm::StringAttr InitialCondition() const;
		::Udm::StringAttr IncrementExpr() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_InitialCondition;
		static ::Uml::Attribute meta_IncrementExpr;

	};

	class PICML_Export BranchTransition :  public MgaObject {
	public:
		BranchTransition();
		BranchTransition(::Udm::ObjectImpl *impl);
		BranchTransition(const BranchTransition &master);

#ifdef UDM_RVALUE
		BranchTransition(BranchTransition &&master);

		static BranchTransition Cast(::Udm::Object &&a);
		BranchTransition& operator=(BranchTransition &&a);

#endif
		static BranchTransition Cast(const ::Udm::Object &a);
		static BranchTransition Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		BranchTransition CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< BranchTransition> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< BranchTransition, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< BranchTransition, Pred>(impl); };
		BranchTransition CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< BranchTransition> Derived();
		template <class Pred> ::Udm::DerivedAttr< BranchTransition, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< BranchTransition, Pred>(impl); };
		::Udm::ArchetypeAttr< BranchTransition> Archetype() const;
		::Udm::StringAttr Condition() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		::Udm::AssocEndAttr< ::PICML::BranchState> srcBranchTransition_end() const;
		::Udm::AssocEndAttr< ::PICML::ActionBase> dstBranchTransition_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Condition;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;
		static ::Uml::AssociationRole meta_srcBranchTransition_end_;
		static ::Uml::AssociationRole meta_dstBranchTransition_end_;

	};

	class PICML_Export BranchState :  public StateBase {
	public:
		BranchState();
		BranchState(::Udm::ObjectImpl *impl);
		BranchState(const BranchState &master);

#ifdef UDM_RVALUE
		BranchState(BranchState &&master);

		static BranchState Cast(::Udm::Object &&a);
		BranchState& operator=(BranchState &&a);

#endif
		static BranchState Cast(const ::Udm::Object &a);
		static BranchState Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		BranchState CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< BranchState> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< BranchState, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< BranchState, Pred>(impl); };
		BranchState CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< BranchState> Derived();
		template <class Pred> ::Udm::DerivedAttr< BranchState, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< BranchState, Pred>(impl); };
		::Udm::ArchetypeAttr< BranchState> Archetype() const;
		::Udm::AClassAssocAttr< BranchTransition, ActionBase> dstBranchTransition() const;
		template <class Pred> ::Udm::AClassAssocAttr< BranchTransition, ActionBase, Pred> dstBranchTransition_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< BranchTransition, ActionBase, Pred>(impl, meta_dstBranchTransition, meta_dstBranchTransition_rev); };
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstBranchTransition;
		static ::Uml::AssociationRole meta_dstBranchTransition_rev;

	};

	class PICML_Export State :  public StateBase {
	public:
		State();
		State(::Udm::ObjectImpl *impl);
		State(const State &master);

#ifdef UDM_RVALUE
		State(State &&master);

		static State Cast(::Udm::Object &&a);
		State& operator=(State &&a);

#endif
		static State Cast(const ::Udm::Object &a);
		static State Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		State CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< State> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< State, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< State, Pred>(impl); };
		State CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< State> Derived();
		template <class Pred> ::Udm::DerivedAttr< State, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< State, Pred>(impl); };
		::Udm::ArchetypeAttr< State> Archetype() const;
		::Udm::AClassPointerAttr< Transition, ActionBase> dstTransition() const;
		::Udm::AClassPointerAttr< TerminalTransition, Terminal> dstTerminalTransition() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstTransition;
		static ::Uml::AssociationRole meta_dstTransition_rev;
		static ::Uml::AssociationRole meta_dstTerminalTransition;
		static ::Uml::AssociationRole meta_dstTerminalTransition_rev;

	};

	class PICML_Export Transition :  public MgaObject {
	public:
		Transition();
		Transition(::Udm::ObjectImpl *impl);
		Transition(const Transition &master);

#ifdef UDM_RVALUE
		Transition(Transition &&master);

		static Transition Cast(::Udm::Object &&a);
		Transition& operator=(Transition &&a);

#endif
		static Transition Cast(const ::Udm::Object &a);
		static Transition Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Transition CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Transition> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Transition, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Transition, Pred>(impl); };
		Transition CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Transition> Derived();
		template <class Pred> ::Udm::DerivedAttr< Transition, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Transition, Pred>(impl); };
		::Udm::ArchetypeAttr< Transition> Archetype() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		::Udm::AssocEndAttr< ::PICML::State> srcTransition_end() const;
		::Udm::AssocEndAttr< ::PICML::ActionBase> dstTransition_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;
		static ::Uml::AssociationRole meta_srcTransition_end_;
		static ::Uml::AssociationRole meta_dstTransition_end_;

	};

	class PICML_Export QueryInputBase :  virtual  public MgaObject {
	public:
		QueryInputBase();
		QueryInputBase(::Udm::ObjectImpl *impl);
		QueryInputBase(const QueryInputBase &master);

#ifdef UDM_RVALUE
		QueryInputBase(QueryInputBase &&master);

		static QueryInputBase Cast(::Udm::Object &&a);
		QueryInputBase& operator=(QueryInputBase &&a);

#endif
		static QueryInputBase Cast(const ::Udm::Object &a);
		static QueryInputBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		QueryInputBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< QueryInputBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< QueryInputBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< QueryInputBase, Pred>(impl); };
		QueryInputBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< QueryInputBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< QueryInputBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< QueryInputBase, Pred>(impl); };
		::Udm::ArchetypeAttr< QueryInputBase> Archetype() const;
		::Udm::AClassPointerAttr< QueryInput, QueryInputAction> dstQueryInput() const;
		::Udm::ParentAttr< ::Udm::Object> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstQueryInput;
		static ::Uml::AssociationRole meta_dstQueryInput_rev;

	};

	class PICML_Export QueryInput :  public MgaObject {
	public:
		QueryInput();
		QueryInput(::Udm::ObjectImpl *impl);
		QueryInput(const QueryInput &master);

#ifdef UDM_RVALUE
		QueryInput(QueryInput &&master);

		static QueryInput Cast(::Udm::Object &&a);
		QueryInput& operator=(QueryInput &&a);

#endif
		static QueryInput Cast(const ::Udm::Object &a);
		static QueryInput Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		QueryInput CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< QueryInput> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< QueryInput, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< QueryInput, Pred>(impl); };
		QueryInput CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< QueryInput> Derived();
		template <class Pred> ::Udm::DerivedAttr< QueryInput, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< QueryInput, Pred>(impl); };
		::Udm::ArchetypeAttr< QueryInput> Archetype() const;
		::Udm::ParentAttr< ::PICML::TopLevelBehavior> TopLevelBehavior_parent() const;
		::Udm::ParentAttr< ::PICML::TopLevelBehavior> parent() const;
		::Udm::AssocEndAttr< ::PICML::QueryInputBase> srcQueryInput_end() const;
		::Udm::AssocEndAttr< ::PICML::QueryInputAction> dstQueryInput_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_TopLevelBehavior_parent;
		static ::Uml::AssociationRole meta_srcQueryInput_end_;
		static ::Uml::AssociationRole meta_dstQueryInput_end_;

	};

	class PICML_Export MultiInput :  public MgaObject {
	public:
		MultiInput();
		MultiInput(::Udm::ObjectImpl *impl);
		MultiInput(const MultiInput &master);

#ifdef UDM_RVALUE
		MultiInput(MultiInput &&master);

		static MultiInput Cast(::Udm::Object &&a);
		MultiInput& operator=(MultiInput &&a);

#endif
		static MultiInput Cast(const ::Udm::Object &a);
		static MultiInput Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MultiInput CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MultiInput> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MultiInput, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MultiInput, Pred>(impl); };
		MultiInput CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MultiInput> Derived();
		template <class Pred> ::Udm::DerivedAttr< MultiInput, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MultiInput, Pred>(impl); };
		::Udm::ArchetypeAttr< MultiInput> Archetype() const;
		::Udm::ParentAttr< ::PICML::TopLevelBehavior> TopLevelBehavior_parent() const;
		::Udm::ParentAttr< ::PICML::TopLevelBehavior> parent() const;
		::Udm::AssocEndAttr< ::PICML::MultiInputBase> srcMultiInput_end() const;
		::Udm::AssocEndAttr< ::PICML::MultiInputAction> dstMultiInput_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_TopLevelBehavior_parent;
		static ::Uml::AssociationRole meta_srcMultiInput_end_;
		static ::Uml::AssociationRole meta_dstMultiInput_end_;

	};

	class PICML_Export SingleOutputBase :  virtual  public MgaObject {
	public:
		SingleOutputBase();
		SingleOutputBase(::Udm::ObjectImpl *impl);
		SingleOutputBase(const SingleOutputBase &master);

#ifdef UDM_RVALUE
		SingleOutputBase(SingleOutputBase &&master);

		static SingleOutputBase Cast(::Udm::Object &&a);
		SingleOutputBase& operator=(SingleOutputBase &&a);

#endif
		static SingleOutputBase Cast(const ::Udm::Object &a);
		static SingleOutputBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		SingleOutputBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< SingleOutputBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< SingleOutputBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< SingleOutputBase, Pred>(impl); };
		SingleOutputBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< SingleOutputBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< SingleOutputBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< SingleOutputBase, Pred>(impl); };
		::Udm::ArchetypeAttr< SingleOutputBase> Archetype() const;
		::Udm::ParentAttr< ::Udm::Object> parent() const;

		static ::Uml::Class meta;

	};

	class PICML_Export OutEventPort :  public EventPort,  public SingleOutputBase {
	public:
		OutEventPort();
		OutEventPort(::Udm::ObjectImpl *impl);
		OutEventPort(const OutEventPort &master);

#ifdef UDM_RVALUE
		OutEventPort(OutEventPort &&master);

		static OutEventPort Cast(::Udm::Object &&a);
		OutEventPort& operator=(OutEventPort &&a);

#endif
		static OutEventPort Cast(const ::Udm::Object &a);
		static OutEventPort Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		OutEventPort CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< OutEventPort> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< OutEventPort, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< OutEventPort, Pred>(impl); };
		OutEventPort CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< OutEventPort> Derived();
		template <class Pred> ::Udm::DerivedAttr< OutEventPort, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< OutEventPort, Pred>(impl); };
		::Udm::ArchetypeAttr< OutEventPort> Archetype() const;
		::Udm::BooleanAttr single_destination() const;
		::Udm::StringAttr out_event_port_type() const;
		::Udm::AssocAttr< OutEventPortInstance> referedbyOutEventPortInstance() const;
		template <class Pred> ::Udm::AssocAttr< OutEventPortInstance, Pred> referedbyOutEventPortInstance_sorted(const Pred &) const { return ::Udm::AssocAttr< OutEventPortInstance, Pred>(impl, meta_referedbyOutEventPortInstance); };
		::Udm::PointerAttr< EventType> ref() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_single_destination;
		static ::Uml::Attribute meta_out_event_port_type;
		static ::Uml::AssociationRole meta_referedbyOutEventPortInstance;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export MultiOutputBase :  virtual  public MgaObject {
	public:
		MultiOutputBase();
		MultiOutputBase(::Udm::ObjectImpl *impl);
		MultiOutputBase(const MultiOutputBase &master);

#ifdef UDM_RVALUE
		MultiOutputBase(MultiOutputBase &&master);

		static MultiOutputBase Cast(::Udm::Object &&a);
		MultiOutputBase& operator=(MultiOutputBase &&a);

#endif
		static MultiOutputBase Cast(const ::Udm::Object &a);
		static MultiOutputBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MultiOutputBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MultiOutputBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MultiOutputBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MultiOutputBase, Pred>(impl); };
		MultiOutputBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MultiOutputBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< MultiOutputBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MultiOutputBase, Pred>(impl); };
		::Udm::ArchetypeAttr< MultiOutputBase> Archetype() const;
		::Udm::ParentAttr< ::Udm::Object> parent() const;

		static ::Uml::Class meta;

	};

	class PICML_Export RequiredRequestPort :  public MultiOutputBase,  public ObjectPort {
	public:
		RequiredRequestPort();
		RequiredRequestPort(::Udm::ObjectImpl *impl);
		RequiredRequestPort(const RequiredRequestPort &master);

#ifdef UDM_RVALUE
		RequiredRequestPort(RequiredRequestPort &&master);

		static RequiredRequestPort Cast(::Udm::Object &&a);
		RequiredRequestPort& operator=(RequiredRequestPort &&a);

#endif
		static RequiredRequestPort Cast(const ::Udm::Object &a);
		static RequiredRequestPort Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		RequiredRequestPort CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< RequiredRequestPort> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< RequiredRequestPort, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< RequiredRequestPort, Pred>(impl); };
		RequiredRequestPort CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< RequiredRequestPort> Derived();
		template <class Pred> ::Udm::DerivedAttr< RequiredRequestPort, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< RequiredRequestPort, Pred>(impl); };
		::Udm::ArchetypeAttr< RequiredRequestPort> Archetype() const;
		::Udm::BooleanAttr multiple_connections() const;
		::Udm::BooleanAttr AsyncCommunication() const;
		::Udm::AssocAttr< RequiredRequestPortInstance> referedbyRequiredRequestPortInstance() const;
		template <class Pred> ::Udm::AssocAttr< RequiredRequestPortInstance, Pred> referedbyRequiredRequestPortInstance_sorted(const Pred &) const { return ::Udm::AssocAttr< RequiredRequestPortInstance, Pred>(impl, meta_referedbyRequiredRequestPortInstance); };
		::Udm::PointerAttr< Provideable> ref() const;
		::Udm::AssocAttr< TargetRequiredRequestPort> referedbyTargetRequiredRequestPort() const;
		template <class Pred> ::Udm::AssocAttr< TargetRequiredRequestPort, Pred> referedbyTargetRequiredRequestPort_sorted(const Pred &) const { return ::Udm::AssocAttr< TargetRequiredRequestPort, Pred>(impl, meta_referedbyTargetRequiredRequestPort); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_multiple_connections;
		static ::Uml::Attribute meta_AsyncCommunication;
		static ::Uml::AssociationRole meta_referedbyRequiredRequestPortInstance;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::AssociationRole meta_referedbyTargetRequiredRequestPort;

	};

	class PICML_Export MultiInputBase :  virtual  public MgaObject {
	public:
		MultiInputBase();
		MultiInputBase(::Udm::ObjectImpl *impl);
		MultiInputBase(const MultiInputBase &master);

#ifdef UDM_RVALUE
		MultiInputBase(MultiInputBase &&master);

		static MultiInputBase Cast(::Udm::Object &&a);
		MultiInputBase& operator=(MultiInputBase &&a);

#endif
		static MultiInputBase Cast(const ::Udm::Object &a);
		static MultiInputBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MultiInputBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MultiInputBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MultiInputBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MultiInputBase, Pred>(impl); };
		MultiInputBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MultiInputBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< MultiInputBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MultiInputBase, Pred>(impl); };
		::Udm::ArchetypeAttr< MultiInputBase> Archetype() const;
		::Udm::AClassAssocAttr< MultiInput, MultiInputAction> dstMultiInput() const;
		template <class Pred> ::Udm::AClassAssocAttr< MultiInput, MultiInputAction, Pred> dstMultiInput_sorted(const Pred &) const { return ::Udm::AClassAssocAttr< MultiInput, MultiInputAction, Pred>(impl, meta_dstMultiInput, meta_dstMultiInput_rev); };
		::Udm::ParentAttr< ::PICML::TopLevelBehavior> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstMultiInput;
		static ::Uml::AssociationRole meta_dstMultiInput_rev;

	};

	class PICML_Export ProvidedRequestPort :  public MultiInputBase,  public ObjectPort {
	public:
		ProvidedRequestPort();
		ProvidedRequestPort(::Udm::ObjectImpl *impl);
		ProvidedRequestPort(const ProvidedRequestPort &master);

#ifdef UDM_RVALUE
		ProvidedRequestPort(ProvidedRequestPort &&master);

		static ProvidedRequestPort Cast(::Udm::Object &&a);
		ProvidedRequestPort& operator=(ProvidedRequestPort &&a);

#endif
		static ProvidedRequestPort Cast(const ::Udm::Object &a);
		static ProvidedRequestPort Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ProvidedRequestPort CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ProvidedRequestPort> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ProvidedRequestPort, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ProvidedRequestPort, Pred>(impl); };
		ProvidedRequestPort CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ProvidedRequestPort> Derived();
		template <class Pred> ::Udm::DerivedAttr< ProvidedRequestPort, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ProvidedRequestPort, Pred>(impl); };
		::Udm::ArchetypeAttr< ProvidedRequestPort> Archetype() const;
		::Udm::AssocAttr< ProvidedRequestPortInstance> referedbyProvidedRequestPortInstance() const;
		template <class Pred> ::Udm::AssocAttr< ProvidedRequestPortInstance, Pred> referedbyProvidedRequestPortInstance_sorted(const Pred &) const { return ::Udm::AssocAttr< ProvidedRequestPortInstance, Pred>(impl, meta_referedbyProvidedRequestPortInstance); };
		::Udm::PointerAttr< Provideable> ref() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyProvidedRequestPortInstance;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export SingleInputBase :  virtual  public MgaObject {
	public:
		SingleInputBase();
		SingleInputBase(::Udm::ObjectImpl *impl);
		SingleInputBase(const SingleInputBase &master);

#ifdef UDM_RVALUE
		SingleInputBase(SingleInputBase &&master);

		static SingleInputBase Cast(::Udm::Object &&a);
		SingleInputBase& operator=(SingleInputBase &&a);

#endif
		static SingleInputBase Cast(const ::Udm::Object &a);
		static SingleInputBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		SingleInputBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< SingleInputBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< SingleInputBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< SingleInputBase, Pred>(impl); };
		SingleInputBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< SingleInputBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< SingleInputBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< SingleInputBase, Pred>(impl); };
		::Udm::ArchetypeAttr< SingleInputBase> Archetype() const;
		::Udm::AClassPointerAttr< Input, InputAction> dstInput() const;
		::Udm::ParentAttr< ::PICML::TopLevelBehavior> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_dstInput;
		static ::Uml::AssociationRole meta_dstInput_rev;

	};

	class PICML_Export InEventPort :  public EventPort,  public QueryInputBase,  public SingleInputBase {
	public:
		InEventPort();
		InEventPort(::Udm::ObjectImpl *impl);
		InEventPort(const InEventPort &master);

#ifdef UDM_RVALUE
		InEventPort(InEventPort &&master);

		static InEventPort Cast(::Udm::Object &&a);
		InEventPort& operator=(InEventPort &&a);

#endif
		static InEventPort Cast(const ::Udm::Object &a);
		static InEventPort Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		InEventPort CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< InEventPort> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< InEventPort, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< InEventPort, Pred>(impl); };
		InEventPort CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< InEventPort> Derived();
		template <class Pred> ::Udm::DerivedAttr< InEventPort, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< InEventPort, Pred>(impl); };
		::Udm::ArchetypeAttr< InEventPort> Archetype() const;
		::Udm::AssocAttr< InEventPortInstance> referedbyInEventPortInstance() const;
		template <class Pred> ::Udm::AssocAttr< InEventPortInstance, Pred> referedbyInEventPortInstance_sorted(const Pred &) const { return ::Udm::AssocAttr< InEventPortInstance, Pred>(impl, meta_referedbyInEventPortInstance); };
		::Udm::PointerAttr< EventType> ref() const;
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyInEventPortInstance;
		static ::Uml::AssociationRole meta_ref;

	};

	class PICML_Export Input :  public MgaObject {
	public:
		Input();
		Input(::Udm::ObjectImpl *impl);
		Input(const Input &master);

#ifdef UDM_RVALUE
		Input(Input &&master);

		static Input Cast(::Udm::Object &&a);
		Input& operator=(Input &&a);

#endif
		static Input Cast(const ::Udm::Object &a);
		static Input Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Input CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Input> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Input, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Input, Pred>(impl); };
		Input CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Input> Derived();
		template <class Pred> ::Udm::DerivedAttr< Input, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Input, Pred>(impl); };
		::Udm::ArchetypeAttr< Input> Archetype() const;
		::Udm::ParentAttr< ::PICML::TopLevelBehavior> TopLevelBehavior_parent() const;
		::Udm::ParentAttr< ::PICML::TopLevelBehavior> parent() const;
		::Udm::AssocEndAttr< ::PICML::SingleInputBase> srcInput_end() const;
		::Udm::AssocEndAttr< ::PICML::InputAction> dstInput_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_TopLevelBehavior_parent;
		static ::Uml::AssociationRole meta_srcInput_end_;
		static ::Uml::AssociationRole meta_dstInput_end_;

	};

	class PICML_Export WorkerType :  public MgaObject {
	public:
		WorkerType();
		WorkerType(::Udm::ObjectImpl *impl);
		WorkerType(const WorkerType &master);

#ifdef UDM_RVALUE
		WorkerType(WorkerType &&master);

		static WorkerType Cast(::Udm::Object &&a);
		WorkerType& operator=(WorkerType &&a);

#endif
		static WorkerType Cast(const ::Udm::Object &a);
		static WorkerType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		WorkerType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< WorkerType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< WorkerType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< WorkerType, Pred>(impl); };
		WorkerType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< WorkerType> Derived();
		template <class Pred> ::Udm::DerivedAttr< WorkerType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< WorkerType, Pred>(impl); };
		::Udm::ArchetypeAttr< WorkerType> Archetype() const;
		::Udm::PointerAttr< Worker> ref() const;
		::Udm::ParentAttr< ::PICML::TopLevelBehavior> TopLevelBehavior_parent() const;
		::Udm::ParentAttr< ::PICML::TopLevelBehavior> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_TopLevelBehavior_parent;

	};

	class PICML_Export ApplicationTask :  public SingleInputBase {
	public:
		ApplicationTask();
		ApplicationTask(::Udm::ObjectImpl *impl);
		ApplicationTask(const ApplicationTask &master);

#ifdef UDM_RVALUE
		ApplicationTask(ApplicationTask &&master);

		static ApplicationTask Cast(::Udm::Object &&a);
		ApplicationTask& operator=(ApplicationTask &&a);

#endif
		static ApplicationTask Cast(const ::Udm::Object &a);
		static ApplicationTask Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ApplicationTask CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ApplicationTask> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ApplicationTask, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ApplicationTask, Pred>(impl); };
		ApplicationTask CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ApplicationTask> Derived();
		template <class Pred> ::Udm::DerivedAttr< ApplicationTask, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ApplicationTask, Pred>(impl); };
		::Udm::ArchetypeAttr< ApplicationTask> Archetype() const;
		::Udm::ParentAttr< ::PICML::TopLevelBehavior> TopLevelBehavior_parent() const;
		::Udm::ParentAttr< ::PICML::TopLevelBehavior> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_TopLevelBehavior_parent;

	};

	class PICML_Export PeriodicEvent :  public SingleInputBase {
	public:
		PeriodicEvent();
		PeriodicEvent(::Udm::ObjectImpl *impl);
		PeriodicEvent(const PeriodicEvent &master);

#ifdef UDM_RVALUE
		PeriodicEvent(PeriodicEvent &&master);

		static PeriodicEvent Cast(::Udm::Object &&a);
		PeriodicEvent& operator=(PeriodicEvent &&a);

#endif
		static PeriodicEvent Cast(const ::Udm::Object &a);
		static PeriodicEvent Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		PeriodicEvent CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< PeriodicEvent> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< PeriodicEvent, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< PeriodicEvent, Pred>(impl); };
		PeriodicEvent CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< PeriodicEvent> Derived();
		template <class Pred> ::Udm::DerivedAttr< PeriodicEvent, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< PeriodicEvent, Pred>(impl); };
		::Udm::ArchetypeAttr< PeriodicEvent> Archetype() const;
		::Udm::StringAttr Hertz() const;
		::Udm::StringAttr Distribution() const;
		::Udm::ParentAttr< ::PICML::TopLevelBehavior> TopLevelBehavior_parent() const;
		::Udm::ParentAttr< ::PICML::TopLevelBehavior> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Hertz;
		static ::Uml::Attribute meta_Distribution;
		static ::Uml::CompositionParentRole meta_TopLevelBehavior_parent;

	};

	class PICML_Export Environment :  public MultiInputBase {
	public:
		Environment();
		Environment(::Udm::ObjectImpl *impl);
		Environment(const Environment &master);

#ifdef UDM_RVALUE
		Environment(Environment &&master);

		static Environment Cast(::Udm::Object &&a);
		Environment& operator=(Environment &&a);

#endif
		static Environment Cast(const ::Udm::Object &a);
		static Environment Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Environment CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Environment> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Environment, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Environment, Pred>(impl); };
		Environment CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Environment> Derived();
		template <class Pred> ::Udm::DerivedAttr< Environment, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Environment, Pred>(impl); };
		::Udm::ArchetypeAttr< Environment> Archetype() const;
		::Udm::ParentAttr< ::PICML::TopLevelBehavior> TopLevelBehavior_parent() const;
		::Udm::ParentAttr< ::PICML::TopLevelBehavior> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_TopLevelBehavior_parent;

	};

	class PICML_Export TargetRequiredRequestPort :  public MgaObject {
	public:
		TargetRequiredRequestPort();
		TargetRequiredRequestPort(::Udm::ObjectImpl *impl);
		TargetRequiredRequestPort(const TargetRequiredRequestPort &master);

#ifdef UDM_RVALUE
		TargetRequiredRequestPort(TargetRequiredRequestPort &&master);

		static TargetRequiredRequestPort Cast(::Udm::Object &&a);
		TargetRequiredRequestPort& operator=(TargetRequiredRequestPort &&a);

#endif
		static TargetRequiredRequestPort Cast(const ::Udm::Object &a);
		static TargetRequiredRequestPort Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TargetRequiredRequestPort CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TargetRequiredRequestPort> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TargetRequiredRequestPort, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TargetRequiredRequestPort, Pred>(impl); };
		TargetRequiredRequestPort CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TargetRequiredRequestPort> Derived();
		template <class Pred> ::Udm::DerivedAttr< TargetRequiredRequestPort, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TargetRequiredRequestPort, Pred>(impl); };
		::Udm::ArchetypeAttr< TargetRequiredRequestPort> Archetype() const;
		::Udm::PointerAttr< RequiredRequestPort> ref() const;
		::Udm::ParentAttr< ::PICML::CallAction> CallAction_parent() const;
		::Udm::ParentAttr< ::PICML::CallAction> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_CallAction_parent;

	};

	class PICML_Export ActionType :  public MgaObject {
	public:
		ActionType();
		ActionType(::Udm::ObjectImpl *impl);
		ActionType(const ActionType &master);

#ifdef UDM_RVALUE
		ActionType(ActionType &&master);

		static ActionType Cast(::Udm::Object &&a);
		ActionType& operator=(ActionType &&a);

#endif
		static ActionType Cast(const ::Udm::Object &a);
		static ActionType Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ActionType CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ActionType> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ActionType, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ActionType, Pred>(impl); };
		ActionType CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ActionType> Derived();
		template <class Pred> ::Udm::DerivedAttr< ActionType, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ActionType, Pred>(impl); };
		::Udm::ArchetypeAttr< ActionType> Archetype() const;
		::Udm::PointerAttr< Operation> ref() const;
		::Udm::ParentAttr< ::PICML::Action> Action_parent() const;
		::Udm::ParentAttr< ::PICML::Action> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_Action_parent;

	};

	class PICML_Export QueryInputAction :  public MgaObject {
	public:
		QueryInputAction();
		QueryInputAction(::Udm::ObjectImpl *impl);
		QueryInputAction(const QueryInputAction &master);

#ifdef UDM_RVALUE
		QueryInputAction(QueryInputAction &&master);

		static QueryInputAction Cast(::Udm::Object &&a);
		QueryInputAction& operator=(QueryInputAction &&a);

#endif
		static QueryInputAction Cast(const ::Udm::Object &a);
		static QueryInputAction Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		QueryInputAction CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< QueryInputAction> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< QueryInputAction, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< QueryInputAction, Pred>(impl); };
		QueryInputAction CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< QueryInputAction> Derived();
		template <class Pred> ::Udm::DerivedAttr< QueryInputAction, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< QueryInputAction, Pred>(impl); };
		::Udm::ArchetypeAttr< QueryInputAction> Archetype() const;
		::Udm::AClassPointerAttr< QueryInput, QueryInputBase> srcQueryInput() const;
		::Udm::ChildrenAttr< ::PICML::Property> Property_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); };
		::Udm::ChildrenAttr< ::PICML::ComplexProperty> ComplexProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred> ComplexProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SimpleProperty> SimpleProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred> SimpleProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcQueryInput;
		static ::Uml::AssociationRole meta_srcQueryInput_rev;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;

	};

	class PICML_Export ActionBase :  public MgaObject {
	public:
		ActionBase();
		ActionBase(::Udm::ObjectImpl *impl);
		ActionBase(const ActionBase &master);

#ifdef UDM_RVALUE
		ActionBase(ActionBase &&master);

		static ActionBase Cast(::Udm::Object &&a);
		ActionBase& operator=(ActionBase &&a);

#endif
		static ActionBase Cast(const ::Udm::Object &a);
		static ActionBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		ActionBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< ActionBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< ActionBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< ActionBase, Pred>(impl); };
		ActionBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< ActionBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< ActionBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< ActionBase, Pred>(impl); };
		::Udm::ArchetypeAttr< ActionBase> Archetype() const;
		::Udm::IntegerAttr Duration() const;
		::Udm::AClassPointerAttr< LoopTransition, LoopState> srcLoopTransition() const;
		::Udm::AClassPointerAttr< BranchTransition, BranchState> srcBranchTransition() const;
		::Udm::AClassPointerAttr< Transition, State> srcTransition() const;
		::Udm::AClassPointerAttr< Effect, StateBase> dstEffect() const;
		::Udm::ChildrenAttr< ::PICML::Property> Property_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); };
		::Udm::ChildrenAttr< ::PICML::ComplexProperty> ComplexProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred> ComplexProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SimpleProperty> SimpleProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred> SimpleProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Duration;
		static ::Uml::AssociationRole meta_srcLoopTransition;
		static ::Uml::AssociationRole meta_srcLoopTransition_rev;
		static ::Uml::AssociationRole meta_srcBranchTransition;
		static ::Uml::AssociationRole meta_srcBranchTransition_rev;
		static ::Uml::AssociationRole meta_srcTransition;
		static ::Uml::AssociationRole meta_srcTransition_rev;
		static ::Uml::AssociationRole meta_dstEffect;
		static ::Uml::AssociationRole meta_dstEffect_rev;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;

	};

	class PICML_Export CallAction :  public ActionBase {
	public:
		CallAction();
		CallAction(::Udm::ObjectImpl *impl);
		CallAction(const CallAction &master);

#ifdef UDM_RVALUE
		CallAction(CallAction &&master);

		static CallAction Cast(::Udm::Object &&a);
		CallAction& operator=(CallAction &&a);

#endif
		static CallAction Cast(const ::Udm::Object &a);
		static CallAction Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		CallAction CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< CallAction> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< CallAction, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< CallAction, Pred>(impl); };
		CallAction CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< CallAction> Derived();
		template <class Pred> ::Udm::DerivedAttr< CallAction, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< CallAction, Pred>(impl); };
		::Udm::ArchetypeAttr< CallAction> Archetype() const;
		::Udm::ChildAttr< ::PICML::TargetRequiredRequestPort> TargetRequiredRequestPort_child() const;
		::Udm::ChildrenAttr< ::PICML::TargetRequiredRequestPort> TargetRequiredRequestPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TargetRequiredRequestPort, Pred> TargetRequiredRequestPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TargetRequiredRequestPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_TargetRequiredRequestPort_child;

	};

	class PICML_Export RequestAction :  public ActionBase {
	public:
		RequestAction();
		RequestAction(::Udm::ObjectImpl *impl);
		RequestAction(const RequestAction &master);

#ifdef UDM_RVALUE
		RequestAction(RequestAction &&master);

		static RequestAction Cast(::Udm::Object &&a);
		RequestAction& operator=(RequestAction &&a);

#endif
		static RequestAction Cast(const ::Udm::Object &a);
		static RequestAction Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		RequestAction CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< RequestAction> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< RequestAction, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< RequestAction, Pred>(impl); };
		RequestAction CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< RequestAction> Derived();
		template <class Pred> ::Udm::DerivedAttr< RequestAction, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< RequestAction, Pred>(impl); };
		::Udm::ArchetypeAttr< RequestAction> Archetype() const;
		::Udm::StringAttr MethodName() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_MethodName;

	};

	class PICML_Export QueryAction :  public ActionBase {
	public:
		QueryAction();
		QueryAction(::Udm::ObjectImpl *impl);
		QueryAction(const QueryAction &master);

#ifdef UDM_RVALUE
		QueryAction(QueryAction &&master);

		static QueryAction Cast(::Udm::Object &&a);
		QueryAction& operator=(QueryAction &&a);

#endif
		static QueryAction Cast(const ::Udm::Object &a);
		static QueryAction Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		QueryAction CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< QueryAction> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< QueryAction, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< QueryAction, Pred>(impl); };
		QueryAction CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< QueryAction> Derived();
		template <class Pred> ::Udm::DerivedAttr< QueryAction, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< QueryAction, Pred>(impl); };
		::Udm::ArchetypeAttr< QueryAction> Archetype() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export Finish :  public MgaObject {
	public:
		Finish();
		Finish(::Udm::ObjectImpl *impl);
		Finish(const Finish &master);

#ifdef UDM_RVALUE
		Finish(Finish &&master);

		static Finish Cast(::Udm::Object &&a);
		Finish& operator=(Finish &&a);

#endif
		static Finish Cast(const ::Udm::Object &a);
		static Finish Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Finish CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Finish> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Finish, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Finish, Pred>(impl); };
		Finish CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Finish> Derived();
		template <class Pred> ::Udm::DerivedAttr< Finish, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Finish, Pred>(impl); };
		::Udm::ArchetypeAttr< Finish> Archetype() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		::Udm::AssocEndAttr< ::PICML::StateBase> srcFinish_end() const;
		::Udm::AssocEndAttr< ::PICML::BehaviorInputAction> dstFinish_end() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;
		static ::Uml::AssociationRole meta_srcFinish_end_;
		static ::Uml::AssociationRole meta_dstFinish_end_;

	};

	class PICML_Export OutputAction :  public ActionBase {
	public:
		OutputAction();
		OutputAction(::Udm::ObjectImpl *impl);
		OutputAction(const OutputAction &master);

#ifdef UDM_RVALUE
		OutputAction(OutputAction &&master);

		static OutputAction Cast(::Udm::Object &&a);
		OutputAction& operator=(OutputAction &&a);

#endif
		static OutputAction Cast(const ::Udm::Object &a);
		static OutputAction Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		OutputAction CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< OutputAction> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< OutputAction, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< OutputAction, Pred>(impl); };
		OutputAction CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< OutputAction> Derived();
		template <class Pred> ::Udm::DerivedAttr< OutputAction, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< OutputAction, Pred>(impl); };
		::Udm::ArchetypeAttr< OutputAction> Archetype() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;

	};

	class PICML_Export Action :  public ActionBase {
	public:
		Action();
		Action(::Udm::ObjectImpl *impl);
		Action(const Action &master);

#ifdef UDM_RVALUE
		Action(Action &&master);

		static Action Cast(::Udm::Object &&a);
		Action& operator=(Action &&a);

#endif
		static Action Cast(const ::Udm::Object &a);
		static Action Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Action CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Action> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Action, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Action, Pred>(impl); };
		Action CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Action> Derived();
		template <class Pred> ::Udm::DerivedAttr< Action, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Action, Pred>(impl); };
		::Udm::ArchetypeAttr< Action> Archetype() const;
		::Udm::ChildAttr< ::PICML::ActionType> ActionType_child() const;
		::Udm::ChildrenAttr< ::PICML::ActionType> ActionType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ActionType, Pred> ActionType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ActionType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_ActionType_child;

	};

	class PICML_Export BehaviorInputAction :  public MgaObject {
	public:
		BehaviorInputAction();
		BehaviorInputAction(::Udm::ObjectImpl *impl);
		BehaviorInputAction(const BehaviorInputAction &master);

#ifdef UDM_RVALUE
		BehaviorInputAction(BehaviorInputAction &&master);

		static BehaviorInputAction Cast(::Udm::Object &&a);
		BehaviorInputAction& operator=(BehaviorInputAction &&a);

#endif
		static BehaviorInputAction Cast(const ::Udm::Object &a);
		static BehaviorInputAction Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		BehaviorInputAction CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< BehaviorInputAction> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< BehaviorInputAction, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< BehaviorInputAction, Pred>(impl); };
		BehaviorInputAction CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< BehaviorInputAction> Derived();
		template <class Pred> ::Udm::DerivedAttr< BehaviorInputAction, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< BehaviorInputAction, Pred>(impl); };
		::Udm::ArchetypeAttr< BehaviorInputAction> Archetype() const;
		::Udm::AClassPointerAttr< Finish, StateBase> srcFinish() const;
		::Udm::AClassPointerAttr< InputEffect, StateBase> dstInputEffect() const;
		::Udm::ChildrenAttr< ::PICML::Property> Property_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, meta_Property_children); };
		::Udm::ChildrenAttr< ::PICML::ComplexProperty> ComplexProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred> ComplexProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComplexProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SimpleProperty> SimpleProperty_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred> SimpleProperty_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SimpleProperty, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Property> Property_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Property, Pred> Property_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Property, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcFinish;
		static ::Uml::AssociationRole meta_srcFinish_rev;
		static ::Uml::AssociationRole meta_dstInputEffect;
		static ::Uml::AssociationRole meta_dstInputEffect_rev;
		static ::Uml::CompositionChildRole meta_Property_children;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;

	};

	class PICML_Export InputAction :  public BehaviorInputAction {
	public:
		InputAction();
		InputAction(::Udm::ObjectImpl *impl);
		InputAction(const InputAction &master);

#ifdef UDM_RVALUE
		InputAction(InputAction &&master);

		static InputAction Cast(::Udm::Object &&a);
		InputAction& operator=(InputAction &&a);

#endif
		static InputAction Cast(const ::Udm::Object &a);
		static InputAction Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		InputAction CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< InputAction> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< InputAction, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< InputAction, Pred>(impl); };
		InputAction CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< InputAction> Derived();
		template <class Pred> ::Udm::DerivedAttr< InputAction, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< InputAction, Pred>(impl); };
		::Udm::ArchetypeAttr< InputAction> Archetype() const;
		::Udm::AClassPointerAttr< Input, SingleInputBase> srcInput() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcInput;
		static ::Uml::AssociationRole meta_srcInput_rev;

	};

	class PICML_Export MultiInputAction :  public BehaviorInputAction {
	public:
		MultiInputAction();
		MultiInputAction(::Udm::ObjectImpl *impl);
		MultiInputAction(const MultiInputAction &master);

#ifdef UDM_RVALUE
		MultiInputAction(MultiInputAction &&master);

		static MultiInputAction Cast(::Udm::Object &&a);
		MultiInputAction& operator=(MultiInputAction &&a);

#endif
		static MultiInputAction Cast(const ::Udm::Object &a);
		static MultiInputAction Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		MultiInputAction CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< MultiInputAction> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< MultiInputAction, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< MultiInputAction, Pred>(impl); };
		MultiInputAction CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< MultiInputAction> Derived();
		template <class Pred> ::Udm::DerivedAttr< MultiInputAction, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< MultiInputAction, Pred>(impl); };
		::Udm::ArchetypeAttr< MultiInputAction> Archetype() const;
		::Udm::AClassPointerAttr< MultiInput, MultiInputBase> srcMultiInput() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_srcMultiInput;
		static ::Uml::AssociationRole meta_srcMultiInput_rev;

	};

	class PICML_Export BehaviorModel :  virtual  public MgaObject {
	public:
		BehaviorModel();
		BehaviorModel(::Udm::ObjectImpl *impl);
		BehaviorModel(const BehaviorModel &master);

#ifdef UDM_RVALUE
		BehaviorModel(BehaviorModel &&master);

		static BehaviorModel Cast(::Udm::Object &&a);
		BehaviorModel& operator=(BehaviorModel &&a);

#endif
		static BehaviorModel Cast(const ::Udm::Object &a);
		static BehaviorModel Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		BehaviorModel CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< BehaviorModel> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< BehaviorModel, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< BehaviorModel, Pred>(impl); };
		BehaviorModel CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< BehaviorModel> Derived();
		template <class Pred> ::Udm::DerivedAttr< BehaviorModel, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< BehaviorModel, Pred>(impl); };
		::Udm::ArchetypeAttr< BehaviorModel> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::Variable> Variable_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Variable, Pred> Variable_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Variable, Pred>(impl, meta_Variable_children); };
		::Udm::ChildrenAttr< ::PICML::LoopTransition> LoopTransition_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::LoopTransition, Pred> LoopTransition_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::LoopTransition, Pred>(impl, meta_LoopTransition_children); };
		::Udm::ChildrenAttr< ::PICML::Transition> Transition_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Transition, Pred> Transition_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Transition, Pred>(impl, meta_Transition_children); };
		::Udm::ChildrenAttr< ::PICML::BranchTransition> BranchTransition_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::BranchTransition, Pred> BranchTransition_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::BranchTransition, Pred>(impl, meta_BranchTransition_children); };
		::Udm::ChildrenAttr< ::PICML::StateBase> StateBase_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::StateBase, Pred> StateBase_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::StateBase, Pred>(impl, meta_StateBase_children); };
		::Udm::ChildrenAttr< ::PICML::QueryInputAction> QueryInputAction_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::QueryInputAction, Pred> QueryInputAction_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::QueryInputAction, Pred>(impl, meta_QueryInputAction_children); };
		::Udm::ChildrenAttr< ::PICML::Effect> Effect_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Effect, Pred> Effect_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Effect, Pred>(impl, meta_Effect_children); };
		::Udm::ChildrenAttr< ::PICML::ActionBase> ActionBase_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ActionBase, Pred> ActionBase_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ActionBase, Pred>(impl, meta_ActionBase_children); };
		::Udm::ChildrenAttr< ::PICML::InputEffect> InputEffect_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InputEffect, Pred> InputEffect_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InputEffect, Pred>(impl, meta_InputEffect_children); };
		::Udm::ChildrenAttr< ::PICML::BehaviorInputAction> BehaviorInputAction_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::BehaviorInputAction, Pred> BehaviorInputAction_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::BehaviorInputAction, Pred>(impl, meta_BehaviorInputAction_children); };
		::Udm::ChildrenAttr< ::PICML::Finish> Finish_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Finish, Pred> Finish_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Finish, Pred>(impl, meta_Finish_children); };
		::Udm::ChildrenAttr< ::PICML::TerminalEffect> TerminalEffect_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TerminalEffect, Pred> TerminalEffect_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TerminalEffect, Pred>(impl, meta_TerminalEffect_children); };
		::Udm::ChildrenAttr< ::PICML::Terminal> Terminal_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Terminal, Pred> Terminal_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Terminal, Pred>(impl, meta_Terminal_children); };
		::Udm::ChildrenAttr< ::PICML::TerminalTransition> TerminalTransition_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TerminalTransition, Pred> TerminalTransition_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TerminalTransition, Pred>(impl, meta_TerminalTransition_children); };
		::Udm::ChildrenAttr< ::PICML::EffectBase> EffectBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::EffectBase, Pred> EffectBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::EffectBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TerminalEffect> TerminalEffect_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TerminalEffect, Pred> TerminalEffect_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TerminalEffect, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::InputEffect> InputEffect_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InputEffect, Pred> InputEffect_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InputEffect, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Effect> Effect_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Effect, Pred> Effect_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Effect, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::TerminalTransition> TerminalTransition_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::TerminalTransition, Pred> TerminalTransition_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::TerminalTransition, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Terminal> Terminal_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Terminal, Pred> Terminal_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Terminal, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::LoopTransition> LoopTransition_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::LoopTransition, Pred> LoopTransition_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::LoopTransition, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::WhileState> WhileState_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WhileState, Pred> WhileState_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WhileState, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::DoWhileState> DoWhileState_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::DoWhileState, Pred> DoWhileState_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::DoWhileState, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ForState> ForState_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ForState, Pred> ForState_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ForState, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::LoopState> LoopState_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::LoopState, Pred> LoopState_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::LoopState, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::StateBase> StateBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::StateBase, Pred> StateBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::StateBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::BranchTransition> BranchTransition_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::BranchTransition, Pred> BranchTransition_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::BranchTransition, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::BranchState> BranchState_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::BranchState, Pred> BranchState_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::BranchState, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::State> State_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::State, Pred> State_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::State, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Transition> Transition_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Transition, Pred> Transition_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Transition, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::CallAction> CallAction_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CallAction, Pred> CallAction_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CallAction, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequestAction> RequestAction_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequestAction, Pred> RequestAction_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequestAction, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::InputAction> InputAction_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InputAction, Pred> InputAction_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InputAction, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MultiInputAction> MultiInputAction_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MultiInputAction, Pred> MultiInputAction_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MultiInputAction, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::QueryInputAction> QueryInputAction_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::QueryInputAction, Pred> QueryInputAction_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::QueryInputAction, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::QueryAction> QueryAction_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::QueryAction, Pred> QueryAction_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::QueryAction, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ActionBase> ActionBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ActionBase, Pred> ActionBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ActionBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Finish> Finish_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Finish, Pred> Finish_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Finish, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::OutputAction> OutputAction_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OutputAction, Pred> OutputAction_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OutputAction, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Action> Action_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Action, Pred> Action_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Action, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::BehaviorInputAction> BehaviorInputAction_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::BehaviorInputAction, Pred> BehaviorInputAction_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::BehaviorInputAction, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Variable> Variable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Variable, Pred> Variable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Variable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::Udm::Object> parent() const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Variable_children;
		static ::Uml::CompositionChildRole meta_LoopTransition_children;
		static ::Uml::CompositionChildRole meta_Transition_children;
		static ::Uml::CompositionChildRole meta_BranchTransition_children;
		static ::Uml::CompositionChildRole meta_StateBase_children;
		static ::Uml::CompositionChildRole meta_QueryInputAction_children;
		static ::Uml::CompositionChildRole meta_Effect_children;
		static ::Uml::CompositionChildRole meta_ActionBase_children;
		static ::Uml::CompositionChildRole meta_InputEffect_children;
		static ::Uml::CompositionChildRole meta_BehaviorInputAction_children;
		static ::Uml::CompositionChildRole meta_Finish_children;
		static ::Uml::CompositionChildRole meta_TerminalEffect_children;
		static ::Uml::CompositionChildRole meta_Terminal_children;
		static ::Uml::CompositionChildRole meta_TerminalTransition_children;

	};

	class PICML_Export TopLevelBehavior :  public BehaviorModel {
	public:
		TopLevelBehavior();
		TopLevelBehavior(::Udm::ObjectImpl *impl);
		TopLevelBehavior(const TopLevelBehavior &master);

#ifdef UDM_RVALUE
		TopLevelBehavior(TopLevelBehavior &&master);

		static TopLevelBehavior Cast(::Udm::Object &&a);
		TopLevelBehavior& operator=(TopLevelBehavior &&a);

#endif
		static TopLevelBehavior Cast(const ::Udm::Object &a);
		static TopLevelBehavior Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		TopLevelBehavior CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< TopLevelBehavior> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< TopLevelBehavior, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< TopLevelBehavior, Pred>(impl); };
		TopLevelBehavior CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< TopLevelBehavior> Derived();
		template <class Pred> ::Udm::DerivedAttr< TopLevelBehavior, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< TopLevelBehavior, Pred>(impl); };
		::Udm::ArchetypeAttr< TopLevelBehavior> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::WorkerType> WorkerType_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkerType, Pred> WorkerType_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkerType, Pred>(impl, meta_WorkerType_children); };
		::Udm::ChildrenAttr< ::PICML::QueryInput> QueryInput_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::QueryInput, Pred> QueryInput_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::QueryInput, Pred>(impl, meta_QueryInput_children); };
		::Udm::ChildrenAttr< ::PICML::Input> Input_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Input, Pred> Input_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Input, Pred>(impl, meta_Input_children); };
		::Udm::ChildrenAttr< ::PICML::MultiInput> MultiInput_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MultiInput, Pred> MultiInput_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MultiInput, Pred>(impl, meta_MultiInput_children); };
		::Udm::ChildAttr< ::PICML::Environment> Environment_child() const;
		::Udm::ChildrenAttr< ::PICML::ApplicationTask> ApplicationTask_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ApplicationTask, Pred> ApplicationTask_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ApplicationTask, Pred>(impl, meta_ApplicationTask_children); };
		::Udm::ChildrenAttr< ::PICML::PeriodicEvent> PeriodicEvent_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PeriodicEvent, Pred> PeriodicEvent_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PeriodicEvent, Pred>(impl, meta_PeriodicEvent_children); };
		::Udm::ChildrenAttr< ::PICML::QueryInput> QueryInput_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::QueryInput, Pred> QueryInput_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::QueryInput, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MultiInput> MultiInput_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MultiInput, Pred> MultiInput_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MultiInput, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MultiInputBase> MultiInputBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MultiInputBase, Pred> MultiInputBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MultiInputBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::SingleInputBase> SingleInputBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::SingleInputBase, Pred> SingleInputBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::SingleInputBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Input> Input_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Input, Pred> Input_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Input, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::WorkerType> WorkerType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkerType, Pred> WorkerType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkerType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ApplicationTask> ApplicationTask_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ApplicationTask, Pred> ApplicationTask_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ApplicationTask, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::PeriodicEvent> PeriodicEvent_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::PeriodicEvent, Pred> PeriodicEvent_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::PeriodicEvent, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Environment> Environment_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Environment, Pred> Environment_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Environment, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::Udm::Object> parent() const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_WorkerType_children;
		static ::Uml::CompositionChildRole meta_QueryInput_children;
		static ::Uml::CompositionChildRole meta_Input_children;
		static ::Uml::CompositionChildRole meta_MultiInput_children;
		static ::Uml::CompositionChildRole meta_Environment_child;
		static ::Uml::CompositionChildRole meta_ApplicationTask_children;
		static ::Uml::CompositionChildRole meta_PeriodicEvent_children;

	};

	class PICML_Export Component :  public Manageable,  public NamedType,  public SupportsInterfaces,  public TopLevelBehavior {
	public:
		Component();
		Component(::Udm::ObjectImpl *impl);
		Component(const Component &master);

#ifdef UDM_RVALUE
		Component(Component &&master);

		static Component Cast(::Udm::Object &&a);
		Component& operator=(Component &&a);

#endif
		static Component Cast(const ::Udm::Object &a);
		static Component Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Component CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Component> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Component, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Component, Pred>(impl); };
		Component CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Component> Derived();
		template <class Pred> ::Udm::DerivedAttr< Component, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Component, Pred>(impl); };
		::Udm::ArchetypeAttr< Component> Archetype() const;
		::Udm::StringAttr label() const;
		::Udm::StringAttr UUID() const;
		::Udm::AssocAttr< CompRef> referedbyCompRef() const;
		template <class Pred> ::Udm::AssocAttr< CompRef, Pred> referedbyCompRef_sorted(const Pred &) const { return ::Udm::AssocAttr< CompRef, Pred>(impl, meta_referedbyCompRef); };
		::Udm::AssocAttr< ComponentInherits> referedbyComponentInherits() const;
		template <class Pred> ::Udm::AssocAttr< ComponentInherits, Pred> referedbyComponentInherits_sorted(const Pred &) const { return ::Udm::AssocAttr< ComponentInherits, Pred>(impl, meta_referedbyComponentInherits); };
		::Udm::AssocAttr< ComponentRef> referedbyComponentRef() const;
		template <class Pred> ::Udm::AssocAttr< ComponentRef, Pred> referedbyComponentRef_sorted(const Pred &) const { return ::Udm::AssocAttr< ComponentRef, Pred>(impl, meta_referedbyComponentRef); };
		::Udm::ChildrenAttr< ::PICML::ExtendedPortBase> ExtendedPortBase_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExtendedPortBase, Pred> ExtendedPortBase_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExtendedPortBase, Pred>(impl, meta_ExtendedPortBase_children); };
		::Udm::ChildAttr< ::PICML::ComponentInherits> ComponentInherits_child() const;
		::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute> ReadonlyAttribute_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred> ReadonlyAttribute_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred>(impl, meta_ReadonlyAttribute_children); };
		::Udm::ChildrenAttr< ::PICML::Port> Port_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Port, Pred> Port_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Port, Pred>(impl, meta_Port_children); };
		::Udm::ChildrenAttr< ::PICML::GraphVertex> GraphVertex_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::GraphVertex, Pred> GraphVertex_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::GraphVertex, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Taggable> Taggable_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Taggable, Pred> Taggable_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Taggable, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Attribute> Attribute_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Attribute, Pred> Attribute_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Attribute, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute> ReadonlyAttribute_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred> ReadonlyAttribute_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ReadonlyAttribute, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::CommonPortAttrs> CommonPortAttrs_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::CommonPortAttrs, Pred> CommonPortAttrs_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::CommonPortAttrs, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExtendedPortBase> ExtendedPortBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExtendedPortBase, Pred> ExtendedPortBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExtendedPortBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MirrorPort> MirrorPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MirrorPort, Pred> MirrorPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MirrorPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ComponentInherits> ComponentInherits_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ComponentInherits, Pred> ComponentInherits_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ComponentInherits, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ExtendedPort> ExtendedPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ExtendedPort, Pred> ExtendedPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ExtendedPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::EventPort> EventPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::EventPort, Pred> EventPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::EventPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ObjectPort> ObjectPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ObjectPort, Pred> ObjectPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ObjectPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::Port> Port_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Port, Pred> Port_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Port, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::InEventPort> InEventPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InEventPort, Pred> InEventPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InEventPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::RequiredRequestPort> RequiredRequestPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred> RequiredRequestPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::RequiredRequestPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ProvidedRequestPort> ProvidedRequestPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred> ProvidedRequestPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ProvidedRequestPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::OutEventPort> OutEventPort_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OutEventPort, Pred> OutEventPort_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OutEventPort, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::Prefixable> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_label;
		static ::Uml::Attribute meta_UUID;
		static ::Uml::AssociationRole meta_referedbyCompRef;
		static ::Uml::AssociationRole meta_referedbyComponentInherits;
		static ::Uml::AssociationRole meta_referedbyComponentRef;
		static ::Uml::CompositionChildRole meta_ExtendedPortBase_children;
		static ::Uml::CompositionChildRole meta_ComponentInherits_child;
		static ::Uml::CompositionChildRole meta_ReadonlyAttribute_children;
		static ::Uml::CompositionChildRole meta_Port_children;

	};

	class PICML_Export Variable :  public MgaObject {
	public:
		Variable();
		Variable(::Udm::ObjectImpl *impl);
		Variable(const Variable &master);

#ifdef UDM_RVALUE
		Variable(Variable &&master);

		static Variable Cast(::Udm::Object &&a);
		Variable& operator=(Variable &&a);

#endif
		static Variable Cast(const ::Udm::Object &a);
		static Variable Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Variable CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Variable> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Variable, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Variable, Pred>(impl); };
		Variable CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Variable> Derived();
		template <class Pred> ::Udm::DerivedAttr< Variable, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Variable, Pred>(impl); };
		::Udm::ArchetypeAttr< Variable> Archetype() const;
		::Udm::StringAttr InitialValue() const;
		::Udm::PointerAttr< PredefinedType> ref() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> BehaviorModel_parent() const;
		::Udm::ParentAttr< ::PICML::BehaviorModel> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_InitialValue;
		static ::Uml::AssociationRole meta_ref;
		static ::Uml::CompositionParentRole meta_BehaviorModel_parent;

	};

	class PICML_Export Operation :  public MgaObject {
	public:
		Operation();
		Operation(::Udm::ObjectImpl *impl);
		Operation(const Operation &master);

#ifdef UDM_RVALUE
		Operation(Operation &&master);

		static Operation Cast(::Udm::Object &&a);
		Operation& operator=(Operation &&a);

#endif
		static Operation Cast(const ::Udm::Object &a);
		static Operation Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Operation CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Operation> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Operation, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Operation, Pred>(impl); };
		Operation CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Operation> Derived();
		template <class Pred> ::Udm::DerivedAttr< Operation, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Operation, Pred>(impl); };
		::Udm::ArchetypeAttr< Operation> Archetype() const;
		::Udm::AssocAttr< ActionType> referedbyActionType() const;
		template <class Pred> ::Udm::AssocAttr< ActionType, Pred> referedbyActionType_sorted(const Pred &) const { return ::Udm::AssocAttr< ActionType, Pred>(impl, meta_referedbyActionType); };
		::Udm::ChildAttr< ::PICML::ReturnType> ReturnType_child() const;
		::Udm::ChildrenAttr< ::PICML::ParameterType> ParameterType_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ParameterType, Pred> ParameterType_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ParameterType, Pred>(impl, meta_ParameterType_children); };
		::Udm::ChildrenAttr< ::PICML::ParameterType> ParameterType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ParameterType, Pred> ParameterType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ParameterType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::ReturnType> ReturnType_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::ReturnType, Pred> ReturnType_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::ReturnType, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::OutParameter> OutParameter_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::OutParameter, Pred> OutParameter_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::OutParameter, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::InoutParameter> InoutParameter_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InoutParameter, Pred> InoutParameter_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InoutParameter, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::InParameter> InParameter_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::InParameter, Pred> InParameter_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::InParameter, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::Worker> Worker_parent() const;
		::Udm::ParentAttr< ::PICML::Worker> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::AssociationRole meta_referedbyActionType;
		static ::Uml::CompositionChildRole meta_ReturnType_child;
		static ::Uml::CompositionChildRole meta_ParameterType_children;
		static ::Uml::CompositionParentRole meta_Worker_parent;

	};

	class PICML_Export WorkerPackageBase :  public MgaObject {
	public:
		WorkerPackageBase();
		WorkerPackageBase(::Udm::ObjectImpl *impl);
		WorkerPackageBase(const WorkerPackageBase &master);

#ifdef UDM_RVALUE
		WorkerPackageBase(WorkerPackageBase &&master);

		static WorkerPackageBase Cast(::Udm::Object &&a);
		WorkerPackageBase& operator=(WorkerPackageBase &&a);

#endif
		static WorkerPackageBase Cast(const ::Udm::Object &a);
		static WorkerPackageBase Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		WorkerPackageBase CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< WorkerPackageBase> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< WorkerPackageBase, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< WorkerPackageBase, Pred>(impl); };
		WorkerPackageBase CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< WorkerPackageBase> Derived();
		template <class Pred> ::Udm::DerivedAttr< WorkerPackageBase, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< WorkerPackageBase, Pred>(impl); };
		::Udm::ArchetypeAttr< WorkerPackageBase> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::Worker> Worker_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Worker, Pred> Worker_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Worker, Pred>(impl, meta_Worker_children); };
		::Udm::ChildrenAttr< ::PICML::Worker> Worker_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Worker, Pred> Worker_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Worker, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::MgaObject> parent() const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_Worker_children;

	};

	class PICML_Export WorkerPackage :  public WorkerPackageBase {
	public:
		WorkerPackage();
		WorkerPackage(::Udm::ObjectImpl *impl);
		WorkerPackage(const WorkerPackage &master);

#ifdef UDM_RVALUE
		WorkerPackage(WorkerPackage &&master);

		static WorkerPackage Cast(::Udm::Object &&a);
		WorkerPackage& operator=(WorkerPackage &&a);

#endif
		static WorkerPackage Cast(const ::Udm::Object &a);
		static WorkerPackage Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		WorkerPackage CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< WorkerPackage> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< WorkerPackage, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< WorkerPackage, Pred>(impl); };
		WorkerPackage CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< WorkerPackage> Derived();
		template <class Pred> ::Udm::DerivedAttr< WorkerPackage, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< WorkerPackage, Pred>(impl); };
		::Udm::ArchetypeAttr< WorkerPackage> Archetype() const;
		::Udm::ChildrenAttr< ::PICML::WorkerPackage> WorkerPackage_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkerPackage, Pred> WorkerPackage_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkerPackage, Pred>(impl, meta_WorkerPackage_children); };
		::Udm::ChildrenAttr< ::PICML::WorkerPackageBase> WorkerPackageBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkerPackageBase, Pred> WorkerPackageBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkerPackageBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::WorkerPackage> WorkerPackage_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkerPackage, Pred> WorkerPackage_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkerPackage, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::WorkerPackage> WorkerPackage_parent() const;
		::Udm::ParentAttr< ::PICML::WorkerFile> WorkerFile_parent() const;
		::Udm::ParentAttr< ::PICML::WorkerPackageBase> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::CompositionChildRole meta_WorkerPackage_children;
		static ::Uml::CompositionParentRole meta_WorkerPackage_parent;
		static ::Uml::CompositionParentRole meta_WorkerFile_parent;

	};

	class PICML_Export WorkerFile :  public WorkerPackageBase {
	public:
		WorkerFile();
		WorkerFile(::Udm::ObjectImpl *impl);
		WorkerFile(const WorkerFile &master);

#ifdef UDM_RVALUE
		WorkerFile(WorkerFile &&master);

		static WorkerFile Cast(::Udm::Object &&a);
		WorkerFile& operator=(WorkerFile &&a);

#endif
		static WorkerFile Cast(const ::Udm::Object &a);
		static WorkerFile Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		WorkerFile CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< WorkerFile> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< WorkerFile, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< WorkerFile, Pred>(impl); };
		WorkerFile CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< WorkerFile> Derived();
		template <class Pred> ::Udm::DerivedAttr< WorkerFile, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< WorkerFile, Pred>(impl); };
		::Udm::ArchetypeAttr< WorkerFile> Archetype() const;
		::Udm::StringAttr Location() const;
		::Udm::ChildrenAttr< ::PICML::WorkerPackage> WorkerPackage_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkerPackage, Pred> WorkerPackage_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkerPackage, Pred>(impl, meta_WorkerPackage_children); };
		::Udm::ChildrenAttr< ::PICML::WorkerPackageBase> WorkerPackageBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkerPackageBase, Pred> WorkerPackageBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkerPackageBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::WorkerPackage> WorkerPackage_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkerPackage, Pred> WorkerPackage_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkerPackage, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::WorkerLibrary> WorkerLibrary_parent() const;
		::Udm::ParentAttr< ::PICML::WorkerLibrary> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Location;
		static ::Uml::CompositionChildRole meta_WorkerPackage_children;
		static ::Uml::CompositionParentRole meta_WorkerLibrary_parent;

	};

	class PICML_Export Worker :  public MgaObject {
	public:
		Worker();
		Worker(::Udm::ObjectImpl *impl);
		Worker(const Worker &master);

#ifdef UDM_RVALUE
		Worker(Worker &&master);

		static Worker Cast(::Udm::Object &&a);
		Worker& operator=(Worker &&a);

#endif
		static Worker Cast(const ::Udm::Object &a);
		static Worker Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		Worker CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< Worker> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< Worker, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< Worker, Pred>(impl); };
		Worker CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< Worker> Derived();
		template <class Pred> ::Udm::DerivedAttr< Worker, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< Worker, Pred>(impl); };
		::Udm::ArchetypeAttr< Worker> Archetype() const;
		::Udm::BooleanAttr Abstract() const;
		::Udm::AssocAttr< WorkerType> referedbyWorkerType() const;
		template <class Pred> ::Udm::AssocAttr< WorkerType, Pred> referedbyWorkerType_sorted(const Pred &) const { return ::Udm::AssocAttr< WorkerType, Pred>(impl, meta_referedbyWorkerType); };
		::Udm::ChildrenAttr< ::PICML::Operation> Operation_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Operation, Pred> Operation_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Operation, Pred>(impl, meta_Operation_children); };
		::Udm::ChildrenAttr< ::PICML::Operation> Operation_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::Operation, Pred> Operation_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::Operation, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::WorkerPackageBase> WorkerPackageBase_parent() const;
		::Udm::ParentAttr< ::PICML::WorkerPackageBase> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Abstract;
		static ::Uml::AssociationRole meta_referedbyWorkerType;
		static ::Uml::CompositionChildRole meta_Operation_children;
		static ::Uml::CompositionParentRole meta_WorkerPackageBase_parent;

	};

	class PICML_Export WorkerLibrary :  public MgaObject {
	public:
		WorkerLibrary();
		WorkerLibrary(::Udm::ObjectImpl *impl);
		WorkerLibrary(const WorkerLibrary &master);

#ifdef UDM_RVALUE
		WorkerLibrary(WorkerLibrary &&master);

		static WorkerLibrary Cast(::Udm::Object &&a);
		WorkerLibrary& operator=(WorkerLibrary &&a);

#endif
		static WorkerLibrary Cast(const ::Udm::Object &a);
		static WorkerLibrary Create(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		WorkerLibrary CreateInstance(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::InstantiatedAttr< WorkerLibrary> Instances();
		template <class Pred> ::Udm::InstantiatedAttr< WorkerLibrary, Pred> Instances_sorted(const Pred &) { return ::Udm::InstantiatedAttr< WorkerLibrary, Pred>(impl); };
		WorkerLibrary CreateDerived(const ::Udm::Object &parent, const ::Uml::CompositionChildRole &role = ::Udm::NULLCHILDROLE);
		::Udm::DerivedAttr< WorkerLibrary> Derived();
		template <class Pred> ::Udm::DerivedAttr< WorkerLibrary, Pred> Derived_sorted(const Pred &) { return ::Udm::DerivedAttr< WorkerLibrary, Pred>(impl); };
		::Udm::ArchetypeAttr< WorkerLibrary> Archetype() const;
		::Udm::StringAttr Location() const;
		::Udm::ChildrenAttr< ::PICML::WorkerFile> WorkerFile_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkerFile, Pred> WorkerFile_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkerFile, Pred>(impl, meta_WorkerFile_children); };
		::Udm::ChildrenAttr< ::PICML::WorkerPackageBase> WorkerPackageBase_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkerPackageBase, Pred> WorkerPackageBase_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkerPackageBase, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::WorkerFile> WorkerFile_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::WorkerFile, Pred> WorkerFile_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::WorkerFile, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ChildrenAttr< ::PICML::MgaObject> MgaObject_kind_children() const;
		template <class Pred> ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred> MgaObject_kind_children_sorted(const Pred &) const { return ::Udm::ChildrenAttr< ::PICML::MgaObject, Pred>(impl, ::Udm::NULLCHILDROLE); };
		::Udm::ParentAttr< ::PICML::WorkerLibraries> WorkerLibraries_parent() const;
		::Udm::ParentAttr< ::PICML::WorkerLibraries> parent() const;
		void Accept(Visitor &v) const;

		static ::Uml::Class meta;
		static ::Uml::Attribute meta_Location;
		static ::Uml::CompositionChildRole meta_WorkerFile_children;
		static ::Uml::CompositionParentRole meta_WorkerLibraries_parent;

	};

}

#endif // MOBIES_PICML_H
